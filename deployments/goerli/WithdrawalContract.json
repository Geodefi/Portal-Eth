{
  "address": "0xabc595dE6CcEcCA5Af2f8262Bc55A34E05Cc7Dde",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "ContractVersionSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newCONTROLLER",
          "type": "address"
        }
      ],
      "name": "ControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "senate",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "senateExpiry",
          "type": "uint256"
        }
      ],
      "name": "NewSenate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "ProposalApproved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "CONTROLLER",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "TYPE",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "Proposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "approveProposal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newSenate",
          "type": "address"
        }
      ],
      "name": "changeController",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fetchUpgradeProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getContractVersion",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPoolId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPortal",
      "outputs": [
        {
          "internalType": "contract IPortal",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProposedVersion",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getgETH",
      "outputs": [
        {
          "internalType": "contract IgETH",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_VERSION",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_ID",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_gETH",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_PORTAL",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_OWNER",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_CONTROLLER",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_TYPE",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_NAME",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "newProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "recoveryMode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isRecovering",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x8cc69d177219b8252530d9bf70d7b24a8d98cc1321aa1b13d87439a2eb22a8b4",
  "receipt": {
    "to": null,
    "from": "0x2C95BC18Fd9382a07776D416EeF6c2FEb3AD2A8C",
    "contractAddress": "0xabc595dE6CcEcCA5Af2f8262Bc55A34E05Cc7Dde",
    "transactionIndex": 0,
    "gasUsed": "1592976",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb35764107ca44311b9e2b7ed55a52a83a3c9b48aa88bb6ff36589223a7474265",
    "transactionHash": "0x8cc69d177219b8252530d9bf70d7b24a8d98cc1321aa1b13d87439a2eb22a8b4",
    "logs": [],
    "blockNumber": 8557492,
    "cumulativeGasUsed": "1592976",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ade6b4939fda34d609e172906ec4e12a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCONTROLLER\",\"type\":\"address\"}],\"name\":\"ControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senateExpiry\",\"type\":\"uint256\"}],\"name\":\"NewSenate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CONTROLLER\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TYPE\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"Proposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSenate\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchUpgradeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPortal\",\"outputs\":[{\"internalType\":\"contract IPortal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getgETH\",\"outputs\":[{\"internalType\":\"contract IgETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_VERSION\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_gETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_PORTAL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_OWNER\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_CONTROLLER\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TYPE\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_NAME\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"newProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRecovering\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Icebear & Crash Bandicoot\",\"details\":\"This contract utilizes Dual Governance between Portal (GOVERNANCE) and  the Pool Owner (SENATE) to empower the Limited Upgradability.Recovery Mode stops pool operations while allowing withdrawal queue to operate as usualtodo: Withdrawal Queue\",\"kind\":\"dev\",\"methods\":{\"changeController(address)\":{\"details\":\"OnlySenate is checked inside the GeodeUtils\"},\"fetchUpgradeProposal()\":{\"details\":\"remaining code is basically taken from upgradeTo of UUPS since it is still not public, but external\"},\"newProposal(address,uint256,bytes,uint256)\":{\"details\":\"only Governance check is inside, note Governance is Portal.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"recoveryMode()\":{\"returns\":{\"isRecovering\":\"true if recoveryMode is active\"}},\"upgradeTo(address)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"title\":\"WithdrawalContract: Saviour of Trustless Staking Derivatives\",\"version\":1},\"userdoc\":{\"events\":{\"ControllerChanged(uint256,address)\":{\"notice\":\"Events\"}},\"kind\":\"user\",\"methods\":{\"changeController(address)\":{\"notice\":\"changes the Senate's address without extending the expiry\"},\"fetchUpgradeProposal()\":{\"notice\":\"Fetching an upgradeProposal from Portal creates an upgrade proposalapproving the version changes the approvedVersion on GeodeUtils\"},\"getContractVersion()\":{\"notice\":\"get the current version of the contract\"},\"getPoolId()\":{\"notice\":\"get the gETH ID of the corresponding staking pool\"},\"getPortal()\":{\"notice\":\"get Portal as a contract\"},\"getProposedVersion()\":{\"notice\":\"get the latest version of the withdrawal contract module from Portal\"},\"getgETH()\":{\"notice\":\"get gETH as a contract\"},\"newProposal(address,uint256,bytes,uint256)\":{\"notice\":\"Creates a new Proposal within Withdrawal Contract, used by Portal\"},\"pause()\":{\"notice\":\"pausing the contract activates the recoveryMode\"},\"recoveryMode()\":{\"notice\":\"Recovery Mode allows Withdrawal Contract to isolate itself from Portal and continue handling the withdrawals.\"},\"unpause()\":{\"notice\":\"unpausing the contract deactivates the recoveryMode\"}},\"notice\":\"This is a simple contract: - used as the withdrawal credential of the validators. - accrues fees and rewards from validators over time. - handles the withdrawal queue for stakers. - manages its own versioning without trusting Portal.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Portal/withdrawalContract/WithdrawalContract.sol\":\"WithdrawalContract\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x315887e846f1e5f8d8fa535a229d318bb9290aaa69485117f1ee8a9a6b3be823\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7967d130887c4b40666cd88f8744691d4527039a1b2a38aa0de41481ef646778\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09864aea84f01e39313375b5610c73a3c1c68abbdc51e5ccdd25ff977fdadf9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x888d64d221d52c31d015b76e50ca1af5ef8ff076550810b49cea6b01d8267a10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd466e8b07f4c6220eac16da5127f3ff142e65f0c15c03c7d38f257b02c8585e1\",\"license\":\"MIT\"},\"contracts/Portal/helpers/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity =0.8.7;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\\n        internal\\n    {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(\\n                    add(tempBytes, lengthmod),\\n                    mul(0x20, iszero(lengthmod))\\n                )\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(\\n                        add(\\n                            add(_bytes, lengthmod),\\n                            mul(0x20, iszero(lengthmod))\\n                        ),\\n                        _start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(\\n                mload(add(add(_bytes, 0x20), _start)),\\n                0x1000000000000000000000000\\n            )\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint16)\\n    {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint32)\\n    {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint64)\\n    {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint96)\\n    {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint128)\\n    {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0x47661fc872b08aa96131860eb7a6a2c398987b151104ab8dd70ce2ed5a31a5e4\",\"license\":\"Unlicense\"},\"contracts/Portal/utils/DataStoreUtilsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\n/**\\n * @author Icebear & Crash Bandicoot\\n * @title Isolated Storage Layout\\n * A Storage Management Library for Dynamic Structs\\n *\\n * * DataStoreUtils is a storage management tool designed to create a safe and scalable\\n * * storage layout with the help of data types, IDs and keys.\\n *\\n * * Focusing on upgradable contracts with multiple user types to create a\\n * * sustainable development environment.\\n * * In summary, extra gas cost that would be saved with Storage packing are\\n * * ignored to create upgradable structs.\\n *\\n * @dev Distinct id and key pairs SHOULD return different storage slots\\n * @dev TYPEs are defined in globals.sol\\n *\\n * @dev IDs are the representation of an entity with any given key as properties.\\n * @dev While it is good practice to keep record,\\n * * TYPE for ID is NOT mandatory, an ID might not have an explicit type.\\n * * Thus there is no checks of types or keys.\\n */\\n\\nlibrary DataStoreUtils {\\n  /**\\n   * @notice Main Struct for reading and writing operations for given (id, key) pairs\\n   * @param allIdsByType type => id[], optional categorization for IDs, requires direct access\\n   * @param uintData keccak(id, key) =>  returns uint256\\n   * @param bytesData keccak(id, key) => returns bytes\\n   * @param addressData keccak(id, key) =>  returns address\\n   * @param __gap keep the struct size at 16\\n   * @dev any other storage type can be expressed as uint or bytes\\n   */\\n  struct IsolatedStorage {\\n    mapping(uint256 => uint256[]) allIdsByType;\\n    mapping(bytes32 => uint256) uintData;\\n    mapping(bytes32 => bytes) bytesData;\\n    mapping(bytes32 => address) addressData;\\n    uint256[12] __gap;\\n  }\\n\\n  /**\\n   *                              ** HELPERS **\\n   **/\\n\\n  /**\\n   * @notice generaliazed method of generating an ID\\n   * @dev Some TYPEs may require permissionless creation. Allowing anyone to claim any ID,\\n   * meaning malicious actors can claim names to mislead people. To prevent this\\n   * TYPEs will be considered during ID generation.\\n   */\\n  function generateId(\\n    bytes memory _name,\\n    uint256 _type\\n  ) internal pure returns (uint256 id) {\\n    id = uint256(keccak256(abi.encodePacked(_name, _type)));\\n  }\\n\\n  /**\\n   * @notice hashes given id and a parameter to be used as key in getters and setters\\n   * @return key bytes32 hash of id and parameter to be stored\\n   **/\\n  function getKey(\\n    uint256 id,\\n    bytes32 param\\n  ) internal pure returns (bytes32 key) {\\n    key = keccak256(abi.encodePacked(id, param));\\n  }\\n\\n  /**\\n   *                              ** DATA GETTERS **\\n   **/\\n\\n  function readUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_id, _key)];\\n  }\\n\\n  function readBytes(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_id, _key)];\\n  }\\n\\n  function readAddress(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_id, _key)];\\n  }\\n\\n  /**\\n   *                              ** ARRAY GETTERS **\\n   **/\\n\\n  function readUintArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readBytesArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readAddressArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  /**\\n   *                              ** DATA SETTERS **\\n   **/\\n\\n  function writeUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function addUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _addend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] += _addend;\\n  }\\n\\n  function subUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _minuend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] -= _minuend;\\n  }\\n\\n  function writeBytes(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    self.bytesData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function writeAddress(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    self.addressData[getKey(_id, _key)] = _data;\\n  }\\n\\n  /**\\n   *                              ** ARRAY SETTERS **\\n   **/\\n\\n  function appendUintArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendBytesArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendAddressArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  /**\\n   *                              ** BATCH ARRAY SETTERS **\\n   **/\\n\\n  function appendUintArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n    for (uint256 i; i < _data.length; ) {\\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendBytesArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n    for (uint256 i; i < _data.length; ) {\\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendAddressArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n    for (uint256 i; i < _data.length; ) {\\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n}\\n\",\"keccak256\":\"0xa792c6f0c02220de88911ee11ab57c13f69cf020d618556754a713fe320b201a\",\"license\":\"MIT\"},\"contracts/Portal/utils/DepositContractUtilsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"../../interfaces/IDepositContract.sol\\\";\\nimport \\\"../helpers/BytesLib.sol\\\";\\n\\nlibrary DepositContractUtils {\\n  IDepositContract internal constant DEPOSIT_CONTRACT =\\n    IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b);\\n  uint256 internal constant PUBKEY_LENGTH = 48;\\n  uint256 internal constant SIGNATURE_LENGTH = 96;\\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\\n\\n  /**\\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\\n   * @param _b Memory array of size 32 .. 64\\n   */\\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\\n    assert(_b.length >= 32 && _b.length <= 64);\\n    if (64 == _b.length) return _b;\\n\\n    bytes memory zero32 = new bytes(32);\\n    assembly {\\n      mstore(add(zero32, 0x20), 0)\\n    }\\n\\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\\n    else\\n      return\\n        BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\\n  }\\n\\n  /**\\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\\n   * @param _value Number less than `2**64` for compatibility reasons\\n   */\\n  function _toLittleEndian64(\\n    uint256 _value\\n  ) internal pure returns (uint256 result) {\\n    result = 0;\\n    uint256 temp_value = _value;\\n    for (uint256 i = 0; i < 8; ++i) {\\n      result = (result << 8) | (temp_value & 0xFF);\\n      temp_value >>= 8;\\n    }\\n\\n    assert(0 == temp_value); // fully converted\\n    result <<= (24 * 8);\\n  }\\n\\n  function _getDepositDataRoot(\\n    bytes memory _pubkey,\\n    bytes memory _withdrawalCredentials,\\n    bytes memory _signature,\\n    uint256 _stakeAmount\\n  ) internal pure returns (bytes32) {\\n    require(_stakeAmount >= 1 ether, \\\"DepositContract: deposit value too low\\\");\\n    require(\\n      _stakeAmount % 1 gwei == 0,\\n      \\\"DepositContract: deposit value not multiple of gwei\\\"\\n    );\\n\\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\\n    bytes32 signatureRoot = sha256(\\n      abi.encodePacked(\\n        sha256(BytesLib.slice(_signature, 0, 64)),\\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\\n      )\\n    );\\n\\n    bytes32 depositDataRoot = sha256(\\n      abi.encodePacked(\\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\\n        sha256(\\n          abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot)\\n        )\\n      )\\n    );\\n\\n    return depositDataRoot;\\n  }\\n\\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\\n    uint256 w = 1 << 248;\\n\\n    return\\n      abi.encodePacked(\\n        bytes32(w) | bytes32(uint256(uint160(address(wcAddress))))\\n      );\\n  }\\n\\n  function depositValidator(\\n    bytes calldata pubkey,\\n    bytes memory withdrawalCredential,\\n    bytes memory signature,\\n    uint256 amount\\n  ) internal {\\n    DEPOSIT_CONTRACT.deposit{value: amount}(\\n      pubkey,\\n      withdrawalCredential,\\n      signature,\\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0xd81c6713a99d087426a3915d4810fc9638a2e7d6f64cb43585c5474bad7367a8\",\"license\":\"MIT\"},\"contracts/Portal/utils/GeodeUtilsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {ID_TYPE, PERCENTAGE_DENOMINATOR} from \\\"./globals.sol\\\";\\nimport {DataStoreUtils as DSU} from \\\"./DataStoreUtilsLib.sol\\\";\\n\\n/**\\n * @author Icebear & Crash Bandicoot\\n * @title Geode Dual Governance\\n * @notice Exclusively contains functions for the administration of the Isolated Storage,\\n * and Limited Upgradability with Dual Governance of Governance and Senate\\n * Note This library contains both functions called by users(ID) (approveSenate) and admins(GOVERNANCE, SENATE)\\n *\\n * @dev Reserved ID_TYPEs:\\n *\\n * * Type 0 : NULL\\n *\\n * * Type 1 : SENATE ELECTIONS\\n * * * Every SENATE has an expiration date, a new one should be elected before it ends.\\n * * * Only the controllers of IDs with TYPEs that are set true on _electorTypes can vote.\\n * * * 2/3 is the expected concensus, however this logic seems to be improved in the future.\\n *\\n * * Type 2 : CONTRACT UPGRADES\\n * * * Provides Limited Upgradability on Portal and Withdrawal Contract\\n * * * Contract can be upgradable once Senate approves it.\\n *\\n * * Type 3 : __GAP__\\n * * * ormally represented the admin contract, but we use UUPS. Reserved to be never used.\\n *\\n * @dev Contracts relying on this library must initialize GeodeUtils.DualGovernance\\n * @dev Functions are already protected accordingly\\n *\\n * @dev review DataStoreUtils\\n */\\nlibrary GeodeUtils {\\n  /// @notice Using DataStoreUtils for IsolatedStorage struct\\n  using DSU for DSU.IsolatedStorage;\\n\\n  /// @notice EVENTS\\n  event GovernanceFeeUpdated(uint256 newFee);\\n  event ControllerChanged(uint256 indexed id, address newCONTROLLER);\\n  event Proposed(\\n    uint256 id,\\n    address CONTROLLER,\\n    uint256 indexed TYPE,\\n    uint256 deadline\\n  );\\n  event ProposalApproved(uint256 id);\\n  event ElectorTypeSet(uint256 TYPE, bool isElector);\\n  event Vote(uint256 indexed proposalId, uint256 indexed voterId);\\n  event NewSenate(address senate, uint256 senateExpiry);\\n\\n  /**\\n   * @notice Proposals give the control of a specific ID to a CONTROLLER\\n   *\\n   * @notice A Proposal has 4 specs:\\n   * @param TYPE: refer to globals.sol\\n   * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\\n   * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\\n   * @param NAME: DataStore generates ID by keccak(name, type)\\n   * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\\n   * * Expired proposals can not be approved by Senate\\n   * * Expired proposals can not be overriden by new proposals\\n   **/\\n  struct Proposal {\\n    address CONTROLLER;\\n    uint256 TYPE;\\n    bytes NAME;\\n    uint256 deadline;\\n  }\\n\\n  /**\\n   * @notice DualGovernance allows 2 parties to manage a contract with proposals and approvals\\n   * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\\n   * Suggests updates, such as new operators, contract upgrades, a new Senate -without any permission to force them-\\n   * @param SENATE An address that protects the users by controlling the state of governance, contract updates and other crucial changes\\n   * Note SENATE is proposed by Governance and voted by all elector TYPEs, approved if \\u230a2/3\\u230b votes.\\n   * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Enforces a new election, limited by MAX_SENATE_PERIOD\\n   * @param GOVERNANCE_FEE operation fee on the given contract, acquired by GOVERNANCE. Limited by MAX_GOVERNANCE_FEE\\n   * @param approvedVersion only 1 implementation contract SHOULD be \\\"approved\\\" at any given time.\\n   * * @dev safe to set to address(0) after every upgrade as isUpgradeAllowed returns false for address(0)\\n   * @param _electorCount increased when a new id is added with _electorTypes[id] == true\\n   * @param _electorTypes only given TYPEs can vote\\n   * @param _proposals till approved, proposals are kept separated from the Isolated Storage\\n   * @param __gap keep the struct size at 16\\n   **/\\n  struct DualGovernance {\\n    address GOVERNANCE;\\n    address SENATE;\\n    uint256 SENATE_EXPIRY;\\n    uint256 GOVERNANCE_FEE;\\n    address approvedVersion;\\n    uint256 _electorCount;\\n    mapping(uint256 => bool) _electorTypes;\\n    mapping(uint256 => Proposal) _proposals;\\n    uint256[8] __gap;\\n  }\\n\\n  /**\\n   * @notice limiting the GOVERNANCE_FEE, 5%\\n   */\\n  uint256 public constant MAX_GOVERNANCE_FEE =\\n    (PERCENTAGE_DENOMINATOR * 5) / 100;\\n\\n  /**\\n   * @notice prevents Governance from collecting any fees till given timestamp:\\n   * @notice April 2025\\n   * @dev fee switch will be automatically switched on after given timestamp\\n   * @dev fee switch can be switched on with the approval of Senate (a contract upgrade)\\n   */\\n  uint256 public constant FEE_COOLDOWN = 1743454800;\\n\\n  uint32 public constant MIN_PROPOSAL_DURATION = 1 days;\\n  uint32 public constant MAX_PROPOSAL_DURATION = 4 weeks;\\n  uint32 public constant MAX_SENATE_PERIOD = 365 days;\\n\\n  modifier onlySenate(DualGovernance storage self) {\\n    require(msg.sender == self.SENATE, \\\"GU: SENATE role needed\\\");\\n    require(block.timestamp < self.SENATE_EXPIRY, \\\"GU: SENATE expired\\\");\\n    _;\\n  }\\n\\n  modifier onlyGovernance(DualGovernance storage self) {\\n    require(msg.sender == self.GOVERNANCE, \\\"GU: GOVERNANCE role needed\\\");\\n    _;\\n  }\\n\\n  modifier onlyController(DSU.IsolatedStorage storage DATASTORE, uint256 id) {\\n    require(\\n      msg.sender == DATASTORE.readAddress(id, \\\"CONTROLLER\\\"),\\n      \\\"GU: CONTROLLER role needed\\\"\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @notice                                     ** DualGovernance **\\n   **/\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @return address of SENATE\\n   **/\\n  function getSenate(\\n    DualGovernance storage self\\n  ) external view returns (address) {\\n    return self.SENATE;\\n  }\\n\\n  /**\\n   * @return address of GOVERNANCE\\n   **/\\n  function getGovernance(\\n    DualGovernance storage self\\n  ) external view returns (address) {\\n    return self.GOVERNANCE;\\n  }\\n\\n  /**\\n   * @return the expiration date of current SENATE as a timestamp\\n   */\\n  function getSenateExpiry(\\n    DualGovernance storage self\\n  ) external view returns (uint256) {\\n    return self.SENATE_EXPIRY;\\n  }\\n\\n  /**\\n   * @notice active GOVERNANCE_FEE limited by FEE_COOLDOWN and MAX_GOVERNANCE_FEE\\n   * @dev MAX_GOVERNANCE_FEE MUST limit GOVERNANCE_FEE even if MAX is changed later\\n   * @dev MUST return 0 until cooldown period is active\\n   */\\n  function getGovernanceFee(\\n    DualGovernance storage self\\n  ) external view returns (uint256) {\\n    return\\n      block.timestamp < FEE_COOLDOWN\\n        ? 0\\n        : MAX_GOVERNANCE_FEE > self.GOVERNANCE_FEE\\n        ? self.GOVERNANCE_FEE\\n        : MAX_GOVERNANCE_FEE;\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice onlyGovernance, sets the governance fee\\n   * @dev Can not set the fee more than MAX_GOVERNANCE_FEE\\n   */\\n  function setGovernanceFee(\\n    DualGovernance storage self,\\n    uint256 newFee\\n  ) external onlyGovernance(self) {\\n    require(newFee <= MAX_GOVERNANCE_FEE, \\\"GU: > MAX_GOVERNANCE_FEE\\\");\\n\\n    self.GOVERNANCE_FEE = newFee;\\n\\n    emit GovernanceFeeUpdated(newFee);\\n  }\\n\\n  /**\\n   * @notice                                     ** ID **\\n   */\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice onlyController, change the CONTROLLER of an ID\\n   * @dev this operation can not be reverted by the old CONTROLLER !\\n   * @dev can not provide address(0), try 0x000000000000000000000000000000000000dEaD\\n   */\\n  function changeIdCONTROLLER(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address newCONTROLLER\\n  ) external onlyController(DATASTORE, id) {\\n    require(newCONTROLLER != address(0), \\\"GU: CONTROLLER can not be zero\\\");\\n\\n    DATASTORE.writeAddress(id, \\\"CONTROLLER\\\", newCONTROLLER);\\n\\n    emit ControllerChanged(id, newCONTROLLER);\\n  }\\n\\n  /**\\n   * @notice                                     ** PROPOSALS **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @dev refer to Proposal struct\\n   */\\n  function getProposal(\\n    DualGovernance storage self,\\n    uint256 id\\n  ) external view returns (Proposal memory) {\\n    return self._proposals[id];\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice onlyGovernance, creates a new Proposal\\n   * @dev DATASTORE[id] will not be updated until the proposal is approved\\n   * @dev Proposals can NEVER be overriden\\n   * @dev refer to Proposal struct\\n   */\\n  function newProposal(\\n    DualGovernance storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external onlyGovernance(self) returns (uint256 id) {\\n    id = DSU.generateId(_NAME, _TYPE);\\n\\n    require(self._proposals[id].deadline == 0, \\\"GU: NAME already proposed\\\");\\n\\n    require(\\n      (DATASTORE.readBytes(id, \\\"NAME\\\")).length == 0,\\n      \\\"GU: ID already exist\\\"\\n    );\\n\\n    require(_CONTROLLER != address(0), \\\"GU: CONTROLLER can NOT be ZERO\\\");\\n    require(\\n      _TYPE != ID_TYPE.NONE && _TYPE != ID_TYPE.__GAP__,\\n      \\\"GU: TYPE is NONE or GAP\\\"\\n    );\\n    require(\\n      duration >= MIN_PROPOSAL_DURATION && duration <= MAX_PROPOSAL_DURATION,\\n      \\\"GU: invalid proposal duration\\\"\\n    );\\n\\n    uint256 _deadline = block.timestamp + duration;\\n\\n    self._proposals[id] = Proposal({\\n      CONTROLLER: _CONTROLLER,\\n      TYPE: _TYPE,\\n      NAME: _NAME,\\n      deadline: _deadline\\n    });\\n\\n    emit Proposed(id, _CONTROLLER, _TYPE, _deadline);\\n  }\\n\\n  /**\\n   * @notice onlySenate, approves a proposal and records given data to\\n   *  @notice specific changes for the reserved types (1,2,3) are implemented here,\\n   *  any other addition should take place in Portal, as not related\\n   *  @param id given ID proposal that has been approved by Senate\\n   *  @dev Senate is not able to approve approved proposals\\n   *  @dev Senate is not able to approve expired proposals\\n   *  @dev Senate is not able to approve SENATE proposals\\n   */\\n  function approveProposal(\\n    DualGovernance storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) external onlySenate(self) returns (uint256 _type, address _controller) {\\n    require(\\n      self._proposals[id].deadline > block.timestamp,\\n      \\\"GU: NOT an active proposal\\\"\\n    );\\n\\n    _type = self._proposals[id].TYPE;\\n    _controller = self._proposals[id].CONTROLLER;\\n\\n    require(_type != ID_TYPE.SENATE, \\\"GU: can NOT approve SENATE election\\\");\\n\\n    DATASTORE.writeUint(id, \\\"TYPE\\\", _type);\\n    DATASTORE.writeAddress(id, \\\"CONTROLLER\\\", _controller);\\n    DATASTORE.writeBytes(id, \\\"NAME\\\", self._proposals[id].NAME);\\n    DATASTORE.allIdsByType[_type].push(id);\\n\\n    if (_type == ID_TYPE.CONTRACT_UPGRADE) {\\n      self.approvedVersion = _controller;\\n    }\\n\\n    if (isElector(self, _type)) {\\n      self._electorCount += 1;\\n    }\\n\\n    // important\\n    self._proposals[id].deadline = block.timestamp;\\n\\n    emit ProposalApproved(id);\\n  }\\n\\n  /**\\n   * @notice                                       ** SENATE ELECTIONS **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  function isElector(\\n    DualGovernance storage self,\\n    uint256 _TYPE\\n  ) public view returns (bool) {\\n    return self._electorTypes[_TYPE];\\n  }\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice internal function to set a new senate with a given period\\n   */\\n  function _setSenate(\\n    DualGovernance storage self,\\n    address _newSenate,\\n    uint256 _expiry\\n  ) internal {\\n    self.SENATE = _newSenate;\\n    self.SENATE_EXPIRY = _expiry;\\n\\n    emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice onlySenate, Sometimes it is useful to be able to change the Senate's address.\\n   * @dev does not change the expiry\\n   */\\n  function changeSenate(\\n    DualGovernance storage self,\\n    address _newSenate\\n  ) external onlySenate(self) {\\n    _setSenate(self, _newSenate, self.SENATE_EXPIRY);\\n  }\\n\\n  /**\\n   * @notice onlyGovernance, only elector types can vote for senate\\n   * @param _TYPE selected type\\n   * @param _isElector true if selected _type can vote for senate from now on\\n   * @dev can not set with the same value again, preventing double increment/decrements\\n   */\\n  function setElectorType(\\n    DualGovernance storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _TYPE,\\n    bool _isElector\\n  ) external onlyGovernance(self) {\\n    require(_isElector != isElector(self, _TYPE), \\\"GU: type already elector\\\");\\n    require(\\n      _TYPE > ID_TYPE.__GAP__,\\n      \\\"GU: 0, Senate, Upgrade, GAP cannot be elector\\\"\\n    );\\n\\n    self._electorTypes[_TYPE] = _isElector;\\n\\n    if (_isElector) {\\n      self._electorCount += DATASTORE.allIdsByType[_TYPE].length;\\n    } else {\\n      self._electorCount -= DATASTORE.allIdsByType[_TYPE].length;\\n    }\\n\\n    emit ElectorTypeSet(_TYPE, _isElector);\\n  }\\n\\n  /**\\n   * @notice onlyController, Proposed CONTROLLER is the new Senate after 2/3 of the electors approved\\n   * NOTE mathematically, min 3 elector is needed for (c+1)*2/3 to work properly\\n   * @notice id can not vote if:\\n   * - approved already\\n   * - proposal is expired\\n   * - not its type is elector\\n   * - not senate proposal\\n   * @param voterId should have the voting rights, msg.sender should be the CONTROLLER of given ID\\n   * @dev pins id as \\\"voted\\\" when approved\\n   * @dev increases \\\"approvalCount\\\" of proposalId by 1 when approved\\n   */\\n  function approveSenate(\\n    DualGovernance storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 proposalId,\\n    uint256 voterId\\n  ) external onlyController(DATASTORE, voterId) {\\n    uint256 _type = self._proposals[proposalId].TYPE;\\n    require(_type == ID_TYPE.SENATE, \\\"GU: NOT Senate Proposal\\\");\\n    require(\\n      self._proposals[proposalId].deadline >= block.timestamp,\\n      \\\"GU: proposal expired\\\"\\n    );\\n    require(\\n      isElector(self, DATASTORE.readUint(voterId, \\\"TYPE\\\")),\\n      \\\"GU: NOT an elector\\\"\\n    );\\n    require(\\n      DATASTORE.readUint(proposalId, DSU.getKey(voterId, \\\"voted\\\")) == 0,\\n      \\\" GU: already approved\\\"\\n    );\\n\\n    DATASTORE.writeUint(proposalId, DSU.getKey(voterId, \\\"voted\\\"), 1);\\n    DATASTORE.addUint(proposalId, \\\"approvalCount\\\", 1);\\n\\n    if (\\n      DATASTORE.readUint(proposalId, \\\"approvalCount\\\") >=\\n      ((self._electorCount + 1) * 2) / 3\\n    ) {\\n      self._proposals[proposalId].deadline = block.timestamp;\\n      _setSenate(\\n        self,\\n        self._proposals[proposalId].CONTROLLER,\\n        block.timestamp + MAX_SENATE_PERIOD\\n      );\\n    }\\n\\n    emit Vote(proposalId, voterId);\\n  }\\n\\n  /**\\n   * @notice                                       ** LIMITED UPGRADABILITY **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice Get if it is allowed to change a specific contract with the current version.\\n   * @return True if it is allowed by senate and false if not.\\n   * @dev address(0) should return false\\n   * @dev DO NOT TOUCH, EVER! WHATEVER YOU DEVELOP IN FUCKING 3022\\n   **/\\n  function isUpgradeAllowed(\\n    DualGovernance storage self,\\n    address proposedImplementation\\n  ) external view returns (bool) {\\n    return\\n      self.approvedVersion != address(0) &&\\n      self.approvedVersion == proposedImplementation;\\n  }\\n}\\n\",\"keccak256\":\"0x778b193b23ba4dae7dc6b1ddafcd9a460eff6e8f624be6f1fff8aa69efb8606c\",\"license\":\"MIT\"},\"contracts/Portal/utils/OracleUtilsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport {ID_TYPE, VALIDATOR_STATE, PERCENTAGE_DENOMINATOR} from \\\"./globals.sol\\\";\\n\\nimport {DataStoreUtils as DSU} from \\\"./DataStoreUtilsLib.sol\\\";\\nimport {StakeUtils as SU} from \\\"./StakeUtilsLib.sol\\\";\\nimport {DepositContractUtils as DCU} from \\\"./DepositContractUtilsLib.sol\\\";\\n\\n/**\\n * @author Icebear & Crash Bandicoot\\n * @title OracleUtils Library: An extension to StakeUtils Library\\n * @notice Oracle, named Telescope, handles some operations for The Staking Library,\\n * * using the following logic, which is very simple.\\n *\\n * @dev Telescope is responsible from 3 tasks:\\n * * Updating the on-chain price of all pools with a MerkleRoot\\n * * Confirming validator proposals\\n * * Regulating the Node Operators\\n *\\n * 1. reportOracle: Continous Data Flow: Price Merkle Root and MONOPOLY_THRESHOLD\\n * * 1. Oracle Nodes calculates the price of its derivative,\\n * * * according to the validator data such as balance and fees.\\n * * 2. If a pool doesn't have a validator, price is kept the same.\\n * * 3. A merkle tree is constructed with the order of allIdsByType array.\\n * * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root.\\n * * 5. Anyone can update the price of the derivative\\n * * * by calling priceSync() functions with correct merkle proofs\\n * * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update.\\n * * 7. Updates the regulation around Monopolies\\n *\\n * 2. updateVerificationIndex :Confirming validator proposals\\n * * Simply, all proposed validator has an index bound to them,\\n * * n representing the latest proposal: (0,n]\\n * * Telescope verifies the validator data provided in proposeStake:\\n * * especially sig1, sig31 and withdrawal credentials.\\n * * Telescope confirms the latest index it verified and states the faulty validator proposals (aliens)\\n * * If a validator proposal is faulty then it's state is set to 69.\\n * * * 2 step process is essential to prevent the frontrunning\\n * * * with a problematic withdrawalCredential, (https://bit.ly/3Tkc6UC)\\n *\\n * 3. regulateOperators: Regulating the Operators\\n * * Operators can act faulty in many different ways. To prevent such actions,\\n * * Telescope regulates them with well defined limitations.\\n * * * Currently only issue is the fee theft, meaning operator have not\\n * * * used the withdrawal contract for miner fees or MEV boost.\\n * * * * There can be other restrictions in the future.\\n *\\n * @dev All 3 functions have OracleOnly modifier, priceSync functions do not.\\n *\\n * @dev first review DataStoreUtils\\n * @dev then review StakeUtils\\n */\\n\\nlibrary OracleUtils {\\n  /// @notice Using DataStoreUtils for IsolatedStorage struct\\n  using DSU for DSU.IsolatedStorage;\\n\\n  /// @notice Using StakeUtils for PooledStaking struct\\n  using SU for SU.PooledStaking;\\n\\n  /// @notice EVENTS\\n  event Alienated(bytes indexed pubkey);\\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\\n  event FeeTheft(uint256 indexed id, bytes proofs);\\n  event OracleReported(bytes32 merkleRoot, uint256 monopolyThreshold);\\n\\n  /// @notice effective on MONOPOLY_THRESHOLD, limiting the active validators, set to 1% at start.\\n  uint256 public constant MONOPOLY_RATIO = (1 * PERCENTAGE_DENOMINATOR) / 100;\\n\\n  /// @notice sensible value for the total beacon chain validators, no reasoning.\\n  uint256 public constant MIN_VALIDATOR_COUNT = 50000;\\n\\n  modifier onlyOracle(SU.PooledStaking storage STAKER) {\\n    require(msg.sender == STAKER.ORACLE_POSITION, \\\"OU: sender NOT ORACLE\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice                                     ** VERIFICATION INDEX **\\n   **/\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice \\\"Alien\\\" is a validator that is created with a faulty withdrawal\\n   * credential or signatures, this is a malicious act.\\n   * @notice Alienation results in imprisonment for the operator of the faulty validator proposal.\\n   * @dev While alienating a validator we should adjust the 'surplus' and 'secured'\\n   * balances of the pool accordingly\\n   * @dev We should adjust the 'totalProposedValidators', 'proposedValidators' to fix allowances.\\n   */\\n  function _alienateValidator(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    bytes calldata _pk\\n  ) internal {\\n    require(\\n      STAKER._validators[_pk].state == VALIDATOR_STATE.PROPOSED,\\n      \\\"OU: NOT all pubkeys are pending\\\"\\n    );\\n    require(\\n      STAKER._validators[_pk].index <= STAKER.VERIFICATION_INDEX,\\n      \\\"OU: unexpected index\\\"\\n    );\\n    SU._imprison(DATASTORE, STAKER._validators[_pk].operatorId, _pk);\\n\\n    uint256 poolId = STAKER._validators[_pk].poolId;\\n    DATASTORE.subUint(poolId, \\\"secured\\\", DCU.DEPOSIT_AMOUNT);\\n    DATASTORE.addUint(poolId, \\\"surplus\\\", DCU.DEPOSIT_AMOUNT);\\n\\n    uint256 operatorId = STAKER._validators[_pk].operatorId;\\n    DATASTORE.subUint(operatorId, \\\"totalProposedValidators\\\", 1);\\n    DATASTORE.subUint(\\n      poolId,\\n      DSU.getKey(operatorId, \\\"proposedValidators\\\"),\\n      1\\n    );\\n\\n    STAKER._validators[_pk].state = VALIDATOR_STATE.ALIENATED;\\n\\n    emit Alienated(_pk);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice Updating VERIFICATION_INDEX, signaling that it is safe to activate\\n   * the validator proposals with lower index than new VERIFICATION_INDEX\\n   * @param validatorVerificationIndex (inclusive) index of the highest validator that is verified to be activated\\n   * @param alienatedPubkeys faulty proposals within the range of new and old verification indexes.\\n   */\\n  function updateVerificationIndex(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external onlyOracle(STAKER) {\\n    require(\\n      STAKER.VALIDATORS_INDEX >= validatorVerificationIndex,\\n      \\\"OU: high VERIFICATION_INDEX\\\"\\n    );\\n    require(\\n      validatorVerificationIndex > STAKER.VERIFICATION_INDEX,\\n      \\\"OU: low VERIFICATION_INDEX\\\"\\n    );\\n\\n    STAKER.VERIFICATION_INDEX = validatorVerificationIndex;\\n\\n    for (uint256 i; i < alienatedPubkeys.length; ++i) {\\n      _alienateValidator(DATASTORE, STAKER, alienatedPubkeys[i]);\\n    }\\n\\n    emit VerificationIndexUpdated(validatorVerificationIndex);\\n  }\\n\\n  /**\\n   * @notice                                     ** REGULATING OPERATORS **\\n   */\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice regulating operators, currently only regulation is towards fee theft, can add more stuff in the future.\\n   * @param feeThefts Operator ids who have stolen MEV or block rewards detected\\n   * @param proofs  BlockNumber, tx or any other referance as a proof\\n   * @dev Stuff here result in imprisonment\\n   */\\n  function regulateOperators(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256[] calldata feeThefts,\\n    bytes[] calldata proofs\\n  ) external onlyOracle(STAKER) {\\n    require(feeThefts.length == proofs.length, \\\"OU: invalid proofs\\\");\\n    for (uint256 i; i < feeThefts.length; ++i) {\\n      SU._imprison(DATASTORE, feeThefts[i], proofs[i]);\\n\\n      emit FeeTheft(feeThefts[i], proofs[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice                                     ** CONTINUOUS UPDATES **\\n   */\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT.\\n   * Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD\\n   * @param allValidatorsCount Number of all validators within BeaconChain, all of them.\\n   * Prevents monopolies.\\n   */\\n  function reportOracle(\\n    SU.PooledStaking storage STAKER,\\n    bytes32 priceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external onlyOracle(STAKER) {\\n    require(\\n      allValidatorsCount > MIN_VALIDATOR_COUNT,\\n      \\\"OU: low validator count\\\"\\n    );\\n\\n    STAKER.PRICE_MERKLE_ROOT = priceMerkleRoot;\\n    STAKER.ORACLE_UPDATE_TIMESTAMP = block.timestamp;\\n\\n    uint256 newThreshold = (allValidatorsCount * MONOPOLY_RATIO) /\\n      PERCENTAGE_DENOMINATOR;\\n    STAKER.MONOPOLY_THRESHOLD = newThreshold;\\n\\n    emit OracleReported(priceMerkleRoot, newThreshold);\\n  }\\n\\n  /**\\n   * @notice                                     ** Updating PricePerShare **\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @dev in order to prevent faulty updates to the derivative prices there are boundaries to price updates.\\n   * 1. Price should not be increased more than DAILY_PRICE_INCREASE_LIMIT\\n   *  with the factor of how many days since priceUpdateTimestamp has past.\\n   * 2. Price should not be decreased more than DAILY_PRICE_DECREASE_LIMIT\\n   *  with the factor of how many days since priceUpdateTimestamp has past.\\n   */\\n  function _sanityCheck(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256 _id,\\n    uint256 _newPrice\\n  ) internal view {\\n    require(\\n      DATASTORE.readUint(_id, \\\"TYPE\\\") == ID_TYPE.POOL,\\n      \\\"OU: not a pool?\\\"\\n    );\\n\\n    uint256 lastUpdate = STAKER.gETH.priceUpdateTimestamp(_id);\\n    uint256 dayPercentSinceUpdate = ((block.timestamp - lastUpdate) *\\n      PERCENTAGE_DENOMINATOR) / 1 days;\\n\\n    uint256 curPrice = STAKER.gETH.pricePerShare(_id);\\n\\n    uint256 maxPrice = curPrice +\\n      ((curPrice * STAKER.DAILY_PRICE_INCREASE_LIMIT * dayPercentSinceUpdate) /\\n        PERCENTAGE_DENOMINATOR) /\\n      PERCENTAGE_DENOMINATOR;\\n\\n    uint256 minPrice = curPrice -\\n      ((curPrice * STAKER.DAILY_PRICE_DECREASE_LIMIT * dayPercentSinceUpdate) /\\n        PERCENTAGE_DENOMINATOR /\\n        PERCENTAGE_DENOMINATOR);\\n\\n    require(\\n      _newPrice >= minPrice && _newPrice <= maxPrice,\\n      \\\"OU: price is insane\\\"\\n    );\\n  }\\n\\n  /**\\n   * @notice syncing the price of g-derivatives after checking the merkle proofs and the sanity of the price.\\n   * @param _price price of the derivative denominated in gETH.denominator()\\n   * @param _priceProof merkle proofs\\n   */\\n  function _priceSync(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256 _poolId,\\n    uint256 _price,\\n    bytes32[] calldata _priceProof\\n  ) internal {\\n    bytes32 leaf = keccak256(\\n      bytes.concat(keccak256(abi.encode(_poolId, _price)))\\n    );\\n    require(\\n      MerkleProof.verify(_priceProof, STAKER.PRICE_MERKLE_ROOT, leaf),\\n      \\\"OU: NOT all proofs are valid\\\"\\n    );\\n\\n    _sanityCheck(DATASTORE, STAKER, _poolId, _price);\\n\\n    STAKER.gETH.setPricePerShare(_price, _poolId);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice external function to set a derivative price on Portal\\n   * @param price price of the derivative denominated in gETH.denominator()\\n   * @param priceProof merkle proofs\\n   */\\n  function priceSync(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProof\\n  ) external {\\n    _priceSync(DATASTORE, STAKER, poolId, price, priceProof);\\n  }\\n\\n  /**\\n   * @notice external function to set a multiple derivatives price at once, saves gas.\\n   * @param prices price of the derivative denominated in gETH.denominator()\\n   * @param priceProofs merkle proofs\\n   */\\n  function priceSyncBatch(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    SU.PooledStaking storage STAKER,\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external {\\n    require(poolIds.length == prices.length);\\n    require(poolIds.length == priceProofs.length);\\n    for (uint256 i = 0; i < poolIds.length; ++i) {\\n      _priceSync(DATASTORE, STAKER, poolIds[i], prices[i], priceProofs[i]);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xb8e33e210d03af2484d6214859433bf8b37d53bbe969387d9f5327c44ab539e5\",\"license\":\"MIT\"},\"contracts/Portal/utils/StakeUtilsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\nimport {ID_TYPE, VALIDATOR_STATE, PERCENTAGE_DENOMINATOR} from \\\"./globals.sol\\\";\\n\\nimport {DataStoreUtils as DSU} from \\\"./DataStoreUtilsLib.sol\\\";\\nimport {DepositContractUtils as DCU} from \\\"./DepositContractUtilsLib.sol\\\";\\n\\nimport {IgETH} from \\\"../../interfaces/IgETH.sol\\\";\\nimport {IWithdrawalContract} from \\\"../../interfaces/IWithdrawalContract.sol\\\";\\nimport {ISwap} from \\\"../../interfaces/ISwap.sol\\\";\\nimport {ILPToken} from \\\"../../interfaces/ILPToken.sol\\\";\\nimport {IWhitelist} from \\\"../../interfaces/IWhitelist.sol\\\";\\nimport {IgETHInterface} from \\\"../../interfaces/IgETHInterface.sol\\\";\\n\\n/**\\n * @author Icebear & Crash Bandicoot\\n * @title The Staking Library\\n * @notice Creating a global standard for Staking, allowing anyone to create a trustless staking pool,\\n * improving the user experience for stakers and removing the need for intermediaries.\\n * * Exclusively contains functions related to:\\n * * 1. Modular Architecture of Configurable Staking Pools\\n * * 2. Operator Marketplace and Staking Operations.\\n * @dev It is important to keep every pool isolated and remember that every validator is unique.\\n *\\n * @dev Controllers and Maintainers:\\n * * CONTROLLER is the owner of an ID, it manages the pool or the operator and its security is exteremely important.\\n * * maintainer is the worker, can be used to automate some daily tasks\\n * * * like distributing validators for Staking Pools or creating validators for Operators,\\n * * * not so crucial in terms of security.\\n *\\n * @dev Reserved ID_TYPE:\\n *\\n * USERS:\\n *\\n * * Type 4 : Permissioned Operators\\n * * * Needs to be onboarded by the Dual Governance (Senate + Governance).\\n * * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\\n * * * Can participate in the Operator Marketplace after initiation.\\n * * * Can utilize maintainers for staking operations.\\n *\\n * * Type 5 : Configurable Staking Pools\\n * * * Permissionless to create.\\n * * * Can utilize powers of modules such as Bound Liquidity Pools, Interfaces etc.\\n * * * Can be public or private, can use a whitelist if private.\\n * * * Can utilize maintainers for validator distribution on Operator Marketplace.\\n * * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\\n * * * accruing rewards and keeping Staked Ether safe and isolated.\\n *\\n * DEFAULT MODULES:\\n * * Some Modules has only 1 version that can be used by the Pool Owners.\\n *\\n * * Type 21 : Withdrawal Contract implementation version\\n * * * Mandatory.\\n * * * CONTROLLER is the implementation contract position (like always)\\n * * * Requires the approval of Senate\\n * * * Pools are in \\\"Recovery Mode\\\" until their Withdrawal Contract is upgraded.\\n * * * * Meaning, no more Depositing or Staking can happen.\\n *\\n * * Type 41 : Liquidity Pool version\\n * * * Optional.\\n * * * CONTROLLER is the implementation contract position (like always)\\n * * * Requires the approval of Senate.\\n * * * Pools can simply deploy the new version of this Module and start using it, if ever changed.\\n * * * Liquidity Providers however, need to migrate.\\n *\\n * * Type 42 : Liquidity Pool Token version\\n * * * Optional, dependant to Liquidity Pool Module.\\n * * * CONTROLLER is the implementation contract position (like always)\\n * * * Requires the approval of Senate\\n * * * Crucial to have the same name with the LP version\\n *\\n * ALLOWED MODULES:\\n * * Some Modules can support many different versions that can be used by the Pool Owners.\\n *\\n * * Type 31 : gETH interface version\\n * * * Optional.\\n * * * CONTROLLER is the implementation contract position (like always)\\n * * * Requires the approval of Senate\\n * * * Currently should be utilized on initiation.\\n *\\n * @dev Contracts relying on this library must initialize StakeUtils.PooledStaking\\n * @dev Functions are already protected with authentication\\n *\\n * @dev first review DataStoreUtils\\n * @dev then review GeodeUtils\\n */\\n\\nlibrary StakeUtils {\\n  /// @notice Using DataStoreUtils for IsolatedStorage struct\\n  using DSU for DSU.IsolatedStorage;\\n\\n  /// @notice EVENTS\\n  event IdInitiated(uint256 indexed id, uint256 indexed TYPE);\\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\\n  event ValidatorPeriodSwitched(\\n    uint256 indexed id,\\n    uint256 period,\\n    uint256 effectiveAfter\\n  );\\n  event OperatorApproval(\\n    uint256 indexed poolId,\\n    uint256 indexed operatorId,\\n    uint256 allowance\\n  );\\n  event Prisoned(uint256 indexed id, bytes proof, uint256 releaseTimestamp);\\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\\n  event ProposalStaked(\\n    uint256 indexed poolId,\\n    uint256 operatorId,\\n    bytes[] pubkeys\\n  );\\n  event BeaconStaked(bytes[] pubkeys);\\n\\n  /**\\n   * @param state state of the validator, refer to globals.sol\\n   * @param index representing this validator's placement on the chronological order of the validators proposals\\n   * @param poolId needed for withdrawal_credential\\n   * @param operatorId needed for staking after allowance\\n   * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\\n   * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\\n   * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\\n   * @param expectedExit the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\\n   * @param signature BLS12-381 signature for the validator, used when sending the remaining 31 ETH on validator activation.\\n   **/\\n  struct Validator {\\n    uint8 state;\\n    uint256 index;\\n    uint256 poolId;\\n    uint256 operatorId;\\n    uint256 poolFee;\\n    uint256 operatorFee;\\n    uint256 earlyExitFee;\\n    uint256 createdAt;\\n    uint256 expectedExit;\\n    bytes signature31;\\n  }\\n\\n  /**\\n   * @param gETH ERC1155, Staking Derivatives Token, should NOT be changed.\\n   * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\\n   * * Includes all validators: proposed, active, alienated, exited.\\n   * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\\n   * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\\n   * @param EARLY_EXIT_FEE a parameter to be used while handling the validator exits, currently 0 and logic around it is ambigious.\\n   * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\\n   * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval.\\n   * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval.\\n   * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool\\n   * @param ORACLE_POSITION address of the Oracle multisig https://github.com/Geodefi/Telescope-Eth\\n   * @param _defaultModules TYPE => version, pointing to the latest versions of the given TYPE.\\n   * * Like default Withdrawal Contract version.\\n   * @param _allowedModules TYPE => version => isAllowed, useful to check if any version of the module can be used.\\n   * * Like all the whitelisted gETH interfaces.\\n   * @param _validators pubkey => Validator, contains all the data about proposed or/and active validators\\n   * @param __gap keep the struct size at 16\\n   **/\\n  struct PooledStaking {\\n    IgETH gETH;\\n    uint256 VALIDATORS_INDEX;\\n    uint256 VERIFICATION_INDEX;\\n    uint256 MONOPOLY_THRESHOLD;\\n    uint256 EARLY_EXIT_FEE;\\n    uint256 ORACLE_UPDATE_TIMESTAMP;\\n    uint256 DAILY_PRICE_INCREASE_LIMIT;\\n    uint256 DAILY_PRICE_DECREASE_LIMIT;\\n    bytes32 PRICE_MERKLE_ROOT;\\n    address ORACLE_POSITION;\\n    mapping(uint256 => uint256) _defaultModules;\\n    mapping(uint256 => mapping(uint256 => bool)) _allowedModules;\\n    mapping(bytes => Validator) _validators;\\n    uint256[3] __gap;\\n  }\\n  /**\\n   * @notice                                     ** Constants **\\n   */\\n\\n  /// @notice limiting the pool and operator maintenance fee, 10%\\n  uint256 public constant MAX_MAINTENANCE_FEE =\\n    (PERCENTAGE_DENOMINATOR * 10) / 100;\\n\\n  /// @notice limiting EARLY_EXIT_FEE, 5%\\n  uint256 public constant MAX_EARLY_EXIT_FEE =\\n    (PERCENTAGE_DENOMINATOR * 5) / 100;\\n\\n  /// @notice price of gETH is only valid for 24H, after that minting is not allowed.\\n  uint256 public constant PRICE_EXPIRY = 24 hours;\\n\\n  /// @notice ignoring any buybacks if the Liquidity Pools has a low debt\\n  uint256 public constant IGNORABLE_DEBT = 1 ether;\\n\\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 5 years\\n  uint256 public constant MIN_VALIDATOR_PERIOD = 90 days;\\n  uint256 public constant MAX_VALIDATOR_PERIOD = 1825 days;\\n\\n  /// @notice some parameter changes are effective after a delay\\n  uint256 public constant SWITCH_LATENCY = 3 days;\\n\\n  /// @notice limiting the access for Operators in case of bad/malicious/faulty behaviour\\n  uint256 public constant PRISON_SENTENCE = 14 days;\\n\\n  /**\\n   * @notice                                     ** AUTHENTICATION **\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice restricts the access to given function based on TYPE and msg.sender\\n   * @param expectCONTROLLER restricts the access to only CONTROLLER.\\n   * @param expectMaintainer restricts the access to only maintainer.\\n   * @param restrictionMap Restricts which TYPEs can pass the authentication 0: Operator = TYPE(4), Pool = TYPE(5)\\n   * @dev authenticate can only be used after an ID is initiated\\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators can not access.\\n   * @dev In principal, CONTROLLER should be able to do anything a maintainer is authenticated to do.\\n   */\\n  function authenticate(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    bool expectCONTROLLER,\\n    bool expectMaintainer,\\n    bool[2] memory restrictionMap\\n  ) internal view {\\n    require(\\n      DATASTORE.readUint(id, \\\"initiated\\\") != 0,\\n      \\\"SU: ID is not initiated\\\"\\n    );\\n\\n    uint256 typeOfId = DATASTORE.readUint(id, \\\"TYPE\\\");\\n\\n    if (typeOfId == ID_TYPE.OPERATOR) {\\n      require(restrictionMap[0], \\\"SU: TYPE NOT allowed\\\");\\n      if (expectCONTROLLER || expectMaintainer) {\\n        require(\\n          !isPrisoned(DATASTORE, id),\\n          \\\"SU: operator is in prison, get in touch with governance\\\"\\n        );\\n      }\\n    } else if (typeOfId == ID_TYPE.POOL) {\\n      require(restrictionMap[1], \\\"SU: TYPE NOT allowed\\\");\\n    } else revert(\\\"SU: invalid TYPE\\\");\\n\\n    if (expectMaintainer) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(id, \\\"maintainer\\\"),\\n        \\\"SU: sender NOT maintainer\\\"\\n      );\\n      return;\\n    }\\n\\n    if (expectCONTROLLER) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(id, \\\"CONTROLLER\\\"),\\n        \\\"SU: sender NOT CONTROLLER\\\"\\n      );\\n      return;\\n    }\\n  }\\n\\n  /**\\n   * @notice                                     ** CONFIGURABLE STAKING POOL MODULES **\\n   *\\n   * - WithdrawalContracts\\n   * - gETHInterfaces\\n   * - Bound Liquidity Pools\\n   * - Pool visibility (public/private) and using whitelists\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice access all interfaces of a given ID.\\n   * @dev for future referance: unsetted interfaces SHOULD return address(0)\\n   */\\n  function gETHInterfaces(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 index\\n  ) external view returns (address _interface) {\\n    _interface = DATASTORE.readAddressArray(id, \\\"interfaces\\\", index);\\n  }\\n\\n  /**\\n   * @notice returns true if the pool is private\\n   */\\n  function isPrivatePool(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return (DATASTORE.readUint(poolId, \\\"private\\\") == 1);\\n  }\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice internal function to set a gETHInterface\\n   * @param _interface address of the new gETHInterface for given ID\\n   * @dev every interface has a unique index within the \\\"interfaces\\\" dynamic array.\\n   * @dev on unset, SHOULD replace the implementation with address(0) for obvious security reasons.\\n   */\\n  function _setInterface(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address _interface\\n  ) internal {\\n    require(!self.gETH.isInterface(_interface, id), \\\"SU: already interface\\\");\\n    DATASTORE.appendAddressArray(id, \\\"interfaces\\\", _interface);\\n    self.gETH.setInterface(_interface, id, true);\\n  }\\n\\n  /**\\n   * @notice deploys a new gETHInterface by cloning the DEFAULT_gETH_INTERFACE\\n   * @param _version id, can use any version as an interface that is allowed for TYPE = MODULE_GETH_INTERFACE\\n   * @param interface_data interfaces might require additional data on initialization; like name, symbol, etc.\\n   * @dev currrently, can NOT deploy an interface after initiation, thus only used by the initiator.\\n   * @dev currrently, can NOT unset an interface.\\n   */\\n  function _deployInterface(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _version,\\n    bytes memory interface_data\\n  ) internal {\\n    require(\\n      self._allowedModules[ID_TYPE.MODULE_GETH_INTERFACE][_version],\\n      \\\"SU: not an interface\\\"\\n    );\\n\\n    address gInterface = Clones.clone(\\n      DATASTORE.readAddress(_version, \\\"CONTROLLER\\\")\\n    );\\n\\n    require(\\n      IgETHInterface(gInterface).initialize(\\n        _id,\\n        address(self.gETH),\\n        interface_data\\n      ),\\n      \\\"SU: could not init interface\\\"\\n    );\\n\\n    _setInterface(self, DATASTORE, _id, gInterface);\\n  }\\n\\n  /**\\n   * @notice Deploys a Withdrawal Contract that will be used as a withdrawal credential on validator creation\\n   * @dev using the latest version of the MODULE_WITHDRAWAL_CONTRACT\\n   * @dev every pool requires a withdrawal Contract, thus this function is only used by the initiator\\n   */\\n  function _deployWithdrawalContract(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _id\\n  ) internal {\\n    require(\\n      DATASTORE.readAddress(_id, \\\"withdrawalContract\\\") == address(0),\\n      \\\"SU: already has a withdrawal contract\\\"\\n    );\\n\\n    uint256 version = self._defaultModules[ID_TYPE.MODULE_WITHDRAWAL_CONTRACT];\\n\\n    address withdrawalContract = address(\\n      new ERC1967Proxy(\\n        DATASTORE.readAddress(version, \\\"CONTROLLER\\\"),\\n        abi.encodeWithSelector(\\n          IWithdrawalContract(address(0)).initialize.selector,\\n          version,\\n          _id,\\n          self.gETH,\\n          address(this),\\n          DATASTORE.readAddress(_id, \\\"CONTROLLER\\\")\\n        )\\n      )\\n    );\\n\\n    DATASTORE.writeAddress(_id, \\\"withdrawalContract\\\", withdrawalContract);\\n\\n    DATASTORE.writeBytes(\\n      _id,\\n      \\\"withdrawalCredential\\\",\\n      DCU.addressToWC(withdrawalContract)\\n    );\\n  }\\n\\n  /**\\n   * @dev  ->  public\\n   */\\n\\n  /**\\n   * @notice deploys a new liquidity pool using the latest version of MODULE_LIQUDITY_POOL\\n   * @dev sets the liquidity pool, LP token and liquidityPoolVersion\\n   * @dev gives full allowance to the pool, should not be a problem as portal does not hold any tokens\\n   * @param _GOVERNANCE governance address will be the owner of the created pool.\\n   * @dev a controller can deploy a liquidity pool after initiation\\n   * @dev a controller can deploy a new version of this module, but LPs would need to migrate\\n   */\\n  function deployLiquidityPool(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address _GOVERNANCE\\n  ) public {\\n    authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    uint256 lpVersion = self._defaultModules[ID_TYPE.MODULE_LIQUDITY_POOL];\\n\\n    require(\\n      DATASTORE.readUint(poolId, \\\"liquidityPoolVersion\\\") != lpVersion,\\n      \\\"SU: already latest version\\\"\\n    );\\n\\n    address lp = Clones.clone(\\n      DATASTORE.readAddress(lpVersion, \\\"CONTROLLER\\\")\\n    );\\n    bytes memory NAME = DATASTORE.readBytes(poolId, \\\"NAME\\\");\\n\\n    require(\\n      ISwap(lp).initialize(\\n        IgETH(self.gETH),\\n        poolId,\\n        string(abi.encodePacked(NAME, \\\"-Geode LP Token\\\")),\\n        string(abi.encodePacked(NAME, \\\"-LP\\\")),\\n        DATASTORE.readAddress(\\n          self._defaultModules[ID_TYPE.MODULE_LIQUDITY_POOL_TOKEN],\\n          \\\"CONTROLLER\\\"\\n        ),\\n        _GOVERNANCE\\n      ) != address(0),\\n      \\\"SU: could not init liquidity pool\\\"\\n    );\\n\\n    // approve token so we can use it in buybacks\\n    self.gETH.setApprovalForAll(lp, true);\\n\\n    DATASTORE.writeUint(poolId, \\\"liquidityPoolVersion\\\", lpVersion);\\n    DATASTORE.writeAddress(poolId, \\\"liquidityPool\\\", lp);\\n  }\\n\\n  /**\\n   * @notice changes the visibility of the pool\\n   * @param isPrivate true if pool should be private, false for public pools\\n   * Note private pools can whitelist addresses with the help of a third party contract.\\n   */\\n  function setPoolVisibility(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    bool isPrivate\\n  ) public {\\n    authenticate(DATASTORE, poolId, true, false, [false, true]);\\n\\n    require(isPrivate != isPrivatePool(DATASTORE, poolId), \\\"SU: already set\\\");\\n\\n    DATASTORE.writeUint(poolId, \\\"private\\\", isPrivate ? 1 : 0);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice private pools can whitelist addresses with the help of a third party contract\\n   * @dev Whitelisting contracts should implement IWhitelist interface.\\n   */\\n  function setWhitelist(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address whitelist\\n  ) external {\\n    authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(isPrivatePool(DATASTORE, poolId), \\\"SU: must be private pool\\\");\\n    DATASTORE.writeAddress(poolId, \\\"whitelist\\\", whitelist);\\n  }\\n\\n  /**\\n   * @notice                                     ** INITIATORS **\\n   *\\n   * IDs that are occupied by a user should be initiated to be activated\\n   * - Operators need to onboarded by the Dual Governance to be able to initiate an ID.\\n   * - Pools are permissionless, calling the initiator will immediately activate the pool.\\n   */\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice initiates ID as a Permissionned Node Operator\\n   * @notice requires ID to be approved as a node operator with a specific CONTROLLER\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\\n   * @param validatorPeriod the expected maximum staking interval. This value should between\\n   * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above.\\n   * Operator can unstake at any given point before this period ends.\\n   * If operator disobeys this rule, it can be prisoned with blameOperator()\\n   * @param maintainer an address that automates daily operations, a script, a contract...\\n   * @dev operators can fund their internal wallet on initiation by simply sending some ether.\\n   */\\n  function initiateOperator(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external {\\n    require(\\n      DATASTORE.readUint(id, \\\"initiated\\\") == 0,\\n      \\\"SU: already initiated\\\"\\n    );\\n\\n    require(\\n      DATASTORE.readUint(id, \\\"TYPE\\\") == ID_TYPE.OPERATOR,\\n      \\\"SU: TYPE NOT allowed\\\"\\n    );\\n\\n    require(\\n      msg.sender == DATASTORE.readAddress(id, \\\"CONTROLLER\\\"),\\n      \\\"SU: sender NOT CONTROLLER\\\"\\n    );\\n\\n    _setMaintainer(DATASTORE, id, maintainer);\\n    _setMaintenanceFee(DATASTORE, id, fee);\\n    _setValidatorPeriod(DATASTORE, id, validatorPeriod);\\n\\n    _increaseWalletBalance(DATASTORE, id, msg.value);\\n\\n    DATASTORE.writeUint(id, \\\"initiated\\\", block.timestamp);\\n    emit IdInitiated(id, ID_TYPE.OPERATOR);\\n  }\\n\\n  /**\\n   * @notice Creates a Configurable Trustless Staking Pool!\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\\n   * @param interfaceVersion Pool creators can choose any allowed version as their gETHInterface\\n   * @param maintainer an address that automates daily operations, a script, a contract... not really powerful.\\n   * @param _GOVERNANCE needed in case the Pool is configured with a Bound Liquidity Pool\\n   * @param NAME used to generate an ID for the Pool\\n   * @param interface_data interfaces might require additional data on initialization; like name, symbol, etc.\\n   * @param config [private(true) or public(false), deploying an interface with given version, deploying liquidity pool with latest version]\\n   * @dev checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.\\n   * @dev requires exactly 1 validator worth of funds to be deposited on initiation - to prevent sybil attacks\\n   */\\n  function initiatePool(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 fee,\\n    uint256 interfaceVersion,\\n    address maintainer,\\n    address _GOVERNANCE,\\n    bytes calldata NAME,\\n    bytes calldata interface_data,\\n    bool[3] calldata config\\n  ) external {\\n    require(\\n      msg.value == DCU.DEPOSIT_AMOUNT,\\n      \\\"SU: requires 1 validator worth of Ether\\\"\\n    );\\n\\n    uint256 id = DSU.generateId(NAME, ID_TYPE.POOL);\\n\\n    require(id > 10 ** 7, \\\"SU: Wow! low id\\\");\\n\\n    require(\\n      DATASTORE.readUint(id, \\\"initiated\\\") == 0,\\n      \\\"SU: already initiated\\\"\\n    );\\n    DATASTORE.writeUint(id, \\\"TYPE\\\", ID_TYPE.POOL);\\n    DATASTORE.writeAddress(id, \\\"CONTROLLER\\\", msg.sender);\\n    DATASTORE.writeBytes(id, \\\"NAME\\\", NAME);\\n    DATASTORE.writeUint(id, \\\"initiated\\\", block.timestamp);\\n    DATASTORE.allIdsByType[ID_TYPE.POOL].push(id);\\n\\n    _setMaintainer(DATASTORE, id, maintainer);\\n    _setMaintenanceFee(DATASTORE, id, fee);\\n\\n    _deployWithdrawalContract(self, DATASTORE, id);\\n    if (config[0]) setPoolVisibility(DATASTORE, id, true);\\n    if (config[1])\\n      _deployInterface(self, DATASTORE, id, interfaceVersion, interface_data);\\n    if (config[2]) deployLiquidityPool(self, DATASTORE, id, _GOVERNANCE);\\n\\n    // initially 1 ETHER = 1 ETHER\\n    self.gETH.setPricePerShare(1 ether, id);\\n\\n    // mint gETH and send back to the caller\\n    uint256 mintedgETH = _mintgETH(self, DATASTORE, id, DCU.DEPOSIT_AMOUNT);\\n    self.gETH.safeTransferFrom(address(this), msg.sender, id, mintedgETH, \\\"\\\");\\n\\n    emit IdInitiated(id, ID_TYPE.POOL);\\n  }\\n\\n  /**\\n   * @notice                                     ** MAINTAINERS **\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice Set the maintainer address on initiation or later\\n   * @param newMaintainer address of the new maintainer\\n   */\\n  function _setMaintainer(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address newMaintainer\\n  ) internal {\\n    require(newMaintainer != address(0), \\\"SU: maintainer can NOT be zero\\\");\\n\\n    address currentMaintainer = DATASTORE.readAddress(id, \\\"maintainer\\\");\\n\\n    require(\\n      currentMaintainer != newMaintainer,\\n      \\\"SU: provided the current maintainer\\\"\\n    );\\n\\n    DATASTORE.writeAddress(id, \\\"maintainer\\\", newMaintainer);\\n    emit MaintainerChanged(id, newMaintainer);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n  /**\\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\\n   * @dev there can only be 1 maintainer per ID.\\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\\n   */\\n  function changeMaintainer(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address newMaintainer\\n  ) external {\\n    authenticate(DATASTORE, id, true, false, [true, true]);\\n    _setMaintainer(DATASTORE, id, newMaintainer);\\n  }\\n\\n  /**\\n   * @notice                                     ** MAINTENANCE FEE **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\\n   */\\n  function getMaintenanceFee(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 fee) {\\n    if (DATASTORE.readUint(id, \\\"feeSwitch\\\") > block.timestamp) {\\n      return DATASTORE.readUint(id, \\\"priorFee\\\");\\n    }\\n    return DATASTORE.readUint(id, \\\"fee\\\");\\n  }\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice  internal function to set fee with NO DELAY\\n   */\\n  function _setMaintenanceFee(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _newFee\\n  ) internal {\\n    require(_newFee <= MAX_MAINTENANCE_FEE, \\\"SU: > MAX_MAINTENANCE_FEE \\\");\\n    DATASTORE.writeUint(_id, \\\"fee\\\", _newFee);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\\n   * Note Can NOT be called again while its currently switching.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   */\\n  function switchMaintenanceFee(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 newFee\\n  ) external {\\n    authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(\\n      block.timestamp > DATASTORE.readUint(id, \\\"feeSwitch\\\"),\\n      \\\"SU: fee is currently switching\\\"\\n    );\\n\\n    DATASTORE.writeUint(\\n      id,\\n      \\\"priorFee\\\",\\n      DATASTORE.readUint(id, \\\"fee\\\")\\n    );\\n    DATASTORE.writeUint(id, \\\"feeSwitch\\\", block.timestamp + SWITCH_LATENCY);\\n\\n    _setMaintenanceFee(DATASTORE, id, newFee);\\n\\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @notice                                     ** INTERNAL WALLET **\\n   *\\n   * Internal wallet of an ID accrues fees over time.\\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice Simply increases the balance of an IDs Maintainer wallet\\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\\n   * @return success if the amount was deducted\\n   */\\n  function _increaseWalletBalance(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal returns (bool success) {\\n    DATASTORE.addUint(_id, \\\"wallet\\\", _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice To decrease the balance of an Operator's wallet internally\\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\\n   */\\n  function _decreaseWalletBalance(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal returns (bool success) {\\n    require(\\n      DATASTORE.readUint(_id, \\\"wallet\\\") >= _value,\\n      \\\"SU: NOT enough funds in wallet\\\"\\n    );\\n    DATASTORE.subUint(_id, \\\"wallet\\\", _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice external function to increase the internal wallet balance\\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\\n   */\\n  function increaseWalletBalance(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) external returns (bool success) {\\n    authenticate(DATASTORE, id, false, false, [true, true]);\\n    return _increaseWalletBalance(DATASTORE, id, msg.value);\\n  }\\n\\n  /**\\n   * @notice external function to decrease the internal wallet balance\\n   * @dev only CONTROLLER can decrease the balance externally,\\n   * @return success if the amount was sent and deducted\\n   */\\n  function decreaseWalletBalance(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 value\\n  ) external returns (bool success) {\\n    authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(address(this).balance >= value, \\\"SU: not enough funds in Portal ?\\\");\\n\\n    bool decreased = _decreaseWalletBalance(DATASTORE, id, value);\\n\\n    (bool sent, ) = payable(DATASTORE.readAddress(id, \\\"CONTROLLER\\\")).call{\\n      value: value\\n    }(\\\"\\\");\\n    require(decreased && sent, \\\"SU: Failed to send ETH\\\");\\n    return sent;\\n  }\\n\\n  /**\\n   * @notice                                     ** PRISON **\\n   *\\n   * When node operators act in a malicious way, which can also be interpereted as\\n   * an honest mistake like using a faulty signature, Oracle imprisons the operator.\\n   * These conditions are:\\n   * * 1. Created a malicious validator(alien): faulty withdrawal credential, faulty signatures etc.\\n   * * 2. Have not respect the validatorPeriod\\n   * * 3. Stole block fees or MEV boost rewards from the pool\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice Checks if the given operator is Prisoned\\n   * @dev \\\"released\\\" key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function isPrisoned(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _operatorId\\n  ) public view returns (bool) {\\n    return (block.timestamp < DATASTORE.readUint(_operatorId, \\\"released\\\"));\\n  }\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice Put an operator in prison\\n   * @dev \\\"released\\\" key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function _imprison(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    bytes calldata proof\\n  ) internal {\\n    authenticate(DATASTORE, _operatorId, false, false, [true, false]);\\n\\n    DATASTORE.writeUint(\\n      _operatorId,\\n      \\\"released\\\",\\n      block.timestamp + PRISON_SENTENCE\\n    );\\n\\n    emit Prisoned(_operatorId, proof, block.timestamp + PRISON_SENTENCE);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice allows imprisoning an Operator if the validator have not been exited until expectedExit\\n   * @dev anyone can call this function\\n   * @dev if operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned\\n   */\\n  function blameOperator(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    bytes calldata pk\\n  ) external {\\n    require(\\n      self._validators[pk].state == VALIDATOR_STATE.ACTIVE,\\n      \\\"SU: validator is never activated\\\"\\n    );\\n    require(\\n      block.timestamp > self._validators[pk].expectedExit,\\n      \\\"SU: validator is still active\\\"\\n    );\\n\\n    _imprison(DATASTORE, self._validators[pk].operatorId, pk);\\n  }\\n\\n  /**\\n   * @notice                                     ** OPERATOR FUNCTIONS **\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice internal function to set validator period with NO DELAY\\n   */\\n  function _setValidatorPeriod(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    uint256 _newPeriod\\n  ) internal {\\n    require(\\n      _newPeriod >= MIN_VALIDATOR_PERIOD,\\n      \\\"SU: should be more than MIN_VALIDATOR_PERIOD\\\"\\n    );\\n\\n    require(\\n      _newPeriod <= MAX_VALIDATOR_PERIOD,\\n      \\\"SU: should be less than MAX_VALIDATOR_PERIOD\\\"\\n    );\\n\\n    DATASTORE.writeUint(_operatorId, \\\"validatorPeriod\\\", _newPeriod);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\\n   */\\n  function switchValidatorPeriod(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 operatorId,\\n    uint256 newPeriod\\n  ) external {\\n    authenticate(DATASTORE, operatorId, true, true, [true, false]);\\n\\n    require(\\n      block.timestamp > DATASTORE.readUint(operatorId, \\\"periodSwitch\\\"),\\n      \\\"SU: period is currently switching\\\"\\n    );\\n\\n    DATASTORE.writeUint(\\n      operatorId,\\n      \\\"priorPeriod\\\",\\n      DATASTORE.readUint(operatorId, \\\"validatorPeriod\\\")\\n    );\\n    DATASTORE.writeUint(\\n      operatorId,\\n      \\\"periodSwitch\\\",\\n      block.timestamp + SWITCH_LATENCY\\n    );\\n\\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\\n\\n    emit ValidatorPeriodSwitched(\\n      operatorId,\\n      newPeriod,\\n      block.timestamp + SWITCH_LATENCY\\n    );\\n  }\\n\\n  /**\\n   * @notice                                     ** OPERATOR MARKETPLACE **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /** *\\n   * @notice operatorAllowance is the maximum number of validators that the given Operator is allowed to create on behalf of the Pool\\n   * @dev an operator can not create new validators if:\\n   * * 1. allowance is 0 (zero)\\n   * * 2. lower than the current (proposed + active) number of validators\\n   * * But if operator withdraws a validator, then able to create a new one.\\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\\n   */\\n  function operatorAllowance(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId\\n  ) public view returns (uint256 allowance) {\\n    allowance = DATASTORE.readUint(\\n      poolId,\\n      DSU.getKey(operatorId, \\\"allowance\\\")\\n    );\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\\n   * * This number can be set again at any given point in the future.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorIds array of Operator IDs to allow them create validators\\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\\n   * @dev When decreased the approved validator count below current active+proposed validators,\\n   * operator can NOT create new validators.\\n   */\\n  function batchApproveOperators(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external returns (bool) {\\n    authenticate(DATASTORE, poolId, true, true, [false, true]);\\n\\n    require(\\n      operatorIds.length == allowances.length,\\n      \\\"SU: allowances should match\\\"\\n    );\\n\\n    for (uint256 i = 0; i < operatorIds.length; ) {\\n      authenticate(DATASTORE, operatorIds[i], false, false, [true, false]);\\n\\n      DATASTORE.writeUint(\\n        poolId,\\n        DSU.getKey(operatorIds[i], \\\"allowance\\\"),\\n        allowances[i]\\n      );\\n\\n      emit OperatorApproval(poolId, operatorIds[i], allowances[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * @notice                                     ** POOL HELPERS **\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice returns WithdrawalContract as a contract\\n   */\\n  function withdrawalContractById(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (IWithdrawalContract) {\\n    return\\n      IWithdrawalContract(\\n        DATASTORE.readAddress(poolId, \\\"withdrawalContract\\\")\\n      );\\n  }\\n\\n  /**\\n   * @notice returns liquidityPool as a contract\\n   */\\n  function liquidityPoolById(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) public view returns (ISwap) {\\n    return ISwap(DATASTORE.readAddress(_poolId, \\\"liquidityPool\\\"));\\n  }\\n\\n  /**\\n   * @notice checks if the Whitelist allows staker to use given private pool\\n   * @dev Owner of the pool doesn't need whitelisting\\n   * @dev Otherwise requires a whitelisting address to be set\\n   * todo: add to portal\\n   */\\n  function isWhitelisted(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address staker\\n  ) public view returns (bool) {\\n    if (DATASTORE.readAddress(poolId, \\\"CONTROLLER\\\") == msg.sender)\\n      return true;\\n\\n    address whitelist = DATASTORE.readAddress(poolId, \\\"whitelist\\\");\\n    require(whitelist != address(0), \\\"SU: this pool does not have whitelist\\\");\\n\\n    return IWhitelist(whitelist).isAllowed(staker);\\n  }\\n\\n  /**\\n   * @notice returns true if the price is valid:\\n   * - last price syncinc happened less than 24h\\n   * - there has been no oracle reports since the last update\\n   *\\n   * @dev known bug / feature: if there have been no oracle updates,\\n   * * this function will return true.\\n   *\\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\\n   *    : false\\n   */\\n  function isPriceValid(\\n    PooledStaking storage self,\\n    uint256 poolId\\n  ) public view returns (bool isValid) {\\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\\n    unchecked {\\n      isValid =\\n        lastupdate + PRICE_EXPIRY >= block.timestamp ||\\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\\n    }\\n  }\\n\\n  /**\\n   * @notice checks if staking is allowed in given staking pool\\n   * @notice staking is not allowed if:\\n   * 1. Price is not valid\\n   * 2. WithdrawalContract is in Recovery Mode, can have many reasons\\n   */\\n  function isMintingAllowed(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return\\n      isPriceValid(self, poolId) &&\\n      !(withdrawalContractById(DATASTORE, poolId).recoveryMode());\\n  }\\n\\n  /**\\n   * @notice                                     ** POOLING OPERATIONS **\\n   */\\n\\n  /**\\n   * @dev  ->  internal\\n   */\\n\\n  /**\\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\\n   * @dev fails if the price if minting is not allowed\\n   */\\n  function _mintgETH(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 ethAmount\\n  ) internal returns (uint256 mintedgETH) {\\n    require(\\n      isMintingAllowed(self, DATASTORE, poolId),\\n      \\\"SU: minting is not allowed\\\"\\n    );\\n\\n    mintedgETH = (\\n      ((ethAmount * self.gETH.denominator()) / self.gETH.pricePerShare(poolId))\\n    );\\n\\n    self.gETH.mint(address(this), poolId, mintedgETH, \\\"\\\");\\n    DATASTORE.addUint(poolId, \\\"surplus\\\", ethAmount);\\n  }\\n\\n  /**\\n   * @notice conducts a buyback using the given liquidity pool\\n   * @param poolId id of the gETH that will be bought\\n   * @param sellEth ETH amount to sell\\n   * @param minToBuy TX is expected to revert by Swap.sol if not meet\\n   * @param deadline TX is expected to revert by Swap.sol if not meet\\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\\n   * as index 0 is ETH and index 1 is gETH!\\n   */\\n  function _buyback(\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 sellEth,\\n    uint256 minToBuy,\\n    uint256 deadline\\n  ) internal returns (uint256 outAmount) {\\n    // SWAP in LP\\n    outAmount = liquidityPoolById(DATASTORE, poolId).swap{value: sellEth}(\\n      0,\\n      1,\\n      sellEth,\\n      minToBuy,\\n      deadline\\n    );\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice Allowing users to deposit into a staking pool.\\n   * @notice If a pool is not public only the maintainer can deposit.\\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\\n   * @param mingETH liquidity pool parameter\\n   * @param deadline liquidity pool parameter\\n   * @dev an example for minting + buybacks\\n   * * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\\n   * // debt  msgValue\\n   * // 100   10  => buyback\\n   * // 100   100 => buyback\\n   * // 10    100 => buyback + mint\\n   * // 1     x   => mint\\n   * // 0.5   x   => mint\\n   * // 0     x   => mint\\n   */\\n  function deposit(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\\n    authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(deadline > block.timestamp, \\\"SU: deadline not met\\\");\\n    require(receiver != address(0), \\\"SU: receiver is zero address\\\");\\n\\n    if (isPrivatePool(DATASTORE, poolId))\\n      require(\\n        isWhitelisted(DATASTORE, poolId, msg.sender),\\n        \\\"SU: sender NOT whitelisted\\\"\\n      );\\n\\n    uint256 remEth = msg.value;\\n\\n    if (DATASTORE.readAddress(poolId, \\\"liquidityPool\\\") != address(0)) {\\n      uint256 debt = liquidityPoolById(DATASTORE, poolId).getDebt();\\n      if (debt > IGNORABLE_DEBT) {\\n        if (debt < remEth) {\\n          boughtgETH = _buyback(DATASTORE, poolId, debt, 0, deadline);\\n          remEth -= debt;\\n        } else {\\n          boughtgETH = _buyback(DATASTORE, poolId, remEth, mingETH, deadline);\\n          remEth = 0;\\n        }\\n      }\\n    }\\n\\n    if (remEth > 0) mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\\n    require(boughtgETH + mintedgETH >= mingETH, \\\"SU: less than minimum\\\");\\n\\n    // send back to user\\n    self.gETH.safeTransferFrom(\\n      address(this),\\n      receiver,\\n      poolId,\\n      boughtgETH + mintedgETH,\\n      \\\"\\\"\\n    );\\n\\n    emit Deposit(poolId, boughtgETH, mintedgETH);\\n  }\\n\\n  /**\\n   * @notice                                     ** VALIDATOR OPERATIONS **\\n   *\\n   * Creation of a Validator takes 2 steps: propose and beacon stake.\\n   * Before entering beaconStake function, _canStake verifies the eligibility of\\n   * given pubKey that is proposed by an operator with proposeStake function.\\n   * Eligibility is defined by an optimistic alienation, check alienate() for info.\\n   */\\n\\n  /**\\n   * @dev  ->  view\\n   */\\n\\n  /**\\n   * @notice internal function to check if a validator can use the pool funds\\n   *\\n   *  @param pubkey BLS12-381 public key of the validator\\n   *  @return true if:\\n   *   - pubkey should be proposed\\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\\n   *   - validator's index should be lower than VERIFICATION_INDEX. Updated by Telescope.\\n   * Note: TODO while distributing the rewards, if a validator has 1 Eth, it is safe to assume that the balance belongs to Operator\\n   */\\n  function _canStake(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    bytes calldata pubkey,\\n    uint256 verificationIndex\\n  ) internal view returns (bool) {\\n    return\\n      (self._validators[pubkey].state == VALIDATOR_STATE.PROPOSED &&\\n        self._validators[pubkey].index <= verificationIndex) &&\\n      !(\\n        withdrawalContractById(DATASTORE, self._validators[pubkey].poolId)\\n          .recoveryMode()\\n      );\\n  }\\n\\n  /**\\n   * @notice external function to check if a validator can use the pool funds\\n   */\\n  function canStake(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    bytes calldata pubkey\\n  ) external view returns (bool) {\\n    return _canStake(self, DATASTORE, pubkey, self.VERIFICATION_INDEX);\\n  }\\n\\n  /**\\n   * @dev  ->  external\\n   */\\n\\n  /**\\n   * @notice Helper Struct to pack constant data that does not change per validator.\\n   * * needed for that famous Solidity feature.\\n   */\\n  struct constantValidatorData {\\n    uint256 index;\\n    uint256 poolFee;\\n    uint256 operatorFee;\\n    uint256 earlyExitFee;\\n    uint256 expectedExit;\\n    bytes withdrawalCredential;\\n  }\\n\\n  /**\\n   * @notice Validator Credentials Proposal function, first step of crating validators.\\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\\n   * * it is optimistically allowed to take funds from staking pools.\\n   *\\n   * @param poolId the id of the staking pool\\n   * @param operatorId the id of the Operator whose maintainer calling this function\\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\\n   * maintainer balance\\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on beaconStake\\n   *\\n   * @dev DCU.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCU.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\\n   * 31 Ether will be staked after verification of oracles. 32 in total.\\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\\n   * @dev ProposeStake requires enough funds within Wallet.\\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 64)\\n   */\\n  function proposeStake(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external {\\n    // checks and effects\\n    authenticate(DATASTORE, operatorId, true, true, [true, false]);\\n    authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    {\\n      uint256 pkLen = pubkeys.length;\\n\\n      require(\\n        pkLen > 0 && pkLen <= DCU.MAX_DEPOSITS_PER_CALL,\\n        \\\"SU: MAX 50 nodes per call\\\"\\n      );\\n      require(pkLen == signatures1.length, \\\"SU: invalid signatures1 length\\\");\\n      require(pkLen == signatures31.length, \\\"SU: invalid signatures31 length\\\");\\n\\n      unchecked {\\n        require(\\n          (DATASTORE.readUint(operatorId, \\\"totalActiveValidators\\\") +\\n            DATASTORE.readUint(operatorId, \\\"totalProposedValidators\\\") +\\n            pkLen) <= self.MONOPOLY_THRESHOLD,\\n          \\\"SU: IceBear does NOT like monopolies\\\"\\n        );\\n\\n        require(\\n          (DATASTORE.readUint(\\n            poolId,\\n            DSU.getKey(operatorId, \\\"proposedValidators\\\")\\n          ) +\\n            DATASTORE.readUint(\\n              poolId,\\n              DSU.getKey(operatorId, \\\"activeValidators\\\")\\n            ) +\\n            pkLen) <= operatorAllowance(DATASTORE, poolId, operatorId),\\n          \\\"SU: NOT enough allowance\\\"\\n        );\\n\\n        require(\\n          DATASTORE.readUint(poolId, \\\"surplus\\\") >=\\n            DCU.DEPOSIT_AMOUNT * pkLen,\\n          \\\"SU: NOT enough surplus\\\"\\n        );\\n      }\\n\\n      _decreaseWalletBalance(\\n        DATASTORE,\\n        operatorId,\\n        (pkLen * DCU.DEPOSIT_AMOUNT_PRESTAKE)\\n      );\\n\\n      DATASTORE.subUint(poolId, \\\"surplus\\\", (pkLen * DCU.DEPOSIT_AMOUNT));\\n\\n      DATASTORE.addUint(poolId, \\\"secured\\\", (pkLen * DCU.DEPOSIT_AMOUNT));\\n\\n      DATASTORE.addUint(\\n        poolId,\\n        DSU.getKey(operatorId, \\\"proposedValidators\\\"),\\n        pkLen\\n      );\\n\\n      DATASTORE.addUint(operatorId, \\\"totalProposedValidators\\\", pkLen);\\n    }\\n\\n    constantValidatorData memory valData = constantValidatorData({\\n      index: self.VALIDATORS_INDEX + 1,\\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\\n      earlyExitFee: self.EARLY_EXIT_FEE,\\n      expectedExit: block.timestamp +\\n        DATASTORE.readUint(operatorId, \\\"validatorPeriod\\\"),\\n      withdrawalCredential: DATASTORE.readBytes(\\n        poolId,\\n        \\\"withdrawalCredential\\\"\\n      )\\n    });\\n\\n    for (uint256 i; i < pubkeys.length; ) {\\n      require(\\n        self._validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\\n        \\\"SU: Pubkey already used or alienated\\\"\\n      );\\n      require(\\n        pubkeys[i].length == DCU.PUBKEY_LENGTH,\\n        \\\"SU: PUBKEY_LENGTH ERROR\\\"\\n      );\\n      require(\\n        signatures1[i].length == DCU.SIGNATURE_LENGTH,\\n        \\\"SU: SIGNATURE_LENGTH ERROR\\\"\\n      );\\n\\n      require(\\n        signatures31[i].length == DCU.SIGNATURE_LENGTH,\\n        \\\"SU: SIGNATURE_LENGTH ERROR\\\"\\n      );\\n\\n      self._validators[pubkeys[i]] = Validator(\\n        1,\\n        valData.index + i,\\n        poolId,\\n        operatorId,\\n        valData.poolFee,\\n        valData.operatorFee,\\n        valData.earlyExitFee,\\n        block.timestamp,\\n        valData.expectedExit,\\n        signatures31[i]\\n      );\\n\\n      DCU.depositValidator(\\n        pubkeys[i],\\n        valData.withdrawalCredential,\\n        signatures1[i],\\n        DCU.DEPOSIT_AMOUNT_PRESTAKE\\n      );\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.VALIDATORS_INDEX += pubkeys.length;\\n\\n    emit ProposalStaked(poolId, operatorId, pubkeys);\\n  }\\n\\n  /**\\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\\n   *\\n   *  @param operatorId the id of the Operator whose maintainer calling this function\\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\\n   *\\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\\n   *  pk1, pk2, pk3 from pool1\\n   *  pk4, pk5 from pool2\\n   *  pk6 from pool3\\n   *  seperate them in similar groups as much as possible.\\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 64)\\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\\n   */\\n  function beaconStake(\\n    PooledStaking storage self,\\n    DSU.IsolatedStorage storage DATASTORE,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys\\n  ) external {\\n    authenticate(DATASTORE, operatorId, true, true, [true, false]);\\n\\n    require(\\n      pubkeys.length > 0 && pubkeys.length <= DCU.MAX_DEPOSITS_PER_CALL,\\n      \\\"SU: MAX 50 nodes\\\"\\n    );\\n\\n    {\\n      uint256 verificationIndex = self.VERIFICATION_INDEX;\\n      for (uint256 j; j < pubkeys.length; ) {\\n        require(\\n          _canStake(self, DATASTORE, pubkeys[j], verificationIndex),\\n          \\\"SU: NOT all pubkeys are stakeable\\\"\\n        );\\n        unchecked {\\n          j += 1;\\n        }\\n      }\\n    }\\n\\n    {\\n      bytes32 activeValKey = DSU.getKey(operatorId, \\\"activeValidators\\\");\\n      bytes32 proposedValKey = DSU.getKey(operatorId, \\\"proposedValidators\\\");\\n\\n      uint256 poolId = self._validators[pubkeys[0]].poolId;\\n\\n      bytes memory withdrawalCredential = DATASTORE.readBytes(\\n        poolId,\\n        \\\"withdrawalCredential\\\"\\n      );\\n\\n      uint256 lastIdChange;\\n      for (uint256 i; i < pubkeys.length; ) {\\n        if (poolId != self._validators[pubkeys[i]].poolId) {\\n          uint256 sinceLastIdChange;\\n\\n          unchecked {\\n            sinceLastIdChange = i - lastIdChange;\\n          }\\n\\n          DATASTORE.subUint(\\n            poolId,\\n            \\\"secured\\\",\\n            (DCU.DEPOSIT_AMOUNT * (sinceLastIdChange))\\n          );\\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n\\n          poolId = self._validators[pubkeys[i]].poolId;\\n          withdrawalCredential = DATASTORE.readBytes(\\n            poolId,\\n            \\\"withdrawalCredential\\\"\\n          );\\n          lastIdChange = i;\\n        }\\n\\n        bytes memory signature = self._validators[pubkeys[i]].signature31;\\n\\n        DCU.depositValidator(\\n          pubkeys[i],\\n          withdrawalCredential,\\n          signature,\\n          DCU.DEPOSIT_AMOUNT - DCU.DEPOSIT_AMOUNT_PRESTAKE\\n        );\\n\\n        DATASTORE.appendBytesArray(poolId, \\\"validators\\\", pubkeys[i]);\\n        self._validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\\n        unchecked {\\n          i += 1;\\n        }\\n      }\\n      {\\n        uint256 sinceLastIdChange;\\n        unchecked {\\n          sinceLastIdChange = pubkeys.length - lastIdChange;\\n        }\\n\\n        DATASTORE.subUint(\\n          poolId,\\n          \\\"secured\\\",\\n          DCU.DEPOSIT_AMOUNT * (sinceLastIdChange)\\n        );\\n        DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n        DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n\\n        DATASTORE.addUint(\\n          operatorId,\\n          \\\"totalActiveValidators\\\",\\n          pubkeys.length\\n        );\\n        DATASTORE.subUint(\\n          operatorId,\\n          \\\"totalProposedValidators\\\",\\n          pubkeys.length\\n        );\\n        _increaseWalletBalance(\\n          DATASTORE,\\n          operatorId,\\n          DCU.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length\\n        );\\n      }\\n      emit BeaconStaked(pubkeys);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9c44c0565e797fae15fa9accbd63d842266f01e7bd747626df2449c433e2d53a\",\"license\":\"MIT\"},\"contracts/Portal/utils/globals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// PERCENTAGE_DENOMINATOR represents 100%\\nuint256 constant PERCENTAGE_DENOMINATOR = 10 ** 10;\\n\\n/**\\n * @notice ID_TYPE is like an ENUM, widely used within Portal and Modules like Withdrawal Contract\\n * @dev Why not use enums, they basically do the same thing?\\n * * We like using a explicit defined uints than linearly increasing ones.\\n */\\nlibrary ID_TYPE {\\n  /// @notice TYPE 0: *invalid*\\n  uint256 internal constant NONE = 0;\\n\\n  /// @notice TYPE 1: Senate and Senate Election Proposals\\n  uint256 internal constant SENATE = 1;\\n\\n  /// @notice TYPE 2: Contract Upgrade\\n  uint256 internal constant CONTRACT_UPGRADE = 2;\\n\\n  /// @notice TYPE 3: *gap*: formally represented the admin contract, now reserved to be never used\\n  uint256 internal constant __GAP__ = 3;\\n\\n  /// @notice TYPE 4: Node Operators\\n  uint256 internal constant OPERATOR = 4;\\n\\n  /// @notice TYPE 5: Staking Pools\\n  uint256 internal constant POOL = 5;\\n\\n  /// @notice TYPE 21: Module: Withdrawal Contract\\n  uint256 internal constant MODULE_WITHDRAWAL_CONTRACT = 21;\\n\\n  /// @notice TYPE 31: Module: A new gETH interface\\n  uint256 internal constant MODULE_GETH_INTERFACE = 31;\\n\\n  /// @notice TYPE 41: Module: A new Liquidity Pool\\n  uint256 internal constant MODULE_LIQUDITY_POOL = 41;\\n\\n  /// @notice TYPE 42: Module: A new Liquidity Pool token\\n  uint256 internal constant MODULE_LIQUDITY_POOL_TOKEN = 42;\\n}\\n\\n/**\\n * @notice VALIDATOR_STATE keeping track of validators within The Staking Library\\n */\\nlibrary VALIDATOR_STATE {\\n  /// @notice STATE 0: *invalid*\\n  uint8 internal constant NONE = 0;\\n\\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract\\n  uint8 internal constant PROPOSED = 1;\\n\\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator\\n  uint8 internal constant ACTIVE = 2;\\n\\n  /// @notice STATE 3: validator is exited, not currently used much\\n  uint8 internal constant EXITED = 3;\\n\\n  /// @notice STATE 69: proposal was malicious(alien), maybe faulty signatures or probably: (https://bit.ly/3Tkc6UC)\\n  uint8 internal constant ALIENATED = 69;\\n}\\n\",\"keccak256\":\"0xda2ab3b886f2e31a1c6dabf2115aead8022e6b91bf0495e3793b7a5189824478\",\"license\":\"MIT\"},\"contracts/Portal/withdrawalContract/WithdrawalContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport {ID_TYPE} from \\\"../utils/globals.sol\\\";\\nimport {DataStoreUtils} from \\\"../utils/DataStoreUtilsLib.sol\\\";\\nimport {GeodeUtils} from \\\"../utils/GeodeUtilsLib.sol\\\";\\n\\nimport {IgETH} from \\\"../../interfaces/IgETH.sol\\\";\\nimport {IPortal} from \\\"../../interfaces/IPortal.sol\\\";\\nimport {IWithdrawalContract} from \\\"../../interfaces/IWithdrawalContract.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @author Icebear & Crash Bandicoot\\n * @title WithdrawalContract: Saviour of Trustless Staking Derivatives\\n * @notice This is a simple contract:\\n * - used as the withdrawal credential of the validators.\\n * - accrues fees and rewards from validators over time.\\n * - handles the withdrawal queue for stakers.\\n * - manages its own versioning without trusting Portal.\\n * @dev This contract utilizes Dual Governance between Portal (GOVERNANCE) and \\n the Pool Owner (SENATE) to empower the Limited Upgradability.\\n *\\n * @dev Recovery Mode stops pool operations while allowing withdrawal queue to operate as usual\\n *\\n * @dev todo: Withdrawal Queue\\n */\\n\\ncontract WithdrawalContract is\\n  IWithdrawalContract,\\n  ReentrancyGuardUpgradeable,\\n  PausableUpgradeable,\\n  UUPSUpgradeable\\n{\\n  using DataStoreUtils for DataStoreUtils.IsolatedStorage;\\n  using GeodeUtils for GeodeUtils.DualGovernance;\\n\\n  ///@notice Events\\n  event ControllerChanged(uint256 id, address newCONTROLLER);\\n  event Proposed(\\n    uint256 id,\\n    address CONTROLLER,\\n    uint256 TYPE,\\n    uint256 deadline\\n  );\\n  event ProposalApproved(uint256 id);\\n  event NewSenate(address senate, uint256 senateExpiry);\\n\\n  event ContractVersionSet(uint256 version);\\n\\n  ///@notice Variables\\n  DataStoreUtils.IsolatedStorage private DATASTORE;\\n  GeodeUtils.DualGovernance private GEM;\\n  address internal gETH;\\n  uint256 internal POOL_ID;\\n  uint256 internal CONTRACT_VERSION;\\n\\n  function initialize(\\n    uint256 _VERSION,\\n    uint256 _ID,\\n    address _gETH,\\n    address _PORTAL,\\n    address _OWNER\\n  ) public virtual override initializer returns (bool) {\\n    __ReentrancyGuard_init();\\n    __Pausable_init();\\n    __UUPSUpgradeable_init();\\n\\n    gETH = _gETH;\\n    POOL_ID = _ID;\\n\\n    GEM.GOVERNANCE = _PORTAL;\\n    GEM.SENATE = _OWNER;\\n    GEM.SENATE_EXPIRY = type(uint256).max;\\n\\n    CONTRACT_VERSION = _VERSION;\\n    emit ContractVersionSet(_VERSION);\\n\\n    return true;\\n  }\\n\\n  modifier onlyPortal() {\\n    require(\\n      msg.sender == GEM.getGovernance(),\\n      \\\"WithdrawalContract: sender NOT PORTAL\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      msg.sender == GEM.getSenate(),\\n      \\\"WithdrawalContract: sender NOT OWNER\\\"\\n    );\\n    _;\\n  }\\n\\n  ///@dev required by the UUPS module\\n  function _authorizeUpgrade(\\n    address proposed_implementation\\n  ) internal virtual override onlyOwner {\\n    require(\\n      GEM.isUpgradeAllowed(proposed_implementation),\\n      \\\"WithdrawalContract: NOT allowed to upgrade\\\"\\n    );\\n  }\\n\\n  /**\\n   * @notice pausing the contract activates the recoveryMode\\n   */\\n  function pause() external virtual override onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice unpausing the contract deactivates the recoveryMode\\n   */\\n  function unpause() external virtual override onlyOwner {\\n    _unpause();\\n  }\\n\\n  /**\\n   * @notice get gETH as a contract\\n   */\\n  function getgETH() public view override returns (IgETH) {\\n    return IgETH(gETH);\\n  }\\n\\n  /**\\n   * @notice get Portal as a contract\\n   */\\n  function getPortal() public view override returns (IPortal) {\\n    return IPortal(GEM.getGovernance());\\n  }\\n\\n  /**\\n   * @notice get the gETH ID of the corresponding staking pool\\n   */\\n  function getPoolId() public view override returns (uint256) {\\n    return POOL_ID;\\n  }\\n\\n  /**\\n   * @notice get the current version of the contract\\n   */\\n  function getContractVersion() public view virtual override returns (uint256) {\\n    return CONTRACT_VERSION;\\n  }\\n\\n  /**\\n   * @notice get the latest version of the withdrawal contract module from Portal\\n   */\\n  function getProposedVersion() public view virtual override returns (uint256) {\\n    return getPortal().getDefaultModule(ID_TYPE.MODULE_WITHDRAWAL_CONTRACT);\\n  }\\n\\n  /**\\n   * @notice Recovery Mode allows Withdrawal Contract to isolate itself\\n   * from Portal and continue handling the withdrawals.\\n   * @return isRecovering true if recoveryMode is active\\n   */\\n  function recoveryMode()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool isRecovering)\\n  {\\n    isRecovering =\\n      getContractVersion() != getProposedVersion() ||\\n      paused() ||\\n      getPortal().readAddress(getPoolId(), \\\"CONTROLLER\\\") !=\\n      GEM.getSenate() ||\\n      block.timestamp >= GEM.getSenateExpiry();\\n  }\\n\\n  /**\\n   * @notice Creates a new Proposal within Withdrawal Contract, used by Portal\\n   * @dev only Governance check is inside, note Governance is Portal.\\n   */\\n  function newProposal(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external virtual override {\\n    GEM.newProposal(DATASTORE, _CONTROLLER, _TYPE, _NAME, duration);\\n  }\\n\\n  function approveProposal(\\n    uint256 id\\n  )\\n    public\\n    virtual\\n    override\\n    whenNotPaused\\n    returns (uint256 _type, address _controller)\\n  {\\n    (_type, _controller) = GEM.approveProposal(DATASTORE, id);\\n  }\\n\\n  /**\\n   * @notice Fetching an upgradeProposal from Portal creates an upgrade proposal\\n   * @notice approving the version changes the approvedVersion on GeodeUtils\\n   * @dev remaining code is basically taken from upgradeTo of UUPS since\\n   * it is still not public, but external\\n   */\\n  function fetchUpgradeProposal() external virtual override onlyOwner {\\n    uint256 proposedVersion = getPortal()\\n      .fetchWithdrawalContractUpgradeProposal(POOL_ID);\\n\\n    require(\\n      proposedVersion != getContractVersion() && proposedVersion != 0,\\n      \\\"WithdrawalContract: PROPOSED_VERSION ERROR\\\"\\n    );\\n\\n    approveProposal(proposedVersion);\\n    _authorizeUpgrade(GEM.approvedVersion);\\n    _upgradeToAndCallUUPS(GEM.approvedVersion, new bytes(0), false);\\n  }\\n\\n  /**\\n   * @notice changes the Senate's address without extending the expiry\\n   * @dev OnlySenate is checked inside the GeodeUtils\\n   */\\n  function changeController(address _newSenate) external virtual override {\\n    GEM.changeSenate(_newSenate);\\n  }\\n\\n  fallback() external payable {}\\n\\n  receive() external payable {}\\n\\n  /**\\n   * @notice keep the contract size at 50\\n   */\\n  uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0x1417040a031928558836fd5920b526c1be0572c122674385dfdd115c94ed519d\",\"license\":\"MIT\"},\"contracts/interfaces/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// This interface is designed to be compatible with the Vyper version.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x30e9e5fbb5b5db73c5964c9c6c4753819ad0b64230c0e77021c9b01f9bf5f68d\",\"license\":\"MIT\"},\"contracts/interfaces/ILPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\ninterface ILPToken {\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external\\n        returns (bool);\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        external\\n        returns (bool);\\n\\n    function initialize(string memory name, string memory symbol)\\n        external\\n        returns (bool);\\n\\n    function mint(address recipient, uint256 amount) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\",\"keccak256\":\"0x7ee52a6c1db3c279a92be6c04ccd6dbbafed5f4476dc16007e4e8465a00a313f\",\"license\":\"MIT\"},\"contracts/interfaces/IPortal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"../Portal/utils/DataStoreUtilsLib.sol\\\";\\nimport \\\"../Portal/utils/GeodeUtilsLib.sol\\\";\\nimport \\\"../Portal/utils/OracleUtilsLib.sol\\\";\\nimport \\\"../Portal/utils/StakeUtilsLib.sol\\\";\\n\\ninterface IPortal {\\n  function initialize(\\n    address _GOVERNANCE,\\n    address _SENATE,\\n    address _gETH,\\n    address _ORACLE_POSITION,\\n    address _DEFAULT_WITHDRAWAL_CONTRACT_MODULE,\\n    address _DEFAULT_LP_MODULE,\\n    address _DEFAULT_LP_TOKEN_MODULE,\\n    address[] calldata _ALLOWED_GETH_INTERFACE_MODULES,\\n    bytes[] calldata _ALLOWED_GETH_INTERFACE_MODULE_NAMES,\\n    uint256 _GOVERNANCE_FEE\\n  ) external;\\n\\n  function getContractVersion() external view returns (uint256);\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function pausegETH() external;\\n\\n  function unpausegETH() external;\\n\\n  function fetchWithdrawalContractUpgradeProposal(\\n    uint256 id\\n  ) external returns (uint256 withdrawalContractVersion);\\n\\n  function gETH() external view returns (address);\\n\\n  function gETHInterfaces(\\n    uint256 id,\\n    uint256 index\\n  ) external view returns (address);\\n\\n  function allIdsByType(\\n    uint256 _type,\\n    uint256 _index\\n  ) external view returns (uint256);\\n\\n  function generateId(\\n    string calldata _name,\\n    uint256 _type\\n  ) external pure returns (uint256 id);\\n\\n  function getKey(\\n    uint256 _id,\\n    bytes32 _param\\n  ) external pure returns (bytes32 key);\\n\\n  function readAddress(\\n    uint256 id,\\n    bytes32 key\\n  ) external view returns (address data);\\n\\n  function readUint(\\n    uint256 id,\\n    bytes32 key\\n  ) external view returns (uint256 data);\\n\\n  function readBytes(\\n    uint256 id,\\n    bytes32 key\\n  ) external view returns (bytes memory data);\\n\\n  function readUintArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (uint256 data);\\n\\n  function readBytesArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (bytes memory data);\\n\\n  function readAddressArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (address data);\\n\\n  function GeodeParams()\\n    external\\n    view\\n    returns (\\n      address SENATE,\\n      address GOVERNANCE,\\n      uint256 SENATE_EXPIRY,\\n      uint256 GOVERNANCE_FEE\\n    );\\n\\n  function getProposal(\\n    uint256 id\\n  ) external view returns (GeodeUtils.Proposal memory proposal);\\n\\n  function isElector(uint256 _TYPE) external view returns (bool);\\n\\n  function isUpgradeAllowed(\\n    address proposedImplementation\\n  ) external view returns (bool);\\n\\n  function setGovernanceFee(uint256 newFee) external;\\n\\n  function setElectorType(uint256 _TYPE, bool isElector) external;\\n\\n  function newProposal(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external;\\n\\n  function approveProposal(uint256 id) external;\\n\\n  function changeSenate(address _newSenate) external;\\n\\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\\n\\n  function approveSenate(uint256 proposalId, uint256 electorId) external;\\n\\n  function StakingParams()\\n    external\\n    view\\n    returns (\\n      uint256 VALIDATORS_INDEX,\\n      uint256 VERIFICATION_INDEX,\\n      uint256 MONOPOLY_THRESHOLD,\\n      uint256 EARLY_EXIT_FEE,\\n      uint256 ORACLE_UPDATE_TIMESTAMP,\\n      uint256 DAILY_PRICE_INCREASE_LIMIT,\\n      uint256 DAILY_PRICE_DECREASE_LIMIT,\\n      bytes32 PRICE_MERKLE_ROOT,\\n      address ORACLE_POSITION\\n    );\\n\\n  function getDefaultModule(\\n    uint256 _type\\n  ) external view returns (uint256 _version);\\n\\n  function isAllowedModule(\\n    uint256 _type,\\n    uint256 _version\\n  ) external view returns (bool);\\n\\n  function getValidator(\\n    bytes calldata pubkey\\n  ) external view returns (StakeUtils.Validator memory);\\n\\n  function getValidatorByPool(\\n    uint256 poolId,\\n    uint256 index\\n  ) external view returns (bytes memory);\\n\\n  function getMaintenanceFee(uint256 id) external view returns (uint256 fee);\\n\\n  // function operatorAllowance(\\n  //   uint256 poolId,\\n  //   uint256 operatorId\\n  // ) external view returns (uint256 allowance);\\n\\n  function isPrisoned(uint256 operatorId) external view returns (bool);\\n\\n  function isPrivatePool(uint256 poolId) external view returns (bool);\\n\\n  function isPriceValid(uint256 poolId) external view returns (bool);\\n\\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\\n\\n  function canStake(bytes calldata pubkey) external view returns (bool);\\n\\n  function initiateOperator(\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external payable;\\n\\n  function initiatePool(\\n    uint256 fee,\\n    uint256 interfaceVersion,\\n    address maintainer,\\n    bytes calldata NAME,\\n    bytes calldata interface_data,\\n    bool[3] calldata config\\n  ) external payable;\\n\\n  function setPoolVisibility(uint256 poolId, bool isPrivate) external;\\n\\n  function deployLiquidityPool(uint256 poolId) external;\\n\\n  function changeMaintainer(uint256 id, address newMaintainer) external;\\n\\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\\n\\n  function increaseWalletBalance(\\n    uint256 id\\n  ) external payable returns (bool success);\\n\\n  function decreaseWalletBalance(\\n    uint256 id,\\n    uint256 value\\n  ) external returns (bool success);\\n\\n  function switchValidatorPeriod(uint256 id, uint256 newPeriod) external;\\n\\n  function blameOperator(bytes calldata pk) external;\\n\\n  function setEarlyExitFee(uint256 fee) external;\\n\\n  function releasePrisoned(uint256 operatorId) external;\\n\\n  function approveOperators(\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external;\\n\\n  function setWhitelist(uint256 poolId, address whitelist) external;\\n\\n  function deposit(\\n    uint256 poolId,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    uint256 price,\\n    bytes32[] calldata priceProofs,\\n    address receiver\\n  ) external payable;\\n\\n  function proposeStake(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external;\\n\\n  function beaconStake(uint256 operatorId, bytes[] calldata pubkeys) external;\\n\\n  function updateVerificationIndex(\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external;\\n\\n  function regulateOperators(\\n    uint256[] calldata feeThefts,\\n    bytes[] calldata stolenBlocks\\n  ) external;\\n\\n  function reportOracle(\\n    bytes32 priceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external;\\n\\n  function priceSync(\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProofs\\n  ) external;\\n\\n  function priceSyncBatch(\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external;\\n}\\n\",\"keccak256\":\"0xad694c194a8ea0d64eb505163205e57ee874ba855f58f1686ba83cbeef58e1f6\",\"license\":\"MIT\"},\"contracts/interfaces/ISwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\nimport \\\"./IgETH.sol\\\";\\n\\ninterface ISwap {\\n  // pool data view functions\\n  function getERC1155() external view returns (address);\\n\\n  function getA() external view returns (uint256);\\n\\n  function getAPrecise() external view returns (uint256);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function getToken() external view returns (uint256);\\n\\n  function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  function getDebt() external view returns (uint256);\\n\\n  function getAdminBalance(uint256 index) external view returns (uint256);\\n\\n  // min return calculation functions\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(\\n    uint256 amount\\n  ) external view returns (uint256[2] memory);\\n\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256 availableTokenAmount);\\n\\n  // state modifying functions\\n  function initialize(\\n    IgETH _gEth,\\n    uint256 _pooledTokenId,\\n    string memory lpTokenName,\\n    string memory lpTokenSymbol,\\n    address lpTokenTargetAddress,\\n    address owner\\n  ) external returns (address lpToken);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[2] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function withdrawAdminFees() external;\\n\\n  function setAdminFee(uint256 newAdminFee) external;\\n\\n  function setSwapFee(uint256 newSwapFee) external;\\n\\n  function rampA(uint256 futureA, uint256 futureTime) external;\\n\\n  function stopRampA() external;\\n}\\n\",\"keccak256\":\"0x34510bc5e9065f86a20fae5ca94b71a9333d141484c99254efb47845f3a74490\",\"license\":\"MIT\"},\"contracts/interfaces/IWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IWhitelist {\\n  function isAllowed(address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x19fef7cf90817c40e9c773d5a4c2ee81e8bf48791fdd406b2349821c89a5411c\",\"license\":\"MIT\"},\"contracts/interfaces/IWithdrawalContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"./IgETH.sol\\\";\\nimport \\\"./IPortal.sol\\\";\\n\\ninterface IWithdrawalContract {\\n  function initialize(\\n    uint256 _VERSION,\\n    uint256 _ID,\\n    address _gETH,\\n    address _PORTAL,\\n    address _CONTROLLER\\n  ) external returns (bool);\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function getgETH() external view returns (IgETH);\\n\\n  function getPortal() external view returns (IPortal);\\n\\n  function getPoolId() external view returns (uint256);\\n\\n  function getContractVersion() external view returns (uint256);\\n\\n  function getProposedVersion() external view returns (uint256);\\n\\n  function recoveryMode() external view returns (bool);\\n\\n  function newProposal(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external;\\n\\n  function approveProposal(\\n    uint256 id\\n  ) external returns (uint256 _type, address _controller);\\n\\n  function fetchUpgradeProposal() external;\\n\\n  function changeController(address _newSenate) external;\\n}\\n\",\"keccak256\":\"0x5dc505ca1284824afc4e5f67e9b0456ce14ac5eaa28a48402f7f3bfa78862fa0\",\"license\":\"MIT\"},\"contracts/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IgETH {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    function uri(uint256) external view returns (string memory);\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    function burn(address account, uint256 id, uint256 value) external;\\n\\n    function burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) external;\\n\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    function exists(uint256 id) external view returns (bool);\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    // gETH Specials\\n\\n    function denominator() external view returns (uint256);\\n\\n    function pricePerShare(uint256 id) external view returns (uint256);\\n\\n    function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\n\\n    function setPricePerShare(uint256 price, uint256 id) external;\\n\\n    function isInterface(\\n        address _interface,\\n        uint256 id\\n    ) external view returns (bool);\\n\\n    function isAvoider(\\n        address account,\\n        uint256 id\\n    ) external view returns (bool);\\n\\n    function avoidInterfaces(uint256 id, bool isAvoid) external;\\n\\n    function setInterface(address _interface, uint256 id, bool isSet) external;\\n\\n    function updateMinterRole(address Minter) external;\\n\\n    function updatePauserRole(address Pauser) external;\\n\\n    function updateOracleRole(address Oracle) external;\\n}\\n\",\"keccak256\":\"0xda89519bc8f6f3ece7bfd842d379fbfba768080cc0de0b6983065be4ec73af14\",\"license\":\"MIT\"},\"contracts/interfaces/IgETHInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IgETHInterface {\\n  function initialize(\\n    uint256 id_,\\n    address erc1155_,\\n    bytes memory data\\n  ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3b9f0fb1e4fc4ab7d57477b715679e3a587edc6fe27d8a4e281b0d55d5120c83\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523060601b60805234801561001757600080fd5b5060805160601c611bdf6100526000396000818161071f0152818161075f01528181610ad201528181610b120152610ba50152611bdf6000f3fe6080604052600436106100f65760003560e01c806352d1902d1161008f5780637d65a7ab116100615780637d65a7ab1461025b5780638456cb59146102705780638aa104351461028557806398951b561461029b578063ac7a7eb3146102d857005b806352d1902d146101e65780635c975abb146101fb57806366f788c614610213578063745653de1461024657005b80633cebb823116100c85780633cebb8231461017e5780633f4ba83a1461019e5780633fbfd4df146101b35780634f1ef286146101d357005b806307a00b1f146100ff57806317c6ebd5146101295780633659cfe61461013e57806338fff2d01461015e57005b366100fd57005b005b34801561010b57600080fd5b506101146102f8565b60405190151581526020015b60405180910390f35b34801561013557600080fd5b506100fd6104e8565b34801561014a57600080fd5b506100fd6101593660046116c6565b610714565b34801561016a57600080fd5b5061011c545b604051908152602001610120565b34801561018a57600080fd5b506100fd6101993660046116c6565b6107e0565b3480156101aa57600080fd5b506100fd610856565b3480156101bf57600080fd5b506101146101ce3660046118d9565b610914565b6100fd6101e1366004611700565b610ac7565b3480156101f257600080fd5b50610170610b98565b34801561020757600080fd5b5060655460ff16610114565b34801561021f57600080fd5b5061011b546001600160a01b03165b6040516001600160a01b039091168152602001610120565b34801561025257600080fd5b50610170610c4b565b34801561026757600080fd5b5061022e610ccf565b34801561027c57600080fd5b506100fd610d56565b34801561029157600080fd5b5061011d54610170565b3480156102a757600080fd5b506102bb6102b6366004611890565b610e12565b604080519283526001600160a01b03909116602083015201610120565b3480156102e457600080fd5b506100fd6102f33660046117c4565b610eb8565b6000610302610c4b565b61011d54141580610315575060655460ff165b80610455575060405163071a0e5560e21b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D90631c6839549060240160206040518083038186803b15801561036757600080fd5b505af415801561037b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039f91906116e3565b6001600160a01b03166103b0610ccf565b6001600160a01b03166318f2ccde6103c861011c5490565b6040518263ffffffff1660e01b81526004016103f99181526921a7a72a2927a62622a960b11b602082015260400190565b60206040518083038186803b15801561041157600080fd5b505afa158015610425573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044991906116e3565b6001600160a01b031614155b806104e35750604051636797415560e01b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D9063679741559060240160206040518083038186803b1580156104a757600080fd5b505af41580156104bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104df9190611877565b4210155b905090565b60405163071a0e5560e21b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D90631c6839549060240160206040518083038186803b15801561053457600080fd5b505af4158015610548573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056c91906116e3565b6001600160a01b0316336001600160a01b0316146105a55760405162461bcd60e51b815260040161059c90611a6a565b60405180910390fd5b60006105af610ccf565b6001600160a01b031663b383a04461011c546040518263ffffffff1660e01b81526004016105df91815260200190565b602060405180830381600087803b1580156105f957600080fd5b505af115801561060d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106319190611877565b905061063d61011d5490565b811415801561064b57508015155b6106aa5760405162461bcd60e51b815260206004820152602a60248201527f5769746864726177616c436f6e74726163743a2050524f504f5345445f56455260448201526929a4a7a71022a92927a960b11b606482015260840161059c565b6106b381610e12565b505061010f546106cb906001600160a01b0316610f56565b61010f54610711906001600160a01b031660005b6040519080825280601f01601f191660200182016040528015610709576020820181803683370190505b5060006110ff565b50565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141561075d5760405162461bcd60e51b815260040161059c90611987565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166107a6600080516020611b63833981519152546001600160a01b031690565b6001600160a01b0316146107cc5760405162461bcd60e51b815260040161059c906119d3565b6107d581610f56565b6107118160006106df565b60405163058ba25360e31b815261010b60048201526001600160a01b038216602482015273d07A36C1d111A978f0626d19175E0453900d1F4D90632c5d12989060440160006040518083038186803b15801561083b57600080fd5b505af415801561084f573d6000803e3d6000fd5b5050505050565b60405163071a0e5560e21b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D90631c6839549060240160206040518083038186803b1580156108a257600080fd5b505af41580156108b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108da91906116e3565b6001600160a01b0316336001600160a01b03161461090a5760405162461bcd60e51b815260040161059c90611a6a565b61091261127e565b565b60008054610100900460ff16158080156109355750600054600160ff909116105b8061094f5750303b15801561094f575060005460ff166001145b6109b25760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161059c565b6000805460ff1916600117905580156109d5576000805461ff0019166101001790555b6109dd6112d0565b6109e56112ff565b6109ed61132e565b61011b80546001600160a01b038781166001600160a01b03199283161790925561011c88905561010b805487841690831617905561010c80549286169290911691909117905560001961010d5561011d8790556040518781527ffddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb9060200160405180910390a1600191508015610abd576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5095945050505050565b306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161415610b105760405162461bcd60e51b815260040161059c90611987565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b59600080516020611b63833981519152546001600160a01b031690565b6001600160a01b031614610b7f5760405162461bcd60e51b815260040161059c906119d3565b610b8882610f56565b610b94828260016110ff565b5050565b6000306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c385760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000606482015260840161059c565b50600080516020611b6383398151915290565b6000610c55610ccf565b60405163096699f360e31b8152601560048201526001600160a01b039190911690634b34cf989060240160206040518083038186803b158015610c9757600080fd5b505afa158015610cab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e39190611877565b604051630e29024f60e31b815261010b600482015260009073d07A36C1d111A978f0626d19175E0453900d1F4D9063714812789060240160206040518083038186803b158015610d1e57600080fd5b505af4158015610d32573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e391906116e3565b60405163071a0e5560e21b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D90631c6839549060240160206040518083038186803b158015610da257600080fd5b505af4158015610db6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dda91906116e3565b6001600160a01b0316336001600160a01b031614610e0a5760405162461bcd60e51b815260040161059c90611a6a565b610912611355565b600080610e1d611392565b60405163d9fc310f60e01b815261010b600482015260fb60248201526044810184905273d07A36C1d111A978f0626d19175E0453900d1F4D9063d9fc310f90606401604080518083038186803b158015610e7657600080fd5b505af4158015610e8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eae91906118a9565b9094909350915050565b604051635bd2b11360e01b815273d07A36C1d111A978f0626d19175E0453900d1F4D90635bd2b11390610efe9061010b9060fb908a908a908a908a908a90600401611aae565b60206040518083038186803b158015610f1657600080fd5b505af4158015610f2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4e9190611877565b505050505050565b60405163071a0e5560e21b815261010b600482015273d07A36C1d111A978f0626d19175E0453900d1F4D90631c6839549060240160206040518083038186803b158015610fa257600080fd5b505af4158015610fb6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fda91906116e3565b6001600160a01b0316336001600160a01b03161461100a5760405162461bcd60e51b815260040161059c90611a6a565b60405160016223f63b60e21b0319815261010b60048201526001600160a01b038216602482015273d07A36C1d111A978f0626d19175E0453900d1F4D9063ff7027149060440160206040518083038186803b15801561106857600080fd5b505af415801561107c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a09190611855565b6107115760405162461bcd60e51b815260206004820152602a60248201527f5769746864726177616c436f6e74726163743a204e4f5420616c6c6f77656420604482015269746f207570677261646560b01b606482015260840161059c565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff161561113757611132836113d8565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561117057600080fd5b505afa9250505080156111a0575060408051601f3d908101601f1916820190925261119d91810190611877565b60015b6112035760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b606482015260840161059c565b600080516020611b6383398151915281146112725760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b606482015260840161059c565b50611132838383611474565b61128661149f565b6065805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600054610100900460ff166112f75760405162461bcd60e51b815260040161059c90611a1f565b6109126114e8565b600054610100900460ff166113265760405162461bcd60e51b815260040161059c90611a1f565b610912611515565b600054610100900460ff166109125760405162461bcd60e51b815260040161059c90611a1f565b61135d611392565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586112b33390565b60655460ff16156109125760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161059c565b6001600160a01b0381163b6114455760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b606482015260840161059c565b600080516020611b6383398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b61147d83611548565b60008251118061148a5750805b15611132576114998383611588565b50505050565b60655460ff166109125760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b604482015260640161059c565b600054610100900460ff1661150f5760405162461bcd60e51b815260040161059c90611a1f565b60018055565b600054610100900460ff1661153c5760405162461bcd60e51b815260040161059c90611a1f565b6065805460ff19169055565b611551816113d8565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b6115f05760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b606482015260840161059c565b600080846001600160a01b03168460405161160b9190611938565b600060405180830381855af49150503d8060008114611646576040519150601f19603f3d011682016040523d82523d6000602084013e61164b565b606091505b50915091506116738282604051806060016040528060278152602001611b836027913961167c565b95945050505050565b6060831561168b575081611695565b611695838361169c565b9392505050565b8151156116ac5781518083602001fd5b8060405162461bcd60e51b815260040161059c9190611954565b6000602082840312156116d857600080fd5b813561169581611b4d565b6000602082840312156116f557600080fd5b815161169581611b4d565b6000806040838503121561171357600080fd5b823561171e81611b4d565b9150602083013567ffffffffffffffff8082111561173b57600080fd5b818501915085601f83011261174f57600080fd5b81358181111561176157611761611b37565b604051601f8201601f19908116603f0116810190838211818310171561178957611789611b37565b816040528281528860208487010111156117a257600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b6000806000806000608086880312156117dc57600080fd5b85356117e781611b4d565b945060208601359350604086013567ffffffffffffffff8082111561180b57600080fd5b818801915088601f83011261181f57600080fd5b81358181111561182e57600080fd5b89602082850101111561184057600080fd5b96999598505060200195606001359392505050565b60006020828403121561186757600080fd5b8151801515811461169557600080fd5b60006020828403121561188957600080fd5b5051919050565b6000602082840312156118a257600080fd5b5035919050565b600080604083850312156118bc57600080fd5b8251915060208301516118ce81611b4d565b809150509250929050565b600080600080600060a086880312156118f157600080fd5b8535945060208601359350604086013561190a81611b4d565b9250606086013561191a81611b4d565b9150608086013561192a81611b4d565b809150509295509295909350565b6000825161194a818460208701611b0b565b9190910192915050565b6020815260008251806020840152611973816040850160208701611b0b565b601f01601f19169190910160400192915050565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60208082526024908201527f5769746864726177616c436f6e74726163743a2073656e646572204e4f54204f6040820152632ba722a960e11b606082015260800190565b87815286602082015260018060a01b038616604082015284606082015260c060808201528260c0820152828460e0830137600060e08483010152600060e0601f19601f86011683010190508260a083015298975050505050505050565b60005b83811015611b26578181015183820152602001611b0e565b838111156114995750506000910152565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461071157600080fdfe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220fdd1c8a9a0a042dde9d4360783a890c1f4b48f0ef6e8e42529131e562cabb31f64736f6c63430008070033",
  "deployedBytecode": "0x6080604052600436106100f65760003560e01c806352d1902d1161008f5780637d65a7ab116100615780637d65a7ab1461025b5780638456cb59146102705780638aa104351461028557806398951b561461029b578063ac7a7eb3146102d857005b806352d1902d146101e65780635c975abb146101fb57806366f788c614610213578063745653de1461024657005b80633cebb823116100c85780633cebb8231461017e5780633f4ba83a1461019e5780633fbfd4df146101b35780634f1ef286146101d357005b806307a00b1f146100ff57806317c6ebd5146101295780633659cfe61461013e57806338fff2d01461015e57005b366100fd57005b005b34801561010b57600080fd5b506101146102f8565b60405190151581526020015b60405180910390f35b34801561013557600080fd5b506100fd6104e8565b34801561014a57600080fd5b506100fd6101593660046116c6565b610714565b34801561016a57600080fd5b5061011c545b604051908152602001610120565b34801561018a57600080fd5b506100fd6101993660046116c6565b6107e0565b3480156101aa57600080fd5b506100fd610856565b3480156101bf57600080fd5b506101146101ce3660046118d9565b610914565b6100fd6101e1366004611700565b610ac7565b3480156101f257600080fd5b50610170610b98565b34801561020757600080fd5b5060655460ff16610114565b34801561021f57600080fd5b5061011b546001600160a01b03165b6040516001600160a01b039091168152602001610120565b34801561025257600080fd5b50610170610c4b565b34801561026757600080fd5b5061022e610ccf565b34801561027c57600080fd5b506100fd610d56565b34801561029157600080fd5b5061011d54610170565b3480156102a757600080fd5b506102bb6102b6366004611890565b610e12565b604080519283526001600160a01b03909116602083015201610120565b3480156102e457600080fd5b506100fd6102f33660046117c4565b610eb8565b6000610302610c4b565b61011d54141580610315575060655460ff165b80610455575060405163071a0e5560e21b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__90631c6839549060240160206040518083038186803b15801561036757600080fd5b505af415801561037b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039f91906116e3565b6001600160a01b03166103b0610ccf565b6001600160a01b03166318f2ccde6103c861011c5490565b6040518263ffffffff1660e01b81526004016103f99181526921a7a72a2927a62622a960b11b602082015260400190565b60206040518083038186803b15801561041157600080fd5b505afa158015610425573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044991906116e3565b6001600160a01b031614155b806104e35750604051636797415560e01b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__9063679741559060240160206040518083038186803b1580156104a757600080fd5b505af41580156104bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104df9190611877565b4210155b905090565b60405163071a0e5560e21b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__90631c6839549060240160206040518083038186803b15801561053457600080fd5b505af4158015610548573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056c91906116e3565b6001600160a01b0316336001600160a01b0316146105a55760405162461bcd60e51b815260040161059c90611a6a565b60405180910390fd5b60006105af610ccf565b6001600160a01b031663b383a04461011c546040518263ffffffff1660e01b81526004016105df91815260200190565b602060405180830381600087803b1580156105f957600080fd5b505af115801561060d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106319190611877565b905061063d61011d5490565b811415801561064b57508015155b6106aa5760405162461bcd60e51b815260206004820152602a60248201527f5769746864726177616c436f6e74726163743a2050524f504f5345445f56455260448201526929a4a7a71022a92927a960b11b606482015260840161059c565b6106b381610e12565b505061010f546106cb906001600160a01b0316610f56565b61010f54610711906001600160a01b031660005b6040519080825280601f01601f191660200182016040528015610709576020820181803683370190505b5060006110ff565b50565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141561075d5760405162461bcd60e51b815260040161059c90611987565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166107a6600080516020611b63833981519152546001600160a01b031690565b6001600160a01b0316146107cc5760405162461bcd60e51b815260040161059c906119d3565b6107d581610f56565b6107118160006106df565b60405163058ba25360e31b815261010b60048201526001600160a01b038216602482015273__$470c7289acb57212a69b34ceb5289ef95c$__90632c5d12989060440160006040518083038186803b15801561083b57600080fd5b505af415801561084f573d6000803e3d6000fd5b5050505050565b60405163071a0e5560e21b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__90631c6839549060240160206040518083038186803b1580156108a257600080fd5b505af41580156108b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108da91906116e3565b6001600160a01b0316336001600160a01b03161461090a5760405162461bcd60e51b815260040161059c90611a6a565b61091261127e565b565b60008054610100900460ff16158080156109355750600054600160ff909116105b8061094f5750303b15801561094f575060005460ff166001145b6109b25760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161059c565b6000805460ff1916600117905580156109d5576000805461ff0019166101001790555b6109dd6112d0565b6109e56112ff565b6109ed61132e565b61011b80546001600160a01b038781166001600160a01b03199283161790925561011c88905561010b805487841690831617905561010c80549286169290911691909117905560001961010d5561011d8790556040518781527ffddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb9060200160405180910390a1600191508015610abd576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5095945050505050565b306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161415610b105760405162461bcd60e51b815260040161059c90611987565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b59600080516020611b63833981519152546001600160a01b031690565b6001600160a01b031614610b7f5760405162461bcd60e51b815260040161059c906119d3565b610b8882610f56565b610b94828260016110ff565b5050565b6000306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c385760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000606482015260840161059c565b50600080516020611b6383398151915290565b6000610c55610ccf565b60405163096699f360e31b8152601560048201526001600160a01b039190911690634b34cf989060240160206040518083038186803b158015610c9757600080fd5b505afa158015610cab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e39190611877565b604051630e29024f60e31b815261010b600482015260009073__$470c7289acb57212a69b34ceb5289ef95c$__9063714812789060240160206040518083038186803b158015610d1e57600080fd5b505af4158015610d32573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104e391906116e3565b60405163071a0e5560e21b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__90631c6839549060240160206040518083038186803b158015610da257600080fd5b505af4158015610db6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dda91906116e3565b6001600160a01b0316336001600160a01b031614610e0a5760405162461bcd60e51b815260040161059c90611a6a565b610912611355565b600080610e1d611392565b60405163d9fc310f60e01b815261010b600482015260fb60248201526044810184905273__$470c7289acb57212a69b34ceb5289ef95c$__9063d9fc310f90606401604080518083038186803b158015610e7657600080fd5b505af4158015610e8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eae91906118a9565b9094909350915050565b604051635bd2b11360e01b815273__$470c7289acb57212a69b34ceb5289ef95c$__90635bd2b11390610efe9061010b9060fb908a908a908a908a908a90600401611aae565b60206040518083038186803b158015610f1657600080fd5b505af4158015610f2a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4e9190611877565b505050505050565b60405163071a0e5560e21b815261010b600482015273__$470c7289acb57212a69b34ceb5289ef95c$__90631c6839549060240160206040518083038186803b158015610fa257600080fd5b505af4158015610fb6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fda91906116e3565b6001600160a01b0316336001600160a01b03161461100a5760405162461bcd60e51b815260040161059c90611a6a565b60405160016223f63b60e21b0319815261010b60048201526001600160a01b038216602482015273__$470c7289acb57212a69b34ceb5289ef95c$__9063ff7027149060440160206040518083038186803b15801561106857600080fd5b505af415801561107c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a09190611855565b6107115760405162461bcd60e51b815260206004820152602a60248201527f5769746864726177616c436f6e74726163743a204e4f5420616c6c6f77656420604482015269746f207570677261646560b01b606482015260840161059c565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff161561113757611132836113d8565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561117057600080fd5b505afa9250505080156111a0575060408051601f3d908101601f1916820190925261119d91810190611877565b60015b6112035760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b606482015260840161059c565b600080516020611b6383398151915281146112725760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b606482015260840161059c565b50611132838383611474565b61128661149f565b6065805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600054610100900460ff166112f75760405162461bcd60e51b815260040161059c90611a1f565b6109126114e8565b600054610100900460ff166113265760405162461bcd60e51b815260040161059c90611a1f565b610912611515565b600054610100900460ff166109125760405162461bcd60e51b815260040161059c90611a1f565b61135d611392565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586112b33390565b60655460ff16156109125760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161059c565b6001600160a01b0381163b6114455760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b606482015260840161059c565b600080516020611b6383398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b61147d83611548565b60008251118061148a5750805b15611132576114998383611588565b50505050565b60655460ff166109125760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b604482015260640161059c565b600054610100900460ff1661150f5760405162461bcd60e51b815260040161059c90611a1f565b60018055565b600054610100900460ff1661153c5760405162461bcd60e51b815260040161059c90611a1f565b6065805460ff19169055565b611551816113d8565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b6115f05760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b606482015260840161059c565b600080846001600160a01b03168460405161160b9190611938565b600060405180830381855af49150503d8060008114611646576040519150601f19603f3d011682016040523d82523d6000602084013e61164b565b606091505b50915091506116738282604051806060016040528060278152602001611b836027913961167c565b95945050505050565b6060831561168b575081611695565b611695838361169c565b9392505050565b8151156116ac5781518083602001fd5b8060405162461bcd60e51b815260040161059c9190611954565b6000602082840312156116d857600080fd5b813561169581611b4d565b6000602082840312156116f557600080fd5b815161169581611b4d565b6000806040838503121561171357600080fd5b823561171e81611b4d565b9150602083013567ffffffffffffffff8082111561173b57600080fd5b818501915085601f83011261174f57600080fd5b81358181111561176157611761611b37565b604051601f8201601f19908116603f0116810190838211818310171561178957611789611b37565b816040528281528860208487010111156117a257600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b6000806000806000608086880312156117dc57600080fd5b85356117e781611b4d565b945060208601359350604086013567ffffffffffffffff8082111561180b57600080fd5b818801915088601f83011261181f57600080fd5b81358181111561182e57600080fd5b89602082850101111561184057600080fd5b96999598505060200195606001359392505050565b60006020828403121561186757600080fd5b8151801515811461169557600080fd5b60006020828403121561188957600080fd5b5051919050565b6000602082840312156118a257600080fd5b5035919050565b600080604083850312156118bc57600080fd5b8251915060208301516118ce81611b4d565b809150509250929050565b600080600080600060a086880312156118f157600080fd5b8535945060208601359350604086013561190a81611b4d565b9250606086013561191a81611b4d565b9150608086013561192a81611b4d565b809150509295509295909350565b6000825161194a818460208701611b0b565b9190910192915050565b6020815260008251806020840152611973816040850160208701611b0b565b601f01601f19169190910160400192915050565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60208082526024908201527f5769746864726177616c436f6e74726163743a2073656e646572204e4f54204f6040820152632ba722a960e11b606082015260800190565b87815286602082015260018060a01b038616604082015284606082015260c060808201528260c0820152828460e0830137600060e08483010152600060e0601f19601f86011683010190508260a083015298975050505050505050565b60005b83811015611b26578181015183820152602001611b0e565b838111156114995750506000910152565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461071157600080fdfe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220fdd1c8a9a0a042dde9d4360783a890c1f4b48f0ef6e8e42529131e562cabb31f64736f6c63430008070033",
  "libraries": {
    "GeodeUtils": "0xd07A36C1d111A978f0626d19175E0453900d1F4D"
  },
  "devdoc": {
    "author": "Icebear & Crash Bandicoot",
    "details": "This contract utilizes Dual Governance between Portal (GOVERNANCE) and  the Pool Owner (SENATE) to empower the Limited Upgradability.Recovery Mode stops pool operations while allowing withdrawal queue to operate as usualtodo: Withdrawal Queue",
    "kind": "dev",
    "methods": {
      "changeController(address)": {
        "details": "OnlySenate is checked inside the GeodeUtils"
      },
      "fetchUpgradeProposal()": {
        "details": "remaining code is basically taken from upgradeTo of UUPS since it is still not public, but external"
      },
      "newProposal(address,uint256,bytes,uint256)": {
        "details": "only Governance check is inside, note Governance is Portal."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "recoveryMode()": {
        "returns": {
          "isRecovering": "true if recoveryMode is active"
        }
      },
      "upgradeTo(address)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "title": "WithdrawalContract: Saviour of Trustless Staking Derivatives",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ControllerChanged(uint256,address)": {
        "notice": "Events"
      }
    },
    "kind": "user",
    "methods": {
      "changeController(address)": {
        "notice": "changes the Senate's address without extending the expiry"
      },
      "fetchUpgradeProposal()": {
        "notice": "Fetching an upgradeProposal from Portal creates an upgrade proposalapproving the version changes the approvedVersion on GeodeUtils"
      },
      "getContractVersion()": {
        "notice": "get the current version of the contract"
      },
      "getPoolId()": {
        "notice": "get the gETH ID of the corresponding staking pool"
      },
      "getPortal()": {
        "notice": "get Portal as a contract"
      },
      "getProposedVersion()": {
        "notice": "get the latest version of the withdrawal contract module from Portal"
      },
      "getgETH()": {
        "notice": "get gETH as a contract"
      },
      "newProposal(address,uint256,bytes,uint256)": {
        "notice": "Creates a new Proposal within Withdrawal Contract, used by Portal"
      },
      "pause()": {
        "notice": "pausing the contract activates the recoveryMode"
      },
      "recoveryMode()": {
        "notice": "Recovery Mode allows Withdrawal Contract to isolate itself from Portal and continue handling the withdrawals."
      },
      "unpause()": {
        "notice": "unpausing the contract deactivates the recoveryMode"
      }
    },
    "notice": "This is a simple contract: - used as the withdrawal credential of the validators. - accrues fees and rewards from validators over time. - handles the withdrawal queue for stakers. - manages its own versioning without trusting Portal.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 527,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 530,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 966,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1024,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 2331,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 846,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "_paused",
        "offset": 0,
        "slot": "101",
        "type": "t_bool"
      },
      {
        "astId": 951,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 509,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "151",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 824,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "201",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 25276,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "DATASTORE",
        "offset": 0,
        "slot": "251",
        "type": "t_struct(IsolatedStorage)19744_storage"
      },
      {
        "astId": 25279,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "GEM",
        "offset": 0,
        "slot": "267",
        "type": "t_struct(DualGovernance)20768_storage"
      },
      {
        "astId": 25281,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "gETH",
        "offset": 0,
        "slot": "283",
        "type": "t_address"
      },
      {
        "astId": 25283,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "POOL_ID",
        "offset": 0,
        "slot": "284",
        "type": "t_uint256"
      },
      {
        "astId": 25285,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "CONTRACT_VERSION",
        "offset": 0,
        "slot": "285",
        "type": "t_uint256"
      },
      {
        "astId": 25643,
        "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "286",
        "type": "t_array(t_uint256)45_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)12_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[12]",
        "numberOfBytes": "384"
      },
      "t_array(t_uint256)45_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[45]",
        "numberOfBytes": "1440"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)8_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[8]",
        "numberOfBytes": "256"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes32,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_struct(Proposal)20742_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct GeodeUtils.Proposal)",
        "numberOfBytes": "32",
        "value": "t_struct(Proposal)20742_storage"
      },
      "t_struct(DualGovernance)20768_storage": {
        "encoding": "inplace",
        "label": "struct GeodeUtils.DualGovernance",
        "members": [
          {
            "astId": 20744,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "GOVERNANCE",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 20746,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "SENATE",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 20748,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "SENATE_EXPIRY",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 20750,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "GOVERNANCE_FEE",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 20752,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "approvedVersion",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 20754,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "_electorCount",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 20758,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "_electorTypes",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_uint256,t_bool)"
          },
          {
            "astId": 20763,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "_proposals",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_uint256,t_struct(Proposal)20742_storage)"
          },
          {
            "astId": 20767,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "__gap",
            "offset": 0,
            "slot": "8",
            "type": "t_array(t_uint256)8_storage"
          }
        ],
        "numberOfBytes": "512"
      },
      "t_struct(IsolatedStorage)19744_storage": {
        "encoding": "inplace",
        "label": "struct DataStoreUtils.IsolatedStorage",
        "members": [
          {
            "astId": 19727,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "allIdsByType",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)"
          },
          {
            "astId": 19731,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "uintData",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 19735,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "bytesData",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_bytes32,t_bytes_storage)"
          },
          {
            "astId": 19739,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "addressData",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes32,t_address)"
          },
          {
            "astId": 19743,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "__gap",
            "offset": 0,
            "slot": "4",
            "type": "t_array(t_uint256)12_storage"
          }
        ],
        "numberOfBytes": "512"
      },
      "t_struct(Proposal)20742_storage": {
        "encoding": "inplace",
        "label": "struct GeodeUtils.Proposal",
        "members": [
          {
            "astId": 20735,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "CONTROLLER",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 20737,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "TYPE",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 20739,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "NAME",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes_storage"
          },
          {
            "astId": 20741,
            "contract": "contracts/Portal/withdrawalContract/WithdrawalContract.sol:WithdrawalContract",
            "label": "deadline",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}
