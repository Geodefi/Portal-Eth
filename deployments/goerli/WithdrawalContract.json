{
  "address": "0x139CC0A1DE0658a274fD0A6cF2672709ecdA2b02",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_gETHPos",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_portalPos",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ID",
          "type": "uint256"
        }
      ],
      "name": "Approved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "ContractVersionSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "ID",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "CONTROLLER",
          "type": "address"
        }
      ],
      "name": "ControllerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "senate",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        }
      ],
      "name": "NewSenate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "TYPE",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ID",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "CONTROLLER",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "Proposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "GeodeParams",
      "outputs": [
        {
          "internalType": "address",
          "name": "governance",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "senate",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "approvedUpgrade",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "senateExpiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "packageType",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "allIdsByType",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        }
      ],
      "name": "allIdsByTypeLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "approveProposal",
      "outputs": [
        {
          "internalType": "address",
          "name": "_controller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_name",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "newCONTROLLER",
          "type": "address"
        }
      ],
      "name": "changeIdCONTROLLER",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newSenate",
          "type": "address"
        }
      ],
      "name": "changeSenate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "_type",
          "type": "uint256"
        }
      ],
      "name": "generateId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getContractVersion",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_param",
          "type": "bytes32"
        }
      ],
      "name": "getKey",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPoolId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPortal",
      "outputs": [
        {
          "internalType": "contract IPortal",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getProposal",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "CONTROLLER",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "TYPE",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "NAME",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            }
          ],
          "internalType": "struct GeodeModuleLib.Proposal",
          "name": "proposal",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProposedVersion",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pooledTokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "poolOwner",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "versionName",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isolationMode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_CONTROLLER",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_TYPE",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_NAME",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "propose",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pullUpgrade",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "readAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "data",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "readAddressArray",
      "outputs": [
        {
          "internalType": "address",
          "name": "data",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "readBytes",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "readBytesArray",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "readUint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "data",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "readUintArray",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "data",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newSenate",
          "type": "address"
        }
      ],
      "name": "rescueSenate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc5b80dded41c867f1282b8acc59b5d32ce3a57342223e0a6fe40655faeb20d15",
  "receipt": {
    "to": null,
    "from": "0x2C95BC18Fd9382a07776D416EeF6c2FEb3AD2A8C",
    "contractAddress": "0x139CC0A1DE0658a274fD0A6cF2672709ecdA2b02",
    "transactionIndex": 1,
    "gasUsed": "2342066",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000080000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000500000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb880ec8ea413048360e8282ab8932c71dbd2fb77c2ef68cbed0f0f5f861058e6",
    "transactionHash": "0xc5b80dded41c867f1282b8acc59b5d32ce3a57342223e0a6fe40655faeb20d15",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 9149163,
        "transactionHash": "0xc5b80dded41c867f1282b8acc59b5d32ce3a57342223e0a6fe40655faeb20d15",
        "address": "0x139CC0A1DE0658a274fD0A6cF2672709ecdA2b02",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 0,
        "blockHash": "0xb880ec8ea413048360e8282ab8932c71dbd2fb77c2ef68cbed0f0f5f861058e6"
      }
    ],
    "blockNumber": 9149163,
    "cumulativeGasUsed": "2363242",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3f911696044d000CcF7D085e35b060e846b95f56",
    "0xFAF3b3eE96Fa210Cf196CDa9015384dE049Fa2a8"
  ],
  "numDeployments": 1,
  "solcInputHash": "0d9b4f013ad8b24d94c0978b4d3f3ea8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gETHPos\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_portalPos\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CONTROLLER\",\"type\":\"address\"}],\"name\":\"ControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"NewSenate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"TYPE\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CONTROLLER\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"Proposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GeodeParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approvedUpgrade\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"senateExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"allIdsByType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"allIdsByTypeLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveProposal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_name\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newCONTROLLER\",\"type\":\"address\"}],\"name\":\"changeIdCONTROLLER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSenate\",\"type\":\"address\"}],\"name\":\"changeSenate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"generateId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_param\",\"type\":\"bytes32\"}],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPortal\",\"outputs\":[{\"internalType\":\"contract IPortal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"CONTROLLER\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TYPE\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"NAME\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct GeodeModuleLib.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pooledTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolOwner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"versionName\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isolationMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_CONTROLLER\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TYPE\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_NAME\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"readAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"readAddressArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"readBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"readBytesArray\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"readUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"readUintArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSenate\",\"type\":\"address\"}],\"name\":\"rescueSenate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"GeodeParams()\":{\"custom:section\":\"** GETTER FUNCTIONS **\",\"custom:visibility\":\"-> view-external\"},\"allIdsByType(uint256,uint256)\":{\"details\":\"useful for outside reach, shouldn't be used within contracts as a referance\",\"returns\":{\"_0\":\"allIdsByType is an array of IDs of the given TYPE from Datastore, returns a specific index\"}},\"approveProposal(uint256)\":{\"details\":\"handles PACKAGE_TYPE proposals by upgrading the contract immediately.\"},\"changeIdCONTROLLER(uint256,address)\":{\"custom:subsection\":\"** ONLY CONTROLLER **\"},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\",\"details\":\"we don't want to provide these package-specific not-changing parameters accross all instances of the packages. So we will store them in the ref implementation contract of the package, and fetch when needed on initialization.\"},\"generateId(string,uint256)\":{\"details\":\"id is generated by keccak(name, type)\"},\"getProposedVersion()\":{\"details\":\"GeodeModule override\"},\"isolationMode()\":{\"details\":\"GeodeModule override\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"propose(address,uint256,bytes,uint256)\":{\"custom:subsection\":\"** ONLY GOVERNANCE **\"},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"readUintArray(uint256,bytes32,uint256)\":{\"custom:section\":\"** ARRAY GETTER FUNCTIONS **\",\"custom:visibility\":\"-> view-external\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"upgradeTo(address)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"generateId(string,uint256)\":{\"notice\":\"useful function for string inputs - returns same with the DSML.generateId\"},\"getKey(uint256,bytes32)\":{\"notice\":\"useful view function for string inputs - returns same with the DSML.generateId\"},\"getPortal()\":{\"notice\":\"get Portal as a contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Portal/packages/WithdrawalContract.sol\":\"WithdrawalContract\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x315887e846f1e5f8d8fa535a229d318bb9290aaa69485117f1ee8a9a6b3be823\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7967d130887c4b40666cd88f8744691d4527039a1b2a38aa0de41481ef646778\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xffcb29612efb57efc8f0d4897deb5abaeac830022c59a3aa17446d698dbc856b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8a1f16aa62b4d8c9e380057d9c3ee5c992e4a10dccc5650b26e38d4c61287d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa1b77d6d0f4591359c42b747a31375f20b0571b5e1fb62652d8184fb10f1d63a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09864aea84f01e39313375b5610c73a3c1c68abbdc51e5ccdd25ff977fdadf9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x888d64d221d52c31d015b76e50ca1af5ef8ff076550810b49cea6b01d8267a10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6392f2cfe3a5ee802227fe7a2dfd47096d881aec89bddd214b35c5b46d3cd941\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/Portal/globals/id_type.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n/**\\n * @notice ID_TYPE is an internal library that acts like an ENUM.\\n *\\n * @dev Used within the limited upgradability pattern:\\n *\\n * NONE & GAP: should not be used.\\n *\\n * Dual Governance:\\n * * SENATE: points to a proposal that will update the current SENATE address of a package(or Portal).\\n * * CONTRACT UPGRADE: proposal to change the given contract's implementation. TYPE should be package's TYPE.\\n *\\n * Users:\\n * * OPERATOR: permissionned Node Operators (hosted on Portal).\\n * * POOL: permissionless staking pools (hosted on Portal).\\n *\\n * Packages: (hosted on StakeModuleLib)\\n * * An ID can only point to 1(one) Package version' implementation address at a given point.\\n * * Can be upgraded by a dual governance, via pullUpgrade.\\n * * * Portal's dual governance consists of a Governance Token(governance) and a Senate(senate).\\n * * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n * * Built by utilizing the Modules.\\n * * LiquidityPool and WithdrawalContract are some examples.\\n *\\n * Middlewares: (hosted on StakeModuleLib)\\n * * An ID can point to multiple Middleware version' implementation address at the same time.\\n * * Can not be upgraded.\\n * * Do not have any guides to build really.\\n * * Currently only gETHMiddlewares\\n *\\n *  Limits:\\n *  * We simply set limits to separate a group of types from others. Like Packages and Middlewares.\\n *\\n * @dev all LIMIT parameters are exclusive, prevents double usage.\\n */\\nlibrary ID_TYPE {\\n  /// @notice TYPE 0: *invalid*\\n  uint256 internal constant NONE = 0;\\n\\n  /// @notice TYPE 1: Senate\\n  uint256 internal constant SENATE = 1;\\n\\n  /// --\\n\\n  /// @notice TYPE 3: Limit: exclusive, minimum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MIN_USER = 3;\\n\\n  /// @notice TYPE 4: USER: Permissionned Node Operator\\n  uint256 internal constant OPERATOR = 4;\\n\\n  /// @notice TYPE 5: USER: Staking Pool\\n  uint256 internal constant POOL = 5;\\n\\n  /// @notice TYPE 9999: Limit: exclusive, maximum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MAX_USER = 9999;\\n\\n  /// --\\n\\n  /// @notice TYPE 10000: Limit: exclusive, minimum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MIN_PACKAGE = 10000;\\n\\n  /// @notice TYPE 10001: Package: Portal is also a package\\n  uint256 internal constant PACKAGE_PORTAL = 10001;\\n\\n  /// @notice TYPE 10011: Package: The Withdrawal Credential Contract\\n  uint256 internal constant PACKAGE_WITHDRAWAL_CONTRACT = 10011;\\n\\n  /// @notice TYPE 10021: Package: A Liquidity Pool\\n  uint256 internal constant PACKAGE_LIQUIDITY_POOL = 10021;\\n\\n  /// @notice TYPE 19999: Limit: exclusive, maximum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MAX_PACKAGE = 19999;\\n\\n  /// --\\n\\n  /// @notice TYPE 20000: Limit: exclusive, minimum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MIN_MIDDLEWARE = 20000;\\n\\n  /// @notice TYPE 20011: Middleware: A new gETH interface\\n  uint256 internal constant MIDDLEWARE_GETH = 20011;\\n\\n  /// @notice TYPE 29999: Limit: exclusive, maximum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MAX_MIDDLEWARE = 29999;\\n}\\n\",\"keccak256\":\"0x08dd2d86c870ecd80a7f81a52ed45d362ca425359b8c27329bf16ef6e8764626\",\"license\":\"MIT\"},\"contracts/Portal/globals/macros.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// no floats in solidity. If needed, PERCENTAGE_DENOMINATOR always represents \\\"1\\\" (100%)\\nuint256 constant PERCENTAGE_DENOMINATOR = 10 ** 10;\\n\",\"keccak256\":\"0xf3a2ec72fdfc804f088c4f7245f1dbb881b23fae868ce7d8efa3f66c6008f60d\",\"license\":\"MIT\"},\"contracts/Portal/globals/reserved_key_space.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n/**\\n * @notice Reserved Key Space for DataStoreModule\\n * * helps preventing potential dev mistakes.\\n * * helps keeping track of them.\\n * * limits keys to bytes32.\\n *\\n * @dev utilize a key with rks.key\\n * @dev keep this list in alphabetical order, per module.\\n * @dev NEVER name your variables something else other than *its string value*.\\n * @dev ! array keys with readUint returns the lenght of the array !\\n */\\nlibrary RESERVED_KEY_SPACE {\\n  /**\\n   * @dev reserved on GeodeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition representing body of an id\\n   */\\n  bytes32 internal constant CONTROLLER = \\\"CONTROLLER\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition base of an id\\n   */\\n  bytes32 internal constant NAME = \\\"NAME\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition identifier for an id, based on ID_TYPEs\\n   */\\n  bytes32 internal constant TYPE = \\\"TYPE\\\";\\n\\n  /**\\n   * @dev reserved on StakeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of active validators run by an operator for a pool\\n   */\\n  bytes32 internal constant activeValidators = \\\"activeValidators\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition max amount of validators for an operator to run, for a specific pool.\\n   */\\n  bytes32 internal constant allowance = \\\"allowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition special operator that has max allowance, if threshold is hit for the pool\\n   */\\n  bytes32 internal constant fallbackOperator = \\\"fallbackOperator\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition treshold calculated with given percentage value for fallback operator to be activated\\n   */\\n  bytes32 internal constant fallbackThreshold = \\\"fallbackThreshold\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee of the pool or operator, will be shadowed by priorFee if switching\\n   */\\n  bytes32 internal constant fee = \\\"fee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed fee change\\n   */\\n  bytes32 internal constant feeSwitch = \\\"feeSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition the initiation timestamp of a \\\"user\\\" TYPE id\\n   */\\n  bytes32 internal constant initiated = \\\"initiated\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition bound liquidity pool of a pool\\n   */\\n  bytes32 internal constant liquidityPool = \\\"liquidityPool\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition receiver address for yield seperation functionality\\n   * * will receive minted gETH to given receiver instead of increasing pricePerShare\\n   */\\n  bytes32 internal constant yieldReceiver = \\\"yieldReceiver\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition hot wallet for pool and operators, automatooor\\n   */\\n  bytes32 internal constant maintainer = \\\"maintainer\\\";\\n\\n  /**\\n   * @custom:type address array, direct call returns length\\n   * @custom:definition contracts with more than one versions, ex: gETHMiddlewares of a pool\\n   */\\n  bytes32 internal constant middlewares = \\\"middlewares\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed validator period change\\n   */\\n  bytes32 internal constant periodSwitch = \\\"periodSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee that will be effective if fee is currently switching\\n   */\\n  bytes32 internal constant priorFee = \\\"priorFee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition period that will be effective if validatorPeriod is currently switching\\n   */\\n  bytes32 internal constant priorPeriod = \\\"priorPeriod\\\";\\n\\n  /**\\n   * @custom:type uint, bool\\n   * @custom:definition 1(true) if id is a private pool\\n   */\\n  bytes32 internal constant privatePool = \\\"privatePool\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition proposed validator count for pool-operator pair.\\n   */\\n  bytes32 internal constant proposedValidators = \\\"proposedValidators\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition timestamp of the date of the latest imprisonment for an operator\\n   */\\n  bytes32 internal constant release = \\\"release\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition 32 eth is secured, per proposed-but-not-yet-activated validator\\n   */\\n  bytes32 internal constant secured = \\\"secured\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition collateral waiting to be staked, in wei\\n   */\\n  bytes32 internal constant surplus = \\\"surplus\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition sum of all allowances for a pool\\n   */\\n\\n  bytes32 internal constant totalAllowance = \\\"totalAllowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition seconds, time that passes before the expected exit is reached for a validator\\n   */\\n  bytes32 internal constant validatorPeriod = \\\"validatorPeriod\\\";\\n\\n  /**\\n   * @custom:type bytes array, direct call returns length\\n   * @custom:definition lists all (any state) validators' pubkeys for a pool, or an operator\\n   */\\n  bytes32 internal constant validators = \\\"validators\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition custodian of validator funds for a pool\\n   */\\n  bytes32 internal constant withdrawalContract = \\\"withdrawalContract\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition derived from withdrawalContract\\n   */\\n  bytes32 internal constant withdrawalCredential = \\\"withdrawalCredential\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition size of the internal wallet, which accrues fees etc. in wei\\n   */\\n  bytes32 internal constant wallet = \\\"wallet\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition whitelist contract for the pool\\n   */\\n  bytes32 internal constant whitelist = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev reserved on OracleExtensionLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of alienated validators run by an operator for a pool\\n   */\\n  bytes32 internal constant alienValidators = \\\"alienValidators\\\";\\n}\\n\",\"keccak256\":\"0x8e3f1954e49738a3915efe5aaf41bb1f06f3bcb7f730ea6f21d9283dd1264548\",\"license\":\"MIT\"},\"contracts/Portal/globals/validator_state.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n/**\\n * @notice VALIDATOR_STATE: keeping track of validators within The Staking Library.\\n */\\nlibrary VALIDATOR_STATE {\\n  /// @notice STATE 0: *invalid*\\n  uint8 internal constant NONE = 0;\\n\\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract.\\n  uint8 internal constant PROPOSED = 1;\\n\\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator.\\n  uint8 internal constant ACTIVE = 2;\\n\\n  /// @notice STATE 3: validator is called to be exited.\\n  uint8 internal constant EXIT_REQUESTED = 3;\\n\\n  /// @notice STATE 4: validator is fully exited.\\n  uint8 internal constant EXITED = 4;\\n\\n  /// @notice STATE 69: proposal was malicious(alien). Maybe faulty signatures or probably frontrunning (https://bit.ly/3Tkc6UC)\\n  uint8 internal constant ALIENATED = 69;\\n}\\n\",\"keccak256\":\"0x90adbf99d079711be50d084046c2e1b3a992003e644b255945dbf436856c700c\",\"license\":\"MIT\"},\"contracts/Portal/helpers/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity =0.8.7;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\\n        internal\\n    {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(\\n                    add(tempBytes, lengthmod),\\n                    mul(0x20, iszero(lengthmod))\\n                )\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(\\n                        add(\\n                            add(_bytes, lengthmod),\\n                            mul(0x20, iszero(lengthmod))\\n                        ),\\n                        _start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(\\n                mload(add(add(_bytes, 0x20), _start)),\\n                0x1000000000000000000000000\\n            )\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint16)\\n    {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint32)\\n    {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint64)\\n    {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint96)\\n    {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint128)\\n    {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(\\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\\n                2\\n            )\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0x47661fc872b08aa96131860eb7a6a2c398987b151104ab8dd70ce2ed5a31a5e4\",\"license\":\"Unlicense\"},\"contracts/Portal/interfaces/IPortal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\nimport {IGeodeModule} from \\\"./modules/IGeodeModule.sol\\\";\\nimport {IStakeModule} from \\\"./modules/IStakeModule.sol\\\";\\n\\ninterface IPortal is IStakeModule, IGeodeModule {\\n  function pausegETH() external;\\n\\n  function unpausegETH() external;\\n\\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\\n\\n  function releasePrisoned(uint256 operatorId) external;\\n\\n  function setGovernanceFee(uint256 newFee) external;\\n}\\n\",\"keccak256\":\"0xda4b90b214a07eff1343407e6099aa398340a2a8d55b10174bbe0620c7db82f7\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\nimport {IERC1155PausableBurnableSupply} from \\\"./helpers/IERC1155PausableBurnableSupply.sol\\\";\\n\\ninterface IgETH is IERC1155PausableBurnableSupply {\\n  function denominator() external view returns (uint256);\\n\\n  function isMiddleware(address middleware, uint256 id) external view returns (bool);\\n\\n  function setMiddleware(address middleware, uint256 id, bool isSet) external;\\n\\n  function isAvoider(address account, uint256 id) external view returns (bool);\\n\\n  function avoidMiddlewares(uint256 id, bool isAvoid) external;\\n\\n  function pricePerShare(uint256 id) external view returns (uint256);\\n\\n  function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\n\\n  function setPricePerShare(uint256 price, uint256 id) external;\\n\\n  function transferUriSetterRole(address newUriSetter) external;\\n\\n  function transferPauserRole(address newPauser) external;\\n\\n  function transferMinterRole(address newMinter) external;\\n\\n  function transferOracleRole(address newOracle) external;\\n\\n  function transferMiddlewareManagerRole(address newMiddlewareManager) external;\\n}\\n\",\"keccak256\":\"0x5f8a92104d98c387d41e038463b666ccc095e8c38272e9f45aef9f74d352f903\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/helpers/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n/** This interface is designed to be compatible with the Vyper version.\\n * @notice This is the Ethereum 2.0 deposit contract interface.\\n * For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\n */\\ninterface IDepositContract {\\n  /**\\n   * @notice Submit a Phase 0 DepositData object.\\n   * @param pubkey A BLS12-381 public key.\\n   * @param withdrawal_credentials Commitment to a public key for withdrawals.\\n   * @param signature A BLS12-381 signature.\\n   * @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n   *Used as a protection against malformed input.\\n   */\\n  function deposit(\\n    bytes calldata pubkey,\\n    bytes calldata withdrawal_credentials,\\n    bytes calldata signature,\\n    bytes32 deposit_data_root\\n  ) external payable;\\n}\\n\",\"keccak256\":\"0xaa602358c13dc8a69d0ea06021fc1187e1f5ece809797273d05956b4ac877cd9\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/helpers/IERC1155PausableBurnableSupply.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\n\\ninterface IERC1155Burnable is IERC165, IERC1155, IERC1155MetadataURI {\\n  function burn(address account, uint256 id, uint256 value) external;\\n\\n  function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\\n}\\n\\ninterface IERC1155Supply is IERC165, IERC1155, IERC1155MetadataURI {\\n  function totalSupply(uint256 id) external view returns (uint256);\\n\\n  function exists(uint256 id) external view returns (bool);\\n}\\n\\ninterface IERC1155PausableBurnableSupply is IERC1155Burnable, IERC1155Supply {\\n  function setURI(string memory newuri) external;\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\\n\\n  function mintBatch(\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x815e777c097747b9d7e2ba44129420204b2d446736fb8e04733ebf2d482d81ad\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/helpers/IWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IWhitelist {\\n  function isAllowed(address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x19fef7cf90817c40e9c773d5a4c2ee81e8bf48791fdd406b2349821c89a5411c\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/middlewares/IgETHMiddleware.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IgETHMiddleware {\\n  function initialize(uint256 id_, address erc1155_, bytes memory data) external;\\n}\\n\",\"keccak256\":\"0xd441be9f2e81a66fc6a257ad47cc48ef55bdc963dd8e540eaf684b632c56b41e\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/modules/IDataStoreModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IDataStoreModule {\\n  function generateId(string calldata _name, uint256 _type) external pure returns (uint256 id);\\n\\n  function getKey(uint256 _id, bytes32 _param) external pure returns (bytes32 key);\\n\\n  function allIdsByType(uint256 _type, uint256 _index) external view returns (uint256);\\n\\n  function allIdsByTypeLength(uint256 _type) external view returns (uint256);\\n\\n  function readUint(uint256 id, bytes32 key) external view returns (uint256 data);\\n\\n  function readAddress(uint256 id, bytes32 key) external view returns (address data);\\n\\n  function readBytes(uint256 id, bytes32 key) external view returns (bytes memory data);\\n\\n  function readUintArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (uint256 data);\\n\\n  function readBytesArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (bytes memory data);\\n\\n  function readAddressArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (address data);\\n}\\n\",\"keccak256\":\"0x3d5e228c67d74312869502cf3f1c8ffa72be88bc97e31253298872a4d7d0ed85\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/modules/IGeodeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {GeodeModuleLib as GML} from \\\"../../modules/GeodeModule/libs/GeodeModuleLib.sol\\\";\\n\\ninterface IGeodeModule is IDataStoreModule {\\n  function isolationMode() external view returns (bool);\\n\\n  function GeodeParams()\\n    external\\n    view\\n    returns (\\n      address governance,\\n      address senate,\\n      address approvedUpgrade,\\n      uint256 senateExpiry,\\n      uint256 packageType\\n    );\\n\\n  function getContractVersion() external view returns (uint256);\\n\\n  function getProposal(uint256 id) external view returns (GML.Proposal memory proposal);\\n\\n  function propose(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external returns (uint256 id);\\n\\n  function rescueSenate(address _newSenate) external;\\n\\n  function approveProposal(\\n    uint256 id\\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\\n\\n  function changeSenate(address _newSenate) external;\\n\\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\\n}\\n\",\"keccak256\":\"0x102636466dac45ca6e7390d45cbe791170fc013a15b0d064823f83623eecaace\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/modules/ILiquidityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface ILiquidityModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function LiquidityParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address lpToken,\\n      uint256 pooledTokenId,\\n      uint256 initialA,\\n      uint256 futureA,\\n      uint256 initialATime,\\n      uint256 futureATime,\\n      uint256 swapFee,\\n      uint256 adminFee\\n    );\\n\\n  function getA() external view returns (uint256);\\n\\n  function getAPrecise() external view returns (uint256);\\n\\n  function getBalance(uint8 index) external view returns (uint256);\\n\\n  function getDebt() external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  function getAdminBalance(uint256 index) external view returns (uint256);\\n\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory);\\n\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256 availableTokenAmount);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[2] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function withdrawAdminFees(address receiver) external;\\n\\n  function setAdminFee(uint256 newAdminFee) external;\\n\\n  function setSwapFee(uint256 newSwapFee) external;\\n\\n  function rampA(uint256 futureA, uint256 futureTime) external;\\n\\n  function stopRampA() external;\\n}\\n\",\"keccak256\":\"0x4826f93a4438926045119b431893b8f662cd2b5cb04b45707fc08d35c8434fdd\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/modules/IStakeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {StakeModuleLib as SML} from \\\"../../modules/StakeModule/libs/StakeModuleLib.sol\\\";\\n\\ninterface IStakeModule is IDataStoreModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function StakeParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address oraclePosition,\\n      uint256 validatorsIndex,\\n      uint256 verificationIndex,\\n      uint256 monopolyThreshold,\\n      uint256 oracleUpdateTimestamp,\\n      uint256 dailyPriceIncreaseLimit,\\n      uint256 dailyPriceDecreaseLimit,\\n      uint256 governanceFee,\\n      bytes32 priceMerkleRoot,\\n      bytes32 balanceMerkleRoot\\n    );\\n\\n  function getValidator(bytes calldata pubkey) external view returns (SML.Validator memory);\\n\\n  function getPackageVersion(uint256 _type) external view returns (uint256);\\n\\n  function isMiddleware(uint256 _type, uint256 _version) external view returns (bool);\\n\\n  function initiateOperator(\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external payable;\\n\\n  function deployLiquidityPool(uint256 poolId) external;\\n\\n  function initiatePool(\\n    uint256 fee,\\n    uint256 middlewareVersion,\\n    address maintainer,\\n    bytes calldata NAME,\\n    bytes calldata middleware_data,\\n    bool[3] calldata config\\n  ) external payable returns (uint256 poolId);\\n\\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external;\\n\\n  function setWhitelist(uint256 poolId, address whitelist) external;\\n\\n  function setYieldReceiver(uint256 poolId, address yieldReceiver) external;\\n\\n  function changeMaintainer(uint256 poolId, address newMaintainer) external;\\n\\n  function getMaintenanceFee(uint256 id) external view returns (uint256);\\n\\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\\n\\n  function increaseWalletBalance(uint256 id) external payable returns (bool);\\n\\n  function decreaseWalletBalance(uint256 id, uint256 value) external returns (bool);\\n\\n  function isPrisoned(uint256 operatorId) external view returns (bool);\\n\\n  function blameOperator(bytes calldata pk) external;\\n\\n  function getValidatorPeriod(uint256 id) external view returns (uint256);\\n\\n  function switchValidatorPeriod(uint256 operatorId, uint256 newPeriod) external;\\n\\n  function setFallbackOperator(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external;\\n\\n  function operatorAllowance(uint256 poolId, uint256 operatorId) external view returns (uint256);\\n\\n  function delegate(\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external;\\n\\n  function isWhitelisted(uint256 poolId, address staker) external view returns (bool);\\n\\n  function isPrivatePool(uint256 poolId) external view returns (bool);\\n\\n  function isPriceValid(uint256 poolId) external view returns (bool);\\n\\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\\n\\n  function deposit(\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProof,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external payable returns (uint256 boughtgETH, uint256 mintedgETH);\\n\\n  function canStake(bytes calldata pubkey) external view returns (bool);\\n\\n  function proposeStake(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external;\\n\\n  function stake(uint256 operatorId, bytes[] calldata pubkeys) external;\\n\\n  function updateVerificationIndex(\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external;\\n\\n  function regulateOperators(uint256[] calldata feeThefts, bytes[] calldata proofs) external;\\n\\n  function reportBeacon(\\n    bytes32 priceMerkleRoot,\\n    bytes32 balanceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external;\\n\\n  function priceSync(uint256 poolId, uint256 price, bytes32[] calldata priceProof) external;\\n\\n  function priceSyncBatch(\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external;\\n}\\n\",\"keccak256\":\"0x8c59577cc10f7336a4d3c05396ab35dd879afd25ea13db01803d3c98a01cb4b3\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/packages/IGeodePackage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {IGeodeModule} from \\\"../modules/IGeodeModule.sol\\\";\\nimport {IPortal} from \\\"../IPortal.sol\\\";\\n\\ninterface IGeodePackage is IGeodeModule {\\n  function initialize(\\n    uint256 poolId,\\n    address owner,\\n    bytes calldata versionName,\\n    bytes memory data\\n  ) external;\\n\\n  function getPortal() external view returns (IPortal);\\n\\n  function getPoolId() external view returns (uint256);\\n\\n  function getProposedVersion() external view returns (uint256);\\n\\n  function pullUpgrade() external;\\n}\\n\",\"keccak256\":\"0xa945f92e5585fdaea1408ec9967b6536d5c44c8983e22ff435b503abfcb02d41\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/packages/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {ILiquidityModule} from \\\"../modules/ILiquidityModule.sol\\\";\\nimport {IGeodePackage} from \\\"./IGeodePackage.sol\\\";\\n\\ninterface ILiquidityPool is ILiquidityModule, IGeodePackage {}\\n\",\"keccak256\":\"0xbf7927cec5953f7850969189e50a4093085e72b3b2a00c97658c11658b651e9a\",\"license\":\"MIT\"},\"contracts/Portal/interfaces/packages/IWithdrawalContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {IGeodePackage} from \\\"./IGeodePackage.sol\\\";\\n\\ninterface IWithdrawalContract is IGeodePackage {}\\n\",\"keccak256\":\"0x74cb983c2bc0996f54dea780761eea2a5ae24a69af0e5e635ea914395067dc7b\",\"license\":\"MIT\"},\"contracts/Portal/modules/DataStoreModule/DataStoreModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// interfaces\\nimport {IDataStoreModule} from \\\"../../interfaces/modules/IDataStoreModule.sol\\\";\\n// libraries\\nimport {DataStoreModuleLib as DSML} from \\\"./libs/DataStoreModuleLib.sol\\\";\\n// external\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title DSM: DataStore Module\\n *\\n * @notice A storage management tool designed to create a safe and scalable storage layout\\n * for upgradable contracts with various types of data classes (users, packages, definitions).\\n *\\n * @dev review: this module delegates its functionality to DSML (DataStoreModuleLib).\\n * DSM or DSML has NO access control.\\n *\\n * @dev There are no additional functionalities implemented apart from the library.\\n *\\n * @dev NO function needs to be overriden when inherited.\\n *\\n * @dev __DataStoreModule_init (or _unchained) call is NOT NECESSARY when inherited.\\n *\\n * @dev No storage-altering external/public functions are exposed here, only view/pure external functions.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\nabstract contract DataStoreModule is IDataStoreModule, Initializable {\\n  using DSML for DSML.IsolatedStorage;\\n\\n  /**\\n   * @custom:section                           ** VARIABLES **\\n   *\\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\\n   */\\n  DSML.IsolatedStorage internal DATASTORE;\\n\\n  /**\\n   * @custom:section                           ** INITIALIZING **\\n   */\\n\\n  function __DataStoreModule_init() internal onlyInitializing {}\\n\\n  function __DataStoreModule_init_unchained() internal onlyInitializing {}\\n\\n  /**\\n   * @custom:section                           ** HELPER FUNCTIONS **\\n   *\\n   * @custom:visibility -> pure-external\\n   */\\n\\n  /**\\n   * @notice useful function for string inputs - returns same with the DSML.generateId\\n   * @dev id is generated by keccak(name, type)\\n   */\\n  function generateId(\\n    string calldata _name,\\n    uint256 _type\\n  ) external pure virtual override returns (uint256 id) {\\n    id = uint256(keccak256(abi.encodePacked(_name, _type)));\\n  }\\n\\n  /**\\n   * @notice useful view function for string inputs - returns same with the DSML.generateId\\n   */\\n  function getKey(\\n    uint256 _id,\\n    bytes32 _param\\n  ) external pure virtual override returns (bytes32 key) {\\n    return DSML.getKey(_id, _param);\\n  }\\n\\n  /**\\n   * @custom:section                           ** DATA GETTER FUNCTIONS **\\n   *\\n   * @custom:visibility -> view-external\\n   */\\n\\n  /**\\n   * @dev useful for outside reach, shouldn't be used within contracts as a referance\\n   * @return allIdsByType is an array of IDs of the given TYPE from Datastore,\\n   * returns a specific index\\n   */\\n  function allIdsByType(\\n    uint256 _type,\\n    uint256 _index\\n  ) external view virtual override returns (uint256) {\\n    return DATASTORE.allIdsByType[_type][_index];\\n  }\\n\\n  function allIdsByTypeLength(uint256 _type) external view virtual override returns (uint256) {\\n    return DATASTORE.allIdsByType[_type].length;\\n  }\\n\\n  function readUint(uint256 id, bytes32 key) external view virtual override returns (uint256 data) {\\n    data = DATASTORE.readUint(id, key);\\n  }\\n\\n  function readAddress(\\n    uint256 id,\\n    bytes32 key\\n  ) external view virtual override returns (address data) {\\n    data = DATASTORE.readAddress(id, key);\\n  }\\n\\n  function readBytes(\\n    uint256 id,\\n    bytes32 key\\n  ) external view virtual override returns (bytes memory data) {\\n    data = DATASTORE.readBytes(id, key);\\n  }\\n\\n  /**\\n   * @custom:section                           ** ARRAY GETTER FUNCTIONS **\\n   *\\n   * @custom:visibility -> view-external\\n   */\\n\\n  function readUintArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view virtual override returns (uint256 data) {\\n    data = DATASTORE.readUintArray(id, key, index);\\n  }\\n\\n  function readBytesArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view virtual override returns (bytes memory data) {\\n    data = DATASTORE.readBytesArray(id, key, index);\\n  }\\n\\n  function readAddressArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view virtual override returns (address data) {\\n    data = DATASTORE.readAddressArray(id, key, index);\\n  }\\n}\\n\",\"keccak256\":\"0xa08f519a85046d48bcc986b5cf93858f72b000e3b1a69f40e894bda004c5c94d\",\"license\":\"MIT\"},\"contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\n/**\\n * @title DSML: DataStore Module Library\\n *\\n * @notice A Storage Management Library created for the contracts and modules that inherits DataStoreModule (DSM).\\n * Enables Dynamic Structs with unlimited key space.\\n * Provides an Isolated Storage Layout with IDs and KEYs.\\n * Focusing on upgradable contracts with various data types to create a\\n * * sustainable development environment.\\n * In summary, extra gas cost that would be saved with Storage packing are\\n * * ignored to create dynamic structs.\\n *\\n * @dev Distinct id and key pairs SHOULD return different storage slots. No collisions!\\n * @dev IDs are the representation of an entity with any given key as properties.\\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\\n * @dev review: For a safer development process, NEVER use the IsolatedStorage with strings. Refer to globals/reserved_key_space.sol\\n *\\n * @dev While it is a good practice for keeping a record;\\n * * TYPE for ID is NOT mandatory, an ID might not have an explicit type.\\n * * e.g., When a relational data is added with getKey, like allowance, it has a unique ID but no TYPE.\\n * * Thus there are no checks for types or keys.\\n *\\n * @dev readUint(id, arrayName) returns the lenght of array.\\n *\\n * @dev Contracts relying on this library must use DataStoreModuleLib.IsolatedStorage\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary DataStoreModuleLib {\\n  /**\\n   * @notice Main Struct for reading/writing operations for given (id, key) pairs.\\n   *\\n   * @param allIdsByType type => id[], optional categorization for IDs, can be directly accessed.\\n   * @param uintData keccak(id, key) =>  returns uint256\\n   * @param bytesData keccak(id, key) => returns bytes\\n   * @param addressData keccak(id, key) =>  returns address\\n   * @param __gap keep the struct size at 16\\n   *\\n   * @dev any other storage type can be expressed as uint or bytes. E.g., bools are 0/1 as uints.\\n   */\\n  struct IsolatedStorage {\\n    mapping(uint256 => uint256[]) allIdsByType;\\n    mapping(bytes32 => uint256) uintData;\\n    mapping(bytes32 => bytes) bytesData;\\n    mapping(bytes32 => address) addressData;\\n    uint256[12] __gap;\\n  }\\n\\n  /**\\n   * @custom:section                           ** HELPERS **\\n   *\\n   * @custom:visibility -> pure-internal\\n   */\\n\\n  /**\\n   * @notice generalized method of generating an ID\\n   *\\n   * @dev Some TYPEs may require permissionless creation, allowing anyone to claim any ID;\\n   * meaning malicious actors can claim names to mislead people. To prevent this\\n   * TYPEs will be considered during ID generation.\\n   */\\n  function generateId(bytes memory _name, uint256 _type) internal pure returns (uint256 id) {\\n    id = uint256(keccak256(abi.encodePacked(_name, _type)));\\n  }\\n\\n  /**\\n   * @notice hash of given ID and a KEY defines the key for the IsolatedStorage\\n   * @return key bytes32, hash.\\n   **/\\n  function getKey(uint256 id, bytes32 param) internal pure returns (bytes32 key) {\\n    key = keccak256(abi.encodePacked(id, param));\\n  }\\n\\n  /**\\n   * @custom:section                           ** DATA GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_id, _key)];\\n  }\\n\\n  function readBytes(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_id, _key)];\\n  }\\n\\n  function readAddress(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_id, _key)];\\n  }\\n\\n  /**\\n   * @custom:section                           ** ARRAY GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUintArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readBytesArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readAddressArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  /**\\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** DATA SETTERS **\\n   */\\n\\n  function writeUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function addUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _addend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] += _addend;\\n  }\\n\\n  function subUint(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _minuend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] -= _minuend;\\n  }\\n\\n  function writeBytes(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    self.bytesData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function writeAddress(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    self.addressData[getKey(_id, _key)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ARRAY SETTERS **\\n   */\\n\\n  function appendUintArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendBytesArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendAddressArray(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** BATCH ARRAY SETTERS **\\n   */\\n\\n  function appendUintArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    for (uint256 i = 0; i < _data.length; ) {\\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendBytesArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    for (uint256 i = 0; i < _data.length; ) {\\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendAddressArrayBatch(\\n    IsolatedStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    for (uint256 i = 0; i < _data.length; ) {\\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n}\\n\",\"keccak256\":\"0x2d74bdce38dca73f27695089cac1345d962794837fb0e5a042fa3a33bd6ee2ed\",\"license\":\"MIT\"},\"contracts/Portal/modules/GeodeModule/GeodeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// globals\\nimport {ID_TYPE} from \\\"../../globals/id_type.sol\\\";\\n// interfaces\\nimport {IGeodeModule} from \\\"../../interfaces/modules/IGeodeModule.sol\\\";\\n// libraries\\nimport {GeodeModuleLib as GML} from \\\"./libs/GeodeModuleLib.sol\\\";\\nimport {DataStoreModuleLib as DSML} from \\\"../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\n// contracts\\nimport {DataStoreModule} from \\\"../DataStoreModule/DataStoreModule.sol\\\";\\n// external\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/**\\n * @title GM: Geode Module\\n *\\n * @notice Base logic for Upgradable Packages:\\n * * Dual Governance with Senate+Governance: Governance proposes, Senate approves.\\n * * Limited Upgradability built on top of UUPS via Dual Governance.\\n *\\n * @dev review: this module delegates its functionality to GML (GeodeModuleLib):\\n * GML has onlyGovernance, onlySenate, onlyController modifiers for access control.\\n *\\n * @dev There is 1 additional functionality implemented apart from the library:\\n * Mutating UUPS pattern to fit Limited Upgradability:\\n * 1. New implementation contract is proposed with its own package type within the limits, refer to globals/id_type.sol.\\n * 2. Proposal is approved by the contract owner, Senate.\\n * 3. approveProposal calls _handleUpgrade which mimics UUPS.upgradeTo:\\n * 3.1. Checks the implementation address with _authorizeUpgrade, also preventing any UUPS upgrades.\\n * 3.2. Upgrades the contract with no function to call afterwards.\\n * 3.3. Sets contract version. Note that it does not increase linearly like one might expect.\\n *\\n * @dev 1 function needs to be overriden when inherited: isolationMode. (also refer to approveProposal)\\n *\\n * @dev __GeodeModule_init (or _unchained) call is NECESSARY when inherited.\\n * However, deployer MUST call initializer after upgradeTo call,\\n * SHOULD NOT call initializer on upgradeToAndCall or new ERC1967Proxy calls.\\n *\\n * @dev This module inherits DataStoreModule.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\nabstract contract GeodeModule is IGeodeModule, DataStoreModule, UUPSUpgradeable {\\n  using GML for GML.DualGovernance;\\n\\n  /**\\n   * @custom:section                           ** VARIABLES **\\n   *\\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\\n   */\\n  GML.DualGovernance internal GEODE;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event ContractVersionSet(uint256 version);\\n\\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\\n  event Approved(uint256 ID);\\n  event NewSenate(address senate, uint256 expiry);\\n\\n  /**\\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\\n   */\\n  function isolationMode() external view virtual override returns (bool);\\n\\n  /**\\n   * @custom:section                           ** INITIALIZING **\\n   */\\n\\n  function __GeodeModule_init(\\n    address governance,\\n    address senate,\\n    uint256 senateExpiry,\\n    uint256 packageType,\\n    bytes calldata initVersionName\\n  ) internal onlyInitializing {\\n    __UUPSUpgradeable_init();\\n    __DataStoreModule_init();\\n    __GeodeModule_init_unchained(governance, senate, senateExpiry, packageType, initVersionName);\\n  }\\n\\n  /**\\n   * @dev This function uses _getImplementation(), clearly deployer SHOULD NOT call initializer on\\n   * upgradeToAndCall or new ERC1967Proxy calls. _getImplementation() returns 0 then.\\n   * @dev GOVERNANCE and SENATE set to msg.sender at beginning, can not propose+approve otherwise.\\n   * @dev native approveProposal(public) is not used here. Because it has an _handleUpgrade,\\n   * however initialization does not require UUPS.upgradeTo.\\n   */\\n  function __GeodeModule_init_unchained(\\n    address governance,\\n    address senate,\\n    uint256 senateExpiry,\\n    uint256 packageType,\\n    bytes calldata initVersionName\\n  ) internal onlyInitializing {\\n    require(governance != address(0), \\\"GM:governance can not be zero\\\");\\n    require(senate != address(0), \\\"GM:senate can not be zero\\\");\\n    require(senateExpiry > block.timestamp, \\\"GM:low senateExpiry\\\");\\n    require(packageType != 0, \\\"GM:packageType can not be zero\\\");\\n    require(initVersionName.length != 0, \\\"GM:initVersionName can not be empty\\\");\\n\\n    GEODE.GOVERNANCE = msg.sender;\\n    GEODE.SENATE = msg.sender;\\n\\n    GEODE.SENATE_EXPIRY = senateExpiry;\\n    GEODE.PACKAGE_TYPE = packageType;\\n\\n    uint256 initVersion = GEODE.propose(\\n      DATASTORE,\\n      _getImplementation(),\\n      packageType,\\n      initVersionName,\\n      1 days\\n    );\\n\\n    GEODE.approveProposal(DATASTORE, initVersion);\\n\\n    _setContractVersion(DSML.generateId(initVersionName, GEODE.PACKAGE_TYPE));\\n\\n    GEODE.GOVERNANCE = governance;\\n    GEODE.SENATE = senate;\\n  }\\n\\n  /**\\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @dev required by the OZ UUPS module, improved by the Geode Module.\\n   */\\n  function _authorizeUpgrade(address proposed_implementation) internal virtual override {\\n    require(\\n      GEODE.isUpgradeAllowed(proposed_implementation, _getImplementation()),\\n      \\\"GM:not allowed to upgrade\\\"\\n    );\\n  }\\n\\n  function _setContractVersion(uint256 id) internal virtual {\\n    GEODE.CONTRACT_VERSION = id;\\n    emit ContractVersionSet(id);\\n  }\\n\\n  /**\\n   * @dev Would use the public upgradeTo() call, which does _authorizeUpgrade and _upgradeToAndCallUUPS,\\n   * but it is external, OZ have not made it public yet.\\n   */\\n  function _handleUpgrade(\\n    address proposed_implementation,\\n    uint256 id\\n  ) internal virtual {\\n    _authorizeUpgrade(proposed_implementation);\\n    _upgradeToAndCallUUPS(proposed_implementation, new bytes(0), false);\\n    _setContractVersion(id);\\n  }\\n\\n  /**\\n   * @custom:section                           ** GETTER FUNCTIONS **\\n   *\\n   * @custom:visibility -> view-external\\n   */\\n\\n  // TODO: maybe seperate this? why not.\\n  function GeodeParams()\\n    external\\n    view\\n    virtual\\n    override\\n    returns (\\n      address governance,\\n      address senate,\\n      address approvedUpgrade,\\n      uint256 senateExpiry,\\n      uint256 packageType\\n    )\\n  {\\n    governance = GEODE.GOVERNANCE;\\n    senate = GEODE.SENATE;\\n    approvedUpgrade = GEODE.APPROVED_UPGRADE;\\n    senateExpiry = GEODE.SENATE_EXPIRY;\\n    packageType = GEODE.PACKAGE_TYPE;\\n  }\\n\\n  function getContractVersion() public view virtual override returns (uint256) {\\n    return GEODE.CONTRACT_VERSION;\\n  }\\n\\n  function getProposal(\\n    uint256 id\\n  ) external view virtual override returns (GML.Proposal memory proposal) {\\n    proposal = GEODE.getProposal(id);\\n  }\\n\\n  /**\\n   * @custom:section                           ** SETTER FUNCTIONS **\\n   *\\n   * @custom:visibility -> public/external\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** ONLY GOVERNANCE **\\n   *\\n   */\\n\\n  function propose(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) public virtual override returns (uint256 id) {\\n    id = GEODE.propose(DATASTORE, _CONTROLLER, _TYPE, _NAME, duration);\\n  }\\n\\n  function rescueSenate(address _newSenate) external virtual override {\\n    GEODE.rescueSenate(_newSenate);\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ONLY SENATE **\\n   */\\n\\n  /**\\n   * @dev handles PACKAGE_TYPE proposals by upgrading the contract immediately.\\n   */\\n  function approveProposal(\\n    uint256 id\\n  ) public virtual override returns (address _controller, uint256 _type, bytes memory _name) {\\n    (_controller, _type, _name) = GEODE.approveProposal(DATASTORE, id);\\n\\n    if (_type == GEODE.PACKAGE_TYPE) {\\n      _handleUpgrade(_controller, id);\\n    }\\n  }\\n\\n  function changeSenate(address _newSenate) external virtual override {\\n    GEODE.changeSenate(_newSenate);\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ONLY CONTROLLER **\\n   */\\n\\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external virtual override {\\n    GML.changeIdCONTROLLER(DATASTORE, id, newCONTROLLER);\\n  }\\n}\\n\",\"keccak256\":\"0xa723798dd62c06281c55cc8c5d813c2290eb221be943af4263d774ba8f79fa0b\",\"license\":\"MIT\"},\"contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// globals\\nimport {PERCENTAGE_DENOMINATOR} from \\\"../../../globals/macros.sol\\\";\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\n// libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\n\\n/**\\n * @title GML: Geode Module Library\\n *\\n * @notice Dual Governance & Limited Upgradability:\\n * Administration of the Isolated Storage with a Dual Governance consisting a Governance and a Senate.\\n * Administration of a UUPS contract with Limited Upgradability for Packages like Portal, LiquidityPool.\\n *\\n * @dev review: DataStoreModule for the IsolatedStorage logic.\\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\\n *\\n * @dev SENATE_EXPIRY is not mandatory to utilize. Simply set it to MAX_UINT256 if rescueSenate is not needed.\\n *\\n * @dev There are 3 ways to set a new Senate:\\n * 1. With a proposal TYPE 1. Proposal's controller becomes the new Senate, refreshes the expiry.\\n * 2. Current Senate can call changeSenate, which doesn't change the expiry\\n * 3. As a circuit breaker: If senate is expired, then rescue senate can be called by governance.\\n * @dev Currently, there are no way to set a new Governance.\\n *\\n *\\n * @dev Contracts relying on this library must use GeodeModuleLib.DualGovernance\\n * @dev This is an external library, requires deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\nlibrary GeodeModuleLib {\\n  using DSML for DSML.IsolatedStorage;\\n\\n  /**\\n   * @custom:section                           ** STRUCTS **\\n   */\\n\\n  /**\\n   * @notice Giving the control of a specific ID to proposed CONTROLLER.\\n   *\\n   * @param TYPE: refer to globals/id_type.sol\\n   * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\\n   * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\\n   * @param NAME: DataStore generates ID by keccak(name, type)\\n   * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\\n   * * Expired proposals can not be approved by Senate\\n   * * Expired proposals can not be overriden by new proposals\\n   **/\\n  struct Proposal {\\n    address CONTROLLER;\\n    uint256 TYPE;\\n    bytes NAME;\\n    uint256 deadline;\\n  }\\n\\n  /**\\n   * @notice Dual Governance allows 2 parties to manage a package with proposals and approvals.\\n   * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\\n   * Suggests updates, such as new operators, contract/package upgrades, a new Senate (without any permission to force them)\\n   * @param SENATE An address that protects the users by controlling the state of governance, contract updates and other crucial changes\\n   * @param APPROVED_UPGRADE only 1 implementation contract SHOULD be \\\"approved\\\" at any given time.\\n   * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Might not be utilized. Limited by MAX_SENATE_PERIOD\\n   * @param PACKAGE_TYPE every package has a specific TYPE. Defined in globals/id_type.sol\\n   * @param CONTRACT_VERSION always refers to the upgrade proposal ID. Does NOT increase uniformly like one might expect.\\n   * @param proposals till approved, proposals are kept separated from the Isolated Storage\\n   * @param __gap keep the struct size at 16\\n   **/\\n  struct DualGovernance {\\n    address GOVERNANCE;\\n    address SENATE;\\n    address APPROVED_UPGRADE;\\n    uint256 SENATE_EXPIRY;\\n    uint256 PACKAGE_TYPE;\\n    uint256 CONTRACT_VERSION;\\n    mapping(uint256 => Proposal) proposals;\\n    uint256[9] __gap;\\n  }\\n\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  /// @notice a proposal can have a duration between 1 days to 4 weeks (inclusive)\\n  uint32 public constant MIN_PROPOSAL_DURATION = 1 days;\\n  uint32 public constant MAX_PROPOSAL_DURATION = 4 weeks;\\n\\n  /// @notice if expiry is utilized, a senate can be active for a year.\\n  /// @dev \\\"MAX\\\" underlines a new senate can be set without expecting an expiry\\n  uint32 public constant MAX_SENATE_PERIOD = 365 days;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\\n  event Approved(uint256 ID);\\n  event NewSenate(address senate, uint256 expiry);\\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\\n\\n  /**\\n   * @custom:section                           ** MODIFIERS **\\n   */\\n  modifier onlyGovernance(DualGovernance storage self) {\\n    require(msg.sender == self.GOVERNANCE, \\\"GML:GOVERNANCE role needed\\\");\\n    _;\\n  }\\n\\n  modifier onlySenate(DualGovernance storage self) {\\n    require(msg.sender == self.SENATE, \\\"GML:SENATE role needed\\\");\\n    require(block.timestamp < self.SENATE_EXPIRY, \\\"GML:SENATE expired\\\");\\n    _;\\n  }\\n\\n  modifier onlyController(DSML.IsolatedStorage storage DATASTORE, uint256 id) {\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"GML:CONTROLLER role needed\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\\n   *\\n   * @custom:visibility -> view-external\\n   */\\n\\n  /**\\n   * @notice Check if it is allowed to change the package version to given proposedImplementation.\\n   * @dev provided for _authorizeUpgrade\\n   * @dev currentImplementation should always be UUPS._getImplementation()\\n   * @dev currentImplementation or zero as proposedImplementation will return false\\n   **/\\n  function isUpgradeAllowed(\\n    DualGovernance storage self,\\n    address proposedImplementation,\\n    address currentImplementation\\n  ) external view returns (bool) {\\n    return\\n      (self.APPROVED_UPGRADE != address(0)) &&\\n      (proposedImplementation != currentImplementation) &&\\n      (self.APPROVED_UPGRADE == proposedImplementation);\\n  }\\n\\n  /**\\n   * @custom:section                           ** GETTER FUNCTIONS **\\n   *\\n   * @custom:visibility -> view-external\\n   */\\n\\n  function getProposal(\\n    DualGovernance storage self,\\n    uint256 id\\n  ) external view returns (Proposal memory) {\\n    return self.proposals[id];\\n  }\\n\\n  /**\\n   * @custom:section                           ** SETTER FUNCTIONS **\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** INTERNAL **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n  function _setSenate(DualGovernance storage self, address _newSenate, uint256 _expiry) internal {\\n    self.SENATE = _newSenate;\\n    self.SENATE_EXPIRY = _expiry;\\n\\n    emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ONLY GOVERNANCE **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice generates a new ID with given TYPE and NAME, proposes it to be owned by a CONTROLLER.\\n   * @dev DATASTORE[id] will not be updated until the proposal is approved\\n   * @dev Proposals can NEVER be overriden\\n   */\\n  function propose(\\n    DualGovernance storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external onlyGovernance(self) returns (uint256 id) {\\n    id = DSML.generateId(_NAME, _TYPE);\\n\\n    require(self.proposals[id].deadline == 0, \\\"GML:already proposed\\\");\\n    require((DATASTORE.readBytes(id, rks.NAME)).length == 0, \\\"GML:ID already exist\\\");\\n    require(_CONTROLLER != address(0), \\\"GML:CONTROLLER can NOT be ZERO\\\");\\n    require((_TYPE != ID_TYPE.NONE) && (_TYPE != ID_TYPE.POOL), \\\"GML:TYPE is NONE or POOL\\\");\\n    require(\\n      (duration >= MIN_PROPOSAL_DURATION) && (duration <= MAX_PROPOSAL_DURATION),\\n      \\\"GML:invalid proposal duration\\\"\\n    );\\n\\n    uint256 _deadline = block.timestamp + duration;\\n\\n    self.proposals[id] = Proposal({\\n      CONTROLLER: _CONTROLLER,\\n      TYPE: _TYPE,\\n      NAME: _NAME,\\n      deadline: _deadline\\n    });\\n\\n    emit Proposed(_TYPE, id, _CONTROLLER, _deadline);\\n  }\\n\\n  /**\\n   * @notice changes Senate in a scenerio where the current Senate acts maliciously!\\n   * * We are sure this will not be the case, but creating a method for possible recovery is a must.\\n   * @notice Normally, Governance creates Senate Proposals frequently to signal it does not have\\n   * * any intent of malicious overtake.\\n   * note: If Governance does not send a Senate Proposal \\\"a while\\\" before the SENATE_EXPIRY,\\n   * * we recommend users to take their money out.\\n   * @dev Obviously, Governance needs to wait for SENATE_EXPIRY.\\n   * @dev Refreshes the expiry\\n   */\\n  function rescueSenate(\\n    DualGovernance storage self,\\n    address _newSenate\\n  ) external onlyGovernance(self) {\\n    require(block.timestamp > self.SENATE_EXPIRY, \\\"GML:cannot rescue yet\\\");\\n\\n    _setSenate(self, _newSenate, block.timestamp + MAX_SENATE_PERIOD);\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ONLY SENATE **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice approves a proposal and records given data to DataStore\\n   * @notice specific changes for the reserved types (1, 2, 3) are implemented here,\\n   * any other addition should take place in Portal, as not related.\\n   * Note that GM has additional logic for package type approvals.\\n   * @param id given ID proposal that has will be approved by Senate\\n   * @dev Senate is not able to approve approved proposals\\n   * @dev Senate is not able to approve expired proposals\\n   */\\n  function approveProposal(\\n    DualGovernance storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) external onlySenate(self) returns (address _controller, uint256 _type, bytes memory _name) {\\n    require(self.proposals[id].deadline > block.timestamp, \\\"GML:NOT an active proposal\\\");\\n\\n    _controller = self.proposals[id].CONTROLLER;\\n    _type = self.proposals[id].TYPE;\\n    _name = self.proposals[id].NAME;\\n\\n    DATASTORE.writeUint(id, rks.TYPE, _type);\\n    DATASTORE.writeAddress(id, rks.CONTROLLER, _controller);\\n    DATASTORE.writeBytes(id, rks.NAME, _name);\\n    DATASTORE.allIdsByType[_type].push(id);\\n\\n    if (_type == ID_TYPE.SENATE) {\\n      _setSenate(self, _controller, block.timestamp + MAX_SENATE_PERIOD);\\n    } else if (_type == self.PACKAGE_TYPE) {\\n      self.APPROVED_UPGRADE = _controller;\\n    }\\n\\n    // important\\n    self.proposals[id].deadline = block.timestamp;\\n\\n    emit Approved(id);\\n  }\\n\\n  /**\\n   * @notice It is useful to be able to change the Senate's address without changing the expiry.\\n   * @dev Does not change the expiry\\n   */\\n  function changeSenate(DualGovernance storage self, address _newSenate) external onlySenate(self) {\\n    _setSenate(self, _newSenate, self.SENATE_EXPIRY);\\n  }\\n\\n  /**\\n   * @custom:section                           ** ONLY CONTROLLER **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice change the CONTROLLER of an ID\\n   * @dev this operation can not be reverted by the old CONTROLLER!!!\\n   * @dev can not provide address(0), try 0x000000000000000000000000000000000000dEaD\\n   */\\n  function changeIdCONTROLLER(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address newCONTROLLER\\n  ) external onlyController(DATASTORE, id) {\\n    require(newCONTROLLER != address(0), \\\"GML:CONTROLLER can not be zero\\\");\\n\\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\\n    require(\\n      typeOfId > ID_TYPE.LIMIT_MIN_USER && typeOfId < ID_TYPE.LIMIT_MAX_USER,\\n      \\\"GML:ID TYPE is NOT user\\\"\\n    );\\n\\n    DATASTORE.writeAddress(id, rks.CONTROLLER, newCONTROLLER);\\n\\n    emit ControllerChanged(id, newCONTROLLER);\\n  }\\n}\\n\",\"keccak256\":\"0xef31598f6cc9d2a1ef087c69b7184773532747a2cf5caf7ede566e05111d21fd\",\"license\":\"MIT\"},\"contracts/Portal/modules/StakeModule/libs/DepositContractLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// interfaces\\nimport {IDepositContract} from \\\"../../../interfaces/helpers/IDepositContract.sol\\\";\\n// libraries\\nimport {BytesLib} from \\\"../../../helpers/BytesLib.sol\\\";\\n\\n/**\\n * @title DCL: Deposit Contract Library\\n *\\n * @notice Includes constants & functions that helps to the deposit process.\\n *\\n * @dev DEPOSIT_CONTRACT is chain specific and should be changed before deployments.\\n *\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary DepositContractLib {\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  IDepositContract internal constant DEPOSIT_CONTRACT =\\n    IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b);\\n  uint256 internal constant PUBKEY_LENGTH = 48;\\n  uint256 internal constant SIGNATURE_LENGTH = 96;\\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\\n\\n  /**\\n   * @custom:section                           ** FUNCTIONS **\\n   */\\n\\n  /**\\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\\n   * @param _b Memory array of size 32 .. 64\\n   */\\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\\n    assert(_b.length >= 32 && _b.length <= 64);\\n    if (64 == _b.length) return _b;\\n\\n    bytes memory zero32 = new bytes(32);\\n    assembly {\\n      mstore(add(zero32, 0x20), 0)\\n    }\\n\\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\\n    else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\\n  }\\n\\n  /**\\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\\n   * @param _value Number less than `2**64` for compatibility reasons\\n   */\\n  function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n    result = 0;\\n    uint256 temp_value = _value;\\n    for (uint256 i = 0; i < 8; ++i) {\\n      result = (result << 8) | (temp_value & 0xFF);\\n      temp_value >>= 8;\\n    }\\n\\n    assert(0 == temp_value); // fully converted\\n    result <<= (24 * 8);\\n  }\\n\\n  function _getDepositDataRoot(\\n    bytes memory _pubkey,\\n    bytes memory _withdrawalCredentials,\\n    bytes memory _signature,\\n    uint256 _stakeAmount\\n  ) internal pure returns (bytes32) {\\n    require(_stakeAmount >= 1 ether, \\\"DepositContract: deposit value too low\\\");\\n    require(_stakeAmount % 1 gwei == 0, \\\"DepositContract: deposit value not multiple of gwei\\\");\\n\\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\\n    bytes32 signatureRoot = sha256(\\n      abi.encodePacked(\\n        sha256(BytesLib.slice(_signature, 0, 64)),\\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\\n      )\\n    );\\n\\n    bytes32 depositDataRoot = sha256(\\n      abi.encodePacked(\\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\\n        sha256(abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot))\\n      )\\n    );\\n\\n    return depositDataRoot;\\n  }\\n\\n  /**\\n   * @notice converts an address to withdrawal credential, used on validator creation\\n   */\\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\\n    uint256 w = 1 << 248;\\n\\n    return abi.encodePacked(bytes32(w) | bytes32(uint256(uint160(address(wcAddress)))));\\n  }\\n\\n  /**\\n   * @notice deposit to DEPOSIT_CONTRACT and initiate a validator.\\n   */\\n  function depositValidator(\\n    bytes calldata pubkey,\\n    bytes memory withdrawalCredential,\\n    bytes memory signature,\\n    uint256 amount\\n  ) internal {\\n    DEPOSIT_CONTRACT.deposit{value: amount}(\\n      pubkey,\\n      withdrawalCredential,\\n      signature,\\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0x31ce87ce9addab6b0b08e27e8df45a11040d559e8390dc6e1118a6ba7db72327\",\"license\":\"MIT\"},\"contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// globals\\nimport {PERCENTAGE_DENOMINATOR} from \\\"../../../globals/macros.sol\\\";\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {VALIDATOR_STATE} from \\\"../../../globals/validator_state.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\n// libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {DepositContractLib as DCL} from \\\"./DepositContractLib.sol\\\";\\n// interfaces\\nimport {IgETH} from \\\"../../../interfaces/IgETH.sol\\\";\\nimport {IgETHMiddleware} from \\\"../../../interfaces/middlewares/IgETHMiddleware.sol\\\";\\nimport {IGeodePackage} from \\\"../../../interfaces/packages/IGeodePackage.sol\\\";\\nimport {ILiquidityPool} from \\\"../../../interfaces/packages/ILiquidityPool.sol\\\";\\nimport {IWhitelist} from \\\"../../../interfaces/helpers/IWhitelist.sol\\\";\\n// external\\nimport {Clones} from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {ERC1967Proxy} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @title SML: Stake Module Library (The Staking Library)\\n *\\n * @notice Creating a global standard for Staking, allowing anyone to OWN a trustless staking pool,\\n * improving the user experience for stakers and removing the \\\"need\\\" for centralized or decentralized intermediaries.\\n * * Exclusively contains functions related to:\\n * * 1. Initiators and Configurable Staking Pools.\\n * * 2. Pool and Operator management.\\n * * 3. Validator Delegation.\\n * * 4. Depositing.\\n * * 5. Staking Operations.\\n *\\n * @dev review: DataStoreModule for the IsolatedStorage logic.\\n * @dev review: OracleExtensionLib for oracle logic.\\n *\\n * @dev Every pool is isolated and every validator is unique. Segregate all the risk.\\n *\\n * @dev CONTROLLER and Maintainer:\\n * CONTROLLER is the owner of an ID, it manages the pool/operator. Its security is exteremely important.\\n * maintainer is the worker, can be used to automate some daily tasks:\\n * * distributing validators for Staking Pools or creating validators for Operators.\\n * * not so crucial in terms of security.\\n *\\n * @dev Users:\\n * Type 4 : Permissioned Operators\\n * * Needs to be onboarded by the Dual Governance (Senate + Governance).\\n * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\\n * * Can participate in the Operator Marketplace after initiation.\\n * * Can utilize maintainers for staking operations.\\n *\\n * Type 5 : Permissionless Configurable Staking Pools\\n * * Permissionless to create.\\n * * Can utilize powers of packages and middlewares such as Bound Liquidity Pools, gETHMiddlewares etc.\\n * * Can be public or private, can use a whitelist if private.\\n * * Can utilize maintainers for validator distribution on Operator Marketplace.\\n * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\\n * * accruing rewards and keeping Staked Ether safe and isolated.\\n *\\n * @dev Packages:\\n * An ID can only point to one version of a Package at a time.\\n * Built by utilizing the Modules!\\n * Can be upgraded by a dual governance, via pullUpgrade.\\n * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n *\\n * Type 10011 : Withdrawal Contract\\n * * Mandatory.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Staking Pools are in \\\"Isolation Mode\\\" until their Withdrawal Contract is upgraded.\\n * * * Meaning, no more Depositing or Validator Proposal can happen.\\n * * Custodian of the validator funds after creation, including any type of rewards and fees.\\n *\\n * Type 10021 : Liquidity Pool implementation\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Liquidity Pools are in \\\"Isolation Mode\\\" until upgraded.\\n *\\n * @dev Middlewares:\\n * Can support many different versions that can be utilized by the Pool Owners.\\n * No particular way to build one.\\n * Can not be upgraded.\\n * Currently only gETHMiddlewares.\\n *\\n * Type 20011 : gETHMiddleware\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Requires the approval of Senate\\n * * Currently should be utilized on initiation.\\n *\\n * @dev Contracts relying on this library must initialize StakeUtils.PooledStaking\\n *\\n * @dev Functions are protected with authentication function\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary StakeModuleLib {\\n  using DSML for DSML.IsolatedStorage;\\n\\n  /**\\n   * @custom:section                           ** STRUCTS **\\n   */\\n\\n  /**\\n   * @notice Helper Struct to pack constant data that does not change per validator on batch proposals\\n   * * needed for that famous Solidity feature.\\n   */\\n  struct ConstantValidatorData {\\n    uint64 index;\\n    uint64 period;\\n    uint256 poolFee;\\n    uint256 operatorFee;\\n    uint256 governanceFee;\\n    bytes withdrawalCredential;\\n  }\\n\\n  /**\\n   * @param state state of the validator, refer to globals.sol\\n   * @param index representing this validator's placement on the chronological order of the validators proposals\\n   * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\\n   * @param period the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\\n   * @param poolId needed for withdrawal_credential\\n   * @param operatorId needed for staking after allowance\\n   * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\\n   * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\\n   * @param governanceFee although governance fee is zero right now, all fees are crucial for the price calculation by the oracle.\\n   * @param signature31 BLS12-381 signature for the validator, used when the remaining 31 ETH is sent on validator activation.\\n   **/\\n  struct Validator {\\n    uint64 state;\\n    uint64 index;\\n    uint64 createdAt;\\n    uint64 period;\\n    uint256 poolId;\\n    uint256 operatorId;\\n    uint256 poolFee;\\n    uint256 operatorFee;\\n    uint256 governanceFee;\\n    bytes signature31;\\n  }\\n\\n  /**\\n   * @param gETH constant, ERC1155, all Geode Staking Derivatives.\\n   * @param ORACLE_POSITION constant, address of the Oracle https://github.com/Geodefi/Telescope-Eth\\n   * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\\n   * * Includes all validators: proposed, active, alienated, exited.\\n   * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\\n   * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\\n   * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\\n   * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval, per second.\\n   * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval, per second.\\n   * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, updated by the Holy Oracle.\\n   * @param GOVERNANCE_FEE **reserved** Although it is 0 right now, It can be updated in the future.\\n   * @param BALANCE_MERKLE_ROOT merkle root of the balances and other validator related data, useful on withdrawals, updated by the Holy Oracle.\\n   * @param validators pubkey => Validator, contains all the data about proposed, alienated, active, exit-called and fully exited validators.\\n   * @param packages TYPE => version id, pointing to the latest versions of the given package.\\n   * * Like default Withdrawal Contract version.\\n   * @param middlewares TYPE => version id => isAllowed, useful to check if given version of the middleware can be used.\\n   * * Like all the whitelisted gETHMiddlewares.\\n   * @param __gap keep the struct size at 16\\n   **/\\n  struct PooledStaking {\\n    IgETH gETH;\\n    address ORACLE_POSITION;\\n    uint256 VALIDATORS_INDEX;\\n    uint256 VERIFICATION_INDEX;\\n    uint256 MONOPOLY_THRESHOLD;\\n    uint256 ORACLE_UPDATE_TIMESTAMP;\\n    uint256 DAILY_PRICE_INCREASE_LIMIT;\\n    uint256 DAILY_PRICE_DECREASE_LIMIT;\\n    uint256 GOVERNANCE_FEE;\\n    bytes32 PRICE_MERKLE_ROOT;\\n    bytes32 BALANCE_MERKLE_ROOT;\\n    mapping(bytes => Validator) validators;\\n    mapping(uint256 => uint256) packages;\\n    mapping(uint256 => mapping(uint256 => bool)) middlewares;\\n    uint256[2] __gap;\\n  }\\n\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  /// @notice limiting the GOVERNANCE_FEE to 5%\\n  uint256 public constant MAX_GOVERNANCE_FEE = (PERCENTAGE_DENOMINATOR * 5) / 100;\\n\\n  /// @notice limiting the pool and operator maintenance fee, 10%\\n  uint256 public constant MAX_MAINTENANCE_FEE = (PERCENTAGE_DENOMINATOR * 10) / 100;\\n\\n  /// @notice effective on allowance per operator, prevents overflow. Exclusive, save gas with +1.\\n  uint256 public constant MAX_ALLOWANCE = 10 ** 6 + 1;\\n\\n  /// @notice price of gETH is only valid for 24H, minting is not allowed afterwards.\\n  uint256 public constant PRICE_EXPIRY = 24 hours;\\n\\n  /// @notice ignoring any buybacks if the Liquidity Pool has a low debt\\n  uint256 public constant IGNORABLE_DEBT = 1 ether;\\n\\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 2 years\\n  uint256 public constant MIN_VALIDATOR_PERIOD = 3 * 30 days;\\n  uint256 public constant MAX_VALIDATOR_PERIOD = 2 * 365 days;\\n\\n  /// @notice some parameter changes are effective after a delay\\n  uint256 public constant SWITCH_LATENCY = 3 days;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\\n  event MiddlewareDeployed(uint256 poolId, uint256 version);\\n  event PackageDeployed(uint256 poolId, uint256 packageType, address instance);\\n  event VisibilitySet(uint256 id, bool isPrivate);\\n  event YieldReceiverSet(uint256 indexed poolId, address yieldReceiver);\\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId, uint256 threshold);\\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\\n  event Stake(bytes[] pubkeys);\\n\\n  /**\\n   * @custom:section                           ** AUTHENTICATION **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  /**\\n   * @notice restricts the access to given function based on TYPE and msg.sender\\n   * @param _expectCONTROLLER restricts the access to only CONTROLLER.\\n   * @param _expectMaintainer restricts the access to only maintainer.\\n   * @param _restrictionMap Restricts which TYPEs can pass the authentication.\\n   * * [0: Operator = TYPE(4), 1: Pool = TYPE(5)]\\n   * @dev can only be used after an ID is initiated\\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators can not access.\\n   */\\n  function _authenticate(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    bool _expectCONTROLLER,\\n    bool _expectMaintainer,\\n    bool[2] memory _restrictionMap\\n  ) internal view {\\n    require(DATASTORE.readUint(_id, rks.initiated) != 0, \\\"SML:not initiated\\\");\\n\\n    uint256 typeOfId = DATASTORE.readUint(_id, rks.TYPE);\\n\\n    if (typeOfId == ID_TYPE.OPERATOR) {\\n      require(_restrictionMap[0], \\\"SML:TYPE NOT allowed\\\");\\n      if (_expectCONTROLLER || _expectMaintainer) {\\n        require(!isPrisoned(DATASTORE, _id), \\\"SML:prisoned, get in touch with governance\\\");\\n      }\\n    } else if (typeOfId == ID_TYPE.POOL) {\\n      require(_restrictionMap[1], \\\"SML:TYPE NOT allowed\\\");\\n    } else revert(\\\"SML:invalid TYPE\\\");\\n\\n    if (_expectMaintainer) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.maintainer),\\n        \\\"SML:sender NOT maintainer\\\"\\n      );\\n      return;\\n    }\\n\\n    if (_expectCONTROLLER) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.CONTROLLER),\\n        \\\"SML:sender NOT CONTROLLER\\\"\\n      );\\n      return;\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** OPERATOR INITIATOR **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice initiates ID as a Permissionned Node Operator\\n   * @notice requires ID to be approved as a node operator with a specific CONTROLLER\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%\\n   * @param validatorPeriod the expected maximum staking interval. This value should between\\n   * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above.\\n   * Operator can unstake at any given point before this period ends.\\n   * If operator disobeys this rule, it can be prisoned with blameOperator()\\n   * @param maintainer an address that automates daily operations, a script, a contract...\\n   * @dev operators can fund their internal wallet on initiation by simply sending some ether.\\n   */\\n  function initiateOperator(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external {\\n    require(DATASTORE.readUint(id, rks.initiated) == 0, \\\"SML:already initiated\\\");\\n    require(DATASTORE.readUint(id, rks.TYPE) == ID_TYPE.OPERATOR, \\\"SML:TYPE NOT allowed\\\");\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"SML:sender NOT CONTROLLER\\\");\\n\\n    DATASTORE.writeUint(id, rks.initiated, block.timestamp);\\n\\n    _setMaintenanceFee(DATASTORE, id, fee);\\n    _setValidatorPeriod(DATASTORE, id, validatorPeriod);\\n    _setMaintainer(DATASTORE, id, maintainer);\\n    _increaseWalletBalance(DATASTORE, id, msg.value);\\n\\n    emit IdInitiated(id, ID_TYPE.OPERATOR);\\n  }\\n\\n  /**\\n   * @custom:section                           ** STAKING POOL INITIATOR **\\n   *\\n   * @dev this section also contains the helper functions for packages and middlewares.\\n   */\\n\\n  /**\\n   * @notice Creates a Configurable Trustless Staking Pool!\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\\n   * @param middlewareVersion Pool creators can choose any allowed version as their gETHMiddleware\\n   * @param maintainer an address that automates daily operations, a script, a contract... not so critical.\\n   * @param name is utilized while generating an ID for the Pool, similar to any other ID generation.\\n   * @param middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\\n   * @param config array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]\\n   * @dev checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.\\n   * @dev requires exactly 1 validator worth of funds to be deposited on initiation, prevent sybil attacks.\\n   */\\n  function initiatePool(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 fee,\\n    uint256 middlewareVersion,\\n    address maintainer,\\n    bytes calldata name,\\n    bytes calldata middleware_data,\\n    bool[3] calldata config\\n  ) external returns (uint256 poolId) {\\n    require(msg.value == DCL.DEPOSIT_AMOUNT, \\\"SML:need 1 validator worth of funds\\\");\\n\\n    poolId = DSML.generateId(name, ID_TYPE.POOL);\\n    require(DATASTORE.readUint(poolId, rks.initiated) == 0, \\\"SML:already initiated\\\");\\n    require(poolId > 10 ** 9, \\\"SML:Wow! Low pool id\\\");\\n\\n    DATASTORE.writeUint(poolId, rks.initiated, block.timestamp);\\n\\n    DATASTORE.writeUint(poolId, rks.TYPE, ID_TYPE.POOL);\\n    DATASTORE.writeAddress(poolId, rks.CONTROLLER, msg.sender);\\n    DATASTORE.writeBytes(poolId, rks.NAME, name);\\n    DATASTORE.allIdsByType[ID_TYPE.POOL].push(poolId);\\n\\n    _setMaintainer(DATASTORE, poolId, maintainer);\\n    _setMaintenanceFee(DATASTORE, poolId, fee);\\n\\n    // deploy a withdrawal Contract - mandatory\\n    _deployWithdrawalContract(self, DATASTORE, poolId);\\n\\n    if (config[0]) {\\n      // set pool to private\\n      setPoolVisibility(DATASTORE, poolId, true);\\n    }\\n    if (config[1]) {\\n      // deploy a gETH middleware(erc20 etc.) - optional\\n      _deploygETHMiddleware(self, DATASTORE, poolId, middlewareVersion, middleware_data);\\n    }\\n    if (config[2]) {\\n      // deploy a bound liquidity pool - optional\\n      deployLiquidityPool(self, DATASTORE, poolId);\\n    }\\n\\n    // initially 1 ETHER = 1 ETHER\\n    self.gETH.setPricePerShare(1 ether, poolId);\\n\\n    // mint gETH and send back to the caller\\n    uint256 mintedgETH = _mintgETH(self, DATASTORE, poolId, msg.value);\\n    self.gETH.safeTransferFrom(address(this), msg.sender, poolId, mintedgETH, \\\"\\\");\\n\\n    emit IdInitiated(poolId, ID_TYPE.POOL);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** POOL INITIATOR HELPERS **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set a gETHMiddleware\\n   * @param _middleware address of the new gETHMiddleware for given ID\\n   * @dev every middleware has a unique index within the middlewares dynamic array.\\n   * @dev if ever unset, SHOULD replace the implementation with address(0) for obvious security reasons.\\n   */\\n  function _setgETHMiddleware(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address _middleware\\n  ) internal {\\n    require(!self.gETH.isMiddleware(_middleware, id), \\\"SML:already middleware\\\");\\n\\n    DATASTORE.appendAddressArray(id, rks.middlewares, _middleware);\\n\\n    self.gETH.setMiddleware(_middleware, id, true);\\n  }\\n\\n  /**\\n   * @notice deploys a new gETHMiddleware by cloning (no upgradability)\\n   * @param _id gETH id, also required for IgETHMiddleware.initialize\\n   * @param _versionId provided version id, can use any as a middleware if allowed for TYPE = MIDDLEWARE_GETH\\n   * @param _middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\\n   * @dev currrently, can NOT deploy a middleware after initiation, thus only used by the initiator.\\n   * @dev currrently, can NOT unset a middleware.\\n   */\\n  function _deploygETHMiddleware(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _versionId,\\n    bytes memory _middleware_data\\n  ) internal {\\n    require(_versionId > 0);\\n    require(self.middlewares[ID_TYPE.MIDDLEWARE_GETH][_versionId], \\\"SML:not a middleware\\\");\\n\\n    address newgETHMiddleware = Clones.clone(DATASTORE.readAddress(_versionId, rks.CONTROLLER));\\n\\n    IgETHMiddleware(newgETHMiddleware).initialize(_id, address(self.gETH), _middleware_data);\\n\\n    _setgETHMiddleware(self, DATASTORE, _id, newgETHMiddleware);\\n\\n    // isolate the contract from middleware risk for ID\\n    self.gETH.avoidMiddlewares(_id, true);\\n\\n    emit MiddlewareDeployed(_id, _versionId);\\n  }\\n\\n  /**\\n   * @notice deploys a new package for given id with given type from packages mapping.\\n   * @param _type given package type\\n   * @param _poolId pool id, required for IGeodePackage.initialize\\n   * @param _package_data packages might require additional data on initialization\\n   * @dev no cloning because GeodePackages has Limited Upgradability (based on UUPS)\\n   */\\n  function _deployGeodePackage(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _type,\\n    bytes memory _package_data\\n  ) internal returns (address packageInstance) {\\n    uint256 versionId = self.packages[_type];\\n    require(versionId > 0);\\n\\n    packageInstance = address(\\n      new ERC1967Proxy(DATASTORE.readAddress(versionId, rks.CONTROLLER), \\\"\\\")\\n    );\\n    // we don't call on deployment because initialize uses _getImplementation() which is not available\\n    IGeodePackage(packageInstance).initialize(\\n      _poolId,\\n      DATASTORE.readAddress(_poolId, rks.CONTROLLER),\\n      DATASTORE.readBytes(versionId, rks.NAME),\\n      _package_data\\n    );\\n\\n    emit PackageDeployed(_poolId, _type, packageInstance);\\n  }\\n\\n  /**\\n   * @notice Deploys a Withdrawal Contract that will be used as a withdrawal credential on validator creation\\n   * @dev every pool requires a Withdrawal Contract, thus this function is only used by the initiator\\n   */\\n  function _deployWithdrawalContract(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) internal {\\n    require(\\n      DATASTORE.readAddress(_poolId, rks.withdrawalContract) == address(0),\\n      \\\"SML:already deployed\\\"\\n    );\\n\\n    address wp = _deployGeodePackage(\\n      self,\\n      DATASTORE,\\n      _poolId,\\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\\n      bytes(\\\"\\\")\\n    );\\n\\n    DATASTORE.writeAddress(_poolId, rks.withdrawalContract, wp);\\n    DATASTORE.writeBytes(_poolId, rks.withdrawalCredential, DCL.addressToWC(wp));\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** BOUND LIQUIDITY POOL **\\n   *\\n   * @custom:visibility -> public\\n   */\\n\\n  /**\\n   * @notice deploys a bound liquidity pool for a staking pool, if it does not have one.\\n   * @dev gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)\\n   * @dev unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well\\n   * @dev _package_data of a liquidity pool is only the staking pool's name.\\n   */\\n  function deployLiquidityPool(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(DATASTORE.readAddress(poolId, rks.liquidityPool) == address(0), \\\"SML:already deployed\\\");\\n\\n    address lp = _deployGeodePackage(\\n      self,\\n      DATASTORE,\\n      poolId,\\n      ID_TYPE.PACKAGE_LIQUIDITY_POOL,\\n      DATASTORE.readBytes(poolId, rks.NAME)\\n    );\\n\\n    DATASTORE.writeAddress(poolId, rks.liquidityPool, lp);\\n    // approve gETH so we can use it in buybacks\\n    self.gETH.setApprovalForAll(lp, true);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** POOL VISIBILITY **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice changes the visibility of the pool\\n   * @param makePrivate true if pool should be private, false for public pools\\n   * @dev whitelist is cleared when pool is set to public, to prevent legacy bugs if ever made private again.\\n   * Note private pools can whitelist addresses with the help of a third party contract.\\n   */\\n  function setPoolVisibility(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    bool makePrivate\\n  ) public {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(makePrivate != isPrivatePool(DATASTORE, poolId), \\\"SML:already set\\\");\\n\\n    DATASTORE.writeUint(poolId, rks.privatePool, makePrivate ? 1 : 0);\\n\\n    if (!makePrivate) {\\n      DATASTORE.writeAddress(poolId, rks.whitelist, address(0));\\n    }\\n\\n    emit VisibilitySet(poolId, makePrivate);\\n  }\\n\\n  /**\\n   * @notice private pools can whitelist addresses with the help of a third party contract.\\n   * @dev Whitelisting contracts should implement IWhitelist interface.\\n   */\\n  function setWhitelist(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address whitelist\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(isPrivatePool(DATASTORE, poolId), \\\"SML:must be private pool\\\");\\n\\n    DATASTORE.writeAddress(poolId, rks.whitelist, whitelist);\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the pool is private\\n   */\\n  function isPrivatePool(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return (DATASTORE.readUint(poolId, rks.privatePool) == 1);\\n  }\\n\\n  /**\\n   * @notice checks if the Whitelist allows staker to use given private pool\\n   * @dev Owner of the pool doesn't need whitelisting\\n   * @dev Otherwise requires a whitelisting address to be set\\n   */\\n  function isWhitelisted(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address staker\\n  ) public view returns (bool) {\\n    if (DATASTORE.readAddress(poolId, rks.CONTROLLER) == staker) {\\n      return true;\\n    }\\n\\n    address whitelist = DATASTORE.readAddress(poolId, rks.whitelist);\\n    require(whitelist != address(0), \\\"SML:no whitelist\\\");\\n\\n    return IWhitelist(whitelist).isAllowed(staker);\\n  }\\n\\n  /**\\n   * @custom:section                           ** ID MANAGEMENT **\\n   *\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** YIELD SEPARATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Set the yield receiver address to activate or deactivete yield separation logic.\\n   * * If set other than address(0) separation will be activated, if set back to address(0)\\n   * * separation will be deactivated again.\\n   * @param poolId the gETH id of the Pool\\n   * @param yieldReceiver address of the yield receiver\\n   * @dev Only CONTROLLER of pool can set yield receier.\\n   */\\n  function setYieldReceiver(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    address yieldReceiver\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n\\n    DATASTORE.writeAddress(poolId, rks.yieldReceiver, yieldReceiver);\\n    emit YieldReceiverSet(poolId, yieldReceiver);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** MAINTAINER **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Set the maintainer address on initiation or later\\n   * @param _newMaintainer address of the new maintainer\\n   */\\n  function _setMaintainer(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    address _newMaintainer\\n  ) internal {\\n    require(_newMaintainer != address(0), \\\"SML:maintainer can NOT be zero\\\");\\n\\n    DATASTORE.writeAddress(_id, rks.maintainer, _newMaintainer);\\n    emit MaintainerChanged(_id, _newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\\n   * @dev there can only be 1 maintainer per ID.\\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\\n   * @dev we don't use _authenticate here because malicious maintainers can imprison operators\\n   * * and prevent them entering here, smh.\\n   */\\n  function changeMaintainer(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    address newMaintainer\\n  ) external {\\n    require(DATASTORE.readUint(id, rks.initiated) != 0, \\\"SML:ID is not initiated\\\");\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"SML:sender NOT CONTROLLER\\\");\\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\\n    require(typeOfId == ID_TYPE.OPERATOR || typeOfId == ID_TYPE.POOL, \\\"SML:invalid TYPE\\\");\\n\\n    _setMaintainer(DATASTORE, id, newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** FEE **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\\n   *\\n   * @dev respecs to the switching delay.\\n   *\\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\\n   */\\n  function getMaintenanceFee(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 fee) {\\n    if (DATASTORE.readUint(id, rks.feeSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorFee);\\n    }\\n    return DATASTORE.readUint(id, rks.fee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set fee with NO DELAY\\n   */\\n  function _setMaintenanceFee(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _newFee\\n  ) internal {\\n    require(_newFee <= MAX_MAINTENANCE_FEE, \\\"SML:> MAX_MAINTENANCE_FEE \\\");\\n    DATASTORE.writeUint(_id, rks.fee, _newFee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\\n   * @dev Can NOT be called again while its currently switching.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   */\\n  function switchMaintenanceFee(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 newFee\\n  ) external {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(block.timestamp > DATASTORE.readUint(id, rks.feeSwitch), \\\"SML:currently switching\\\");\\n\\n    DATASTORE.writeUint(id, rks.priorFee, DATASTORE.readUint(id, rks.fee));\\n    DATASTORE.writeUint(id, rks.feeSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setMaintenanceFee(DATASTORE, id, newFee);\\n\\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** INTERNAL WALLET **\\n   *\\n   * @dev Internal wallet of an ID accrues fees over time.\\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Simply increases the balance of an IDs Maintainer wallet\\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\\n   */\\n  function _increaseWalletBalance(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    DATASTORE.addUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @notice To decrease the balance of an Operator's wallet internally\\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\\n   */\\n  function _decreaseWalletBalance(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    require(DATASTORE.readUint(_id, rks.wallet) >= _value, \\\"SML:insufficient wallet balance\\\");\\n    DATASTORE.subUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice external function to increase the internal wallet balance\\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\\n   */\\n  function increaseWalletBalance(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, false, false, [true, true]);\\n    _increaseWalletBalance(DATASTORE, id, msg.value);\\n    success = true;\\n  }\\n\\n  /**\\n   * @notice external function to decrease the internal wallet balance\\n   * @dev only CONTROLLER can decrease the balance externally,\\n   * @return success if the amount was sent and deducted\\n   */\\n  function decreaseWalletBalance(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 value\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(address(this).balance >= value, \\\"SML:insufficient contract balance\\\");\\n\\n    _decreaseWalletBalance(DATASTORE, id, value);\\n    address controller = DATASTORE.readAddress(id, rks.CONTROLLER);\\n\\n    (success, ) = payable(controller).call{value: value}(\\\"\\\");\\n    require(success, \\\"SML:Failed to send ETH\\\");\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** OPERATORS PERIOD **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  function getValidatorPeriod(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 period) {\\n    if (DATASTORE.readUint(id, rks.periodSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorPeriod);\\n    }\\n    return DATASTORE.readUint(id, rks.validatorPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set validator period with NO DELAY\\n   */\\n  function _setValidatorPeriod(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    uint256 _newPeriod\\n  ) internal {\\n    require(_newPeriod >= MIN_VALIDATOR_PERIOD, \\\"SML:< MIN_VALIDATOR_PERIOD\\\");\\n    require(_newPeriod <= MAX_VALIDATOR_PERIOD, \\\"SML:> MAX_VALIDATOR_PERIOD\\\");\\n\\n    DATASTORE.writeUint(_operatorId, rks.validatorPeriod, _newPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\\n   */\\n  function switchValidatorPeriod(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 operatorId,\\n    uint256 newPeriod\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, true, false, [true, false]);\\n\\n    require(\\n      block.timestamp > DATASTORE.readUint(operatorId, rks.periodSwitch),\\n      \\\"SML:currently switching\\\"\\n    );\\n\\n    DATASTORE.writeUint(\\n      operatorId,\\n      rks.priorPeriod,\\n      DATASTORE.readUint(operatorId, rks.validatorPeriod)\\n    );\\n    DATASTORE.writeUint(operatorId, rks.periodSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\\n\\n    emit ValidatorPeriodSwitched(operatorId, newPeriod, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:section                           ** PRISON **\\n   *\\n   * @custom:visibility -> view-public\\n   * @dev check OEL._blameOperators for imprisonment details\\n   */\\n\\n  /**\\n   * @notice Checks if the given operator is Prisoned\\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function isPrisoned(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 operatorId\\n  ) public view returns (bool) {\\n    return (block.timestamp < DATASTORE.readUint(operatorId, rks.release));\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR DELEGATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice maximum number of remaining operator allowance that the given Operator is allowed to create for given Pool\\n   * @dev an operator can not create new validators if:\\n   * * 1. operator is a monopoly\\n   * * 2. allowance is filled\\n   * * * But if operator is set as a fallback, it can if set fallbackThreshold is reached on all allowances.\\n   * @dev If operator withdraws a validator, then able to create a new one.\\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\\n   */\\n  function operatorAllowance(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId\\n  ) public view returns (uint256 remValidators) {\\n    // monopoly check\\n    {\\n      // readUint for an array gives us length\\n      uint256 numOperatorValidators = DATASTORE.readUint(operatorId, rks.validators);\\n      uint256 monopoly_threshold = self.MONOPOLY_THRESHOLD;\\n      if (numOperatorValidators >= monopoly_threshold) {\\n        return 0;\\n      } else {\\n        remValidators = monopoly_threshold - numOperatorValidators;\\n      }\\n    }\\n\\n    // fallback check\\n    {\\n      if (operatorId == DATASTORE.readUint(poolId, rks.fallbackOperator)) {\\n        // readUint for an array gives us length\\n        uint256 numPoolValidators = DATASTORE.readUint(poolId, rks.validators);\\n        uint256 totalAllowance = DATASTORE.readUint(poolId, rks.totalAllowance);\\n\\n        if (\\n          totalAllowance == 0 ||\\n          (((numPoolValidators * PERCENTAGE_DENOMINATOR) / totalAllowance) >=\\n            DATASTORE.readUint(poolId, rks.fallbackThreshold))\\n        ) {\\n          return remValidators;\\n        }\\n      }\\n    }\\n\\n    // approval check\\n    {\\n      uint256 allowance = DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.allowance));\\n      uint256 pooledValidators = DATASTORE.readUint(\\n        poolId,\\n        DSML.getKey(operatorId, rks.proposedValidators)\\n      ) + DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.activeValidators));\\n      if (pooledValidators >= allowance) {\\n        return 0;\\n      } else {\\n        uint256 remAllowance = allowance - pooledValidators;\\n        if (remValidators > remAllowance) {\\n          remValidators = remAllowance;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool without a limit\\n   * * after pool reaches a given treshold as percentage.\\n   * * fallback operator and percentage can be set again at any given point in the future.\\n   * * cannot set an operator as a fallback operator while it is currently in prison.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorId Operator ID to allow create validators\\n   * @param fallbackThreshold the percentage (with PERCENTAGE_DENOMINATOR) that fallback operator\\n   * * is activated for given Pool. Should not be greater than 100.\\n   */\\n  function setFallbackOperator(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n\\n    if (operatorId == 0) {\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, 0);\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, 0);\\n      emit FallbackOperator(poolId, 0, 0);\\n    } else {\\n      require(\\n        DATASTORE.readUint(operatorId, rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:fallback not operator\\\"\\n      );\\n\\n      require(\\n        fallbackThreshold <= PERCENTAGE_DENOMINATOR,\\n        \\\"SML:threshold cannot be greater than 100\\\"\\n      );\\n\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, fallbackThreshold);\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, operatorId);\\n\\n      emit FallbackOperator(poolId, operatorId, fallbackThreshold);\\n    }\\n  }\\n\\n  /**\\n   * @notice To give allowence to node operator for a pool. It re-sets the allowance with the given value.\\n   * @dev The value that is returned is not the new allowance, but the old one since it is required\\n   * * at the point where it is being returned.\\n   * @return oldAllowance to be used later, nothing is done with it within this function.\\n   */\\n  function _approveOperator(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 allowance\\n  ) internal returns (uint256 oldAllowance) {\\n    bytes32 allowanceKey = DSML.getKey(operatorId, rks.allowance);\\n\\n    oldAllowance = DATASTORE.readUint(poolId, allowanceKey);\\n    DATASTORE.writeUint(poolId, allowanceKey, allowance);\\n\\n    emit Delegation(poolId, operatorId, allowance);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\\n   * * This number can be set again at any given point in the future.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorIds array of Operator IDs to allow them create validators\\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\\n   * @dev When decreased the approved validator count below current active+proposed validators,\\n   * operator can NOT create new validators.\\n   */\\n  function delegate(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n    require(operatorIds.length == allowances.length, \\\"SML:allowances should match\\\");\\n    for (uint256 i = 0; i < operatorIds.length; ) {\\n      require(\\n        DATASTORE.readUint(operatorIds[i], rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:id not operator\\\"\\n      );\\n      require(allowances[i] < MAX_ALLOWANCE, \\\"SML:> MAX_ALLOWANCE, set fallback\\\");\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    uint256 newCumulativeSubset;\\n    uint256 oldCumulativeSubset;\\n    for (uint256 i = 0; i < operatorIds.length; ) {\\n      newCumulativeSubset += allowances[i];\\n      oldCumulativeSubset += _approveOperator(DATASTORE, poolId, operatorIds[i], allowances[i]);\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    if (newCumulativeSubset > oldCumulativeSubset) {\\n      DATASTORE.addUint(poolId, rks.totalAllowance, newCumulativeSubset - oldCumulativeSubset);\\n    } else if (newCumulativeSubset < oldCumulativeSubset) {\\n      DATASTORE.subUint(poolId, rks.totalAllowance, oldCumulativeSubset - newCumulativeSubset);\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** POOLING  **\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT HELPERS **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function _isGeodePackageIsolated(address _packageAddress) internal view returns (bool) {\\n    return IGeodePackage(_packageAddress).isolationMode();\\n  }\\n\\n  /**\\n   * @notice returns wrapped bound liquidity pool. If deployed, if not in isolationMode.\\n   * @dev returns address(0) if no pool or it is under isolation\\n   */\\n  function _getLiquidityPool(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) internal view returns (ILiquidityPool) {\\n    address liqPool = DATASTORE.readAddress(_poolId, rks.liquidityPool);\\n    if (liqPool == address(0)) {\\n      return ILiquidityPool(address(0));\\n    } else if (_isGeodePackageIsolated(liqPool)) {\\n      return ILiquidityPool(address(0));\\n    } else {\\n      return ILiquidityPool(liqPool);\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the price is valid:\\n   * - last price syncinc happened less than 24h\\n   * - there has been no oracle reports since the last update\\n   *\\n   * @dev known bug / feature: if there have been no oracle updates,\\n   * * this function will return true.\\n   *\\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\\n   *    : false\\n   */\\n  function isPriceValid(\\n    PooledStaking storage self,\\n    uint256 poolId\\n  ) public view returns (bool isValid) {\\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\\n    unchecked {\\n      isValid =\\n        lastupdate + PRICE_EXPIRY >= block.timestamp ||\\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\\n    }\\n  }\\n\\n  /**\\n   * @notice checks if staking is allowed in given staking pool\\n   * @notice staking is not allowed if:\\n   * 1. Price is not valid\\n   * 2. WithdrawalContract is in Isolation Mode, can have many reasons\\n   */\\n  function isMintingAllowed(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return\\n      (isPriceValid(self, poolId)) &&\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract)));\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\\n   * @dev fails if minting is not allowed: invalid price, or isolationMode.\\n   */\\n  function _mintgETH(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _ethAmount\\n  ) internal returns (uint256 mintedgETH) {\\n    require(isMintingAllowed(self, DATASTORE, _poolId), \\\"SML:minting is not allowed\\\");\\n\\n    uint256 price = self.gETH.pricePerShare(_poolId);\\n    require(price > 0, \\\"SML:price is zero?\\\");\\n\\n    mintedgETH = (((_ethAmount * self.gETH.denominator()) / price));\\n    self.gETH.mint(address(this), _poolId, mintedgETH, \\\"\\\");\\n    DATASTORE.addUint(_poolId, rks.surplus, _ethAmount);\\n  }\\n\\n  /**\\n   * @notice conducts a buyback using the given liquidity pool\\n   * @param _poolId id of the gETH that will be bought\\n   * @param _maxEthToSell max ETH amount to sell in the liq pool\\n   * @param _deadline TX is expected to revert by Swap.sol if not meet\\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\\n   * as index 0 is ETH and index 1 is gETH!\\n   */\\n  function _buyback(\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _maxEthToSell,\\n    uint256 _deadline\\n  ) internal returns (uint256 remETH, uint256 boughtgETH) {\\n    ILiquidityPool LP = _getLiquidityPool(DATASTORE, _poolId);\\n    // skip if no liquidity pool is found\\n    if (address(LP) != address(0)) {\\n      uint256 debt = LP.getDebt();\\n      // skip if debt is too low\\n      if (debt > IGNORABLE_DEBT) {\\n        if (_maxEthToSell > debt) {\\n          // if debt is lower, then only sell debt\\n          remETH = _maxEthToSell - debt;\\n        } else {\\n          // if eth is lower, then sell all eth, remETH already 0\\n          debt = _maxEthToSell;\\n        }\\n        // SWAP in LP\\n        boughtgETH = LP.swap{value: debt}(0, 1, debt, 0, _deadline);\\n      } else {\\n        remETH = _maxEthToSell;\\n      }\\n    } else {\\n      remETH = _maxEthToSell;\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Allowing users to deposit into a staking pool.\\n   * @notice If a pool is not public, only the controller and if there is a whitelist contract, the whitelisted addresses can deposit.\\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\\n   * @param mingETH liquidity pool parameter\\n   * @param deadline liquidity pool parameter\\n   * @dev an example for minting + buybacks\\n   * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\\n   * * debt  msgValue\\n   * * 100   10  => buyback\\n   * * 100   100 => buyback\\n   * * 10    100 => buyback + mint\\n   * * 1     x   => mint\\n   * * 0.5   x   => mint\\n   * * 0     x   => mint\\n   */\\n  function deposit(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(deadline > block.timestamp, \\\"SML:deadline not met\\\");\\n    require(receiver != address(0), \\\"SML:receiver is zero address\\\");\\n\\n    if (isPrivatePool(DATASTORE, poolId)) {\\n      require(isWhitelisted(DATASTORE, poolId, msg.sender), \\\"SML:sender NOT whitelisted\\\");\\n    }\\n\\n    uint256 remEth = msg.value;\\n    (remEth, boughtgETH) = _buyback(DATASTORE, poolId, remEth, deadline);\\n\\n    if (remEth > 0) {\\n      mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\\n    }\\n\\n    require(boughtgETH + mintedgETH >= mingETH, \\\"SML:less than minimum\\\");\\n\\n    // send back to user\\n    self.gETH.safeTransferFrom(address(this), receiver, poolId, boughtgETH + mintedgETH, \\\"\\\");\\n\\n    emit Deposit(poolId, boughtgETH, mintedgETH);\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR CREATION **\\n   *\\n   * @dev Creation of a Validator takes 2 steps: propose and beacon stake.\\n   * Before entering stake() function, _canStake verifies the eligibility of\\n   * given pubKey that is proposed by an operator with proposeStake function.\\n   * Eligibility is defined by an optimistic alienation, check OracleUtils._alienateValidator() for info.\\n   */\\n\\n  /**\\n   * @custom:visibility -> view\\n   */\\n\\n  /**\\n   * @notice internal function to check if a validator can use the pool funds\\n   *\\n   *  @param _pubkey BLS12-381 public key of the validator\\n   *  @return true if:\\n   *   - pubkey should be proposed\\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\\n   *   - the validator's index is already covered by VERIFICATION_INDEX. Updated by Telescope.\\n   */\\n  function _canStake(\\n    PooledStaking storage self,\\n    bytes calldata _pubkey,\\n    uint256 _verificationIndex\\n  ) internal view returns (bool) {\\n    return\\n      (self.validators[_pubkey].state == VALIDATOR_STATE.PROPOSED) &&\\n      (self.validators[_pubkey].index <= _verificationIndex);\\n  }\\n\\n  /**\\n   * @notice external function to check if a validator can use the pool funds\\n   */\\n  function canStake(\\n    PooledStaking storage self,\\n    bytes calldata pubkey\\n  ) external view returns (bool) {\\n    return _canStake(self, pubkey, self.VERIFICATION_INDEX);\\n  }\\n\\n  /**\\n   * @dev -> external\\n   */\\n\\n  /**\\n   * @notice Validator Credentials Proposal function, first step of crating validators.\\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\\n   * * it is optimistically allowed to take funds from staking pools.\\n   *\\n   * @param poolId the id of the staking pool\\n   * @param operatorId the id of the Operator whose maintainer calling this function\\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\\n   * maintainer balance\\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on stake() function call\\n   *\\n   * @dev DCL.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCL.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\\n   * 31 Ether will be staked after verification of oracles. 32 in total.\\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\\n   * @dev ProposeStake requires enough funds within Wallet.\\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 50)\\n   */\\n  function proposeStake(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external {\\n    // checks\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract))),\\n      \\\"SML:withdrawalContract is isolated\\\"\\n    );\\n\\n    uint256 pkLen = pubkeys.length;\\n\\n    require((pkLen > 0) && (pkLen <= DCL.MAX_DEPOSITS_PER_CALL), \\\"SML:1 - 50 validators\\\");\\n\\n    require(\\n      pkLen == signatures1.length && pkLen == signatures31.length,\\n      \\\"SML:invalid input length\\\"\\n    );\\n\\n    require(\\n      operatorAllowance(self, DATASTORE, poolId, operatorId) >= pkLen,\\n      \\\"SML:insufficient allowance\\\"\\n    );\\n\\n    require(\\n      DATASTORE.readUint(poolId, rks.surplus) >= DCL.DEPOSIT_AMOUNT * pkLen,\\n      \\\"SML:NOT enough surplus\\\"\\n    );\\n\\n    _decreaseWalletBalance(DATASTORE, operatorId, (pkLen * DCL.DEPOSIT_AMOUNT_PRESTAKE));\\n\\n    for (uint256 i = 0; i < pkLen; ) {\\n      require(pubkeys[i].length == DCL.PUBKEY_LENGTH, \\\"SML:PUBKEY_LENGTH ERROR\\\");\\n      require(signatures1[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n      require(signatures31[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    ConstantValidatorData memory valData = ConstantValidatorData({\\n      index: uint64(self.VALIDATORS_INDEX + 1),\\n      period: uint64(getValidatorPeriod(DATASTORE, operatorId)),\\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\\n      governanceFee: self.GOVERNANCE_FEE,\\n      withdrawalCredential: DATASTORE.readBytes(poolId, rks.withdrawalCredential)\\n    });\\n\\n    for (uint256 i = 0; i < pkLen; ) {\\n      require(\\n        self.validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\\n        \\\"SML: used or alienated pk\\\"\\n      );\\n\\n      self.validators[pubkeys[i]] = Validator(\\n        VALIDATOR_STATE.PROPOSED,\\n        valData.index + uint64(i),\\n        uint64(block.timestamp),\\n        valData.period,\\n        poolId,\\n        operatorId,\\n        valData.poolFee,\\n        valData.operatorFee,\\n        valData.governanceFee,\\n        signatures31[i]\\n      );\\n\\n      DCL.depositValidator(\\n        pubkeys[i],\\n        valData.withdrawalCredential,\\n        signatures1[i],\\n        DCL.DEPOSIT_AMOUNT_PRESTAKE\\n      );\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    DATASTORE.subUint(poolId, rks.surplus, (pkLen * DCL.DEPOSIT_AMOUNT));\\n    DATASTORE.addUint(poolId, rks.secured, (pkLen * DCL.DEPOSIT_AMOUNT));\\n\\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), pkLen);\\n    DATASTORE.appendBytesArrayBatch(poolId, rks.validators, pubkeys);\\n    DATASTORE.appendBytesArrayBatch(operatorId, rks.validators, pubkeys);\\n\\n    self.VALIDATORS_INDEX += pkLen;\\n\\n    emit StakeProposal(poolId, operatorId, pubkeys);\\n  }\\n\\n  /**\\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\\n   *\\n   *  @param operatorId the id of the Operator whose maintainer calling this function\\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\\n   *\\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\\n   *  pk1, pk2, pk3 from pool1\\n   *  pk4, pk5 from pool2\\n   *  pk6 from pool3\\n   *  seperate them in similar groups as much as possible.\\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 50)\\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\\n   */\\n  function stake(\\n    PooledStaking storage self,\\n    DSML.IsolatedStorage storage DATASTORE,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n\\n    require(\\n      (pubkeys.length > 0) && (pubkeys.length <= DCL.MAX_DEPOSITS_PER_CALL),\\n      \\\"SML:1 - 50 validators\\\"\\n    );\\n\\n    {\\n      uint256 _verificationIndex = self.VERIFICATION_INDEX;\\n      for (uint256 j = 0; j < pubkeys.length; ) {\\n        require(\\n          _canStake(self, pubkeys[j], _verificationIndex),\\n          \\\"SML:NOT all pubkeys are stakeable\\\"\\n        );\\n\\n        require(\\n          self.validators[pubkeys[j]].operatorId == operatorId,\\n          \\\"SML:NOT all pubkeys belong to operator\\\"\\n        );\\n\\n        unchecked {\\n          j += 1;\\n        }\\n      }\\n    }\\n\\n    {\\n      bytes32 activeValKey = DSML.getKey(operatorId, rks.activeValidators);\\n      bytes32 proposedValKey = DSML.getKey(operatorId, rks.proposedValidators);\\n      uint256 poolId = self.validators[pubkeys[0]].poolId;\\n      bytes memory withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n\\n      uint256 lastIdChange = 0;\\n      for (uint256 i = 0; i < pubkeys.length; ) {\\n        uint256 newPoolId = self.validators[pubkeys[i]].poolId;\\n        if (poolId != newPoolId) {\\n          uint256 sinceLastIdChange;\\n\\n          unchecked {\\n            sinceLastIdChange = i - lastIdChange;\\n          }\\n\\n          DATASTORE.subUint(poolId, rks.secured, (DCL.DEPOSIT_AMOUNT * (sinceLastIdChange)));\\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n\\n          lastIdChange = i;\\n          poolId = newPoolId;\\n          withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n        }\\n\\n        DCL.depositValidator(\\n          pubkeys[i],\\n          withdrawalCredential,\\n          self.validators[pubkeys[i]].signature31,\\n          (DCL.DEPOSIT_AMOUNT - DCL.DEPOSIT_AMOUNT_PRESTAKE)\\n        );\\n\\n        self.validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\\n\\n        unchecked {\\n          i += 1;\\n        }\\n      }\\n      {\\n        uint256 sinceLastIdChange;\\n        unchecked {\\n          sinceLastIdChange = pubkeys.length - lastIdChange;\\n        }\\n\\n        DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT * (sinceLastIdChange));\\n        DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n        DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n      }\\n\\n      _increaseWalletBalance(DATASTORE, operatorId, DCL.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length);\\n\\n      emit Stake(pubkeys);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xd7e6a969dd06a447611d529ed7535047262fa7fc9ff1dad6630c5dac621aa064\",\"license\":\"MIT\"},\"contracts/Portal/modules/WithdrawalModule/WithdrawalModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// libraries\\nimport {WithdrawalModuleLib as WML} from \\\"./libs/WithdrawalModuleLib.sol\\\";\\n// contracts\\nimport {DataStoreModule} from \\\"../DataStoreModule/DataStoreModule.sol\\\";\\n// external\\nimport {ERC1155HolderUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nabstract contract WithdrawalModule is\\n  DataStoreModule,\\n  ERC1155HolderUpgradeable,\\n  PausableUpgradeable,\\n  ReentrancyGuardUpgradeable\\n{\\n  using WML for WML.PooledWithdrawal;\\n  /**\\n   * @custom:section                           ** VARIABLES **\\n   *\\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\\n   */\\n  WML.PooledWithdrawal internal WITHDRAWAL;\\n\\n  function __WithdrawalModule_init(uint256 _pooledTokenId) internal onlyInitializing {\\n    __WithdrawalModule_init_unchained(_pooledTokenId);\\n  }\\n\\n  function __WithdrawalModule_init_unchained(uint256 _pooledTokenId) internal onlyInitializing {\\n    WITHDRAWAL.pooledTokenId = _pooledTokenId;\\n  }\\n}\\n\",\"keccak256\":\"0x169470b8f69eacf5a684ccb4ee6d87620893134fe71fb2f3c6f089c1aac23c5d\",\"license\":\"MIT\"},\"contracts/Portal/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\n\\nlibrary WithdrawalModuleLib {\\n  using DSML for DSML.IsolatedStorage;\\n\\n  struct PooledWithdrawal {\\n    uint256 pooledTokenId;\\n    uint256[15] __gap;\\n  }\\n}\\n\",\"keccak256\":\"0x9b797bcd4f179df6886a128cea28bea4e565cf8dac5d942730a030d5eb567d4e\",\"license\":\"MIT\"},\"contracts/Portal/packages/WithdrawalContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// globals\\nimport {ID_TYPE} from \\\"../globals/id_type.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../globals/reserved_key_space.sol\\\";\\n// interfaces\\nimport {IWithdrawalContract} from \\\"../interfaces/packages/IWithdrawalContract.sol\\\";\\nimport {IPortal} from \\\"../interfaces/IPortal.sol\\\";\\nimport {IGeodeModule} from \\\"../interfaces/modules/IGeodeModule.sol\\\";\\n// libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../modules/DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {GeodeModuleLib as GML} from \\\"../modules/GeodeModule/libs/GeodeModuleLib.sol\\\";\\nimport {WithdrawalModuleLib as WML} from \\\"../modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\\\";\\n// contracts\\nimport {GeodeModule} from \\\"../modules/GeodeModule/GeodeModule.sol\\\";\\nimport {WithdrawalModule} from \\\"../modules/WithdrawalModule/WithdrawalModule.sol\\\";\\n\\ncontract WithdrawalContract is IWithdrawalContract, WithdrawalModule, GeodeModule {\\n  /**\\n   * @custom:section                           ** VARIABLES **\\n   * Following immutable parameters are set when the referance library implementation is deployed.\\n   * Making necessary data for initialization reachable for all instances of LP package.\\n   */\\n  /// @notice gETH position\\n  address internal immutable gETHPos;\\n  /// @notice Portal position\\n  address internal immutable portalPos;\\n  // uint internal POOL_ID; // delete this, just a placeholder for now.\\n  /**\\n   * @custom:section                           ** MODIFIERS **\\n   */\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == GEODE.SENATE, \\\"LPP:sender NOT owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @custom:section                           ** INITIALIZING **\\n   */\\n  /**\\n   * @custom:oz-upgrades-unsafe-allow constructor\\n   *\\n   * @dev we don't want to provide these package-specific not-changing parameters\\n   * accross all instances of the packages.\\n   * So we will store them in the ref implementation contract of the package,\\n   * and fetch when needed on initialization.\\n   */\\n  constructor(address _gETHPos, address _portalPos) {\\n    require(_gETHPos != address(0), \\\"LPP:_gETHPos can not be zero\\\");\\n    require(_portalPos != address(0), \\\"LPP:_portalPos can not be zero\\\");\\n\\n    gETHPos = _gETHPos;\\n    portalPos = _portalPos;\\n\\n    _disableInitializers();\\n  }\\n\\n  function initialize(\\n    uint256 pooledTokenId,\\n    address poolOwner,\\n    bytes calldata versionName,\\n    bytes calldata data\\n  ) public virtual override initializer {\\n    __WithdrawalContract_init(pooledTokenId, poolOwner, versionName);\\n  }\\n\\n  function __WithdrawalContract_init(\\n    uint256 pooledTokenId,\\n    address poolOwner,\\n    bytes calldata versionName\\n  ) internal onlyInitializing {\\n    __GeodeModule_init(\\n      portalPos,\\n      poolOwner,\\n      type(uint256).max,\\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\\n      versionName\\n    );\\n\\n    __WithdrawalContract_init_unchained(pooledTokenId);\\n  }\\n\\n  function __WithdrawalContract_init_unchained(uint256 pooledTokenId) internal onlyInitializing {\\n    __WithdrawalModule_init(pooledTokenId);\\n  }\\n\\n  function getPoolId() public view override returns (uint256) {\\n    return WITHDRAWAL.pooledTokenId;\\n  }\\n\\n  /**\\n   * @notice get Portal as a contract\\n   */\\n  function getPortal() public view override returns (IPortal) {\\n    return IPortal(GEODE.GOVERNANCE);\\n  }\\n\\n  /**\\n   * @dev GeodeModule override\\n   */\\n  function getProposedVersion() public view virtual override returns (uint256) {\\n    return getPortal().getPackageVersion(GEODE.PACKAGE_TYPE);\\n  }\\n\\n  function pullUpgrade() external virtual override onlyOwner {\\n    require(!(getPortal().isolationMode()), \\\"LPP:Portal is isolated\\\");\\n    require(getProposedVersion() != getContractVersion(), \\\"LPP:no upgrades\\\");\\n\\n    uint256 id = getPortal().pushUpgrade(GEODE.PACKAGE_TYPE);\\n    approveProposal(id);\\n  }\\n\\n  /**\\n   * @dev GeodeModule override\\n   */\\n  function isolationMode()\\n    external\\n    view\\n    virtual\\n    override(GeodeModule, IGeodeModule)\\n    returns (bool)\\n  {\\n    if (getContractVersion() != getProposedVersion()) {\\n      return true;\\n    }\\n\\n    if (GEODE.APPROVED_UPGRADE != _getImplementation()) {\\n      return true;\\n    }\\n\\n    if (getPortal().readAddress(getPoolId(), rks.CONTROLLER) != GEODE.SENATE) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * @notice keep the total number of variables at 50\\n   */\\n  uint256[48] private __gap;\\n}\\n\",\"keccak256\":\"0x1a0373107d19abd5fcee497b6f90556b5c51fe12f8a10874e1e1ccb8be47a7a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e06040523060601b6080523480156200001857600080fd5b5060405162002b5538038062002b558339810160408190526200003b91620001f7565b6001600160a01b038216620000975760405162461bcd60e51b815260206004820152601c60248201527f4c50503a5f67455448506f732063616e206e6f74206265207a65726f0000000060448201526064015b60405180910390fd5b6001600160a01b038116620000ef5760405162461bcd60e51b815260206004820152601e60248201527f4c50503a5f706f7274616c506f732063616e206e6f74206265207a65726f000060448201526064016200008e565b6001600160601b0319606083811b821660a05282901b1660c052620001136200011b565b50506200022f565b600054610100900460ff1615620001855760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b60648201526084016200008e565b60005460ff9081161015620001d8576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b80516001600160a01b0381168114620001f257600080fd5b919050565b600080604083850312156200020b57600080fd5b6200021683620001da565b91506200022660208401620001da565b90509250929050565b60805160601c60a05160601c60c05160601c6128d46200028160003960006116130152600050506000818161069d015281816106e60152818161082f0152818161086f01526108eb01526128d46000f3fe6080604052600436106101d85760003560e01c80637d65a7ab11610102578063aec9886311610095578063e02a520811610064578063e02a5208146105bc578063e72b1d6d146105dc578063e768887e146105fc578063f23a6e611461061c57600080fd5b8063aec9886314610515578063bc197c811461052a578063c7f758a81461056f578063dab840c71461059c57600080fd5b80639934b281116100d15780639934b2811461045857806399ac48ba14610478578063ad4ac4c414610498578063ad8655cb146104f557600080fd5b80637d65a7ab146103df5780638650c072146103fe5780638aa104351461041357806398951b561461042957600080fd5b80635329512b1161017a5780635d9e085d116101495780635d9e085d146103505780636d07e4041461037d578063722679541461039d578063745653de146103ca57600080fd5b80635329512b146102c057806356a72dbf146102f85780635a34bb15146103185780635c975abb1461033857600080fd5b806338fff2d0116101b657806338fff2d0146102625780633b8ba862146102785780634f1ef2861461029857806352d1902d146102ab57600080fd5b806301ffc9a7146101dd5780631da71591146102125780633659cfe614610240575b600080fd5b3480156101e957600080fd5b506101fd6101f83660046122b8565b610648565b60405190151581526020015b60405180910390f35b34801561021e57600080fd5b5061023261022d3660046124b0565b61067f565b604051908152602001610209565b34801561024c57600080fd5b5061026061025b36600461201e565b610692565b005b34801561026e57600080fd5b5061013d54610232565b34801561028457600080fd5b506102326102933660046121bf565b610781565b6102606102a636600461216f565b610824565b3480156102b757600080fd5b506102326108de565b3480156102cc57600080fd5b506102e06102db3660046124d2565b610991565b6040516001600160a01b039091168152602001610209565b34801561030457600080fd5b506102326103133660046124b0565b6109a8565b34801561032457600080fd5b506102326103333660046122e2565b6109b6565b34801561034457600080fd5b5060d95460ff166101fd565b34801561035c57600080fd5b5061023261036b3660046123db565b60009081526001602052604090205490565b34801561038957600080fd5b506102606103983660046123f4565b6109ed565b3480156103a957600080fd5b506103bd6103b83660046124b0565b610a6a565b60405161020991906125ca565b3480156103d657600080fd5b50610232610a78565b3480156103eb57600080fd5b506101b1546001600160a01b03166102e0565b34801561040a57600080fd5b506101fd610b16565b34801561041f57600080fd5b506101b654610232565b34801561043557600080fd5b506104496104443660046123db565b610c27565b604051610209939291906125a3565b34801561046457600080fd5b50610260610473366004612424565b610ce9565b34801561048457600080fd5b506102e06104933660046124b0565b610e04565b3480156104a457600080fd5b506101b1546101b2546101b3546101b4546101b554604080516001600160a01b039687168152948616602086015294909216938301939093526060820192909252608081019190915260a001610209565b34801561050157600080fd5b5061026061051036600461201e565b610e12565b34801561052157600080fd5b50610260610e89565b34801561053657600080fd5b50610556610545366004612058565b63bc197c8160e01b95945050505050565b6040516001600160e01b03199091168152602001610209565b34801561057b57600080fd5b5061058f61058a3660046123db565b611096565b6040516102099190612708565b3480156105a857600080fd5b506102606105b736600461201e565b611159565b3480156105c857600080fd5b506102326105d73660046124b0565b6111a1565b3480156105e857600080fd5b506102326105f73660046124d2565b6111d4565b34801561060857600080fd5b506103bd6106173660046124d2565b6111e3565b34801561062857600080fd5b50610556610637366004612106565b63f23a6e6160e01b95945050505050565b60006001600160e01b03198216630271189760e51b148061067957506301ffc9a760e01b6001600160e01b03198316145b92915050565b600061068b83836111f2565b9392505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614156106e45760405162461bcd60e51b81526004016106db906125dd565b60405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661071661121e565b6001600160a01b03161461073c5760405162461bcd60e51b81526004016106db90612629565b6107458161123a565b61077e8160005b6040519080825280601f01601f191660200182016040528015610776576020820181803683370190505b506000611331565b50565b6040516334c4fde360e11b8152600090733506980d4d72f056d12216cA7c853000f19e638290636989fbc6906107ca906101b1906001908b908b908b908b908b906004016126c0565b60206040518083038186803b1580156107e257600080fd5b505af41580156107f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081a919061229f565b9695505050505050565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141561086d5760405162461bcd60e51b81526004016106db906125dd565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661089f61121e565b6001600160a01b0316146108c55760405162461bcd60e51b81526004016106db90612629565b6108ce8261123a565b6108da82826001611331565b5050565b6000306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461097e5760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c000000000000000060648201526084016106db565b5060008051602061285883398151915290565b60006109a060018585856114b0565b949350505050565b600061068b600184846114ee565b60008383836040516020016109cd93929190612591565b60408051601f198184030181529190528051602090910120949350505050565b6040516304ac4a9160e11b815260016004820152602481018390526001600160a01b0382166044820152733506980d4d72f056d12216cA7c853000f19e63829063095895229060640160006040518083038186803b158015610a4e57600080fd5b505af4158015610a62573d6000803e3d6000fd5b505050505050565b606061068b60018484611518565b6000610a8d6101b1546001600160a01b031690565b6101b554604051630eca989d60e11b81526001600160a01b039290921691631d95313a91610ac19160040190815260200190565b60206040518083038186803b158015610ad957600080fd5b505afa158015610aed573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b11919061229f565b905090565b6000610b20610a78565b6101b65414610b2f5750600190565b610b3761121e565b6101b3546001600160a01b03908116911614610b535750600190565b6101b2546001600160a01b0316610b736101b1546001600160a01b031690565b6001600160a01b03166399ac48ba610b8b61013d5490565b6040516001600160e01b031960e084901b16815260048101919091526921a7a72a2927a62622a960b11b602482015260440160206040518083038186803b158015610bd557600080fd5b505afa158015610be9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0d919061203b565b6001600160a01b031614610c215750600190565b50600090565b604051639c04df5b60e01b81526101b1600482015260016024820152604481018290526000908190606090733506980d4d72f056d12216cA7c853000f19e638290639c04df5b9060640160006040518083038186803b158015610c8957600080fd5b505af4158015610c9d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610cc59190810190612223565b6101b5549295509093509150821415610ce257610ce283856115ca565b9193909250565b600054610100900460ff1615808015610d095750600054600160ff909116105b80610d235750303b158015610d23575060005460ff166001145b610d865760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016106db565b6000805460ff191660011790558015610da9576000805461ff0019166101001790555b610db5878787876115e7565b8015610dfb576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050565b600061068b60018484611649565b60405163e51d9aa360e01b81526101b160048201526001600160a01b0382166024820152733506980d4d72f056d12216cA7c853000f19e63829063e51d9aa3906044015b60006040518083038186803b158015610e6e57600080fd5b505af4158015610e82573d6000803e3d6000fd5b5050505050565b6101b2546001600160a01b03163314610edb5760405162461bcd60e51b81526020600482015260146024820152732628281d39b2b73232b9102727aa1037bbb732b960611b60448201526064016106db565b6101b1546001600160a01b03166001600160a01b0316638650c0726040518163ffffffff1660e01b815260040160206040518083038186803b158015610f2057600080fd5b505afa158015610f34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f58919061227d565b15610f9e5760405162461bcd60e51b81526020600482015260166024820152751314140e941bdc9d185b081a5cc81a5cdbdb185d195960521b60448201526064016106db565b6101b654610faa610a78565b1415610fea5760405162461bcd60e51b815260206004820152600f60248201526e4c50503a6e6f20757067726164657360881b60448201526064016106db565b6000610fff6101b1546001600160a01b031690565b6101b55460405163e3099e0960e01b81526001600160a01b03929092169163e3099e09916110339160040190815260200190565b602060405180830381600087803b15801561104d57600080fd5b505af1158015611061573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611085919061229f565b905061109081610c27565b50505050565b6110ca604051806080016040528060006001600160a01b031681526020016000815260200160608152602001600081525090565b60405163929fbdfb60e01b81526101b1600482015260248101839052733506980d4d72f056d12216cA7c853000f19e63829063929fbdfb9060440160006040518083038186803b15801561111d57600080fd5b505af4158015611131573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610679919081019061232e565b604051630bde2bc360e01b81526101b160048201526001600160a01b0382166024820152733506980d4d72f056d12216cA7c853000f19e638290630bde2bc390604401610e56565b60008281526001602052604081208054839081106111c1576111c1612816565b9060005260206000200154905092915050565b60006109a0600185858561167d565b60606109a060018585856116ac565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080516020612858833981519152546001600160a01b031690565b733506980d4d72f056d12216cA7c853000f19e6382633f98381a6101b18361126061121e565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b03918216602484015216604482015260640160206040518083038186803b1580156112ad57600080fd5b505af41580156112c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112e5919061227d565b61077e5760405162461bcd60e51b815260206004820152601960248201527f474d3a6e6f7420616c6c6f77656420746f20757067726164650000000000000060448201526064016106db565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156113695761136483611763565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156113a257600080fd5b505afa9250505080156113d2575060408051601f3d908101601f191682019092526113cf9181019061229f565b60015b6114355760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b60648201526084016106db565b60008051602061285883398151915281146114a45760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b60648201526084016106db565b506113648383836117ff565b60008460030160006114cb846114c688886111f2565b6111f2565b81526020810191909152604001600020546001600160a01b031695945050505050565b600083600101600061150085856111f2565b81526020019081526020016000205490509392505050565b606083600201600061152a85856111f2565b81526020019081526020016000208054611543906127db565b80601f016020809104026020016040519081016040528092919081815260200182805461156f906127db565b80156115bc5780601f10611591576101008083540402835291602001916115bc565b820191906000526020600020905b81548152906001019060200180831161159f57829003601f168201915b505050505090509392505050565b6115d38261123a565b6115de82600061074c565b6108da81611824565b600054610100900460ff1661160e5760405162461bcd60e51b81526004016106db90612675565b6116407f00000000000000000000000000000000000000000000000000000000000000008460001961271b8686611860565b611090846118a5565b600083600301600061165b85856111f2565b81526020810191909152604001600020546001600160a01b0316949350505050565b6000846001016000611693846114c688886111f2565b8152602001908152602001600020549050949350505050565b60608460020160006116c2846114c688886111f2565b815260200190815260200160002080546116db906127db565b80601f0160208091040260200160405190810160405280929190818152602001828054611707906127db565b80156117545780601f1061172957610100808354040283529160200191611754565b820191906000526020600020905b81548152906001019060200180831161173757829003601f168201915b50505050509050949350505050565b6001600160a01b0381163b6117d05760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016106db565b60008051602061285883398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b611808836118d5565b6000825111806118155750805b15611364576110908383611915565b6101b68190556040518181527ffddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb9060200160405180910390a150565b600054610100900460ff166118875760405162461bcd60e51b81526004016106db90612675565b61188f611a09565b611897611a09565b610a62868686868686611a32565b600054610100900460ff166118cc5760405162461bcd60e51b81526004016106db90612675565b61077e81611de0565b6118de81611763565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b61197d5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016106db565b600080846001600160a01b0316846040516119989190612553565b600060405180830381855af49150503d80600081146119d3576040519150601f19603f3d011682016040523d82523d6000602084013e6119d8565b606091505b5091509150611a00828260405180606001604052806027815260200161287860279139611e10565b95945050505050565b600054610100900460ff16611a305760405162461bcd60e51b81526004016106db90612675565b565b600054610100900460ff16611a595760405162461bcd60e51b81526004016106db90612675565b6001600160a01b038616611aaf5760405162461bcd60e51b815260206004820152601d60248201527f474d3a676f7665726e616e63652063616e206e6f74206265207a65726f00000060448201526064016106db565b6001600160a01b038516611b055760405162461bcd60e51b815260206004820152601960248201527f474d3a73656e6174652063616e206e6f74206265207a65726f0000000000000060448201526064016106db565b428411611b4a5760405162461bcd60e51b8152602060048201526013602482015272474d3a6c6f772073656e61746545787069727960681b60448201526064016106db565b82611b975760405162461bcd60e51b815260206004820152601e60248201527f474d3a7061636b616765547970652063616e206e6f74206265207a65726f000060448201526064016106db565b80611bf05760405162461bcd60e51b815260206004820152602360248201527f474d3a696e697456657273696f6e4e616d652063616e206e6f7420626520656d60448201526270747960e81b60648201526084016106db565b6101b18054336001600160a01b0319918216811783556101b280549092161790556101b48590556101b5849055600090733506980d4d72f056d12216cA7c853000f19e638290636989fbc6906001611c4661121e565b888888620151806040518863ffffffff1660e01b8152600401611c6f97969594939291906126c0565b60206040518083038186803b158015611c8757600080fd5b505af4158015611c9b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cbf919061229f565b604051639c04df5b60e01b81526101b160048201526001602482015260448101829052909150733506980d4d72f056d12216cA7c853000f19e638290639c04df5b9060640160006040518083038186803b158015611d1c57600080fd5b505af4158015611d30573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d589190810190612223565b505050611da7611da284848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506101b5549150611e299050565b611824565b50506101b180546001600160a01b039687166001600160a01b0319918216179091556101b2805495909616941693909317909355505050565b600054610100900460ff16611e075760405162461bcd60e51b81526004016106db90612675565b61077e81611e5d565b60608315611e1f57508161068b565b61068b8383611e8a565b60008282604051602001611e3e92919061256f565b60408051601f1981840301815291905280516020909101209392505050565b600054610100900460ff16611e845760405162461bcd60e51b81526004016106db90612675565b61013d55565b815115611e9a5781518083602001fd5b8060405162461bcd60e51b81526004016106db91906125ca565b600082601f830112611ec557600080fd5b8135602067ffffffffffffffff821115611ee157611ee161282c565b8160051b611ef0828201612756565b838152828101908684018388018501891015611f0b57600080fd5b600093505b85841015611f2e578035835260019390930192918401918401611f10565b50979650505050505050565b60008083601f840112611f4c57600080fd5b50813567ffffffffffffffff811115611f6457600080fd5b602083019150836020828501011115611f7c57600080fd5b9250929050565b600082601f830112611f9457600080fd5b8135611fa7611fa282612787565b612756565b818152846020838601011115611fbc57600080fd5b816020850160208301376000918101602001919091529392505050565b600082601f830112611fea57600080fd5b8151611ff8611fa282612787565b81815284602083860101111561200d57600080fd5b6109a08260208301602087016127af565b60006020828403121561203057600080fd5b813561068b81612842565b60006020828403121561204d57600080fd5b815161068b81612842565b600080600080600060a0868803121561207057600080fd5b853561207b81612842565b9450602086013561208b81612842565b9350604086013567ffffffffffffffff808211156120a857600080fd5b6120b489838a01611eb4565b945060608801359150808211156120ca57600080fd5b6120d689838a01611eb4565b935060808801359150808211156120ec57600080fd5b506120f988828901611f83565b9150509295509295909350565b600080600080600060a0868803121561211e57600080fd5b853561212981612842565b9450602086013561213981612842565b93506040860135925060608601359150608086013567ffffffffffffffff81111561216357600080fd5b6120f988828901611f83565b6000806040838503121561218257600080fd5b823561218d81612842565b9150602083013567ffffffffffffffff8111156121a957600080fd5b6121b585828601611f83565b9150509250929050565b6000806000806000608086880312156121d757600080fd5b85356121e281612842565b945060208601359350604086013567ffffffffffffffff81111561220557600080fd5b61221188828901611f3a565b96999598509660600135949350505050565b60008060006060848603121561223857600080fd5b835161224381612842565b60208501516040860151919450925067ffffffffffffffff81111561226757600080fd5b61227386828701611fd9565b9150509250925092565b60006020828403121561228f57600080fd5b8151801515811461068b57600080fd5b6000602082840312156122b157600080fd5b5051919050565b6000602082840312156122ca57600080fd5b81356001600160e01b03198116811461068b57600080fd5b6000806000604084860312156122f757600080fd5b833567ffffffffffffffff81111561230e57600080fd5b61231a86828701611f3a565b909790965060209590950135949350505050565b60006020828403121561234057600080fd5b815167ffffffffffffffff8082111561235857600080fd5b908301906080828603121561236c57600080fd5b6040516080810181811083821117156123875761238761282c565b604052825161239581612842565b8152602083810151908201526040830151828111156123b357600080fd5b6123bf87828601611fd9565b6040830152506060830151606082015280935050505092915050565b6000602082840312156123ed57600080fd5b5035919050565b6000806040838503121561240757600080fd5b82359150602083013561241981612842565b809150509250929050565b6000806000806000806080878903121561243d57600080fd5b86359550602087013561244f81612842565b9450604087013567ffffffffffffffff8082111561246c57600080fd5b6124788a838b01611f3a565b9096509450606089013591508082111561249157600080fd5b5061249e89828a01611f3a565b979a9699509497509295939492505050565b600080604083850312156124c357600080fd5b50508035926020909101359150565b6000806000606084860312156124e757600080fd5b505081359360208301359350604090920135919050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000815180845261253f8160208601602086016127af565b601f01601f19169290920160200192915050565b600082516125658184602087016127af565b9190910192915050565b600083516125818184602088016127af565b9190910191825250602001919050565b82848237909101908152602001919050565b60018060a01b0384168152826020820152606060408201526000611a006060830184612527565b60208152600061068b6020830184612527565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b87815286602082015260018060a01b038616604082015284606082015260c0608082015260006126f460c0830185876124fe565b90508260a083015298975050505050505050565b6020815260018060a01b03825116602082015260208201516040820152600060408301516080606084015261274060a0840182612527565b9050606084015160808401528091505092915050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561277f5761277f61282c565b604052919050565b600067ffffffffffffffff8211156127a1576127a161282c565b50601f01601f191660200190565b60005b838110156127ca5781810151838201526020016127b2565b838111156110905750506000910152565b600181811c908216806127ef57607f821691505b6020821081141561281057634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461077e57600080fdfe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220eeabfdf1e20d2c552a886d10a5bf60a42dfa0537f6c2a087b85ece6324ad9d9664736f6c63430008070033",
  "deployedBytecode": "0x6080604052600436106101d85760003560e01c80637d65a7ab11610102578063aec9886311610095578063e02a520811610064578063e02a5208146105bc578063e72b1d6d146105dc578063e768887e146105fc578063f23a6e611461061c57600080fd5b8063aec9886314610515578063bc197c811461052a578063c7f758a81461056f578063dab840c71461059c57600080fd5b80639934b281116100d15780639934b2811461045857806399ac48ba14610478578063ad4ac4c414610498578063ad8655cb146104f557600080fd5b80637d65a7ab146103df5780638650c072146103fe5780638aa104351461041357806398951b561461042957600080fd5b80635329512b1161017a5780635d9e085d116101495780635d9e085d146103505780636d07e4041461037d578063722679541461039d578063745653de146103ca57600080fd5b80635329512b146102c057806356a72dbf146102f85780635a34bb15146103185780635c975abb1461033857600080fd5b806338fff2d0116101b657806338fff2d0146102625780633b8ba862146102785780634f1ef2861461029857806352d1902d146102ab57600080fd5b806301ffc9a7146101dd5780631da71591146102125780633659cfe614610240575b600080fd5b3480156101e957600080fd5b506101fd6101f83660046122b8565b610648565b60405190151581526020015b60405180910390f35b34801561021e57600080fd5b5061023261022d3660046124b0565b61067f565b604051908152602001610209565b34801561024c57600080fd5b5061026061025b36600461201e565b610692565b005b34801561026e57600080fd5b5061013d54610232565b34801561028457600080fd5b506102326102933660046121bf565b610781565b6102606102a636600461216f565b610824565b3480156102b757600080fd5b506102326108de565b3480156102cc57600080fd5b506102e06102db3660046124d2565b610991565b6040516001600160a01b039091168152602001610209565b34801561030457600080fd5b506102326103133660046124b0565b6109a8565b34801561032457600080fd5b506102326103333660046122e2565b6109b6565b34801561034457600080fd5b5060d95460ff166101fd565b34801561035c57600080fd5b5061023261036b3660046123db565b60009081526001602052604090205490565b34801561038957600080fd5b506102606103983660046123f4565b6109ed565b3480156103a957600080fd5b506103bd6103b83660046124b0565b610a6a565b60405161020991906125ca565b3480156103d657600080fd5b50610232610a78565b3480156103eb57600080fd5b506101b1546001600160a01b03166102e0565b34801561040a57600080fd5b506101fd610b16565b34801561041f57600080fd5b506101b654610232565b34801561043557600080fd5b506104496104443660046123db565b610c27565b604051610209939291906125a3565b34801561046457600080fd5b50610260610473366004612424565b610ce9565b34801561048457600080fd5b506102e06104933660046124b0565b610e04565b3480156104a457600080fd5b506101b1546101b2546101b3546101b4546101b554604080516001600160a01b039687168152948616602086015294909216938301939093526060820192909252608081019190915260a001610209565b34801561050157600080fd5b5061026061051036600461201e565b610e12565b34801561052157600080fd5b50610260610e89565b34801561053657600080fd5b50610556610545366004612058565b63bc197c8160e01b95945050505050565b6040516001600160e01b03199091168152602001610209565b34801561057b57600080fd5b5061058f61058a3660046123db565b611096565b6040516102099190612708565b3480156105a857600080fd5b506102606105b736600461201e565b611159565b3480156105c857600080fd5b506102326105d73660046124b0565b6111a1565b3480156105e857600080fd5b506102326105f73660046124d2565b6111d4565b34801561060857600080fd5b506103bd6106173660046124d2565b6111e3565b34801561062857600080fd5b50610556610637366004612106565b63f23a6e6160e01b95945050505050565b60006001600160e01b03198216630271189760e51b148061067957506301ffc9a760e01b6001600160e01b03198316145b92915050565b600061068b83836111f2565b9392505050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614156106e45760405162461bcd60e51b81526004016106db906125dd565b60405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661071661121e565b6001600160a01b03161461073c5760405162461bcd60e51b81526004016106db90612629565b6107458161123a565b61077e8160005b6040519080825280601f01601f191660200182016040528015610776576020820181803683370190505b506000611331565b50565b6040516334c4fde360e11b815260009073__$5eb4f00466582f7d4fb62bc47062007858$__90636989fbc6906107ca906101b1906001908b908b908b908b908b906004016126c0565b60206040518083038186803b1580156107e257600080fd5b505af41580156107f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081a919061229f565b9695505050505050565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141561086d5760405162461bcd60e51b81526004016106db906125dd565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031661089f61121e565b6001600160a01b0316146108c55760405162461bcd60e51b81526004016106db90612629565b6108ce8261123a565b6108da82826001611331565b5050565b6000306001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461097e5760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c000000000000000060648201526084016106db565b5060008051602061285883398151915290565b60006109a060018585856114b0565b949350505050565b600061068b600184846114ee565b60008383836040516020016109cd93929190612591565b60408051601f198184030181529190528051602090910120949350505050565b6040516304ac4a9160e11b815260016004820152602481018390526001600160a01b038216604482015273__$5eb4f00466582f7d4fb62bc47062007858$__9063095895229060640160006040518083038186803b158015610a4e57600080fd5b505af4158015610a62573d6000803e3d6000fd5b505050505050565b606061068b60018484611518565b6000610a8d6101b1546001600160a01b031690565b6101b554604051630eca989d60e11b81526001600160a01b039290921691631d95313a91610ac19160040190815260200190565b60206040518083038186803b158015610ad957600080fd5b505afa158015610aed573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b11919061229f565b905090565b6000610b20610a78565b6101b65414610b2f5750600190565b610b3761121e565b6101b3546001600160a01b03908116911614610b535750600190565b6101b2546001600160a01b0316610b736101b1546001600160a01b031690565b6001600160a01b03166399ac48ba610b8b61013d5490565b6040516001600160e01b031960e084901b16815260048101919091526921a7a72a2927a62622a960b11b602482015260440160206040518083038186803b158015610bd557600080fd5b505afa158015610be9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0d919061203b565b6001600160a01b031614610c215750600190565b50600090565b604051639c04df5b60e01b81526101b160048201526001602482015260448101829052600090819060609073__$5eb4f00466582f7d4fb62bc47062007858$__90639c04df5b9060640160006040518083038186803b158015610c8957600080fd5b505af4158015610c9d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610cc59190810190612223565b6101b5549295509093509150821415610ce257610ce283856115ca565b9193909250565b600054610100900460ff1615808015610d095750600054600160ff909116105b80610d235750303b158015610d23575060005460ff166001145b610d865760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016106db565b6000805460ff191660011790558015610da9576000805461ff0019166101001790555b610db5878787876115e7565b8015610dfb576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050565b600061068b60018484611649565b60405163e51d9aa360e01b81526101b160048201526001600160a01b038216602482015273__$5eb4f00466582f7d4fb62bc47062007858$__9063e51d9aa3906044015b60006040518083038186803b158015610e6e57600080fd5b505af4158015610e82573d6000803e3d6000fd5b5050505050565b6101b2546001600160a01b03163314610edb5760405162461bcd60e51b81526020600482015260146024820152732628281d39b2b73232b9102727aa1037bbb732b960611b60448201526064016106db565b6101b1546001600160a01b03166001600160a01b0316638650c0726040518163ffffffff1660e01b815260040160206040518083038186803b158015610f2057600080fd5b505afa158015610f34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f58919061227d565b15610f9e5760405162461bcd60e51b81526020600482015260166024820152751314140e941bdc9d185b081a5cc81a5cdbdb185d195960521b60448201526064016106db565b6101b654610faa610a78565b1415610fea5760405162461bcd60e51b815260206004820152600f60248201526e4c50503a6e6f20757067726164657360881b60448201526064016106db565b6000610fff6101b1546001600160a01b031690565b6101b55460405163e3099e0960e01b81526001600160a01b03929092169163e3099e09916110339160040190815260200190565b602060405180830381600087803b15801561104d57600080fd5b505af1158015611061573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611085919061229f565b905061109081610c27565b50505050565b6110ca604051806080016040528060006001600160a01b031681526020016000815260200160608152602001600081525090565b60405163929fbdfb60e01b81526101b160048201526024810183905273__$5eb4f00466582f7d4fb62bc47062007858$__9063929fbdfb9060440160006040518083038186803b15801561111d57600080fd5b505af4158015611131573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610679919081019061232e565b604051630bde2bc360e01b81526101b160048201526001600160a01b038216602482015273__$5eb4f00466582f7d4fb62bc47062007858$__90630bde2bc390604401610e56565b60008281526001602052604081208054839081106111c1576111c1612816565b9060005260206000200154905092915050565b60006109a0600185858561167d565b60606109a060018585856116ac565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080516020612858833981519152546001600160a01b031690565b73__$5eb4f00466582f7d4fb62bc47062007858$__633f98381a6101b18361126061121e565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b03918216602484015216604482015260640160206040518083038186803b1580156112ad57600080fd5b505af41580156112c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112e5919061227d565b61077e5760405162461bcd60e51b815260206004820152601960248201527f474d3a6e6f7420616c6c6f77656420746f20757067726164650000000000000060448201526064016106db565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff16156113695761136483611763565b505050565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156113a257600080fd5b505afa9250505080156113d2575060408051601f3d908101601f191682019092526113cf9181019061229f565b60015b6114355760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b60648201526084016106db565b60008051602061285883398151915281146114a45760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b60648201526084016106db565b506113648383836117ff565b60008460030160006114cb846114c688886111f2565b6111f2565b81526020810191909152604001600020546001600160a01b031695945050505050565b600083600101600061150085856111f2565b81526020019081526020016000205490509392505050565b606083600201600061152a85856111f2565b81526020019081526020016000208054611543906127db565b80601f016020809104026020016040519081016040528092919081815260200182805461156f906127db565b80156115bc5780601f10611591576101008083540402835291602001916115bc565b820191906000526020600020905b81548152906001019060200180831161159f57829003601f168201915b505050505090509392505050565b6115d38261123a565b6115de82600061074c565b6108da81611824565b600054610100900460ff1661160e5760405162461bcd60e51b81526004016106db90612675565b6116407f00000000000000000000000000000000000000000000000000000000000000008460001961271b8686611860565b611090846118a5565b600083600301600061165b85856111f2565b81526020810191909152604001600020546001600160a01b0316949350505050565b6000846001016000611693846114c688886111f2565b8152602001908152602001600020549050949350505050565b60608460020160006116c2846114c688886111f2565b815260200190815260200160002080546116db906127db565b80601f0160208091040260200160405190810160405280929190818152602001828054611707906127db565b80156117545780601f1061172957610100808354040283529160200191611754565b820191906000526020600020905b81548152906001019060200180831161173757829003601f168201915b50505050509050949350505050565b6001600160a01b0381163b6117d05760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084016106db565b60008051602061285883398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b611808836118d5565b6000825111806118155750805b15611364576110908383611915565b6101b68190556040518181527ffddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb9060200160405180910390a150565b600054610100900460ff166118875760405162461bcd60e51b81526004016106db90612675565b61188f611a09565b611897611a09565b610a62868686868686611a32565b600054610100900460ff166118cc5760405162461bcd60e51b81526004016106db90612675565b61077e81611de0565b6118de81611763565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b61197d5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016106db565b600080846001600160a01b0316846040516119989190612553565b600060405180830381855af49150503d80600081146119d3576040519150601f19603f3d011682016040523d82523d6000602084013e6119d8565b606091505b5091509150611a00828260405180606001604052806027815260200161287860279139611e10565b95945050505050565b600054610100900460ff16611a305760405162461bcd60e51b81526004016106db90612675565b565b600054610100900460ff16611a595760405162461bcd60e51b81526004016106db90612675565b6001600160a01b038616611aaf5760405162461bcd60e51b815260206004820152601d60248201527f474d3a676f7665726e616e63652063616e206e6f74206265207a65726f00000060448201526064016106db565b6001600160a01b038516611b055760405162461bcd60e51b815260206004820152601960248201527f474d3a73656e6174652063616e206e6f74206265207a65726f0000000000000060448201526064016106db565b428411611b4a5760405162461bcd60e51b8152602060048201526013602482015272474d3a6c6f772073656e61746545787069727960681b60448201526064016106db565b82611b975760405162461bcd60e51b815260206004820152601e60248201527f474d3a7061636b616765547970652063616e206e6f74206265207a65726f000060448201526064016106db565b80611bf05760405162461bcd60e51b815260206004820152602360248201527f474d3a696e697456657273696f6e4e616d652063616e206e6f7420626520656d60448201526270747960e81b60648201526084016106db565b6101b18054336001600160a01b0319918216811783556101b280549092161790556101b48590556101b584905560009073__$5eb4f00466582f7d4fb62bc47062007858$__90636989fbc6906001611c4661121e565b888888620151806040518863ffffffff1660e01b8152600401611c6f97969594939291906126c0565b60206040518083038186803b158015611c8757600080fd5b505af4158015611c9b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cbf919061229f565b604051639c04df5b60e01b81526101b16004820152600160248201526044810182905290915073__$5eb4f00466582f7d4fb62bc47062007858$__90639c04df5b9060640160006040518083038186803b158015611d1c57600080fd5b505af4158015611d30573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d589190810190612223565b505050611da7611da284848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250506101b5549150611e299050565b611824565b50506101b180546001600160a01b039687166001600160a01b0319918216179091556101b2805495909616941693909317909355505050565b600054610100900460ff16611e075760405162461bcd60e51b81526004016106db90612675565b61077e81611e5d565b60608315611e1f57508161068b565b61068b8383611e8a565b60008282604051602001611e3e92919061256f565b60408051601f1981840301815291905280516020909101209392505050565b600054610100900460ff16611e845760405162461bcd60e51b81526004016106db90612675565b61013d55565b815115611e9a5781518083602001fd5b8060405162461bcd60e51b81526004016106db91906125ca565b600082601f830112611ec557600080fd5b8135602067ffffffffffffffff821115611ee157611ee161282c565b8160051b611ef0828201612756565b838152828101908684018388018501891015611f0b57600080fd5b600093505b85841015611f2e578035835260019390930192918401918401611f10565b50979650505050505050565b60008083601f840112611f4c57600080fd5b50813567ffffffffffffffff811115611f6457600080fd5b602083019150836020828501011115611f7c57600080fd5b9250929050565b600082601f830112611f9457600080fd5b8135611fa7611fa282612787565b612756565b818152846020838601011115611fbc57600080fd5b816020850160208301376000918101602001919091529392505050565b600082601f830112611fea57600080fd5b8151611ff8611fa282612787565b81815284602083860101111561200d57600080fd5b6109a08260208301602087016127af565b60006020828403121561203057600080fd5b813561068b81612842565b60006020828403121561204d57600080fd5b815161068b81612842565b600080600080600060a0868803121561207057600080fd5b853561207b81612842565b9450602086013561208b81612842565b9350604086013567ffffffffffffffff808211156120a857600080fd5b6120b489838a01611eb4565b945060608801359150808211156120ca57600080fd5b6120d689838a01611eb4565b935060808801359150808211156120ec57600080fd5b506120f988828901611f83565b9150509295509295909350565b600080600080600060a0868803121561211e57600080fd5b853561212981612842565b9450602086013561213981612842565b93506040860135925060608601359150608086013567ffffffffffffffff81111561216357600080fd5b6120f988828901611f83565b6000806040838503121561218257600080fd5b823561218d81612842565b9150602083013567ffffffffffffffff8111156121a957600080fd5b6121b585828601611f83565b9150509250929050565b6000806000806000608086880312156121d757600080fd5b85356121e281612842565b945060208601359350604086013567ffffffffffffffff81111561220557600080fd5b61221188828901611f3a565b96999598509660600135949350505050565b60008060006060848603121561223857600080fd5b835161224381612842565b60208501516040860151919450925067ffffffffffffffff81111561226757600080fd5b61227386828701611fd9565b9150509250925092565b60006020828403121561228f57600080fd5b8151801515811461068b57600080fd5b6000602082840312156122b157600080fd5b5051919050565b6000602082840312156122ca57600080fd5b81356001600160e01b03198116811461068b57600080fd5b6000806000604084860312156122f757600080fd5b833567ffffffffffffffff81111561230e57600080fd5b61231a86828701611f3a565b909790965060209590950135949350505050565b60006020828403121561234057600080fd5b815167ffffffffffffffff8082111561235857600080fd5b908301906080828603121561236c57600080fd5b6040516080810181811083821117156123875761238761282c565b604052825161239581612842565b8152602083810151908201526040830151828111156123b357600080fd5b6123bf87828601611fd9565b6040830152506060830151606082015280935050505092915050565b6000602082840312156123ed57600080fd5b5035919050565b6000806040838503121561240757600080fd5b82359150602083013561241981612842565b809150509250929050565b6000806000806000806080878903121561243d57600080fd5b86359550602087013561244f81612842565b9450604087013567ffffffffffffffff8082111561246c57600080fd5b6124788a838b01611f3a565b9096509450606089013591508082111561249157600080fd5b5061249e89828a01611f3a565b979a9699509497509295939492505050565b600080604083850312156124c357600080fd5b50508035926020909101359150565b6000806000606084860312156124e757600080fd5b505081359360208301359350604090920135919050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000815180845261253f8160208601602086016127af565b601f01601f19169290920160200192915050565b600082516125658184602087016127af565b9190910192915050565b600083516125818184602088016127af565b9190910191825250602001919050565b82848237909101908152602001919050565b60018060a01b0384168152826020820152606060408201526000611a006060830184612527565b60208152600061068b6020830184612527565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b19195b1959d85d1958d85b1b60a21b606082015260800190565b6020808252602c908201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060408201526b6163746976652070726f787960a01b606082015260800190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b87815286602082015260018060a01b038616604082015284606082015260c0608082015260006126f460c0830185876124fe565b90508260a083015298975050505050505050565b6020815260018060a01b03825116602082015260208201516040820152600060408301516080606084015261274060a0840182612527565b9050606084015160808401528091505092915050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561277f5761277f61282c565b604052919050565b600067ffffffffffffffff8211156127a1576127a161282c565b50601f01601f191660200190565b60005b838110156127ca5781810151838201526020016127b2565b838111156110905750506000910152565b600181811c908216806127ef57607f821691505b6020821081141561281057634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461077e57600080fdfe360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220eeabfdf1e20d2c552a886d10a5bf60a42dfa0537f6c2a087b85ece6324ad9d9664736f6c63430008070033",
  "libraries": {
    "GeodeModuleLib": "0x3506980d4d72f056d12216cA7c853000f19e6382"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "GeodeParams()": {
        "custom:section": "** GETTER FUNCTIONS **",
        "custom:visibility": "-> view-external"
      },
      "allIdsByType(uint256,uint256)": {
        "details": "useful for outside reach, shouldn't be used within contracts as a referance",
        "returns": {
          "_0": "allIdsByType is an array of IDs of the given TYPE from Datastore, returns a specific index"
        }
      },
      "approveProposal(uint256)": {
        "details": "handles PACKAGE_TYPE proposals by upgrading the contract immediately."
      },
      "changeIdCONTROLLER(uint256,address)": {
        "custom:subsection": "** ONLY CONTROLLER **"
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor",
        "details": "we don't want to provide these package-specific not-changing parameters accross all instances of the packages. So we will store them in the ref implementation contract of the package, and fetch when needed on initialization."
      },
      "generateId(string,uint256)": {
        "details": "id is generated by keccak(name, type)"
      },
      "getProposedVersion()": {
        "details": "GeodeModule override"
      },
      "isolationMode()": {
        "details": "GeodeModule override"
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "propose(address,uint256,bytes,uint256)": {
        "custom:subsection": "** ONLY GOVERNANCE **"
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "readUintArray(uint256,bytes32,uint256)": {
        "custom:section": "** ARRAY GETTER FUNCTIONS **",
        "custom:visibility": "-> view-external"
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "upgradeTo(address)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "generateId(string,uint256)": {
        "notice": "useful function for string inputs - returns same with the DSML.generateId"
      },
      "getKey(uint256,bytes32)": {
        "notice": "useful view function for string inputs - returns same with the DSML.generateId"
      },
      "getPortal()": {
        "notice": "get Portal as a contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 527,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 530,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 26252,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "DATASTORE",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(IsolatedStorage)26492_storage"
      },
      {
        "astId": 3198,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "17",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1190,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "67",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1136,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "117",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 2331,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "167",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 846,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "_paused",
        "offset": 0,
        "slot": "217",
        "type": "t_bool"
      },
      {
        "astId": 951,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "218",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 966,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "_status",
        "offset": 0,
        "slot": "267",
        "type": "t_uint256"
      },
      {
        "astId": 1024,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "268",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 38045,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "WITHDRAWAL",
        "offset": 0,
        "slot": "317",
        "type": "t_struct(PooledWithdrawal)38087_storage"
      },
      {
        "astId": 509,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "333",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 824,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "383",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 27145,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "GEODE",
        "offset": 0,
        "slot": "433",
        "type": "t_struct(DualGovernance)27622_storage"
      },
      {
        "astId": 38824,
        "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
        "label": "__gap",
        "offset": 0,
        "slot": "449",
        "type": "t_array(t_uint256)48_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)12_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[12]",
        "numberOfBytes": "384"
      },
      "t_array(t_uint256)15_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[15]",
        "numberOfBytes": "480"
      },
      "t_array(t_uint256)48_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[48]",
        "numberOfBytes": "1536"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)9_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[9]",
        "numberOfBytes": "288"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes32,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_uint256,t_struct(Proposal)27600_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct GeodeModuleLib.Proposal)",
        "numberOfBytes": "32",
        "value": "t_struct(Proposal)27600_storage"
      },
      "t_struct(DualGovernance)27622_storage": {
        "encoding": "inplace",
        "label": "struct GeodeModuleLib.DualGovernance",
        "members": [
          {
            "astId": 27602,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "GOVERNANCE",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 27604,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "SENATE",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 27606,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "APPROVED_UPGRADE",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 27608,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "SENATE_EXPIRY",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 27610,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "PACKAGE_TYPE",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 27612,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "CONTRACT_VERSION",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 27617,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "proposals",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_uint256,t_struct(Proposal)27600_storage)"
          },
          {
            "astId": 27621,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "__gap",
            "offset": 0,
            "slot": "7",
            "type": "t_array(t_uint256)9_storage"
          }
        ],
        "numberOfBytes": "512"
      },
      "t_struct(IsolatedStorage)26492_storage": {
        "encoding": "inplace",
        "label": "struct DataStoreModuleLib.IsolatedStorage",
        "members": [
          {
            "astId": 26475,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "allIdsByType",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)"
          },
          {
            "astId": 26479,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "uintData",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 26483,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "bytesData",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_bytes32,t_bytes_storage)"
          },
          {
            "astId": 26487,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "addressData",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes32,t_address)"
          },
          {
            "astId": 26491,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "__gap",
            "offset": 0,
            "slot": "4",
            "type": "t_array(t_uint256)12_storage"
          }
        ],
        "numberOfBytes": "512"
      },
      "t_struct(PooledWithdrawal)38087_storage": {
        "encoding": "inplace",
        "label": "struct WithdrawalModuleLib.PooledWithdrawal",
        "members": [
          {
            "astId": 38082,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "pooledTokenId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 38086,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "__gap",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)15_storage"
          }
        ],
        "numberOfBytes": "512"
      },
      "t_struct(Proposal)27600_storage": {
        "encoding": "inplace",
        "label": "struct GeodeModuleLib.Proposal",
        "members": [
          {
            "astId": 27593,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "CONTROLLER",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 27595,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "TYPE",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 27597,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "NAME",
            "offset": 0,
            "slot": "2",
            "type": "t_bytes_storage"
          },
          {
            "astId": 27599,
            "contract": "contracts/Portal/packages/WithdrawalContract.sol:WithdrawalContract",
            "label": "deadline",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}