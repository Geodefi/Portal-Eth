{
  "address": "0x8C9Cc17DFEEDcF94E3D7E2F23A1533BEa45Ea5db",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "tokenAmounts",
          "type": "uint256[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "fees",
          "type": "uint256[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "invariant",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpTokenSupply",
          "type": "uint256"
        }
      ],
      "name": "AddLiquidity",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAdminFee",
          "type": "uint256"
        }
      ],
      "name": "NewAdminFee",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newSwapFee",
          "type": "uint256"
        }
      ],
      "name": "NewSwapFee",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newWithdrawFee",
          "type": "uint256"
        }
      ],
      "name": "NewWithdrawFee",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "initialTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "futureTime",
          "type": "uint256"
        }
      ],
      "name": "RampA",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "tokenAmounts",
          "type": "uint256[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpTokenSupply",
          "type": "uint256"
        }
      ],
      "name": "RemoveLiquidity",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "tokenAmounts",
          "type": "uint256[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "fees",
          "type": "uint256[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "invariant",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpTokenSupply",
          "type": "uint256"
        }
      ],
      "name": "RemoveLiquidityImbalance",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpTokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpTokenSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "boughtId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokensBought",
          "type": "uint256"
        }
      ],
      "name": "RemoveLiquidityOne",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "currentA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "time",
          "type": "uint256"
        }
      ],
      "name": "StopRampA",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokensSold",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokensBought",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "soldId",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "boughtId",
          "type": "uint128"
        }
      ],
      "name": "TokenSwap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[2]",
          "name": "amounts",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256",
          "name": "minToMint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "addLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "calculateRemoveLiquidity",
      "outputs": [
        {
          "internalType": "uint256[2]",
          "name": "",
          "type": "uint256[2]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "tokenIndex",
          "type": "uint8"
        }
      ],
      "name": "calculateRemoveLiquidityOneToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "availableTokenAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "tokenIndexFrom",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "tokenIndexTo",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "dx",
          "type": "uint256"
        }
      ],
      "name": "calculateSwap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[2]",
          "name": "amounts",
          "type": "uint256[2]"
        },
        {
          "internalType": "bool",
          "name": "deposit",
          "type": "bool"
        }
      ],
      "name": "calculateTokenAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getA",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAPrecise",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getAdminBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getERC1155",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "index",
          "type": "uint8"
        }
      ],
      "name": "getTokenBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVirtualPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IgETH",
          "name": "_gETH",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_pooledTokenId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "lpTokenName",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "lpTokenSymbol",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "lpTokenTargetAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "futureA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "futureTime",
          "type": "uint256"
        }
      ],
      "name": "rampA",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256[2]",
          "name": "minAmounts",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "removeLiquidity",
      "outputs": [
        {
          "internalType": "uint256[2]",
          "name": "",
          "type": "uint256[2]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[2]",
          "name": "amounts",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256",
          "name": "maxBurnAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "removeLiquidityImbalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "tokenIndex",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "minAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "removeLiquidityOneToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newAdminFee",
          "type": "uint256"
        }
      ],
      "name": "setAdminFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newSwapFee",
          "type": "uint256"
        }
      ],
      "name": "setSwapFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stopRampA",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "tokenIndexFrom",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "tokenIndexTo",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "dx",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minDy",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swapStorage",
      "outputs": [
        {
          "internalType": "contract IgETH",
          "name": "gETH",
          "type": "address"
        },
        {
          "internalType": "contract ILPToken",
          "name": "lpToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "pooledTokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "initialA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "futureA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "initialATime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "futureATime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "swapFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "adminFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawAdminFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa537c056624f94d1c6dd1dc5b67a2c3b8479631c700d3b6c46c8fb30f0b65d0a",
  "receipt": {
    "to": null,
    "from": "0x2C95BC18Fd9382a07776D416EeF6c2FEb3AD2A8C",
    "contractAddress": "0x8C9Cc17DFEEDcF94E3D7E2F23A1533BEa45Ea5db",
    "transactionIndex": 3,
    "gasUsed": "2107956",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcb31c6fcbb24c511fef05e9a201aad01fc0e84f827ae3d40904c895b8b4402fd",
    "transactionHash": "0xa537c056624f94d1c6dd1dc5b67a2c3b8479631c700d3b6c46c8fb30f0b65d0a",
    "logs": [],
    "blockNumber": 8557487,
    "cumulativeGasUsed": "2184346",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ade6b4939fda34d609e172906ec4e12a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"fees\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdminFee\",\"type\":\"uint256\"}],\"name\":\"NewAdminFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapFee\",\"type\":\"uint256\"}],\"name\":\"NewSwapFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWithdrawFee\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"futureTime\",\"type\":\"uint256\"}],\"name\":\"RampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"fees\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidityImbalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidityOne\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"soldId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"boughtId\",\"type\":\"uint128\"}],\"name\":\"TokenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"minToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"}],\"name\":\"calculateRemoveLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"bool\",\"name\":\"deposit\",\"type\":\"bool\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPrecise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAdminBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getERC1155\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVirtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IgETH\",\"name\":\"_gETH\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pooledTokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lpTokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"lpTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"lpTokenTargetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"futureA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureTime\",\"type\":\"uint256\"}],\"name\":\"rampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"minAmounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityImbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdminFee\",\"type\":\"uint256\"}],\"name\":\"setAdminFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapStorage\",\"outputs\":[{\"internalType\":\"contract IgETH\",\"name\":\"gETH\",\"type\":\"address\"},{\"internalType\":\"contract ILPToken\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pooledTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAdminFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's deployment size.The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals relying on the Oracle Price, with the help of Liquidity Providers. It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions. Because the underlying price of the staked assets are expected to raise in time. One can see this similar to accomplishing a \\\"rebasing\\\" logic, with the help of a trusted price source.\",\"kind\":\"dev\",\"methods\":{\"addLiquidity(uint256[2],uint256,uint256)\":{\"params\":{\"amounts\":\"the amounts of each token to add, in their native precision\",\"deadline\":\"latest timestamp to accept this transaction\",\"minToMint\":\"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation\"},\"returns\":{\"_0\":\"amount of LP token user minted and received\"}},\"calculateRemoveLiquidity(uint256)\":{\"params\":{\"amount\":\"the amount of LP tokens that would be burned on withdrawal\"},\"returns\":{\"_0\":\"array of token balances that the user will receive\"}},\"calculateRemoveLiquidityOneToken(uint256,uint8)\":{\"params\":{\"tokenAmount\":\"the amount of LP token to burn\",\"tokenIndex\":\"index of which token will be withdrawn\"},\"returns\":{\"availableTokenAmount\":\"calculated amount of underlying token available to withdraw\"}},\"calculateSwap(uint8,uint8,uint256)\":{\"params\":{\"dx\":\"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.\",\"tokenIndexFrom\":\"the token the user wants to sell\",\"tokenIndexTo\":\"the token the user wants to buy\"},\"returns\":{\"_0\":\"amount of tokens the user will receive\"}},\"calculateTokenAmount(uint256[2],bool)\":{\"details\":\"This shouldn't be used outside frontends for user estimates.\",\"params\":{\"amounts\":\"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.\",\"deposit\":\"whether this is a deposit or a withdrawal\"},\"returns\":{\"_0\":\"token amount the user will receive\"}},\"getA()\":{\"details\":\"See the StableSwap paper for details\",\"returns\":{\"_0\":\"A parameter\"}},\"getAPrecise()\":{\"details\":\"See the StableSwap paper for details\",\"returns\":{\"_0\":\"A parameter in its raw precision form\"}},\"getAdminBalance(uint256)\":{\"params\":{\"index\":\"Index of the pooled token\"},\"returns\":{\"_0\":\"admin's token balance in the token's precision\"}},\"getDebt()\":{\"returns\":{\"_0\":\"debt the half of the D StableSwap invariant when debt is needed to be payed.\"}},\"getSwapFee()\":{\"returns\":{\"_0\":\"id of the pooled gEther token\"}},\"getTokenBalance(uint8)\":{\"params\":{\"index\":\"the index of the token\"},\"returns\":{\"_0\":\"current balance of the pooled token at given index with token's native precision\"}},\"getVirtualPrice()\":{\"returns\":{\"_0\":\"the virtual price\"}},\"initialize(address,uint256,string,string,address,address)\":{\"params\":{\"_gETH\":\"reference of the ERC1155 contract\",\"_pooledTokenId\":\"gEther ID that the Pool is operating with\",\"lpTokenName\":\"the long-form name of the token to be deployed\",\"lpTokenSymbol\":\"the short symbol for the token to be deployed\",\"lpTokenTargetAddress\":\"the address of an existing LPToken contract to use as a target\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"rampA(uint256,uint256)\":{\"params\":{\"futureA\":\"the new A to ramp towards\",\"futureTime\":\"timestamp when the new A should be reached\"}},\"removeLiquidity(uint256,uint256[2],uint256)\":{\"details\":\"Liquidity can always be removed, even when the pool is paused.\",\"params\":{\"amount\":\"the amount of LP tokens to burn\",\"deadline\":\"latest timestamp to accept this transaction\",\"minAmounts\":\"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation\"},\"returns\":{\"_0\":\"amounts of tokens user received\"}},\"removeLiquidityImbalance(uint256[2],uint256,uint256)\":{\"params\":{\"amounts\":\"how much of each token to withdraw\",\"deadline\":\"latest timestamp to accept this transaction\",\"maxBurnAmount\":\"the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation.\"},\"returns\":{\"_0\":\"amount of LP tokens burned\"}},\"removeLiquidityOneToken(uint256,uint8,uint256,uint256)\":{\"params\":{\"deadline\":\"latest timestamp to accept this transaction\",\"minAmount\":\"the minimum amount to withdraw, otherwise revert\",\"tokenAmount\":\"the amount of the token you want to receive\",\"tokenIndex\":\"the index of the token you want to receive\"},\"returns\":{\"_0\":\"amount of chosen token user received\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setAdminFee(uint256)\":{\"params\":{\"newAdminFee\":\"new admin fee to be applied on future transactions\"}},\"setSwapFee(uint256)\":{\"params\":{\"newSwapFee\":\"new swap fee to be applied on future transactions\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"swap(uint8,uint8,uint256,uint256,uint256)\":{\"params\":{\"deadline\":\"latest timestamp to accept this transaction\",\"dx\":\"the amount of tokens the user wants to swap from\",\"minDy\":\"the min amount the user would like to receive, or revert.\",\"tokenIndexFrom\":\"the token the user wants to swap from\",\"tokenIndexTo\":\"the token the user wants to swap to\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"Swap - A StableSwap implementation in solidity.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addLiquidity(uint256[2],uint256,uint256)\":{\"notice\":\"Add liquidity to the pool with the given amounts of tokens\"},\"calculateRemoveLiquidity(uint256)\":{\"notice\":\"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens\"},\"calculateRemoveLiquidityOneToken(uint256,uint8)\":{\"notice\":\"Calculate the amount of underlying token available to withdraw when withdrawing via only single token\"},\"calculateSwap(uint8,uint8,uint256)\":{\"notice\":\"Calculate amount of tokens you receive on swap\"},\"calculateTokenAmount(uint256[2],bool)\":{\"notice\":\"A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various \\\"min\\\" parameters on calls to fight front-running\"},\"getA()\":{\"notice\":\"Return A, the amplification coefficient * n * (n - 1)\"},\"getAPrecise()\":{\"notice\":\"Return A in its raw precision form\"},\"getAdminBalance(uint256)\":{\"notice\":\"This function reads the accumulated amount of admin fees of the token with given index\"},\"getDebt()\":{\"notice\":\"Debt, The amount of buyback for stable pricing (1=1).\"},\"getSwapFee()\":{\"notice\":\"Return id of the pooled token\"},\"getTokenBalance(uint8)\":{\"notice\":\"Return current balance of the pooled token at given index\"},\"getVirtualPrice()\":{\"notice\":\"Get the virtual price, to help calculate profit\"},\"initialize(address,uint256,string,string,address,address)\":{\"notice\":\"Initializes this Swap contract with the given parameters. This will also clone a LPToken contract that represents users' LP positions. The owner of LPToken will be this contract - which means only this contract is allowed to mint/burn tokens.\"},\"pause()\":{\"notice\":\"Pause the contract. Revert if already paused.\"},\"rampA(uint256,uint256)\":{\"notice\":\"Start ramping up or down A parameter towards given futureA and futureTime Checks if the change is too rapid, and commits the new A value only when it falls under the limit range.\"},\"removeLiquidity(uint256,uint256[2],uint256)\":{\"notice\":\"Burn LP tokens to remove liquidity from the pool.\"},\"removeLiquidityImbalance(uint256[2],uint256,uint256)\":{\"notice\":\"Remove liquidity from the pool, weighted differently than the pool's current balances.\"},\"removeLiquidityOneToken(uint256,uint8,uint256,uint256)\":{\"notice\":\"Remove liquidity from the pool all in one token.\"},\"setAdminFee(uint256)\":{\"notice\":\"Update the admin fee. Admin fee takes portion of the swap fee.\"},\"setSwapFee(uint256)\":{\"notice\":\"Update the swap fee to be applied on swaps\"},\"stopRampA()\":{\"notice\":\"Stop ramping A immediately. Reverts if ramp A is already stopped.\"},\"swap(uint8,uint8,uint256,uint256,uint256)\":{\"notice\":\"Swap two tokens using this pool\"},\"unpause()\":{\"notice\":\"Unpause the contract. Revert if already unpaused.\"},\"withdrawAdminFees()\":{\"notice\":\"Withdraw all admin fees to the contract owner\"}},\"notice\":\"This contract is responsible for custody of closely pegged assets (eg. group of stablecoins) and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens in desired ratios for an exchange of the pool token that represents their share of the pool. Users can burn pool tokens and withdraw their share of token(s). Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets distributed to the LPs. In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which stops the ratio of the tokens in the pool from changing. Users can always withdraw their tokens via multi-asset withdraws.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Portal/liquidityPool/Swap.sol\":\"Swap\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xffcb29612efb57efc8f0d4897deb5abaeac830022c59a3aa17446d698dbc856b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8a1f16aa62b4d8c9e380057d9c3ee5c992e4a10dccc5650b26e38d4c61287d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa1b77d6d0f4591359c42b747a31375f20b0571b5e1fb62652d8184fb10f1d63a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x888d64d221d52c31d015b76e50ca1af5ef8ff076550810b49cea6b01d8267a10\",\"license\":\"MIT\"},\"contracts/Portal/liquidityPool/Swap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IgETH.sol\\\";\\nimport \\\"./helpers/OwnerPausableUpgradeable.sol\\\";\\nimport \\\"./utils/SwapUtils.sol\\\";\\nimport \\\"./utils/AmplificationUtils.sol\\\";\\nimport \\\"../../interfaces/ISwap.sol\\\";\\n\\n/**\\n * @title Swap - A StableSwap implementation in solidity.\\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\\n * Users can burn pool tokens and withdraw their share of token(s).\\n *\\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\\n * distributed to the LPs.\\n *\\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\\n * stops the ratio of the tokens in the pool from changing.\\n * Users can always withdraw their tokens via multi-asset withdraws.\\n *\\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\\n * deployment size.\\n * @dev The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals\\n * relying on the Oracle Price, with the help of Liquidity Providers.\\n * It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions.\\n * Because the underlying price of the staked assets are expected to raise in time.\\n * One can see this similar to accomplishing a \\\"rebasing\\\" logic, with the help of a trusted price source.\\n */\\ncontract Swap is\\n  ISwap,\\n  OwnerPausableUpgradeable,\\n  ReentrancyGuardUpgradeable,\\n  ERC1155HolderUpgradeable\\n{\\n  using SwapUtils for SwapUtils.Swap;\\n  using AmplificationUtils for SwapUtils.Swap;\\n\\n  // Struct storing data responsible for automatic market maker functionalities. In order to\\n  // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\\n  SwapUtils.Swap public swapStorage;\\n\\n  /*** EVENTS ***/\\n\\n  // events replicated from SwapUtils to make the ABI easier\\n  event TokenSwap(\\n    address indexed buyer,\\n    uint256 tokensSold,\\n    uint256 tokensBought,\\n    uint128 soldId,\\n    uint128 boughtId\\n  );\\n  event AddLiquidity(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256[2] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidity(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidityOne(\\n    address indexed provider,\\n    uint256 lpTokenAmount,\\n    uint256 lpTokenSupply,\\n    uint256 boughtId,\\n    uint256 tokensBought\\n  );\\n  event RemoveLiquidityImbalance(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256[2] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event NewAdminFee(uint256 newAdminFee);\\n  event NewSwapFee(uint256 newSwapFee);\\n  event NewWithdrawFee(uint256 newWithdrawFee);\\n  event RampA(\\n    uint256 oldA,\\n    uint256 newA,\\n    uint256 initialTime,\\n    uint256 futureTime\\n  );\\n  event StopRampA(uint256 currentA, uint256 time);\\n\\n  /**\\n   * @notice Initializes this Swap contract with the given parameters.\\n   * This will also clone a LPToken contract that represents users'\\n   * LP positions. The owner of LPToken will be this contract - which means\\n   * only this contract is allowed to mint/burn tokens.\\n   *\\n   * @param _gETH reference of the ERC1155 contract\\n   * @param _pooledTokenId gEther ID that the Pool is operating with\\n   * @param lpTokenName the long-form name of the token to be deployed\\n   * @param lpTokenSymbol the short symbol for the token to be deployed\\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\\n   */\\n  function initialize(\\n    IgETH _gETH,\\n    uint256 _pooledTokenId,\\n    string memory lpTokenName,\\n    string memory lpTokenSymbol,\\n    address lpTokenTargetAddress,\\n    address owner\\n  ) public virtual override initializer returns (address) {\\n    __OwnerPausable_init();\\n    __ReentrancyGuard_init();\\n    __ERC1155Holder_init();\\n\\n    require(\\n      lpTokenTargetAddress != address(0),\\n      \\\"Swap: lpTokenTargetAddress can not be zero\\\"\\n    );\\n    require(owner != address(0), \\\"Swap: owner can not be zero\\\");\\n    require(address(_gETH) != address(0), \\\"Swap: _gETH can not be zero\\\");\\n    require(_pooledTokenId != 0, \\\"Swap: _pooledTokenId can not be zero\\\");\\n\\n    // Clone and initialize a LPToken contract\\n    ILPToken lpToken = ILPToken(Clones.clone(lpTokenTargetAddress));\\n\\n    require(\\n      lpToken.initialize(lpTokenName, lpTokenSymbol),\\n      \\\"Swap: could not init lpToken clone\\\"\\n    );\\n\\n    // Initialize swapStorage struct\\n    swapStorage.gETH = _gETH;\\n    swapStorage.lpToken = lpToken;\\n    swapStorage.pooledTokenId = _pooledTokenId;\\n    swapStorage.initialA = 60 * AmplificationUtils.A_PRECISION;\\n    swapStorage.futureA = 60 * AmplificationUtils.A_PRECISION;\\n    swapStorage.swapFee = (4 * PERCENTAGE_DENOMINATOR) / 10000;\\n    swapStorage.adminFee = 0;\\n\\n    super.transferOwnership(owner);\\n    return address(lpToken);\\n  }\\n\\n  /*** MODIFIERS ***/\\n\\n  /**\\n   * @notice Modifier to check deadline against current timestamp\\n   * @param deadline latest timestamp to accept this transaction\\n   */\\n  modifier deadlineCheck(uint256 deadline) {\\n    require(block.timestamp <= deadline, \\\"Swap: Deadline not met\\\");\\n    _;\\n  }\\n\\n  /*** VIEW FUNCTIONS ***/\\n  function getERC1155() external view virtual override returns (address) {\\n    return address(swapStorage.gETH);\\n  }\\n\\n  /**\\n   * @notice Return A, the amplification coefficient * n * (n - 1)\\n   * @dev See the StableSwap paper for details\\n   * @return A parameter\\n   */\\n  function getA() external view virtual override returns (uint256) {\\n    return swapStorage.getA();\\n  }\\n\\n  /**\\n   * @notice Return A in its raw precision form\\n   * @dev See the StableSwap paper for details\\n   * @return A parameter in its raw precision form\\n   */\\n  function getAPrecise() external view virtual override returns (uint256) {\\n    return swapStorage.getAPrecise();\\n  }\\n\\n  /**\\n   * @notice Return id of the pooled token\\n   * @return id of the pooled gEther token\\n   */\\n  function getSwapFee() external view virtual override returns (uint256) {\\n    return swapStorage.swapFee;\\n  }\\n\\n  function getToken() external view virtual override returns (uint256) {\\n    return swapStorage.pooledTokenId;\\n  }\\n\\n  /**\\n   * @notice Return current balance of the pooled token at given index\\n   * @param index the index of the token\\n   * @return current balance of the pooled token at given index with token's native precision\\n   */\\n  function getTokenBalance(\\n    uint8 index\\n  ) external view virtual override returns (uint256) {\\n    require(index < 2, \\\"Swap: Index out of range\\\");\\n    return swapStorage.balances[index];\\n  }\\n\\n  /**\\n   * @notice Get the virtual price, to help calculate profit\\n   * @return the virtual price\\n   */\\n  function getVirtualPrice() external view virtual override returns (uint256) {\\n    return swapStorage.getVirtualPrice();\\n  }\\n\\n  /**\\n   * @notice Debt, The amount of buyback for stable pricing (1=1).\\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\\n   */\\n  function getDebt() external view virtual override returns (uint256) {\\n    // might change when price is in.\\n    return swapStorage.getDebt();\\n  }\\n\\n  /**\\n   * @notice Calculate amount of tokens you receive on swap\\n   * @param tokenIndexFrom the token the user wants to sell\\n   * @param tokenIndexTo the token the user wants to buy\\n   * @param dx the amount of tokens the user wants to sell. If the token charges\\n   * a fee on transfers, use the amount that gets transferred after the fee.\\n   * @return amount of tokens the user will receive\\n   */\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view virtual override returns (uint256) {\\n    return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate prices from deposits or\\n   * withdrawals, excluding fees but including slippage. This is\\n   * helpful as an input into the various \\\"min\\\" parameters on calls\\n   * to fight front-running\\n   *\\n   * @dev This shouldn't be used outside frontends for user estimates.\\n   *\\n   * @param amounts an array of token amounts to deposit or withdrawal,\\n   * corresponding to pooledTokens. The amount should be in each\\n   * pooled token's native precision. If a token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @param deposit whether this is a deposit or a withdrawal\\n   * @return token amount the user will receive\\n   */\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view virtual override returns (uint256) {\\n    return swapStorage.calculateTokenAmount(amounts, deposit);\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate amount of each underlying\\n   * tokens that is returned upon burning given amount of LP tokens\\n   * @param amount the amount of LP tokens that would be burned on withdrawal\\n   * @return array of token balances that the user will receive\\n   */\\n  function calculateRemoveLiquidity(\\n    uint256 amount\\n  ) external view virtual override returns (uint256[2] memory) {\\n    return swapStorage.calculateRemoveLiquidity(amount);\\n  }\\n\\n  /**\\n   * @notice Calculate the amount of underlying token available to withdraw\\n   * when withdrawing via only single token\\n   * @param tokenAmount the amount of LP token to burn\\n   * @param tokenIndex index of which token will be withdrawn\\n   * @return availableTokenAmount calculated amount of underlying token\\n   * available to withdraw\\n   */\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view virtual override returns (uint256 availableTokenAmount) {\\n    return swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\\n  }\\n\\n  /**\\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\\n   * @param index Index of the pooled token\\n   * @return admin's token balance in the token's precision\\n   */\\n  function getAdminBalance(\\n    uint256 index\\n  ) external view virtual override returns (uint256) {\\n    return swapStorage.getAdminBalance(index);\\n  }\\n\\n  /*** STATE MODIFYING FUNCTIONS ***/\\n\\n  /**\\n   * @notice Swap two tokens using this pool\\n   * @param tokenIndexFrom the token the user wants to swap from\\n   * @param tokenIndexTo the token the user wants to swap to\\n   * @param dx the amount of tokens the user wants to swap from\\n   * @param minDy the min amount the user would like to receive, or revert.\\n   * @param deadline latest timestamp to accept this transaction\\n   */\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    nonReentrant\\n    whenNotPaused\\n    deadlineCheck(deadline)\\n    returns (uint256)\\n  {\\n    return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\\n  }\\n\\n  /**\\n   * @notice Add liquidity to the pool with the given amounts of tokens\\n   * @param amounts the amounts of each token to add, in their native precision\\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\\n   * should mint, otherwise revert. Handy for front-running mitigation\\n   * @param deadline latest timestamp to accept this transaction\\n   * @return amount of LP token user minted and received\\n   */\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    nonReentrant\\n    whenNotPaused\\n    deadlineCheck(deadline)\\n    returns (uint256)\\n  {\\n    return swapStorage.addLiquidity(amounts, minToMint);\\n  }\\n\\n  /**\\n   * @notice Burn LP tokens to remove liquidity from the pool.\\n   * @dev Liquidity can always be removed, even when the pool is paused.\\n   * @param amount the amount of LP tokens to burn\\n   * @param minAmounts the minimum amounts of each token in the pool\\n   *        acceptable for this burn. Useful as a front-running mitigation\\n   * @param deadline latest timestamp to accept this transaction\\n   * @return amounts of tokens user received\\n   */\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    deadlineCheck(deadline)\\n    returns (uint256[2] memory)\\n  {\\n    return swapStorage.removeLiquidity(amount, minAmounts);\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool all in one token.\\n   * @param tokenAmount the amount of the token you want to receive\\n   * @param tokenIndex the index of the token you want to receive\\n   * @param minAmount the minimum amount to withdraw, otherwise revert\\n   * @param deadline latest timestamp to accept this transaction\\n   * @return amount of chosen token user received\\n   */\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    whenNotPaused\\n    deadlineCheck(deadline)\\n    returns (uint256)\\n  {\\n    return\\n      swapStorage.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool, weighted differently than the\\n   * pool's current balances.\\n   * @param amounts how much of each token to withdraw\\n   * @param maxBurnAmount the max LP token provider is willing to pay to\\n   * remove liquidity. Useful as a front-running mitigation.\\n   * @param deadline latest timestamp to accept this transaction\\n   * @return amount of LP tokens burned\\n   */\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    nonReentrant\\n    whenNotPaused\\n    deadlineCheck(deadline)\\n    returns (uint256)\\n  {\\n    return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\\n  }\\n\\n  /*** ADMIN FUNCTIONS ***/\\n\\n  /**\\n   * @notice Withdraw all admin fees to the contract owner\\n   */\\n  function withdrawAdminFees()\\n    external\\n    virtual\\n    override\\n    onlyOwner\\n    nonReentrant\\n  {\\n    swapStorage.withdrawAdminFees(owner());\\n  }\\n\\n  /**\\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\\n   * @param newAdminFee new admin fee to be applied on future transactions\\n   */\\n  function setAdminFee(\\n    uint256 newAdminFee\\n  ) external virtual override onlyOwner {\\n    swapStorage.setAdminFee(newAdminFee);\\n  }\\n\\n  /**\\n   * @notice Update the swap fee to be applied on swaps\\n   * @param newSwapFee new swap fee to be applied on future transactions\\n   */\\n  function setSwapFee(uint256 newSwapFee) external virtual override onlyOwner {\\n    swapStorage.setSwapFee(newSwapFee);\\n  }\\n\\n  /**\\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\\n   * the limit range.\\n   * @param futureA the new A to ramp towards\\n   * @param futureTime timestamp when the new A should be reached\\n   */\\n  function rampA(\\n    uint256 futureA,\\n    uint256 futureTime\\n  ) external virtual override onlyOwner {\\n    swapStorage.rampA(futureA, futureTime);\\n  }\\n\\n  /**\\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\\n   */\\n  function stopRampA() external virtual override onlyOwner {\\n    swapStorage.stopRampA();\\n  }\\n}\\n\",\"keccak256\":\"0xb9e11df4dc69985f4557fbeb66eedb8dfc02781369a5a1cdf9e960b7fa86cba3\",\"license\":\"MIT\"},\"contracts/Portal/liquidityPool/helpers/OwnerPausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\n/**\\n * @title OwnerPausable\\n * @notice An ownable contract allows the owner to pause and unpause the\\n * contract without a delay.\\n * @dev Only methods using the provided modifiers will be paused.\\n */\\nabstract contract OwnerPausableUpgradeable is\\n    OwnableUpgradeable,\\n    PausableUpgradeable\\n{\\n    function __OwnerPausable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    /**\\n     * @notice Pause the contract. Revert if already paused.\\n     */\\n    function pause() external onlyOwner {\\n        PausableUpgradeable._pause();\\n    }\\n\\n    /**\\n     * @notice Unpause the contract. Revert if already unpaused.\\n     */\\n    function unpause() external onlyOwner {\\n        PausableUpgradeable._unpause();\\n    }\\n}\\n\",\"keccak256\":\"0x0603f77426ab83f3007abd29ba2e2381ae8b5b34ccc76e8c81908f64e350bb28\",\"license\":\"MIT\"},\"contracts/Portal/liquidityPool/utils/AmplificationUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\nimport \\\"./SwapUtils.sol\\\";\\n\\n/**\\n * @title AmplificationUtils library\\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\\n * This library assumes the struct is fully validated.\\n */\\nlibrary AmplificationUtils {\\n    event RampA(\\n        uint256 oldA,\\n        uint256 newA,\\n        uint256 initialTime,\\n        uint256 futureTime\\n    );\\n    event StopRampA(uint256 currentA, uint256 time);\\n\\n    // Constant values used in ramping A calculations\\n    uint256 public constant A_PRECISION = 100;\\n    uint256 public constant MAX_A = 10**6;\\n    uint256 private constant MAX_A_CHANGE = 2;\\n    uint256 private constant MIN_RAMP_TIME = 14 days;\\n\\n    /**\\n     * @notice Return A, the amplification coefficient * n * (n - 1)\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter\\n     */\\n    function getA(SwapUtils.Swap storage self) internal view returns (uint256) {\\n        return _getAPrecise(self) / (A_PRECISION);\\n    }\\n\\n    /**\\n     * @notice Return A in its raw precision\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter in its raw precision form\\n     */\\n    function getAPrecise(SwapUtils.Swap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _getAPrecise(self);\\n    }\\n\\n    /**\\n     * @notice Return A in its raw precision\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter in its raw precision form\\n     */\\n    function _getAPrecise(SwapUtils.Swap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 t1 = self.futureATime; // time when ramp is finished\\n        uint256 a1 = self.futureA; // final A value when ramp is finished\\n\\n        if (block.timestamp < t1) {\\n            uint256 t0 = self.initialATime; // time when ramp is started\\n            uint256 a0 = self.initialA; // initial A value when ramp is started\\n            if (a1 > a0) {\\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\\n                return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\\n            } else {\\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\\n                return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\\n            }\\n        } else {\\n            return a1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\\n     * the limit range.\\n     * @param self Swap struct to update\\n     * @param futureA_ the new A to ramp towards\\n     * @param futureTime_ timestamp when the new A should be reached\\n     */\\n    function rampA(\\n        SwapUtils.Swap storage self,\\n        uint256 futureA_,\\n        uint256 futureTime_\\n    ) internal {\\n        require(\\n            block.timestamp >= self.initialATime + 1 days,\\n            \\\"Wait 1 day before starting ramp\\\"\\n        );\\n        require(\\n            futureTime_ >= block.timestamp + MIN_RAMP_TIME,\\n            \\\"Insufficient ramp time\\\"\\n        );\\n        require(\\n            futureA_ > 0 && futureA_ < MAX_A,\\n            \\\"futureA_ must be > 0 and < MAX_A\\\"\\n        );\\n\\n        uint256 initialAPrecise = _getAPrecise(self);\\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\\n\\n        if (futureAPrecise < initialAPrecise) {\\n            require(\\n                futureAPrecise * MAX_A_CHANGE >= initialAPrecise,\\n                \\\"futureA_ is too small\\\"\\n            );\\n        } else {\\n            require(\\n                futureAPrecise <= initialAPrecise * MAX_A_CHANGE,\\n                \\\"futureA_ is too large\\\"\\n            );\\n        }\\n\\n        self.initialA = initialAPrecise;\\n        self.futureA = futureAPrecise;\\n        self.initialATime = block.timestamp;\\n        self.futureATime = futureTime_;\\n\\n        emit RampA(\\n            initialAPrecise,\\n            futureAPrecise,\\n            block.timestamp,\\n            futureTime_\\n        );\\n    }\\n\\n    /**\\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\\n     * cannot be called for another 24 hours\\n     * @param self Swap struct to update\\n     */\\n    function stopRampA(SwapUtils.Swap storage self) internal {\\n        require(self.futureATime > block.timestamp, \\\"Ramp is already stopped\\\");\\n\\n        uint256 currentA = _getAPrecise(self);\\n        self.initialA = currentA;\\n        self.futureA = currentA;\\n        self.initialATime = block.timestamp;\\n        self.futureATime = block.timestamp;\\n\\n        emit StopRampA(currentA, block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0xfb99c1024c496a57ed7e31d35dc6e31d28fec7e344d1222ca542ee4bfc92d1b9\",\"license\":\"MIT\"},\"contracts/Portal/liquidityPool/utils/MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n/**\\n * @title MathUtils library\\n * @notice  Contains functions for calculating differences between two uint256.\\n */\\nlibrary MathUtils {\\n    /**\\n     * @notice Compares a and b and returns true if the difference between a and b\\n     *         is less than 1 or equal to each other.\\n     * @param a uint256 to compare with\\n     * @param b uint256 to compare with\\n     * @return True if the difference between a and b is less than 1 or equal,\\n     *         otherwise return false\\n     */\\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\\n        return (difference(a, b) <= 1);\\n    }\\n\\n    /**\\n     * @notice Calculates absolute difference between a and b\\n     * @param a uint256 to compare with\\n     * @param b uint256 to compare with\\n     * @return Difference between a and b\\n     */\\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a > b) {\\n            return a - b;\\n        }\\n        return b - a;\\n    }\\n}\\n\",\"keccak256\":\"0x090cab48ae6c4af2e1fe7956612a8344259bfbb1a7d4ea55d562c0f74a5b3bd7\",\"license\":\"MIT\"},\"contracts/Portal/liquidityPool/utils/SwapUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\nimport \\\"./MathUtils.sol\\\";\\nimport \\\"./AmplificationUtils.sol\\\";\\nimport {PERCENTAGE_DENOMINATOR} from \\\"../../utils/globals.sol\\\";\\nimport \\\"../../../interfaces/ILPToken.sol\\\";\\nimport \\\"../../../interfaces/IgETH.sol\\\";\\n\\n/**\\n * @title SwapUtils library\\n *\\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\\n * Admin functions should be protected within contracts using this library.\\n *\\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities with some changes.\\n * The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals\\n * relying on the Oracle Price, with the help of Liquidity Providers.\\n * It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions.\\n * Because the underlying price of the staked assets are expected to raise in time.\\n * One can see this similar to accomplishing a \\\"rebasing\\\" logic, with the help of a trusted price source.\\n *\\n * @dev Whenever \\\"Effective Balance\\\" is mentioned it refers to the balance projected with the underlying price.\\n */\\nlibrary SwapUtils {\\n  using MathUtils for uint256;\\n\\n  /*** EVENTS ***/\\n\\n  event TokenSwap(\\n    address indexed buyer,\\n    uint256 tokensSold,\\n    uint256 tokensBought,\\n    uint128 soldId,\\n    uint128 boughtId\\n  );\\n  event AddLiquidity(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256[2] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidity(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidityOne(\\n    address indexed provider,\\n    uint256 lpTokenAmount,\\n    uint256 lpTokenSupply,\\n    uint256 boughtId,\\n    uint256 tokensBought\\n  );\\n  event RemoveLiquidityImbalance(\\n    address indexed provider,\\n    uint256[2] tokenAmounts,\\n    uint256[2] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event NewAdminFee(uint256 newAdminFee);\\n  event NewSwapFee(uint256 newSwapFee);\\n\\n  /**\\n   * @param gETH ERC1155 contract reference\\n   * @param lpToken address of the LP Token\\n   * @param pooledTokenId gETH ID of the pooled derivative\\n   * @param initialA the amplification coefficient * n * (n - 1)\\n   * @param futureA the amplification coef that will be effective after futureATime\\n   * @param initialATime variable around the ramp management of A\\n   * @param futureATime variable around the ramp management of A\\n   * @param swapFee fee as a percentage/PERCENTAGE_DENOMINATOR, will be deducted from resulting tokens of a swap\\n   * @param adminFee fee as a percentage/PERCENTAGE_DENOMINATOR, will be deducted from swapFee\\n   * @param balances the pool balance as [ETH, gETH]; the contract's actual token balance might differ\\n   * @param __gap keep the contract size at 16\\n   */\\n  struct Swap {\\n    IgETH gETH;\\n    ILPToken lpToken;\\n    uint256 pooledTokenId;\\n    uint256 initialA;\\n    uint256 futureA;\\n    uint256 initialATime;\\n    uint256 futureATime;\\n    uint256 swapFee;\\n    uint256 adminFee;\\n    uint256[2] balances;\\n    uint256[8] __gap;\\n  }\\n\\n  // Struct storing variables used in calculations in the\\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\\n  struct CalculateWithdrawOneTokenDYInfo {\\n    uint256 d0;\\n    uint256 d1;\\n    uint256 newY;\\n    uint256 feePerToken;\\n    uint256 preciseA;\\n  }\\n\\n  // Struct storing variables used in calculations in the\\n  // {add,remove} Liquidity functions to avoid stack too deep errors\\n  struct ManageLiquidityInfo {\\n    ILPToken lpToken;\\n    uint256 d0;\\n    uint256 d1;\\n    uint256 d2;\\n    uint256 preciseA;\\n    uint256 totalSupply;\\n    uint256[2] balances;\\n  }\\n\\n  // Max swap fee is 1% or 100bps of each swap\\n  uint256 public constant MAX_SWAP_FEE = 10 ** 8;\\n\\n  // Max adminFee is 100% of the swapFee\\n  // adminFee does not add additional fee on top of swapFee\\n  // instead it takes a certain percentage of the swapFee.\\n  // Therefore it has no impact on users but only on the earnings of LPs\\n  uint256 public constant MAX_ADMIN_FEE = 10 ** 10;\\n\\n  // Constant value used as max loop limit\\n  uint256 private constant MAX_LOOP_LIMIT = 256;\\n\\n  /*** VIEW & PURE FUNCTIONS ***/\\n\\n  function _getAPrecise(Swap storage self) internal view returns (uint256) {\\n    return AmplificationUtils._getAPrecise(self);\\n  }\\n\\n  /**\\n   * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\n   * @param balance balance that will be taken into calculation\\n   * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\\n   */\\n  function _pricedIn(\\n    Swap storage self,\\n    uint256 balance,\\n    uint256 i\\n  ) internal view returns (uint256) {\\n    return\\n      i == 1\\n        ? (balance * self.gETH.pricePerShare(self.pooledTokenId)) /\\n          self.gETH.denominator()\\n        : balance;\\n  }\\n\\n  /**\\n   * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\n   * @param balance balance that will be taken into calculation\\n   * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\\n   */\\n  function _pricedOut(\\n    Swap storage self,\\n    uint256 balance,\\n    uint256 i\\n  ) internal view returns (uint256) {\\n    return\\n      i == 1\\n        ? (balance * self.gETH.denominator()) /\\n          self.gETH.pricePerShare(self.pooledTokenId)\\n        : balance;\\n  }\\n\\n  /**\\n   * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\n   * @param balances ARRAY of balances that will be taken into calculation\\n   */\\n  function _pricedInBatch(\\n    Swap storage self,\\n    uint256[2] memory balances\\n  ) internal view returns (uint256[2] memory _p) {\\n    _p[0] = balances[0];\\n    _p[1] =\\n      (balances[1] * self.gETH.pricePerShare(self.pooledTokenId)) /\\n      self.gETH.denominator();\\n    return _p;\\n  }\\n\\n  /**\\n   * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\n   * @param balances ARRAY of balances that will be taken into calculation\\n   */\\n  function _pricedOutBatch(\\n    Swap storage self,\\n    uint256[2] memory balances\\n  ) internal view returns (uint256[2] memory _p) {\\n    _p[0] = balances[0];\\n    _p[1] =\\n      (balances[1] * self.gETH.denominator()) /\\n      self.gETH.pricePerShare(self.pooledTokenId);\\n    return _p;\\n  }\\n\\n  /**\\n   * @notice Calculate the dy, the amount of selected token that user receives and\\n   * the fee of withdrawing in one token\\n   * @param tokenAmount the amount to withdraw in the pool's precision\\n   * @param tokenIndex which token will be withdrawn\\n   * @param self Swap struct to read from\\n   * @return the amount of token user will receive\\n   */\\n  function calculateWithdrawOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256) {\\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\\n      self,\\n      tokenAmount,\\n      tokenIndex,\\n      self.lpToken.totalSupply()\\n    );\\n    return availableTokenAmount;\\n  }\\n\\n  function _calculateWithdrawOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 totalSupply\\n  ) internal view returns (uint256, uint256) {\\n    uint256 dy;\\n    uint256 newY;\\n    uint256 currentY;\\n\\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(\\n      self,\\n      tokenIndex,\\n      tokenAmount,\\n      totalSupply\\n    );\\n\\n    uint256 dySwapFee = currentY - newY - dy;\\n\\n    return (dy, dySwapFee);\\n  }\\n\\n  /**\\n   * @notice Calculate the dy of withdrawing in one token\\n   * @param self Swap struct to read from\\n   * @param tokenIndex which token will be withdrawn\\n   * @param tokenAmount the amount to withdraw in the pools precision\\n   * @return the d and the new y after withdrawing one token\\n   */\\n  function calculateWithdrawOneTokenDY(\\n    Swap storage self,\\n    uint8 tokenIndex,\\n    uint256 tokenAmount,\\n    uint256 totalSupply\\n  ) internal view returns (uint256, uint256, uint256) {\\n    // Get the current D, then solve the stableswap invariant\\n    // y_i for D - tokenAmount\\n\\n    require(tokenIndex < 2, \\\"Token index out of range\\\");\\n\\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(\\n      0,\\n      0,\\n      0,\\n      0,\\n      0\\n    );\\n    v.preciseA = _getAPrecise(self);\\n    v.d0 = getD(_pricedInBatch(self, self.balances), v.preciseA);\\n    v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\\n\\n    require(\\n      tokenAmount <= self.balances[tokenIndex],\\n      \\\"Withdraw exceeds available\\\"\\n    );\\n\\n    v.newY = _pricedOut(\\n      self,\\n      getYD(v.preciseA, tokenIndex, _pricedInBatch(self, self.balances), v.d1),\\n      tokenIndex\\n    );\\n\\n    uint256[2] memory xpReduced;\\n\\n    v.feePerToken = self.swapFee / 2;\\n    for (uint256 i = 0; i < 2; ++i) {\\n      uint256 xpi = self.balances[i];\\n      xpReduced[i] =\\n        xpi -\\n        (((\\n          (i == tokenIndex)\\n            ? (xpi * v.d1) / v.d0 - v.newY\\n            : xpi - ((xpi * v.d1) / (v.d0))\\n        ) * (v.feePerToken)) / (PERCENTAGE_DENOMINATOR));\\n    }\\n\\n    uint256 dy = xpReduced[tokenIndex] -\\n      _pricedOut(\\n        self,\\n        (getYD(v.preciseA, tokenIndex, _pricedInBatch(self, xpReduced), v.d1)),\\n        tokenIndex\\n      );\\n    dy = dy - 1;\\n\\n    return (dy, v.newY, self.balances[tokenIndex]);\\n  }\\n\\n  /**\\n   * @notice Get Debt, The amount of buyback for stable pricing.\\n   * @param xp a  set of pool balances. Array should be the same cardinality\\n   * as the pool.\\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\n   * See the StableSwap paper for details\\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\\n   */\\n  function _getDebt(\\n    Swap storage self,\\n    uint256[2] memory xp,\\n    uint256 a\\n  ) internal view returns (uint256) {\\n    uint256 halfD = getD(xp, a) / 2;\\n    if (xp[0] >= halfD) {\\n      return 0;\\n    } else {\\n      uint256 dy = xp[1] - halfD;\\n      uint256 feeHalf = (dy * self.swapFee) / PERCENTAGE_DENOMINATOR / 2;\\n      uint256 debt = halfD - xp[0] + feeHalf;\\n      return debt;\\n    }\\n  }\\n\\n  /**\\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\\n   */\\n  function getDebt(Swap storage self) external view returns (uint256) {\\n    // might change when price is in.\\n    return\\n      _getDebt(self, _pricedInBatch(self, self.balances), _getAPrecise(self));\\n  }\\n\\n  /**\\n   * @notice Calculate the price of a token in the pool with given\\n   *  balances and a particular D.\\n   *\\n   * @dev This is accomplished via solving the invariant iteratively.\\n   * See the StableSwap paper and Curve.fi implementation for further details.\\n   *\\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\\n   * x_1**2 + b*x_1 = c\\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\\n   *\\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\\n   * @param tokenIndex Index of token we are calculating for.\\n   * @param xp a  set of pool balances. Array should be\\n   * the same cardinality as the pool.\\n   * @param d the stableswap invariant\\n   * @return the price of the token, in the same precision as in xp\\n   */\\n  function getYD(\\n    uint256 a,\\n    uint8 tokenIndex,\\n    uint256[2] memory xp,\\n    uint256 d\\n  ) internal pure returns (uint256) {\\n    uint256 numTokens = 2;\\n    require(tokenIndex < numTokens, \\\"Token not found\\\");\\n\\n    uint256 c = d;\\n    uint256 s;\\n    uint256 nA = a * numTokens;\\n\\n    for (uint256 i = 0; i < numTokens; ++i) {\\n      if (i != tokenIndex) {\\n        s = s + xp[i];\\n        c = (c * d) / (xp[i] * (numTokens));\\n        // If we were to protect the division loss we would have to keep the denominator separate\\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n        // c = c * D * D * D * ... overflow!\\n      }\\n    }\\n    c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\\n\\n    uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\n    uint256 yPrev;\\n    uint256 y = d;\\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; ++i) {\\n      yPrev = y;\\n      y = ((y * y) + c) / (2 * y + b - d);\\n      if (y.within1(yPrev)) {\\n        return y;\\n      }\\n    }\\n    revert(\\\"Approximation did not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\\n   * @param xp a  set of pool balances. Array should be the same cardinality\\n   * as the pool.\\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\n   * See the StableSwap paper for details\\n   * @return the invariant, at the precision of the pool\\n   */\\n  function getD(\\n    uint256[2] memory xp,\\n    uint256 a\\n  ) internal pure returns (uint256) {\\n    uint256 numTokens = 2;\\n    uint256 s = xp[0] + xp[1];\\n    if (s == 0) {\\n      return 0;\\n    }\\n\\n    uint256 prevD;\\n    uint256 d = s;\\n    uint256 nA = a * numTokens;\\n\\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; ++i) {\\n      uint256 dP = (d ** (numTokens + 1)) /\\n        (numTokens ** numTokens * xp[0] * xp[1]);\\n      prevD = d;\\n      d =\\n        ((((nA * s) / AmplificationUtils.A_PRECISION) + dP * numTokens) * (d)) /\\n        (((nA - AmplificationUtils.A_PRECISION) * (d)) /\\n          (AmplificationUtils.A_PRECISION) +\\n          ((numTokens + 1) * dP));\\n\\n      if (d.within1(prevD)) {\\n        return d;\\n      }\\n    }\\n\\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\\n    // function which does not rely on D.\\n    revert(\\\"D does not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Get the virtual price, to help calculate profit\\n   * @param self Swap struct to read from\\n   * @return the virtual price\\n   */\\n  function getVirtualPrice(Swap storage self) external view returns (uint256) {\\n    uint256 d = getD(_pricedInBatch(self, self.balances), _getAPrecise(self));\\n    ILPToken lpToken = self.lpToken;\\n    uint256 supply = lpToken.totalSupply();\\n    if (supply > 0) {\\n      return (d * 10 ** 18) / supply;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @notice Calculate the new balances of the tokens given the indexes of the token\\n   * that is swapped from (FROM) and the token that is swapped to (TO).\\n   * This function is used as a helper function to calculate how much TO token\\n   * the user should receive on swap.\\n   *\\n   * @param preciseA precise form of amplification coefficient\\n   * @param tokenIndexFrom index of FROM token\\n   * @param tokenIndexTo index of TO token\\n   * @param x the new total amount of FROM token\\n   * @param xp balances of the tokens in the pool\\n   * @return the amount of TO token that should remain in the pool\\n   */\\n  function getY(\\n    uint256 preciseA,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 x,\\n    uint256[2] memory xp\\n  ) internal pure returns (uint256) {\\n    uint256 numTokens = 2;\\n    require(tokenIndexFrom != tokenIndexTo, \\\"Can't compare token to itself\\\");\\n    require(\\n      tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\\n      \\\"Tokens must be in pool\\\"\\n    );\\n\\n    uint256 d = getD(xp, preciseA);\\n    uint256 c = d;\\n    uint256 s = x;\\n    uint256 nA = numTokens * (preciseA);\\n\\n    c = (c * d) / (x * numTokens);\\n    c = (c * d * (AmplificationUtils.A_PRECISION)) / (nA * numTokens);\\n    uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\n\\n    uint256 yPrev;\\n    uint256 y = d;\\n    for (uint256 i = 0; i < MAX_LOOP_LIMIT; ++i) {\\n      yPrev = y;\\n      y = ((y * y) + c) / (2 * y + b - d);\\n      if (y.within1(yPrev)) {\\n        return y;\\n      }\\n    }\\n    revert(\\\"Approximation did not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Externally calculates a swap between two tokens.\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @return dy the number of tokens the user will get\\n   */\\n  function calculateSwap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256 dy) {\\n    (dy, ) = _calculateSwap(\\n      self,\\n      tokenIndexFrom,\\n      tokenIndexTo,\\n      dx,\\n      self.balances\\n    );\\n  }\\n\\n  /**\\n   * @notice Internally calculates a swap between two tokens.\\n   *\\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\\n   * using the token contracts.\\n   *\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @return dy the number of tokens the user will get\\n   * @return dyFee the associated fee\\n   */\\n  function _calculateSwap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256[2] memory balances\\n  ) internal view returns (uint256 dy, uint256 dyFee) {\\n    require(\\n      tokenIndexFrom < balances.length && tokenIndexTo < balances.length,\\n      \\\"Token index out of range\\\"\\n    );\\n    uint256 x = _pricedIn(self, dx + balances[tokenIndexFrom], tokenIndexFrom);\\n\\n    uint256[2] memory pricedBalances = _pricedInBatch(self, balances);\\n\\n    uint256 y = _pricedOut(\\n      self,\\n      getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, pricedBalances),\\n      tokenIndexTo // => not id, index !!!\\n    );\\n    dy = balances[tokenIndexTo] - y - 1;\\n    dyFee = (dy * self.swapFee) / (PERCENTAGE_DENOMINATOR);\\n    dy = dy - dyFee;\\n  }\\n\\n  /**\\n   * @notice Uses _calculateRemoveLiquidity with Effective Balances,\\n   * then projects the prices to the token amounts\\n   * to get Real Balances, before removing them from pool.\\n   */\\n  function calculateRemoveLiquidity(\\n    Swap storage self,\\n    uint256 amount\\n  ) external view returns (uint256[2] memory) {\\n    return\\n      _pricedOutBatch(\\n        self,\\n        _calculateRemoveLiquidity(\\n          _pricedInBatch(self, self.balances),\\n          amount,\\n          self.lpToken.totalSupply()\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate amount of each underlying\\n   * tokens that is returned upon burning given amount of\\n   * LP tokens\\n   *\\n   * @param amount the amount of LP tokens that would to be burned on\\n   * withdrawal\\n   * @return amounts of tokens user will receive as an array [ETH, gETH]\\n   */\\n  function _calculateRemoveLiquidity(\\n    uint256[2] memory balances,\\n    uint256 amount,\\n    uint256 totalSupply\\n  ) internal pure returns (uint256[2] memory amounts) {\\n    require(amount <= totalSupply, \\\"Cannot exceed total supply\\\");\\n\\n    amounts[0] = (balances[0] * amount) / totalSupply;\\n    amounts[1] = (balances[1] * amount) / totalSupply;\\n\\n    return amounts;\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate prices from deposits or\\n   * withdrawals, excluding fees but including slippage. This is\\n   * helpful as an input into the various \\\"min\\\" parameters on calls\\n   * to fight front-running\\n   *\\n   * @dev This shouldn't be used outside frontends for user estimates.\\n   *\\n   * @param self Swap struct to read from\\n   * @param amounts an array of token amounts to deposit or withdrawal,\\n   * corresponding to pooledTokens. The amount should be in each\\n   * pooled token's native precision. If a token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @param deposit whether this is a deposit or a withdrawal\\n   * @return if deposit was true, total amount of lp token that will be minted and if\\n   * deposit was false, total amount of lp token that will be burned\\n   */\\n  function calculateTokenAmount(\\n    Swap storage self,\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256) {\\n    uint256 a = _getAPrecise(self);\\n    uint256[2] memory balances = self.balances;\\n\\n    uint256 d0 = getD(_pricedInBatch(self, balances), a);\\n    for (uint256 i = 0; i < balances.length; ++i) {\\n      if (deposit) {\\n        balances[i] = balances[i] + amounts[i];\\n      } else {\\n        require(\\n          amounts[i] <= balances[i],\\n          \\\"Cannot withdraw more than available\\\"\\n        );\\n        balances[i] = balances[i] - amounts[i];\\n      }\\n    }\\n    uint256 d1 = getD(_pricedInBatch(self, balances), a);\\n    uint256 totalSupply = self.lpToken.totalSupply();\\n\\n    if (deposit) {\\n      return ((d1 - d0) * totalSupply) / d0;\\n    } else {\\n      return ((d0 - d1) * totalSupply) / d0;\\n    }\\n  }\\n\\n  /**\\n   * @notice return accumulated amount of admin fees of the token with given index\\n   * @param self Swap struct to read from\\n   * @param index Index of the pooled token\\n   * @return admin balance in the token's precision\\n   */\\n  function getAdminBalance(\\n    Swap storage self,\\n    uint256 index\\n  ) external view returns (uint256) {\\n    require(index < 2, \\\"Token index out of range\\\");\\n    if (index == 0) return address(this).balance - (self.balances[index]);\\n\\n    if (index == 1)\\n      return\\n        self.gETH.balanceOf(address(this), self.pooledTokenId) -\\n        (self.balances[index]);\\n    return 0;\\n  }\\n\\n  /*** STATE MODIFYING FUNCTIONS ***/\\n\\n  /**\\n   * @notice swap two tokens in the pool\\n   * @param self Swap struct to read from and write to\\n   * @param tokenIndexFrom the token the user wants to sell\\n   * @param tokenIndexTo the token the user wants to buy\\n   * @param dx the amount of tokens the user wants to sell\\n   * @param minDy the min amount the user would like to receive, or revert.\\n   * @return amount of token user received on swap\\n   */\\n  function swap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy\\n  ) external returns (uint256) {\\n    IgETH gETHReference = self.gETH;\\n    if (tokenIndexFrom == 0) {\\n      // Means user is selling some ETH to the pool to get some gETH.\\n      // In which case, we need to send exactly that amount of ETH.\\n      require(dx == msg.value, \\\"Cannot swap more/less than you sent\\\");\\n    }\\n    if (tokenIndexFrom == 1) {\\n      // Means user is selling some gETH to the pool to get some ETH.\\n\\n      require(\\n        dx <= gETHReference.balanceOf(msg.sender, self.pooledTokenId),\\n        \\\"Cannot swap more than you own\\\"\\n      );\\n\\n      // Transfer tokens first\\n      uint256 beforeBalance = gETHReference.balanceOf(\\n        address(this),\\n        self.pooledTokenId\\n      );\\n      gETHReference.safeTransferFrom(\\n        msg.sender,\\n        address(this),\\n        self.pooledTokenId,\\n        dx,\\n        \\\"\\\"\\n      );\\n\\n      // Use the actual transferred amount for AMM math\\n      dx =\\n        gETHReference.balanceOf(address(this), self.pooledTokenId) -\\n        beforeBalance;\\n    }\\n\\n    uint256 dy;\\n    uint256 dyFee;\\n    // Meaning the real balances *without* any effect of underlying price\\n    // However, when we call _calculateSwap, it uses pricedIn function before calculation,\\n    // and pricedOut function after the calculation. So, we don't need to use priceOut here.\\n    uint256[2] memory balances = self.balances;\\n    (dy, dyFee) = _calculateSwap(\\n      self,\\n      tokenIndexFrom,\\n      tokenIndexTo,\\n      dx,\\n      balances\\n    );\\n\\n    require(dy >= minDy, \\\"Swap didn't result in min tokens\\\");\\n    uint256 dyAdminFee = (dyFee * self.adminFee) / PERCENTAGE_DENOMINATOR;\\n\\n    // To prevent any Reentrancy, balances are updated before transfering the tokens.\\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\\n\\n    if (tokenIndexTo == 0) {\\n      // Means contract is going to send Idle Ether (ETH)\\n      (bool sent, ) = payable(msg.sender).call{value: dy}(\\\"\\\");\\n      require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\n    }\\n    if (tokenIndexTo == 1) {\\n      // Means contract is going to send staked ETH (gETH)\\n      gETHReference.safeTransferFrom(\\n        address(this),\\n        msg.sender,\\n        self.pooledTokenId,\\n        dy,\\n        \\\"\\\"\\n      );\\n    }\\n\\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n    return dy;\\n  }\\n\\n  /**\\n   * @notice Add liquidity to the pool\\n   * @param self Swap struct to read from and write to\\n   * @param amounts the amounts of each token to add, in their native precision\\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\\n   * should mint, otherwise revert. Handy for front-running mitigation\\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\\n   * @return amount of LP token user received\\n   */\\n  function addLiquidity(\\n    Swap storage self,\\n    uint256[2] memory amounts,\\n    uint256 minToMint\\n  ) external returns (uint256) {\\n    require(\\n      amounts[0] == msg.value,\\n      \\\"SwapUtils: received less or more ETH than expected\\\"\\n    );\\n    IgETH gETHReference = self.gETH;\\n    // current state\\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\\n      self.lpToken,\\n      0,\\n      0,\\n      0,\\n      _getAPrecise(self),\\n      0,\\n      self.balances\\n    );\\n    v.totalSupply = v.lpToken.totalSupply();\\n    if (v.totalSupply != 0) {\\n      v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\\n    }\\n\\n    uint256[2] memory newBalances;\\n    newBalances[0] = v.balances[0] + msg.value;\\n\\n    for (uint256 i = 0; i < 2; ++i) {\\n      require(\\n        v.totalSupply != 0 || amounts[i] > 0,\\n        \\\"Must supply all tokens in pool\\\"\\n      );\\n    }\\n\\n    {\\n      // Transfer tokens first\\n      uint256 beforeBalance = gETHReference.balanceOf(\\n        address(this),\\n        self.pooledTokenId\\n      );\\n      gETHReference.safeTransferFrom(\\n        msg.sender,\\n        address(this),\\n        self.pooledTokenId,\\n        amounts[1],\\n        \\\"\\\"\\n      );\\n\\n      // Update the amounts[] with actual transfer amount\\n      amounts[1] =\\n        gETHReference.balanceOf(address(this), self.pooledTokenId) -\\n        beforeBalance;\\n\\n      newBalances[1] = v.balances[1] + amounts[1];\\n    }\\n\\n    // invariant after change\\n    v.d1 = getD(_pricedInBatch(self, newBalances), v.preciseA);\\n    require(v.d1 > v.d0, \\\"D should increase\\\");\\n\\n    // updated to reflect fees and calculate the user's LP tokens\\n    v.d2 = v.d1;\\n    uint256[2] memory fees;\\n\\n    if (v.totalSupply != 0) {\\n      uint256 feePerToken = self.swapFee / 2;\\n      for (uint256 i = 0; i < 2; ++i) {\\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\n        fees[i] =\\n          (feePerToken * (idealBalance.difference(newBalances[i]))) /\\n          (PERCENTAGE_DENOMINATOR);\\n        self.balances[i] =\\n          newBalances[i] -\\n          ((fees[i] * (self.adminFee)) / (PERCENTAGE_DENOMINATOR));\\n        newBalances[i] = newBalances[i] - (fees[i]);\\n      }\\n      v.d2 = getD(_pricedInBatch(self, newBalances), v.preciseA);\\n    } else {\\n      // the initial depositor doesn't pay fees\\n      self.balances = newBalances;\\n    }\\n\\n    uint256 toMint;\\n    if (v.totalSupply == 0) {\\n      toMint = v.d1;\\n    } else {\\n      toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\\n    }\\n\\n    require(toMint >= minToMint, \\\"Couldn't mint min requested\\\");\\n\\n    // mint the user's LP tokens\\n    v.lpToken.mint(msg.sender, toMint);\\n\\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\\n    return toMint;\\n  }\\n\\n  /**\\n   * @notice Burn LP tokens to remove liquidity from the pool.\\n   * @dev Liquidity can always be removed, even when the pool is paused.\\n   * @param self Swap struct to read from and write to\\n   * @param amount the amount of LP tokens to burn\\n   * @param minAmounts the minimum amounts of each token in the pool\\n   * acceptable for this burn. Useful as a front-running mitigation\\n   * @return amounts of tokens the user received\\n   */\\n  function removeLiquidity(\\n    Swap storage self,\\n    uint256 amount,\\n    uint256[2] calldata minAmounts\\n  ) external returns (uint256[2] memory) {\\n    ILPToken lpToken = self.lpToken;\\n    IgETH gETHReference = self.gETH;\\n    require(amount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n\\n    uint256[2] memory balances = self.balances;\\n    uint256 totalSupply = lpToken.totalSupply();\\n\\n    uint256[2] memory amounts = _pricedOutBatch(\\n      self,\\n      _calculateRemoveLiquidity(\\n        _pricedInBatch(self, balances),\\n        amount,\\n        totalSupply\\n      )\\n    );\\n\\n    for (uint256 i = 0; i < amounts.length; ++i) {\\n      require(amounts[i] >= minAmounts[i], \\\"amounts[i] < minAmounts[i]\\\");\\n      self.balances[i] = balances[i] - amounts[i];\\n    }\\n\\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\n    lpToken.burnFrom(msg.sender, amount);\\n\\n    (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\\\"\\\");\\n    require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\n\\n    gETHReference.safeTransferFrom(\\n      address(this),\\n      msg.sender,\\n      self.pooledTokenId,\\n      amounts[1],\\n      \\\"\\\"\\n    );\\n\\n    emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\\n    return amounts;\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool all in one token.\\n   * @param self Swap struct to read from and write to\\n   * @param tokenAmount the amount of the lp tokens to burn\\n   * @param tokenIndex the index of the token you want to receive\\n   * @param minAmount the minimum amount to withdraw, otherwise revert\\n   * @return amount chosen token that user received\\n   */\\n  function removeLiquidityOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount\\n  ) external returns (uint256) {\\n    ILPToken lpToken = self.lpToken;\\n    IgETH gETHReference = self.gETH;\\n\\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n    require(tokenIndex < 2, \\\"Token not found\\\");\\n\\n    uint256 totalSupply = lpToken.totalSupply();\\n\\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\\n      self,\\n      tokenAmount,\\n      tokenIndex,\\n      totalSupply\\n    );\\n\\n    require(dy >= minAmount, \\\"dy < minAmount\\\");\\n\\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\n    self.balances[tokenIndex] =\\n      self.balances[tokenIndex] -\\n      (dy + ((dyFee * (self.adminFee)) / (PERCENTAGE_DENOMINATOR)));\\n    lpToken.burnFrom(msg.sender, tokenAmount);\\n\\n    if (tokenIndex == 0) {\\n      (bool sent, ) = payable(msg.sender).call{value: dy}(\\\"\\\");\\n      require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\n    }\\n    if (tokenIndex == 1) {\\n      gETHReference.safeTransferFrom(\\n        address(this),\\n        msg.sender,\\n        self.pooledTokenId,\\n        dy,\\n        \\\"\\\"\\n      );\\n    }\\n\\n    emit RemoveLiquidityOne(\\n      msg.sender,\\n      tokenAmount,\\n      totalSupply,\\n      tokenIndex,\\n      dy\\n    );\\n\\n    return dy;\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool, weighted differently than the\\n   * pool's current balances.\\n   *\\n   * @param self Swap struct to read from and write to\\n   * @param amounts how much of each token to withdraw\\n   * @param maxBurnAmount the max LP token provider is willing to pay to\\n   * remove liquidity. Useful as a front-running mitigation.\\n   * @return actual amount of LP tokens burned in the withdrawal\\n   */\\n  function removeLiquidityImbalance(\\n    Swap storage self,\\n    uint256[2] memory amounts,\\n    uint256 maxBurnAmount\\n  ) public returns (uint256) {\\n    IgETH gETHReference = self.gETH;\\n\\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\\n      self.lpToken,\\n      0,\\n      0,\\n      0,\\n      _getAPrecise(self),\\n      0,\\n      self.balances\\n    );\\n    v.totalSupply = v.lpToken.totalSupply();\\n\\n    require(\\n      maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0,\\n      \\\">LP.balanceOf\\\"\\n    );\\n\\n    uint256 feePerToken = self.swapFee / 2;\\n    uint256[2] memory fees;\\n\\n    {\\n      uint256[2] memory balances1;\\n\\n      v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\\n      for (uint256 i = 0; i < 2; ++i) {\\n        require(\\n          amounts[i] <= v.balances[i],\\n          \\\"Cannot withdraw more than available\\\"\\n        );\\n        balances1[i] = v.balances[i] - amounts[i];\\n      }\\n      v.d1 = getD(_pricedInBatch(self, balances1), v.preciseA);\\n\\n      for (uint256 i = 0; i < 2; ++i) {\\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\n        uint256 difference = idealBalance.difference(balances1[i]);\\n        fees[i] = (feePerToken * difference) / PERCENTAGE_DENOMINATOR;\\n        uint256 adminFee = self.adminFee;\\n        {\\n          self.balances[i] =\\n            balances1[i] -\\n            ((fees[i] * adminFee) / PERCENTAGE_DENOMINATOR);\\n        }\\n        balances1[i] = balances1[i] - fees[i];\\n      }\\n\\n      v.d2 = getD(_pricedInBatch(self, balances1), v.preciseA);\\n    }\\n\\n    uint256 tokenAmount = ((v.d0 - v.d2) * (v.totalSupply)) / v.d0;\\n    require(tokenAmount != 0, \\\"Burnt amount cannot be zero\\\");\\n    tokenAmount = tokenAmount + 1;\\n\\n    require(tokenAmount <= maxBurnAmount, \\\"tokenAmount > maxBurnAmount\\\");\\n\\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\\n\\n    (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\\\"\\\");\\n    require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\n\\n    gETHReference.safeTransferFrom(\\n      address(this),\\n      msg.sender,\\n      self.pooledTokenId,\\n      amounts[1],\\n      \\\"\\\"\\n    );\\n\\n    emit RemoveLiquidityImbalance(\\n      msg.sender,\\n      amounts,\\n      fees,\\n      v.d1,\\n      v.totalSupply - tokenAmount\\n    );\\n\\n    return tokenAmount;\\n  }\\n\\n  /**\\n   * @notice withdraw all admin fees to a given address\\n   * @param self Swap struct to withdraw fees from\\n   * @param to Address to send the fees to\\n   */\\n  function withdrawAdminFees(Swap storage self, address to) external {\\n    IgETH gETHReference = self.gETH;\\n    uint256 tokenBalance = gETHReference.balanceOf(\\n      address(this),\\n      self.pooledTokenId\\n    ) - self.balances[1];\\n    if (tokenBalance != 0) {\\n      gETHReference.safeTransferFrom(\\n        address(this),\\n        to,\\n        self.pooledTokenId,\\n        tokenBalance,\\n        \\\"\\\"\\n      );\\n    }\\n\\n    uint256 etherBalance = address(this).balance - self.balances[0];\\n    if (etherBalance != 0) {\\n      (bool sent, ) = payable(msg.sender).call{value: etherBalance}(\\\"\\\");\\n      require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the admin fee\\n   * @dev adminFee cannot be higher than 100% of the swap fee\\n   * @param self Swap struct to update\\n   * @param newAdminFee new admin fee to be applied on future transactions\\n   */\\n  function setAdminFee(Swap storage self, uint256 newAdminFee) external {\\n    require(newAdminFee <= MAX_ADMIN_FEE, \\\"Fee is too high\\\");\\n    self.adminFee = newAdminFee;\\n\\n    emit NewAdminFee(newAdminFee);\\n  }\\n\\n  /**\\n   * @notice update the swap fee\\n   * @dev fee cannot be higher than 1% of each swap\\n   * @param self Swap struct to update\\n   * @param newSwapFee new swap fee to be applied on future transactions\\n   */\\n  function setSwapFee(Swap storage self, uint256 newSwapFee) external {\\n    require(newSwapFee <= MAX_SWAP_FEE, \\\"Fee is too high\\\");\\n    self.swapFee = newSwapFee;\\n\\n    emit NewSwapFee(newSwapFee);\\n  }\\n}\\n\",\"keccak256\":\"0xba3ff7cff09b5a8a14b804c682dd930aa67abcea3a34604fac43180eda9ae433\",\"license\":\"MIT\"},\"contracts/Portal/utils/globals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\n// PERCENTAGE_DENOMINATOR represents 100%\\nuint256 constant PERCENTAGE_DENOMINATOR = 10 ** 10;\\n\\n/**\\n * @notice ID_TYPE is like an ENUM, widely used within Portal and Modules like Withdrawal Contract\\n * @dev Why not use enums, they basically do the same thing?\\n * * We like using a explicit defined uints than linearly increasing ones.\\n */\\nlibrary ID_TYPE {\\n  /// @notice TYPE 0: *invalid*\\n  uint256 internal constant NONE = 0;\\n\\n  /// @notice TYPE 1: Senate and Senate Election Proposals\\n  uint256 internal constant SENATE = 1;\\n\\n  /// @notice TYPE 2: Contract Upgrade\\n  uint256 internal constant CONTRACT_UPGRADE = 2;\\n\\n  /// @notice TYPE 3: *gap*: formally represented the admin contract, now reserved to be never used\\n  uint256 internal constant __GAP__ = 3;\\n\\n  /// @notice TYPE 4: Node Operators\\n  uint256 internal constant OPERATOR = 4;\\n\\n  /// @notice TYPE 5: Staking Pools\\n  uint256 internal constant POOL = 5;\\n\\n  /// @notice TYPE 21: Module: Withdrawal Contract\\n  uint256 internal constant MODULE_WITHDRAWAL_CONTRACT = 21;\\n\\n  /// @notice TYPE 31: Module: A new gETH interface\\n  uint256 internal constant MODULE_GETH_INTERFACE = 31;\\n\\n  /// @notice TYPE 41: Module: A new Liquidity Pool\\n  uint256 internal constant MODULE_LIQUDITY_POOL = 41;\\n\\n  /// @notice TYPE 42: Module: A new Liquidity Pool token\\n  uint256 internal constant MODULE_LIQUDITY_POOL_TOKEN = 42;\\n}\\n\\n/**\\n * @notice VALIDATOR_STATE keeping track of validators within The Staking Library\\n */\\nlibrary VALIDATOR_STATE {\\n  /// @notice STATE 0: *invalid*\\n  uint8 internal constant NONE = 0;\\n\\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract\\n  uint8 internal constant PROPOSED = 1;\\n\\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator\\n  uint8 internal constant ACTIVE = 2;\\n\\n  /// @notice STATE 3: validator is exited, not currently used much\\n  uint8 internal constant EXITED = 3;\\n\\n  /// @notice STATE 69: proposal was malicious(alien), maybe faulty signatures or probably: (https://bit.ly/3Tkc6UC)\\n  uint8 internal constant ALIENATED = 69;\\n}\\n\",\"keccak256\":\"0xda2ab3b886f2e31a1c6dabf2115aead8022e6b91bf0495e3793b7a5189824478\",\"license\":\"MIT\"},\"contracts/interfaces/ILPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\ninterface ILPToken {\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external\\n        returns (bool);\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        external\\n        returns (bool);\\n\\n    function initialize(string memory name, string memory symbol)\\n        external\\n        returns (bool);\\n\\n    function mint(address recipient, uint256 amount) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\",\"keccak256\":\"0x7ee52a6c1db3c279a92be6c04ccd6dbbafed5f4476dc16007e4e8465a00a313f\",\"license\":\"MIT\"},\"contracts/interfaces/ISwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.7;\\n\\nimport \\\"./IgETH.sol\\\";\\n\\ninterface ISwap {\\n  // pool data view functions\\n  function getERC1155() external view returns (address);\\n\\n  function getA() external view returns (uint256);\\n\\n  function getAPrecise() external view returns (uint256);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function getToken() external view returns (uint256);\\n\\n  function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  function getDebt() external view returns (uint256);\\n\\n  function getAdminBalance(uint256 index) external view returns (uint256);\\n\\n  // min return calculation functions\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(\\n    uint256 amount\\n  ) external view returns (uint256[2] memory);\\n\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256 availableTokenAmount);\\n\\n  // state modifying functions\\n  function initialize(\\n    IgETH _gEth,\\n    uint256 _pooledTokenId,\\n    string memory lpTokenName,\\n    string memory lpTokenSymbol,\\n    address lpTokenTargetAddress,\\n    address owner\\n  ) external returns (address lpToken);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[2] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function withdrawAdminFees() external;\\n\\n  function setAdminFee(uint256 newAdminFee) external;\\n\\n  function setSwapFee(uint256 newSwapFee) external;\\n\\n  function rampA(uint256 futureA, uint256 futureTime) external;\\n\\n  function stopRampA() external;\\n}\\n\",\"keccak256\":\"0x34510bc5e9065f86a20fae5ca94b71a9333d141484c99254efb47845f3a74490\",\"license\":\"MIT\"},\"contracts/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.7;\\n\\ninterface IgETH {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    function uri(uint256) external view returns (string memory);\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    function burn(address account, uint256 id, uint256 value) external;\\n\\n    function burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) external;\\n\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    function exists(uint256 id) external view returns (bool);\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    // gETH Specials\\n\\n    function denominator() external view returns (uint256);\\n\\n    function pricePerShare(uint256 id) external view returns (uint256);\\n\\n    function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\n\\n    function setPricePerShare(uint256 price, uint256 id) external;\\n\\n    function isInterface(\\n        address _interface,\\n        uint256 id\\n    ) external view returns (bool);\\n\\n    function isAvoider(\\n        address account,\\n        uint256 id\\n    ) external view returns (bool);\\n\\n    function avoidInterfaces(uint256 id, bool isAvoid) external;\\n\\n    function setInterface(address _interface, uint256 id, bool isSet) external;\\n\\n    function updateMinterRole(address Minter) external;\\n\\n    function updatePauserRole(address Pauser) external;\\n\\n    function updateOracleRole(address Oracle) external;\\n}\\n\",\"keccak256\":\"0xda89519bc8f6f3ece7bfd842d379fbfba768080cc0de0b6983065be4ec73af14\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061252d806100206000396000f3fe6080604052600436106101f95760003560e01c80638456cb591161010d578063c4db7fa0116100a0578063e25aa5fa1161006f578063e25aa5fa146105f3578063ef0a712f14610608578063f23a6e6114610628578063f2fad2b614610654578063f2fde38b1461067457600080fd5b8063c4db7fa014610586578063d46300fd1461059b578063d4cadf68146105b0578063d6f0df62146105c657600080fd5b806391ceb3eb116100dc57806391ceb3eb146104e1578063a95b089f14610501578063bc197c8114610521578063bfc65c9b1461056657600080fd5b80638456cb591461047b5780638beb60b6146104905780638da5cb5b146104b057806391695586146104ce57600080fd5b80633e3a1560116101905780635c975abb1161015f5780635c975abb146103735780635fd65f0f1461038b578063715018a6146104265780637e0ccbff1461043b578063820fc5bd1461045b57600080fd5b80633e3a15601461030b5780633f4ba83a1461032b57806346eda74914610340578063593d132c1461035357600080fd5b806314a6bf0f116101cc57806314a6bf0f146102a057806321df0da7146102b5578063342a87a1146102cb57806334e19907146102eb57600080fd5b806301ffc9a7146101fe5780630419b45a146102335780630526930c1461024a5780630ba819591461027d575b600080fd5b34801561020a57600080fd5b5061021e61021936600461200f565b610694565b60405190151581526020015b60405180910390f35b34801561023f57600080fd5b506102486106cb565b005b34801561025657600080fd5b5061015f546001600160a01b03165b6040516001600160a01b03909116815260200161022a565b34801561028957600080fd5b50610292610773565b60405190815260200161022a565b3480156102ac57600080fd5b50610292610785565b3480156102c157600080fd5b5061016154610292565b3480156102d757600080fd5b506102926102e6366004612169565b61080d565b3480156102f757600080fd5b506102486103063660046120df565b6108ac565b34801561031757600080fd5b50610292610326366004612195565b610923565b34801561033757600080fd5b50610248610a0f565b61029261034e366004611f36565b610a1f565b34801561035f57600080fd5b5061024861036e366004612147565b610aec565b34801561037f57600080fd5b5060655460ff1661021e565b34801561039757600080fd5b5061015f5461016054610161546101625461016354610164546101655461016654610167546103d7986001600160a01b0390811698169695949392919089565b604080516001600160a01b039a8b1681529990981660208a0152968801959095526060870193909352608086019190915260a085015260c084015260e08301526101008201526101200161022a565b34801561043257600080fd5b50610248610b05565b34801561044757600080fd5b50610292610456366004611efe565b610b17565b34801561046757600080fd5b50610265610476366004612039565b610b57565b34801561048757600080fd5b50610248610f5e565b34801561049c57600080fd5b506102486104ab3660046120df565b610f6e565b3480156104bc57600080fd5b506033546001600160a01b0316610265565b6102926104dc366004612227565b610fb6565b3480156104ed57600080fd5b506102926104fc3660046121d0565b6110a2565b34801561050d57600080fd5b5061029261051c3660046121eb565b611116565b34801561052d57600080fd5b5061054d61053c366004611de7565b63bc197c8160e01b95945050505050565b6040516001600160e01b0319909116815260200161022a565b34801561057257600080fd5b50610292610581366004611f36565b6111b5565b34801561059257600080fd5b50610248611225565b3480156105a757600080fd5b50610292611238565b3480156105bc57600080fd5b5061016654610292565b3480156105d257600080fd5b506105e66105e1366004612111565b611245565b60405161022a91906122c1565b3480156105ff57600080fd5b50610292611302565b34801561061457600080fd5b506102926106233660046120df565b61133e565b34801561063457600080fd5b5061054d610643366004611e95565b63f23a6e6160e01b95945050505050565b34801561066057600080fd5b506105e661066f3660046120df565b6113cc565b34801561068057600080fd5b5061024861068f366004611dca565b61145e565b60006001600160e01b03198216630271189760e51b14806106c557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6106d36114d7565b6106db611531565b7309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e6324c5c75161015f61070a6033546001600160a01b031690565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260440160006040518083038186803b15801561074f57600080fd5b505af4158015610763573d6000803e3d6000fd5b505050506107716001609755565b565b600061078061015f611592565b905090565b60405163550670c360e11b815261015f60048201526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063aa0ce186906024015b60206040518083038186803b1580156107d557600080fd5b505af41580156107e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078091906120f8565b60405163703493a160e11b815261015f60048201526024810183905260ff821660448201526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063e0692742906064015b60206040518083038186803b15801561086d57600080fd5b505af4158015610881573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a591906120f8565b9392505050565b6108b46114d7565b60405163119f861b60e21b815261015f6004820152602481018290527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063467e186c906044015b60006040518083038186803b15801561090857600080fd5b505af415801561091c573d6000803e3d6000fd5b5050505050565b600061092d611531565b61093561159d565b818042111561095f5760405162461bcd60e51b815260040161095690612362565b60405180910390fd5b60405163e7a4db8160e01b815261015f60048201526024810187905260ff86166044820152606481018590527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063e7a4db819060840160206040518083038186803b1580156109c257600080fd5b505af41580156109d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fa91906120f8565b915050610a076001609755565b949350505050565b610a176114d7565b6107716115e3565b6000610a29611531565b610a3161159d565b8180421115610a525760405162461bcd60e51b815260040161095690612362565b60405163a596460760e01b81527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063a596460790610a8f9061015f90899089906004016123b1565b60206040518083038186803b158015610aa757600080fd5b505af4158015610abb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf91906120f8565b9150506108a56001609755565b610af46114d7565b610b0161015f8383611635565b5050565b610b0d6114d7565b6107716000611881565b6040516337b8b34360e01b81526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e906337b8b343906108559061015f9087908790600401612392565b60008054610100900460ff1615808015610b785750600054600160ff909116105b80610b925750303b158015610b92575060005460ff166001145b610bf55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610956565b6000805460ff191660011790558015610c18576000805461ff0019166101001790555b610c206118d3565b610c28611912565b610c30611941565b6001600160a01b038416610c995760405162461bcd60e51b815260206004820152602a60248201527f537761703a206c70546f6b656e546172676574416464726573732063616e206e6044820152696f74206265207a65726f60b01b6064820152608401610956565b6001600160a01b038316610cef5760405162461bcd60e51b815260206004820152601b60248201527f537761703a206f776e65722063616e206e6f74206265207a65726f00000000006044820152606401610956565b6001600160a01b038816610d455760405162461bcd60e51b815260206004820152601b60248201527f537761703a205f674554482063616e206e6f74206265207a65726f00000000006044820152606401610956565b86610d9e5760405162461bcd60e51b8152602060048201526024808201527f537761703a205f706f6f6c6564546f6b656e49642063616e206e6f74206265206044820152637a65726f60e01b6064820152608401610956565b6000610da985611968565b60405163266c45bb60e11b81529091506001600160a01b03821690634cd88b7690610dda908a908a906004016122f2565b602060405180830381600087803b158015610df457600080fd5b505af1158015610e08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2c9190611ff2565b610e835760405162461bcd60e51b815260206004820152602260248201527f537761703a20636f756c64206e6f7420696e6974206c70546f6b656e20636c6f6044820152616e6560f01b6064820152608401610956565b61015f80546001600160a01b03808c166001600160a01b031992831617909255610160805492841692909116919091179055610161889055610ec76064603c61245c565b61016255610ed76064603c61245c565b61016355612710610eee6402540be400600461245c565b610ef8919061243a565b61016655600061016755610f0b8461145e565b91508015610f53576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b509695505050505050565b610f666114d7565b610771611a02565b610f766114d7565b604051633823393b60e11b815261015f6004820152602481018290527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e906370467276906044016108f0565b6000610fc0611531565b610fc861159d565b8180421115610fe95760405162461bcd60e51b815260040161095690612362565b60405163529cbd9160e11b815261015f600482015260ff80891660248301528716604482015260648101869052608481018590527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063a5397b229060a40160206040518083038186803b15801561105457600080fd5b505af4158015611068573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061108c91906120f8565b9150506110996001609755565b95945050505050565b600060028260ff16106110f75760405162461bcd60e51b815260206004820152601860248201527f537761703a20496e646578206f7574206f662072616e676500000000000000006044820152606401610956565b61016860ff83166002811061110e5761110e6124a8565b015492915050565b6040516312c8d80f60e21b815261015f600482015260ff808516602483015283166044820152606481018290526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e90634b23603c9060840160206040518083038186803b15801561117d57600080fd5b505af4158015611191573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0791906120f8565b60006111bf611531565b6111c761159d565b81804211156111e85760405162461bcd60e51b815260040161095690612362565b60405163c36b87e960e01b81527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063c36b87e990610a8f9061015f90899089906004016123b1565b61122d6114d7565b61077161015f611a3f565b600061078061015f611b00565b61124d611c94565b611255611531565b81804211156112765760405162461bcd60e51b815260040161095690612362565b604051630503c75f60e21b81527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e9063140f1d7c906112b39061015f90899089906004016123d0565b604080518083038186803b1580156112ca57600080fd5b505af41580156112de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf9190611f6a565b604051631c641b0b60e21b815261015f60048201526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e906371906c2c906024016107bd565b6040516303e8240b60e51b815261015f6004820152602481018290526000907309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e90637d0481609060440160206040518083038186803b15801561139457600080fd5b505af41580156113a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c591906120f8565b6113d4611c94565b6040516338381f2560e11b815261015f6004820152602481018390527309a50EBa3B933bDc5ab83b519dA81c3A41a98e8e906370703e4a90604401604080518083038186803b15801561142657600080fd5b505af415801561143a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c59190611f6a565b6114666114d7565b6001600160a01b0381166114cb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610956565b6114d481611881565b50565b6033546001600160a01b031633146107715760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610956565b600260975414156115845760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610956565b6002609755565b6001609755565b60006106c582611b17565b60655460ff16156107715760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610956565b6115eb611bc1565b6065805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60058301546116479062015180612422565b4210156116965760405162461bcd60e51b815260206004820152601f60248201527f57616974203120646179206265666f7265207374617274696e672072616d70006044820152606401610956565b6116a36212750042612422565b8110156116eb5760405162461bcd60e51b8152602060048201526016602482015275496e73756666696369656e742072616d702074696d6560501b6044820152606401610956565b6000821180156116fd5750620f424082105b6117495760405162461bcd60e51b815260206004820181905260248201527f667574757265415f206d757374206265203e203020616e64203c204d41585f416044820152606401610956565b600061175484611b17565b9050600061176360648561245c565b9050818110156117c4578161177960028361245c565b10156117bf5760405162461bcd60e51b8152602060048201526015602482015274199d5d1d5c995057c81a5cc81d1bdbc81cdb585b1b605a1b6044820152606401610956565b611816565b6117cf60028361245c565b8111156118165760405162461bcd60e51b8152602060048201526015602482015274667574757265415f20697320746f6f206c6172676560581b6044820152606401610956565b600385018290556004850181905542600586018190556006860184905560408051848152602081018490528082019290925260608201859052517fa2b71ec6df949300b59aab36b55e189697b750119dd349fcfa8c0f779e83c2549181900360800190a15050505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff166118fa5760405162461bcd60e51b815260040161095690612317565b611902611941565b61190a611c0a565b610771611c3a565b600054610100900460ff166119395760405162461bcd60e51b815260040161095690612317565b610771611c6d565b600054610100900460ff166107715760405162461bcd60e51b815260040161095690612317565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b0381166119fd5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b6044820152606401610956565b919050565b611a0a61159d565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586116183390565b42816006015411611a925760405162461bcd60e51b815260206004820152601760248201527f52616d7020697320616c72656164792073746f707065640000000000000000006044820152606401610956565b6000611a9d82611b17565b60038301819055600483018190554260058401819055600684018190556040519192507f46e22fb3709ad289f62ce63d469248536dbc78d82b84a3d7e74ad606dc20193891611af491848252602082015260400190565b60405180910390a15050565b60006064611b0d83611b17565b6106c5919061243a565b6006810154600482015460009190428211156108a5576005840154600385015480831115611b8557611b49828561247b565b611b53834261247b565b611b5d838661247b565b611b67919061245c565b611b71919061243a565b611b7b9082612422565b9695505050505050565b611b8f828561247b565b611b99834261247b565b611ba3858461247b565b611bad919061245c565b611bb7919061243a565b611b7b908261247b565b60655460ff166107715760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152606401610956565b600054610100900460ff16611c315760405162461bcd60e51b815260040161095690612317565b61077133611881565b600054610100900460ff16611c615760405162461bcd60e51b815260040161095690612317565b6065805460ff19169055565b600054610100900460ff1661158b5760405162461bcd60e51b815260040161095690612317565b60405180604001604052806002906020820280368337509192915050565b80604081018310156106c557600080fd5b600082601f830112611cd457600080fd5b8135602067ffffffffffffffff821115611cf057611cf06124be565b8160051b611cff8282016123f1565b838152828101908684018388018501891015611d1a57600080fd5b600093505b85841015611d3d578035835260019390930192918401918401611d1f565b50979650505050505050565b600082601f830112611d5a57600080fd5b813567ffffffffffffffff811115611d7457611d746124be565b611d87601f8201601f19166020016123f1565b818152846020838601011115611d9c57600080fd5b816020850160208301376000918101602001919091529392505050565b803560ff811681146119fd57600080fd5b600060208284031215611ddc57600080fd5b81356108a5816124d4565b600080600080600060a08688031215611dff57600080fd5b8535611e0a816124d4565b94506020860135611e1a816124d4565b9350604086013567ffffffffffffffff80821115611e3757600080fd5b611e4389838a01611cc3565b94506060880135915080821115611e5957600080fd5b611e6589838a01611cc3565b93506080880135915080821115611e7b57600080fd5b50611e8888828901611d49565b9150509295509295909350565b600080600080600060a08688031215611ead57600080fd5b8535611eb8816124d4565b94506020860135611ec8816124d4565b93506040860135925060608601359150608086013567ffffffffffffffff811115611ef257600080fd5b611e8888828901611d49565b60008060608385031215611f1157600080fd5b611f1b8484611cb2565b91506040830135611f2b816124e9565b809150509250929050565b600080600060808486031215611f4b57600080fd5b611f558585611cb2565b95604085013595506060909401359392505050565b600060408284031215611f7c57600080fd5b82601f830112611f8b57600080fd5b6040516040810181811067ffffffffffffffff82111715611fae57611fae6124be565b8060405250808385604086011115611fc557600080fd5b60005b6002811015611fe7578151835260209283019290910190600101611fc8565b509195945050505050565b60006020828403121561200457600080fd5b81516108a5816124e9565b60006020828403121561202157600080fd5b81356001600160e01b0319811681146108a557600080fd5b60008060008060008060c0878903121561205257600080fd5b863561205d816124d4565b955060208701359450604087013567ffffffffffffffff8082111561208157600080fd5b61208d8a838b01611d49565b955060608901359150808211156120a357600080fd5b506120b089828a01611d49565b93505060808701356120c1816124d4565b915060a08701356120d1816124d4565b809150509295509295509295565b6000602082840312156120f157600080fd5b5035919050565b60006020828403121561210a57600080fd5b5051919050565b60008060006080848603121561212657600080fd5b833592506121378560208601611cb2565b9150606084013590509250925092565b6000806040838503121561215a57600080fd5b50508035926020909101359150565b6000806040838503121561217c57600080fd5b8235915061218c60208401611db9565b90509250929050565b600080600080608085870312156121ab57600080fd5b843593506121bb60208601611db9565b93969395505050506040820135916060013590565b6000602082840312156121e257600080fd5b6108a582611db9565b60008060006060848603121561220057600080fd5b61220984611db9565b925061221760208501611db9565b9150604084013590509250925092565b600080600080600060a0868803121561223f57600080fd5b61224886611db9565b945061225660208701611db9565b94979496505050506040830135926060810135926080909101359150565b6000815180845260005b8181101561229a5760208185018101518683018201520161227e565b818111156122ac576000602083870101525b50601f01601f19169290920160200192915050565b60408101818360005b60028110156122e95781518352602092830192909101906001016122ca565b50505092915050565b6040815260006123056040830185612274565b82810360208401526110998185612274565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60208082526016908201527514ddd85c0e88111958591b1a5b99481b9bdd081b595d60521b604082015260600190565b8381526080810160408460208401379115156060919091015292915050565b8381526080810160408460208401376060919091019190915292915050565b83815260208101839052608081016040838184013760008152949350505050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561241a5761241a6124be565b604052919050565b6000821982111561243557612435612492565b500190565b60008261245757634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561247657612476612492565b500290565b60008282101561248d5761248d612492565b500390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03811681146114d457600080fd5b80151581146114d457600080fdfea26469706673582212204a6536d57de9c08570942a7cc08efb0e203bf19235a317d6d21f2d3dc211155464736f6c63430008070033",
  "deployedBytecode": "0x6080604052600436106101f95760003560e01c80638456cb591161010d578063c4db7fa0116100a0578063e25aa5fa1161006f578063e25aa5fa146105f3578063ef0a712f14610608578063f23a6e6114610628578063f2fad2b614610654578063f2fde38b1461067457600080fd5b8063c4db7fa014610586578063d46300fd1461059b578063d4cadf68146105b0578063d6f0df62146105c657600080fd5b806391ceb3eb116100dc57806391ceb3eb146104e1578063a95b089f14610501578063bc197c8114610521578063bfc65c9b1461056657600080fd5b80638456cb591461047b5780638beb60b6146104905780638da5cb5b146104b057806391695586146104ce57600080fd5b80633e3a1560116101905780635c975abb1161015f5780635c975abb146103735780635fd65f0f1461038b578063715018a6146104265780637e0ccbff1461043b578063820fc5bd1461045b57600080fd5b80633e3a15601461030b5780633f4ba83a1461032b57806346eda74914610340578063593d132c1461035357600080fd5b806314a6bf0f116101cc57806314a6bf0f146102a057806321df0da7146102b5578063342a87a1146102cb57806334e19907146102eb57600080fd5b806301ffc9a7146101fe5780630419b45a146102335780630526930c1461024a5780630ba819591461027d575b600080fd5b34801561020a57600080fd5b5061021e61021936600461200f565b610694565b60405190151581526020015b60405180910390f35b34801561023f57600080fd5b506102486106cb565b005b34801561025657600080fd5b5061015f546001600160a01b03165b6040516001600160a01b03909116815260200161022a565b34801561028957600080fd5b50610292610773565b60405190815260200161022a565b3480156102ac57600080fd5b50610292610785565b3480156102c157600080fd5b5061016154610292565b3480156102d757600080fd5b506102926102e6366004612169565b61080d565b3480156102f757600080fd5b506102486103063660046120df565b6108ac565b34801561031757600080fd5b50610292610326366004612195565b610923565b34801561033757600080fd5b50610248610a0f565b61029261034e366004611f36565b610a1f565b34801561035f57600080fd5b5061024861036e366004612147565b610aec565b34801561037f57600080fd5b5060655460ff1661021e565b34801561039757600080fd5b5061015f5461016054610161546101625461016354610164546101655461016654610167546103d7986001600160a01b0390811698169695949392919089565b604080516001600160a01b039a8b1681529990981660208a0152968801959095526060870193909352608086019190915260a085015260c084015260e08301526101008201526101200161022a565b34801561043257600080fd5b50610248610b05565b34801561044757600080fd5b50610292610456366004611efe565b610b17565b34801561046757600080fd5b50610265610476366004612039565b610b57565b34801561048757600080fd5b50610248610f5e565b34801561049c57600080fd5b506102486104ab3660046120df565b610f6e565b3480156104bc57600080fd5b506033546001600160a01b0316610265565b6102926104dc366004612227565b610fb6565b3480156104ed57600080fd5b506102926104fc3660046121d0565b6110a2565b34801561050d57600080fd5b5061029261051c3660046121eb565b611116565b34801561052d57600080fd5b5061054d61053c366004611de7565b63bc197c8160e01b95945050505050565b6040516001600160e01b0319909116815260200161022a565b34801561057257600080fd5b50610292610581366004611f36565b6111b5565b34801561059257600080fd5b50610248611225565b3480156105a757600080fd5b50610292611238565b3480156105bc57600080fd5b5061016654610292565b3480156105d257600080fd5b506105e66105e1366004612111565b611245565b60405161022a91906122c1565b3480156105ff57600080fd5b50610292611302565b34801561061457600080fd5b506102926106233660046120df565b61133e565b34801561063457600080fd5b5061054d610643366004611e95565b63f23a6e6160e01b95945050505050565b34801561066057600080fd5b506105e661066f3660046120df565b6113cc565b34801561068057600080fd5b5061024861068f366004611dca565b61145e565b60006001600160e01b03198216630271189760e51b14806106c557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6106d36114d7565b6106db611531565b73__$6fb038c7747560c9c1f610b0835b44650b$__6324c5c75161015f61070a6033546001600160a01b031690565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260440160006040518083038186803b15801561074f57600080fd5b505af4158015610763573d6000803e3d6000fd5b505050506107716001609755565b565b600061078061015f611592565b905090565b60405163550670c360e11b815261015f600482015260009073__$6fb038c7747560c9c1f610b0835b44650b$__9063aa0ce186906024015b60206040518083038186803b1580156107d557600080fd5b505af41580156107e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078091906120f8565b60405163703493a160e11b815261015f60048201526024810183905260ff8216604482015260009073__$6fb038c7747560c9c1f610b0835b44650b$__9063e0692742906064015b60206040518083038186803b15801561086d57600080fd5b505af4158015610881573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a591906120f8565b9392505050565b6108b46114d7565b60405163119f861b60e21b815261015f60048201526024810182905273__$6fb038c7747560c9c1f610b0835b44650b$__9063467e186c906044015b60006040518083038186803b15801561090857600080fd5b505af415801561091c573d6000803e3d6000fd5b5050505050565b600061092d611531565b61093561159d565b818042111561095f5760405162461bcd60e51b815260040161095690612362565b60405180910390fd5b60405163e7a4db8160e01b815261015f60048201526024810187905260ff861660448201526064810185905273__$6fb038c7747560c9c1f610b0835b44650b$__9063e7a4db819060840160206040518083038186803b1580156109c257600080fd5b505af41580156109d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fa91906120f8565b915050610a076001609755565b949350505050565b610a176114d7565b6107716115e3565b6000610a29611531565b610a3161159d565b8180421115610a525760405162461bcd60e51b815260040161095690612362565b60405163a596460760e01b815273__$6fb038c7747560c9c1f610b0835b44650b$__9063a596460790610a8f9061015f90899089906004016123b1565b60206040518083038186803b158015610aa757600080fd5b505af4158015610abb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf91906120f8565b9150506108a56001609755565b610af46114d7565b610b0161015f8383611635565b5050565b610b0d6114d7565b6107716000611881565b6040516337b8b34360e01b815260009073__$6fb038c7747560c9c1f610b0835b44650b$__906337b8b343906108559061015f9087908790600401612392565b60008054610100900460ff1615808015610b785750600054600160ff909116105b80610b925750303b158015610b92575060005460ff166001145b610bf55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610956565b6000805460ff191660011790558015610c18576000805461ff0019166101001790555b610c206118d3565b610c28611912565b610c30611941565b6001600160a01b038416610c995760405162461bcd60e51b815260206004820152602a60248201527f537761703a206c70546f6b656e546172676574416464726573732063616e206e6044820152696f74206265207a65726f60b01b6064820152608401610956565b6001600160a01b038316610cef5760405162461bcd60e51b815260206004820152601b60248201527f537761703a206f776e65722063616e206e6f74206265207a65726f00000000006044820152606401610956565b6001600160a01b038816610d455760405162461bcd60e51b815260206004820152601b60248201527f537761703a205f674554482063616e206e6f74206265207a65726f00000000006044820152606401610956565b86610d9e5760405162461bcd60e51b8152602060048201526024808201527f537761703a205f706f6f6c6564546f6b656e49642063616e206e6f74206265206044820152637a65726f60e01b6064820152608401610956565b6000610da985611968565b60405163266c45bb60e11b81529091506001600160a01b03821690634cd88b7690610dda908a908a906004016122f2565b602060405180830381600087803b158015610df457600080fd5b505af1158015610e08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2c9190611ff2565b610e835760405162461bcd60e51b815260206004820152602260248201527f537761703a20636f756c64206e6f7420696e6974206c70546f6b656e20636c6f6044820152616e6560f01b6064820152608401610956565b61015f80546001600160a01b03808c166001600160a01b031992831617909255610160805492841692909116919091179055610161889055610ec76064603c61245c565b61016255610ed76064603c61245c565b61016355612710610eee6402540be400600461245c565b610ef8919061243a565b61016655600061016755610f0b8461145e565b91508015610f53576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b509695505050505050565b610f666114d7565b610771611a02565b610f766114d7565b604051633823393b60e11b815261015f60048201526024810182905273__$6fb038c7747560c9c1f610b0835b44650b$__906370467276906044016108f0565b6000610fc0611531565b610fc861159d565b8180421115610fe95760405162461bcd60e51b815260040161095690612362565b60405163529cbd9160e11b815261015f600482015260ff808916602483015287166044820152606481018690526084810185905273__$6fb038c7747560c9c1f610b0835b44650b$__9063a5397b229060a40160206040518083038186803b15801561105457600080fd5b505af4158015611068573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061108c91906120f8565b9150506110996001609755565b95945050505050565b600060028260ff16106110f75760405162461bcd60e51b815260206004820152601860248201527f537761703a20496e646578206f7574206f662072616e676500000000000000006044820152606401610956565b61016860ff83166002811061110e5761110e6124a8565b015492915050565b6040516312c8d80f60e21b815261015f600482015260ff8085166024830152831660448201526064810182905260009073__$6fb038c7747560c9c1f610b0835b44650b$__90634b23603c9060840160206040518083038186803b15801561117d57600080fd5b505af4158015611191573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0791906120f8565b60006111bf611531565b6111c761159d565b81804211156111e85760405162461bcd60e51b815260040161095690612362565b60405163c36b87e960e01b815273__$6fb038c7747560c9c1f610b0835b44650b$__9063c36b87e990610a8f9061015f90899089906004016123b1565b61122d6114d7565b61077161015f611a3f565b600061078061015f611b00565b61124d611c94565b611255611531565b81804211156112765760405162461bcd60e51b815260040161095690612362565b604051630503c75f60e21b815273__$6fb038c7747560c9c1f610b0835b44650b$__9063140f1d7c906112b39061015f90899089906004016123d0565b604080518083038186803b1580156112ca57600080fd5b505af41580156112de573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adf9190611f6a565b604051631c641b0b60e21b815261015f600482015260009073__$6fb038c7747560c9c1f610b0835b44650b$__906371906c2c906024016107bd565b6040516303e8240b60e51b815261015f60048201526024810182905260009073__$6fb038c7747560c9c1f610b0835b44650b$__90637d0481609060440160206040518083038186803b15801561139457600080fd5b505af41580156113a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c591906120f8565b6113d4611c94565b6040516338381f2560e11b815261015f60048201526024810183905273__$6fb038c7747560c9c1f610b0835b44650b$__906370703e4a90604401604080518083038186803b15801561142657600080fd5b505af415801561143a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c59190611f6a565b6114666114d7565b6001600160a01b0381166114cb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610956565b6114d481611881565b50565b6033546001600160a01b031633146107715760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610956565b600260975414156115845760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610956565b6002609755565b6001609755565b60006106c582611b17565b60655460ff16156107715760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610956565b6115eb611bc1565b6065805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60058301546116479062015180612422565b4210156116965760405162461bcd60e51b815260206004820152601f60248201527f57616974203120646179206265666f7265207374617274696e672072616d70006044820152606401610956565b6116a36212750042612422565b8110156116eb5760405162461bcd60e51b8152602060048201526016602482015275496e73756666696369656e742072616d702074696d6560501b6044820152606401610956565b6000821180156116fd5750620f424082105b6117495760405162461bcd60e51b815260206004820181905260248201527f667574757265415f206d757374206265203e203020616e64203c204d41585f416044820152606401610956565b600061175484611b17565b9050600061176360648561245c565b9050818110156117c4578161177960028361245c565b10156117bf5760405162461bcd60e51b8152602060048201526015602482015274199d5d1d5c995057c81a5cc81d1bdbc81cdb585b1b605a1b6044820152606401610956565b611816565b6117cf60028361245c565b8111156118165760405162461bcd60e51b8152602060048201526015602482015274667574757265415f20697320746f6f206c6172676560581b6044820152606401610956565b600385018290556004850181905542600586018190556006860184905560408051848152602081018490528082019290925260608201859052517fa2b71ec6df949300b59aab36b55e189697b750119dd349fcfa8c0f779e83c2549181900360800190a15050505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600054610100900460ff166118fa5760405162461bcd60e51b815260040161095690612317565b611902611941565b61190a611c0a565b610771611c3a565b600054610100900460ff166119395760405162461bcd60e51b815260040161095690612317565b610771611c6d565b600054610100900460ff166107715760405162461bcd60e51b815260040161095690612317565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b0381166119fd5760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b6044820152606401610956565b919050565b611a0a61159d565b6065805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586116183390565b42816006015411611a925760405162461bcd60e51b815260206004820152601760248201527f52616d7020697320616c72656164792073746f707065640000000000000000006044820152606401610956565b6000611a9d82611b17565b60038301819055600483018190554260058401819055600684018190556040519192507f46e22fb3709ad289f62ce63d469248536dbc78d82b84a3d7e74ad606dc20193891611af491848252602082015260400190565b60405180910390a15050565b60006064611b0d83611b17565b6106c5919061243a565b6006810154600482015460009190428211156108a5576005840154600385015480831115611b8557611b49828561247b565b611b53834261247b565b611b5d838661247b565b611b67919061245c565b611b71919061243a565b611b7b9082612422565b9695505050505050565b611b8f828561247b565b611b99834261247b565b611ba3858461247b565b611bad919061245c565b611bb7919061243a565b611b7b908261247b565b60655460ff166107715760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152606401610956565b600054610100900460ff16611c315760405162461bcd60e51b815260040161095690612317565b61077133611881565b600054610100900460ff16611c615760405162461bcd60e51b815260040161095690612317565b6065805460ff19169055565b600054610100900460ff1661158b5760405162461bcd60e51b815260040161095690612317565b60405180604001604052806002906020820280368337509192915050565b80604081018310156106c557600080fd5b600082601f830112611cd457600080fd5b8135602067ffffffffffffffff821115611cf057611cf06124be565b8160051b611cff8282016123f1565b838152828101908684018388018501891015611d1a57600080fd5b600093505b85841015611d3d578035835260019390930192918401918401611d1f565b50979650505050505050565b600082601f830112611d5a57600080fd5b813567ffffffffffffffff811115611d7457611d746124be565b611d87601f8201601f19166020016123f1565b818152846020838601011115611d9c57600080fd5b816020850160208301376000918101602001919091529392505050565b803560ff811681146119fd57600080fd5b600060208284031215611ddc57600080fd5b81356108a5816124d4565b600080600080600060a08688031215611dff57600080fd5b8535611e0a816124d4565b94506020860135611e1a816124d4565b9350604086013567ffffffffffffffff80821115611e3757600080fd5b611e4389838a01611cc3565b94506060880135915080821115611e5957600080fd5b611e6589838a01611cc3565b93506080880135915080821115611e7b57600080fd5b50611e8888828901611d49565b9150509295509295909350565b600080600080600060a08688031215611ead57600080fd5b8535611eb8816124d4565b94506020860135611ec8816124d4565b93506040860135925060608601359150608086013567ffffffffffffffff811115611ef257600080fd5b611e8888828901611d49565b60008060608385031215611f1157600080fd5b611f1b8484611cb2565b91506040830135611f2b816124e9565b809150509250929050565b600080600060808486031215611f4b57600080fd5b611f558585611cb2565b95604085013595506060909401359392505050565b600060408284031215611f7c57600080fd5b82601f830112611f8b57600080fd5b6040516040810181811067ffffffffffffffff82111715611fae57611fae6124be565b8060405250808385604086011115611fc557600080fd5b60005b6002811015611fe7578151835260209283019290910190600101611fc8565b509195945050505050565b60006020828403121561200457600080fd5b81516108a5816124e9565b60006020828403121561202157600080fd5b81356001600160e01b0319811681146108a557600080fd5b60008060008060008060c0878903121561205257600080fd5b863561205d816124d4565b955060208701359450604087013567ffffffffffffffff8082111561208157600080fd5b61208d8a838b01611d49565b955060608901359150808211156120a357600080fd5b506120b089828a01611d49565b93505060808701356120c1816124d4565b915060a08701356120d1816124d4565b809150509295509295509295565b6000602082840312156120f157600080fd5b5035919050565b60006020828403121561210a57600080fd5b5051919050565b60008060006080848603121561212657600080fd5b833592506121378560208601611cb2565b9150606084013590509250925092565b6000806040838503121561215a57600080fd5b50508035926020909101359150565b6000806040838503121561217c57600080fd5b8235915061218c60208401611db9565b90509250929050565b600080600080608085870312156121ab57600080fd5b843593506121bb60208601611db9565b93969395505050506040820135916060013590565b6000602082840312156121e257600080fd5b6108a582611db9565b60008060006060848603121561220057600080fd5b61220984611db9565b925061221760208501611db9565b9150604084013590509250925092565b600080600080600060a0868803121561223f57600080fd5b61224886611db9565b945061225660208701611db9565b94979496505050506040830135926060810135926080909101359150565b6000815180845260005b8181101561229a5760208185018101518683018201520161227e565b818111156122ac576000602083870101525b50601f01601f19169290920160200192915050565b60408101818360005b60028110156122e95781518352602092830192909101906001016122ca565b50505092915050565b6040815260006123056040830185612274565b82810360208401526110998185612274565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60208082526016908201527514ddd85c0e88111958591b1a5b99481b9bdd081b595d60521b604082015260600190565b8381526080810160408460208401379115156060919091015292915050565b8381526080810160408460208401376060919091019190915292915050565b83815260208101839052608081016040838184013760008152949350505050565b604051601f8201601f1916810167ffffffffffffffff8111828210171561241a5761241a6124be565b604052919050565b6000821982111561243557612435612492565b500190565b60008261245757634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561247657612476612492565b500290565b60008282101561248d5761248d612492565b500390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b03811681146114d457600080fd5b80151581146114d457600080fdfea26469706673582212204a6536d57de9c08570942a7cc08efb0e203bf19235a317d6d21f2d3dc211155464736f6c63430008070033",
  "libraries": {
    "SwapUtils": "0x09a50EBa3B933bDc5ab83b519dA81c3A41a98e8e"
  },
  "devdoc": {
    "details": "Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's deployment size.The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals relying on the Oracle Price, with the help of Liquidity Providers. It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions. Because the underlying price of the staked assets are expected to raise in time. One can see this similar to accomplishing a \"rebasing\" logic, with the help of a trusted price source.",
    "kind": "dev",
    "methods": {
      "addLiquidity(uint256[2],uint256,uint256)": {
        "params": {
          "amounts": "the amounts of each token to add, in their native precision",
          "deadline": "latest timestamp to accept this transaction",
          "minToMint": "the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"
        },
        "returns": {
          "_0": "amount of LP token user minted and received"
        }
      },
      "calculateRemoveLiquidity(uint256)": {
        "params": {
          "amount": "the amount of LP tokens that would be burned on withdrawal"
        },
        "returns": {
          "_0": "array of token balances that the user will receive"
        }
      },
      "calculateRemoveLiquidityOneToken(uint256,uint8)": {
        "params": {
          "tokenAmount": "the amount of LP token to burn",
          "tokenIndex": "index of which token will be withdrawn"
        },
        "returns": {
          "availableTokenAmount": "calculated amount of underlying token available to withdraw"
        }
      },
      "calculateSwap(uint8,uint8,uint256)": {
        "params": {
          "dx": "the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",
          "tokenIndexFrom": "the token the user wants to sell",
          "tokenIndexTo": "the token the user wants to buy"
        },
        "returns": {
          "_0": "amount of tokens the user will receive"
        }
      },
      "calculateTokenAmount(uint256[2],bool)": {
        "details": "This shouldn't be used outside frontends for user estimates.",
        "params": {
          "amounts": "an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",
          "deposit": "whether this is a deposit or a withdrawal"
        },
        "returns": {
          "_0": "token amount the user will receive"
        }
      },
      "getA()": {
        "details": "See the StableSwap paper for details",
        "returns": {
          "_0": "A parameter"
        }
      },
      "getAPrecise()": {
        "details": "See the StableSwap paper for details",
        "returns": {
          "_0": "A parameter in its raw precision form"
        }
      },
      "getAdminBalance(uint256)": {
        "params": {
          "index": "Index of the pooled token"
        },
        "returns": {
          "_0": "admin's token balance in the token's precision"
        }
      },
      "getDebt()": {
        "returns": {
          "_0": "debt the half of the D StableSwap invariant when debt is needed to be payed."
        }
      },
      "getSwapFee()": {
        "returns": {
          "_0": "id of the pooled gEther token"
        }
      },
      "getTokenBalance(uint8)": {
        "params": {
          "index": "the index of the token"
        },
        "returns": {
          "_0": "current balance of the pooled token at given index with token's native precision"
        }
      },
      "getVirtualPrice()": {
        "returns": {
          "_0": "the virtual price"
        }
      },
      "initialize(address,uint256,string,string,address,address)": {
        "params": {
          "_gETH": "reference of the ERC1155 contract",
          "_pooledTokenId": "gEther ID that the Pool is operating with",
          "lpTokenName": "the long-form name of the token to be deployed",
          "lpTokenSymbol": "the short symbol for the token to be deployed",
          "lpTokenTargetAddress": "the address of an existing LPToken contract to use as a target"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "rampA(uint256,uint256)": {
        "params": {
          "futureA": "the new A to ramp towards",
          "futureTime": "timestamp when the new A should be reached"
        }
      },
      "removeLiquidity(uint256,uint256[2],uint256)": {
        "details": "Liquidity can always be removed, even when the pool is paused.",
        "params": {
          "amount": "the amount of LP tokens to burn",
          "deadline": "latest timestamp to accept this transaction",
          "minAmounts": "the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"
        },
        "returns": {
          "_0": "amounts of tokens user received"
        }
      },
      "removeLiquidityImbalance(uint256[2],uint256,uint256)": {
        "params": {
          "amounts": "how much of each token to withdraw",
          "deadline": "latest timestamp to accept this transaction",
          "maxBurnAmount": "the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation."
        },
        "returns": {
          "_0": "amount of LP tokens burned"
        }
      },
      "removeLiquidityOneToken(uint256,uint8,uint256,uint256)": {
        "params": {
          "deadline": "latest timestamp to accept this transaction",
          "minAmount": "the minimum amount to withdraw, otherwise revert",
          "tokenAmount": "the amount of the token you want to receive",
          "tokenIndex": "the index of the token you want to receive"
        },
        "returns": {
          "_0": "amount of chosen token user received"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setAdminFee(uint256)": {
        "params": {
          "newAdminFee": "new admin fee to be applied on future transactions"
        }
      },
      "setSwapFee(uint256)": {
        "params": {
          "newSwapFee": "new swap fee to be applied on future transactions"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "swap(uint8,uint8,uint256,uint256,uint256)": {
        "params": {
          "deadline": "latest timestamp to accept this transaction",
          "dx": "the amount of tokens the user wants to swap from",
          "minDy": "the min amount the user would like to receive, or revert.",
          "tokenIndexFrom": "the token the user wants to swap from",
          "tokenIndexTo": "the token the user wants to swap to"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "Swap - A StableSwap implementation in solidity.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addLiquidity(uint256[2],uint256,uint256)": {
        "notice": "Add liquidity to the pool with the given amounts of tokens"
      },
      "calculateRemoveLiquidity(uint256)": {
        "notice": "A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"
      },
      "calculateRemoveLiquidityOneToken(uint256,uint8)": {
        "notice": "Calculate the amount of underlying token available to withdraw when withdrawing via only single token"
      },
      "calculateSwap(uint8,uint8,uint256)": {
        "notice": "Calculate amount of tokens you receive on swap"
      },
      "calculateTokenAmount(uint256[2],bool)": {
        "notice": "A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various \"min\" parameters on calls to fight front-running"
      },
      "getA()": {
        "notice": "Return A, the amplification coefficient * n * (n - 1)"
      },
      "getAPrecise()": {
        "notice": "Return A in its raw precision form"
      },
      "getAdminBalance(uint256)": {
        "notice": "This function reads the accumulated amount of admin fees of the token with given index"
      },
      "getDebt()": {
        "notice": "Debt, The amount of buyback for stable pricing (1=1)."
      },
      "getSwapFee()": {
        "notice": "Return id of the pooled token"
      },
      "getTokenBalance(uint8)": {
        "notice": "Return current balance of the pooled token at given index"
      },
      "getVirtualPrice()": {
        "notice": "Get the virtual price, to help calculate profit"
      },
      "initialize(address,uint256,string,string,address,address)": {
        "notice": "Initializes this Swap contract with the given parameters. This will also clone a LPToken contract that represents users' LP positions. The owner of LPToken will be this contract - which means only this contract is allowed to mint/burn tokens."
      },
      "pause()": {
        "notice": "Pause the contract. Revert if already paused."
      },
      "rampA(uint256,uint256)": {
        "notice": "Start ramping up or down A parameter towards given futureA and futureTime Checks if the change is too rapid, and commits the new A value only when it falls under the limit range."
      },
      "removeLiquidity(uint256,uint256[2],uint256)": {
        "notice": "Burn LP tokens to remove liquidity from the pool."
      },
      "removeLiquidityImbalance(uint256[2],uint256,uint256)": {
        "notice": "Remove liquidity from the pool, weighted differently than the pool's current balances."
      },
      "removeLiquidityOneToken(uint256,uint8,uint256,uint256)": {
        "notice": "Remove liquidity from the pool all in one token."
      },
      "setAdminFee(uint256)": {
        "notice": "Update the admin fee. Admin fee takes portion of the swap fee."
      },
      "setSwapFee(uint256)": {
        "notice": "Update the swap fee to be applied on swaps"
      },
      "stopRampA()": {
        "notice": "Stop ramping A immediately. Reverts if ramp A is already stopped."
      },
      "swap(uint8,uint8,uint256,uint256,uint256)": {
        "notice": "Swap two tokens using this pool"
      },
      "unpause()": {
        "notice": "Unpause the contract. Revert if already unpaused."
      },
      "withdrawAdminFees()": {
        "notice": "Withdraw all admin fees to the contract owner"
      }
    },
    "notice": "This contract is responsible for custody of closely pegged assets (eg. group of stablecoins) and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens in desired ratios for an exchange of the pool token that represents their share of the pool. Users can burn pool tokens and withdraw their share of token(s). Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets distributed to the LPs. In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which stops the ratio of the tokens in the pool from changing. Users can always withdraw their tokens via multi-asset withdraws.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 527,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 530,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 2331,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 10,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 130,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 846,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "_paused",
        "offset": 0,
        "slot": "101",
        "type": "t_bool"
      },
      {
        "astId": 951,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 966,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "_status",
        "offset": 0,
        "slot": "151",
        "type": "t_uint256"
      },
      {
        "astId": 1024,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 3198,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "201",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1190,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "251",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1136,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "__gap",
        "offset": 0,
        "slot": "301",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 14941,
        "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
        "label": "swapStorage",
        "offset": 0,
        "slot": "351",
        "type": "t_struct(Swap)16765_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)2_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[2]",
        "numberOfBytes": "64"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)8_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[8]",
        "numberOfBytes": "256"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(ILPToken)25812": {
        "encoding": "inplace",
        "label": "contract ILPToken",
        "numberOfBytes": "20"
      },
      "t_contract(IgETH)26862": {
        "encoding": "inplace",
        "label": "contract IgETH",
        "numberOfBytes": "20"
      },
      "t_struct(Swap)16765_storage": {
        "encoding": "inplace",
        "label": "struct SwapUtils.Swap",
        "members": [
          {
            "astId": 16739,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "gETH",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IgETH)26862"
          },
          {
            "astId": 16742,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "lpToken",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(ILPToken)25812"
          },
          {
            "astId": 16744,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "pooledTokenId",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 16746,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "initialA",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 16748,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "futureA",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 16750,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "initialATime",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 16752,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "futureATime",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 16754,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "swapFee",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 16756,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "adminFee",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 16760,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "balances",
            "offset": 0,
            "slot": "9",
            "type": "t_array(t_uint256)2_storage"
          },
          {
            "astId": 16764,
            "contract": "contracts/Portal/liquidityPool/Swap.sol:Swap",
            "label": "__gap",
            "offset": 0,
            "slot": "11",
            "type": "t_array(t_uint256)8_storage"
          }
        ],
        "numberOfBytes": "608"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}