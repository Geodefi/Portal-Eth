{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts-exposed/Portal/globals/id_type.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/globals/id_type.sol\";\n\ncontract $ID_TYPE {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $NONE() external pure returns (uint256) {\n        return ID_TYPE.NONE;\n    }\n\n    function $SENATE() external pure returns (uint256) {\n        return ID_TYPE.SENATE;\n    }\n\n    function $CONTRACT_UPGRADE() external pure returns (uint256) {\n        return ID_TYPE.CONTRACT_UPGRADE;\n    }\n\n    function $__GAP__() external pure returns (uint256) {\n        return ID_TYPE.__GAP__;\n    }\n\n    function $OPERATOR() external pure returns (uint256) {\n        return ID_TYPE.OPERATOR;\n    }\n\n    function $POOL() external pure returns (uint256) {\n        return ID_TYPE.POOL;\n    }\n\n    function $LIMIT_MIN_PACKAGE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MIN_PACKAGE;\n    }\n\n    function $PACKAGE_PORTAL() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_PORTAL;\n    }\n\n    function $PACKAGE_WITHDRAWAL_CONTRACT() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT;\n    }\n\n    function $PACKAGE_LIQUIDITY_POOL() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_LIQUIDITY_POOL;\n    }\n\n    function $LIMIT_MAX_PACKAGE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MAX_PACKAGE;\n    }\n\n    function $LIMIT_MIN_MIDDLEWARE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MIN_MIDDLEWARE;\n    }\n\n    function $MIDDLEWARE_GETH() external pure returns (uint256) {\n        return ID_TYPE.MIDDLEWARE_GETH;\n    }\n\n    function $LIMIT_MAX_MIDDLEWARE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MAX_MIDDLEWARE;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/globals/macros.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/globals/macros.sol\";\n"
    },
    "contracts-exposed/Portal/globals/reserved_key_space.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/globals/reserved_key_space.sol\";\n\ncontract $RESERVED_KEY_SPACE {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $CONTROLLER() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.CONTROLLER;\n    }\n\n    function $NAME() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.NAME;\n    }\n\n    function $TYPE() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.TYPE;\n    }\n\n    function $activeValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.activeValidators;\n    }\n\n    function $allowance() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.allowance;\n    }\n\n    function $fallbackOperator() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.fallbackOperator;\n    }\n\n    function $fee() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.fee;\n    }\n\n    function $feeSwitch() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.feeSwitch;\n    }\n\n    function $initiated() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.initiated;\n    }\n\n    function $liquidityPool() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.liquidityPool;\n    }\n\n    function $maintainer() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.maintainer;\n    }\n\n    function $middlewares() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.middlewares;\n    }\n\n    function $periodSwitch() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.periodSwitch;\n    }\n\n    function $priorFee() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.priorFee;\n    }\n\n    function $priorPeriod() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.priorPeriod;\n    }\n\n    function $privatePool() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.privatePool;\n    }\n\n    function $proposedValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.proposedValidators;\n    }\n\n    function $release() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.release;\n    }\n\n    function $secured() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.secured;\n    }\n\n    function $surplus() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.surplus;\n    }\n\n    function $totalAllowance() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.totalAllowance;\n    }\n\n    function $validatorPeriod() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.validatorPeriod;\n    }\n\n    function $validators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.validators;\n    }\n\n    function $withdrawalContract() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.withdrawalContract;\n    }\n\n    function $withdrawalCredential() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.withdrawalCredential;\n    }\n\n    function $wallet() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.wallet;\n    }\n\n    function $whitelist() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.whitelist;\n    }\n\n    function $alienValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.alienValidators;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/globals/validator_state.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/globals/validator_state.sol\";\n\ncontract $VALIDATOR_STATE {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $NONE() external pure returns (uint8) {\n        return VALIDATOR_STATE.NONE;\n    }\n\n    function $PROPOSED() external pure returns (uint8) {\n        return VALIDATOR_STATE.PROPOSED;\n    }\n\n    function $ACTIVE() external pure returns (uint8) {\n        return VALIDATOR_STATE.ACTIVE;\n    }\n\n    function $EXIT_REQUESTED() external pure returns (uint8) {\n        return VALIDATOR_STATE.EXIT_REQUESTED;\n    }\n\n    function $EXITED() external pure returns (uint8) {\n        return VALIDATOR_STATE.EXITED;\n    }\n\n    function $ALIENATED() external pure returns (uint8) {\n        return VALIDATOR_STATE.ALIENATED;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/helpers/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/helpers/BytesLib.sol\";\n\ncontract $BytesLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => bytes) internal $v_bytes;\n\n    constructor() {}\n\n    function $concat(bytes calldata _preBytes,bytes calldata _postBytes) external pure returns (bytes memory ret0) {\n        (ret0) = BytesLib.concat(_preBytes,_postBytes);\n    }\n\n    function $concatStorage(uint256 _preBytes,bytes calldata _postBytes) external payable {\n        BytesLib.concatStorage($v_bytes[_preBytes],_postBytes);\n    }\n\n    function $slice(bytes calldata _bytes,uint256 _start,uint256 _length) external pure returns (bytes memory ret0) {\n        (ret0) = BytesLib.slice(_bytes,_start,_length);\n    }\n\n    function $toAddress(bytes calldata _bytes,uint256 _start) external pure returns (address ret0) {\n        (ret0) = BytesLib.toAddress(_bytes,_start);\n    }\n\n    function $toUint8(bytes calldata _bytes,uint256 _start) external pure returns (uint8 ret0) {\n        (ret0) = BytesLib.toUint8(_bytes,_start);\n    }\n\n    function $toUint16(bytes calldata _bytes,uint256 _start) external pure returns (uint16 ret0) {\n        (ret0) = BytesLib.toUint16(_bytes,_start);\n    }\n\n    function $toUint32(bytes calldata _bytes,uint256 _start) external pure returns (uint32 ret0) {\n        (ret0) = BytesLib.toUint32(_bytes,_start);\n    }\n\n    function $toUint64(bytes calldata _bytes,uint256 _start) external pure returns (uint64 ret0) {\n        (ret0) = BytesLib.toUint64(_bytes,_start);\n    }\n\n    function $toUint96(bytes calldata _bytes,uint256 _start) external pure returns (uint96 ret0) {\n        (ret0) = BytesLib.toUint96(_bytes,_start);\n    }\n\n    function $toUint128(bytes calldata _bytes,uint256 _start) external pure returns (uint128 ret0) {\n        (ret0) = BytesLib.toUint128(_bytes,_start);\n    }\n\n    function $toUint256(bytes calldata _bytes,uint256 _start) external pure returns (uint256 ret0) {\n        (ret0) = BytesLib.toUint256(_bytes,_start);\n    }\n\n    function $toBytes32(bytes calldata _bytes,uint256 _start) external pure returns (bytes32 ret0) {\n        (ret0) = BytesLib.toBytes32(_bytes,_start);\n    }\n\n    function $equal(bytes calldata _preBytes,bytes calldata _postBytes) external pure returns (bool ret0) {\n        (ret0) = BytesLib.equal(_preBytes,_postBytes);\n    }\n\n    function $equalStorage(uint256 _preBytes,bytes calldata _postBytes) external view returns (bool ret0) {\n        (ret0) = BytesLib.equalStorage($v_bytes[_preBytes],_postBytes);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/helpers/LPToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/helpers/LPToken.sol\";\nimport \"../../../@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../../@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract $LPToken is LPToken {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $_beforeTokenTransfer(address from,address to,uint256 amount) external {\n        super._beforeTokenTransfer(from,to,amount);\n    }\n\n    function $__Ownable_init() external {\n        super.__Ownable_init();\n    }\n\n    function $__Ownable_init_unchained() external {\n        super.__Ownable_init_unchained();\n    }\n\n    function $_checkOwner() external view {\n        super._checkOwner();\n    }\n\n    function $_transferOwnership(address newOwner) external {\n        super._transferOwnership(newOwner);\n    }\n\n    function $__ERC20Burnable_init() external {\n        super.__ERC20Burnable_init();\n    }\n\n    function $__ERC20Burnable_init_unchained() external {\n        super.__ERC20Burnable_init_unchained();\n    }\n\n    function $__ERC20_init(string calldata name_,string calldata symbol_) external {\n        super.__ERC20_init(name_,symbol_);\n    }\n\n    function $__ERC20_init_unchained(string calldata name_,string calldata symbol_) external {\n        super.__ERC20_init_unchained(name_,symbol_);\n    }\n\n    function $_transfer(address from,address to,uint256 amount) external {\n        super._transfer(from,to,amount);\n    }\n\n    function $_mint(address account,uint256 amount) external {\n        super._mint(account,amount);\n    }\n\n    function $_burn(address account,uint256 amount) external {\n        super._burn(account,amount);\n    }\n\n    function $_approve(address owner,address spender,uint256 amount) external {\n        super._approve(owner,spender,amount);\n    }\n\n    function $_spendAllowance(address owner,address spender,uint256 amount) external {\n        super._spendAllowance(owner,spender,amount);\n    }\n\n    function $_afterTokenTransfer(address from,address to,uint256 amount) external {\n        super._afterTokenTransfer(from,to,amount);\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/helpers/test/mocks/OracleExtensionLibMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/helpers/test/mocks/OracleExtensionLibMock.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $OracleExtensionLibMock is OracleExtensionLibMock {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC1155Receiver_init() external {\n        super.__ERC1155Receiver_init();\n    }\n\n    function $__ERC1155Receiver_init_unchained() external {\n        super.__ERC1155Receiver_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/Portal/helpers/test/mocks/StakeModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/helpers/test/mocks/StakeModuleLibMock.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $StakeModuleLibMock is StakeModuleLibMock {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC1155Receiver_init() external {\n        super.__ERC1155Receiver_init();\n    }\n\n    function $__ERC1155Receiver_init_unchained() external {\n        super.__ERC1155Receiver_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/Portal/interfaces/helpers/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/helpers/IDepositContract.sol\";\n\nabstract contract $IDepositContract is IDepositContract {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/helpers/IERC1155PausableBurnableSupply.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../../../../@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"../../../../@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n\nabstract contract $IERC1155Burnable is IERC1155Burnable {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n\nabstract contract $IERC1155Supply is IERC1155Supply {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n\nabstract contract $IERC1155PausableBurnableSupply is IERC1155PausableBurnableSupply {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/helpers/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/helpers/IWhitelist.sol\";\n\nabstract contract $IWhitelist is IWhitelist {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/IgETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/interfaces/IgETH.sol\";\nimport \"../../../contracts/Portal/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\n\nabstract contract $IgETH is IgETH {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/IPortal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/Portal/interfaces/IPortal.sol\";\nimport \"../../../contracts/Portal/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../contracts/Portal/interfaces/modules/IStakeModule.sol\";\n\nabstract contract $IPortal is IPortal {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/middlewares/IgETHMiddleware.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/middlewares/IgETHMiddleware.sol\";\n\nabstract contract $IgETHMiddleware is IgETHMiddleware {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/modules/IDataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/modules/IDataStoreModule.sol\";\n\nabstract contract $IDataStoreModule is IDataStoreModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/modules/IGeodeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol\";\n\nabstract contract $IGeodeModule is IGeodeModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/modules/ILiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/modules/ILiquidityModule.sol\";\n\nabstract contract $ILiquidityModule is ILiquidityModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/modules/IStakeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\n\nabstract contract $IStakeModule is IStakeModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/packages/IGeodePackage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/Portal/interfaces/IPortal.sol\";\n\nabstract contract $IGeodePackage is IGeodePackage {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/interfaces/packages/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../../contracts/Portal/interfaces/packages/IGeodePackage.sol\";\n\nabstract contract $ILiquidityPool is ILiquidityPool {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/DataStoreModule/DataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract $DataStoreModule is DataStoreModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $DataStoreModuleLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => DataStoreModuleLib.IsolatedStorage) internal $v_DataStoreModuleLib_IsolatedStorage;\n\n    constructor() {}\n\n    function $generateId(bytes calldata _name,uint256 _type) external pure returns (uint256 id) {\n        (id) = DataStoreModuleLib.generateId(_name,_type);\n    }\n\n    function $getKey(uint256 id,bytes32 param) external pure returns (bytes32 key) {\n        (key) = DataStoreModuleLib.getKey(id,param);\n    }\n\n    function $readUint(uint256 self,uint256 _id,bytes32 _key) external view returns (uint256 data) {\n        (data) = DataStoreModuleLib.readUint($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key);\n    }\n\n    function $readBytes(uint256 self,uint256 _id,bytes32 _key) external view returns (bytes memory data) {\n        (data) = DataStoreModuleLib.readBytes($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key);\n    }\n\n    function $readAddress(uint256 self,uint256 _id,bytes32 _key) external view returns (address data) {\n        (data) = DataStoreModuleLib.readAddress($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key);\n    }\n\n    function $readUintArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (uint256 data) {\n        (data) = DataStoreModuleLib.readUintArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_index);\n    }\n\n    function $readBytesArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (bytes memory data) {\n        (data) = DataStoreModuleLib.readBytesArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_index);\n    }\n\n    function $readAddressArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (address data) {\n        (data) = DataStoreModuleLib.readAddressArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_index);\n    }\n\n    function $writeUint(uint256 self,uint256 _id,bytes32 _key,uint256 _data) external payable {\n        DataStoreModuleLib.writeUint($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $addUint(uint256 self,uint256 _id,bytes32 _key,uint256 _addend) external payable {\n        DataStoreModuleLib.addUint($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_addend);\n    }\n\n    function $subUint(uint256 self,uint256 _id,bytes32 _key,uint256 _minuend) external payable {\n        DataStoreModuleLib.subUint($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_minuend);\n    }\n\n    function $writeBytes(uint256 self,uint256 _id,bytes32 _key,bytes calldata _data) external payable {\n        DataStoreModuleLib.writeBytes($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $writeAddress(uint256 self,uint256 _id,bytes32 _key,address _data) external payable {\n        DataStoreModuleLib.writeAddress($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendUintArray(uint256 self,uint256 _id,bytes32 _key,uint256 _data) external payable {\n        DataStoreModuleLib.appendUintArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendBytesArray(uint256 self,uint256 _id,bytes32 _key,bytes calldata _data) external payable {\n        DataStoreModuleLib.appendBytesArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendAddressArray(uint256 self,uint256 _id,bytes32 _key,address _data) external payable {\n        DataStoreModuleLib.appendAddressArray($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendUintArrayBatch(uint256 self,uint256 _id,bytes32 _key,uint256[] calldata _data) external payable {\n        DataStoreModuleLib.appendUintArrayBatch($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendBytesArrayBatch(uint256 self,uint256 _id,bytes32 _key,bytes[] calldata _data) external payable {\n        DataStoreModuleLib.appendBytesArrayBatch($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    function $appendAddressArrayBatch(uint256 self,uint256 _id,bytes32 _key,address[] calldata _data) external payable {\n        DataStoreModuleLib.appendAddressArrayBatch($v_DataStoreModuleLib_IsolatedStorage[self],_id,_key,_data);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/GeodeModule/GeodeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../../../contracts/Portal/globals/id_type.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/Portal/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"../../../../@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nabstract contract $GeodeModule is GeodeModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $_IMPLEMENTATION_SLOT() external pure returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    function $_ADMIN_SLOT() external pure returns (bytes32) {\n        return _ADMIN_SLOT;\n    }\n\n    function $_BEACON_SLOT() external pure returns (bytes32) {\n        return _BEACON_SLOT;\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(bytes calldata versionName) external {\n        super._setContractVersion(versionName);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,bytes calldata versionName) external {\n        super._handleUpgrade(proposed_implementation,versionName);\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $__ERC1967Upgrade_init() external {\n        super.__ERC1967Upgrade_init();\n    }\n\n    function $__ERC1967Upgrade_init_unchained() external {\n        super.__ERC1967Upgrade_init_unchained();\n    }\n\n    function $_getImplementation() external view returns (address ret0) {\n        (ret0) = super._getImplementation();\n    }\n\n    function $_upgradeTo(address newImplementation) external {\n        super._upgradeTo(newImplementation);\n    }\n\n    function $_upgradeToAndCall(address newImplementation,bytes calldata data,bool forceCall) external {\n        super._upgradeToAndCall(newImplementation,data,forceCall);\n    }\n\n    function $_upgradeToAndCallUUPS(address newImplementation,bytes calldata data,bool forceCall) external {\n        super._upgradeToAndCallUUPS(newImplementation,data,forceCall);\n    }\n\n    function $_getAdmin() external view returns (address ret0) {\n        (ret0) = super._getAdmin();\n    }\n\n    function $_changeAdmin(address newAdmin) external {\n        super._changeAdmin(newAdmin);\n    }\n\n    function $_getBeacon() external view returns (address ret0) {\n        (ret0) = super._getBeacon();\n    }\n\n    function $_upgradeBeaconToAndCall(address newBeacon,bytes calldata data,bool forceCall) external {\n        super._upgradeBeaconToAndCall(newBeacon,data,forceCall);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../../../contracts/Portal/globals/macros.sol\";\nimport \"../../../../../contracts/Portal/globals/id_type.sol\";\nimport \"../../../../../contracts/Portal/globals/reserved_key_space.sol\";\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $GeodeModuleLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => GeodeModuleLib.DualGovernance) internal $v_GeodeModuleLib_DualGovernance;\n\n    mapping(uint256 => DataStoreModuleLib.IsolatedStorage) internal $v_DataStoreModuleLib_IsolatedStorage;\n\n    event return$propose(uint256 id);\n\n    event return$approveProposal(address _controller, uint256 _type, bytes _name);\n\n    constructor() {}\n\n    function $MIN_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLib.MIN_PROPOSAL_DURATION;\n    }\n\n    function $MAX_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLib.MAX_PROPOSAL_DURATION;\n    }\n\n    function $MAX_SENATE_PERIOD() external pure returns (uint32) {\n        return GeodeModuleLib.MAX_SENATE_PERIOD;\n    }\n\n    function $isUpgradeAllowed(uint256 self,address proposedImplementation,address currentImplementation) external view returns (bool ret0) {\n        (ret0) = GeodeModuleLib.isUpgradeAllowed($v_GeodeModuleLib_DualGovernance[self],proposedImplementation,currentImplementation);\n    }\n\n    function $getProposal(uint256 self,uint256 id) external view returns (GeodeModuleLib.Proposal memory ret0) {\n        (ret0) = GeodeModuleLib.getProposal($v_GeodeModuleLib_DualGovernance[self],id);\n    }\n\n    function $_setSenate(uint256 self,address _newSenate,uint256 _expiry) external payable {\n        GeodeModuleLib._setSenate($v_GeodeModuleLib_DualGovernance[self],_newSenate,_expiry);\n    }\n\n    function $propose(uint256 self,uint256 DATASTORE,address _CONTROLLER,uint256 _TYPE,bytes calldata _NAME,uint256 duration) external payable returns (uint256 id) {\n        (id) = GeodeModuleLib.propose($v_GeodeModuleLib_DualGovernance[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_CONTROLLER,_TYPE,_NAME,duration);\n        emit return$propose(id);\n    }\n\n    function $rescueSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLib.rescueSenate($v_GeodeModuleLib_DualGovernance[self],_newSenate);\n    }\n\n    function $approveProposal(uint256 self,uint256 DATASTORE,uint256 id) external payable returns (address _controller, uint256 _type, bytes memory _name) {\n        (_controller, _type, _name) = GeodeModuleLib.approveProposal($v_GeodeModuleLib_DualGovernance[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id);\n        emit return$approveProposal(_controller, _type, _name);\n    }\n\n    function $changeSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLib.changeSenate($v_GeodeModuleLib_DualGovernance[self],_newSenate);\n    }\n\n    function $changeIdCONTROLLER(uint256 DATASTORE,uint256 id,address newCONTROLLER) external payable {\n        GeodeModuleLib.changeIdCONTROLLER($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,newCONTROLLER);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/StakeModule/libs/DepositContractLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../../contracts/Portal/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../../contracts/Portal/helpers/BytesLib.sol\";\n\ncontract $DepositContractLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $DEPOSIT_CONTRACT() external pure returns (IDepositContract) {\n        return DepositContractLib.DEPOSIT_CONTRACT;\n    }\n\n    function $PUBKEY_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.PUBKEY_LENGTH;\n    }\n\n    function $SIGNATURE_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.SIGNATURE_LENGTH;\n    }\n\n    function $WITHDRAWAL_CREDENTIALS_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.WITHDRAWAL_CREDENTIALS_LENGTH;\n    }\n\n    function $DEPOSIT_AMOUNT() external pure returns (uint256) {\n        return DepositContractLib.DEPOSIT_AMOUNT;\n    }\n\n    function $DEPOSIT_AMOUNT_PRESTAKE() external pure returns (uint256) {\n        return DepositContractLib.DEPOSIT_AMOUNT_PRESTAKE;\n    }\n\n    function $MAX_DEPOSITS_PER_CALL() external pure returns (uint256) {\n        return DepositContractLib.MAX_DEPOSITS_PER_CALL;\n    }\n\n    function $_pad64(bytes calldata _b) external pure returns (bytes memory ret0) {\n        (ret0) = DepositContractLib._pad64(_b);\n    }\n\n    function $_toLittleEndian64(uint256 _value) external pure returns (uint256 result) {\n        (result) = DepositContractLib._toLittleEndian64(_value);\n    }\n\n    function $_getDepositDataRoot(bytes calldata _pubkey,bytes calldata _withdrawalCredentials,bytes calldata _signature,uint256 _stakeAmount) external pure returns (bytes32 ret0) {\n        (ret0) = DepositContractLib._getDepositDataRoot(_pubkey,_withdrawalCredentials,_signature,_stakeAmount);\n    }\n\n    function $addressToWC(address wcAddress) external pure returns (bytes memory ret0) {\n        (ret0) = DepositContractLib.addressToWC(wcAddress);\n    }\n\n    function $depositValidator(bytes calldata pubkey,bytes calldata withdrawalCredential,bytes calldata signature,uint256 amount) external payable {\n        DepositContractLib.depositValidator(pubkey,withdrawalCredential,signature,amount);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/StakeModule/libs/OracleExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../../contracts/Portal/globals/macros.sol\";\nimport \"../../../../../contracts/Portal/globals/reserved_key_space.sol\";\nimport \"../../../../../contracts/Portal/globals/id_type.sol\";\nimport \"../../../../../contracts/Portal/globals/validator_state.sol\";\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../../@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ncontract $OracleExtensionLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => StakeModuleLib.PooledStaking) internal $v_StakeModuleLib_PooledStaking;\n\n    mapping(uint256 => DataStoreModuleLib.IsolatedStorage) internal $v_DataStoreModuleLib_IsolatedStorage;\n\n    constructor() {}\n\n    function $MONOPOLY_RATIO() external pure returns (uint256) {\n        return OracleExtensionLib.MONOPOLY_RATIO;\n    }\n\n    function $MIN_VALIDATOR_COUNT() external pure returns (uint256) {\n        return OracleExtensionLib.MIN_VALIDATOR_COUNT;\n    }\n\n    function $_alienateValidator(uint256 STAKE,uint256 DATASTORE,uint256 verificationIndex,bytes calldata _pk) external payable {\n        OracleExtensionLib._alienateValidator($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],verificationIndex,_pk);\n    }\n\n    function $updateVerificationIndex(uint256 STAKE,uint256 DATASTORE,uint256 validatorVerificationIndex,bytes[] calldata alienatedPubkeys) external payable {\n        OracleExtensionLib.updateVerificationIndex($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],validatorVerificationIndex,alienatedPubkeys);\n    }\n\n    function $regulateOperators(uint256 STAKE,uint256 DATASTORE,uint256[] calldata feeThefts,bytes[] calldata proofs) external payable {\n        OracleExtensionLib.regulateOperators($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],feeThefts,proofs);\n    }\n\n    function $reportBeacon(uint256 STAKE,bytes32 priceMerkleRoot,bytes32 balanceMerkleRoot,uint256 allValidatorsCount) external payable {\n        OracleExtensionLib.reportBeacon($v_StakeModuleLib_PooledStaking[STAKE],priceMerkleRoot,balanceMerkleRoot,allValidatorsCount);\n    }\n\n    function $_sanityCheck(uint256 STAKE,uint256 DATASTORE,uint256 _id,uint256 _newPrice) external view {\n        OracleExtensionLib._sanityCheck($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_newPrice);\n    }\n\n    function $_priceSync(uint256 STAKE,uint256 DATASTORE,uint256 _poolId,uint256 _price,bytes32[] calldata _priceProof) external payable {\n        OracleExtensionLib._priceSync($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId,_price,_priceProof);\n    }\n\n    function $priceSync(uint256 STAKE,uint256 DATASTORE,uint256 poolId,uint256 price,bytes32[] calldata priceProof) external payable {\n        OracleExtensionLib.priceSync($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,price,priceProof);\n    }\n\n    function $priceSyncBatch(uint256 STAKE,uint256 DATASTORE,uint256[] calldata poolIds,uint256[] calldata prices,bytes32[][] calldata priceProofs) external payable {\n        OracleExtensionLib.priceSyncBatch($v_StakeModuleLib_PooledStaking[STAKE],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolIds,prices,priceProofs);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/StakeModule/libs/StakeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../../contracts/Portal/globals/macros.sol\";\nimport \"../../../../../contracts/Portal/globals/id_type.sol\";\nimport \"../../../../../contracts/Portal/globals/validator_state.sol\";\nimport \"../../../../../contracts/Portal/globals/reserved_key_space.sol\";\nimport \"../../../../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../../contracts/Portal/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../../contracts/Portal/interfaces/IgETH.sol\";\nimport \"../../../../../contracts/Portal/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"../../../../../contracts/Portal/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../../contracts/Portal/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../../contracts/Portal/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../../@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../../../../../@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\ncontract $StakeModuleLib {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => DataStoreModuleLib.IsolatedStorage) internal $v_DataStoreModuleLib_IsolatedStorage;\n\n    mapping(uint256 => StakeModuleLib.PooledStaking) internal $v_StakeModuleLib_PooledStaking;\n\n    event return$initiatePool(uint256 poolId);\n\n    event return$_deployGeodePackage(address packageInstance);\n\n    event return$increaseWalletBalance(bool success);\n\n    event return$decreaseWalletBalance(bool success);\n\n    event return$_approveOperator(uint256 oldAllowance);\n\n    event return$_mintgETH(uint256 mintedgETH);\n\n    event return$_buyback(uint256 remETH, uint256 boughtgETH);\n\n    event return$deposit(uint256 boughtgETH, uint256 mintedgETH);\n\n    constructor() {}\n\n    function $MAX_GOVERNANCE_FEE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_GOVERNANCE_FEE;\n    }\n\n    function $MAX_MAINTENANCE_FEE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_MAINTENANCE_FEE;\n    }\n\n    function $MAX_ALLOWANCE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_ALLOWANCE;\n    }\n\n    function $FALLBACK_THRESHOLD() external pure returns (uint256) {\n        return StakeModuleLib.FALLBACK_THRESHOLD;\n    }\n\n    function $PRICE_EXPIRY() external pure returns (uint256) {\n        return StakeModuleLib.PRICE_EXPIRY;\n    }\n\n    function $IGNORABLE_DEBT() external pure returns (uint256) {\n        return StakeModuleLib.IGNORABLE_DEBT;\n    }\n\n    function $MIN_VALIDATOR_PERIOD() external pure returns (uint256) {\n        return StakeModuleLib.MIN_VALIDATOR_PERIOD;\n    }\n\n    function $MAX_VALIDATOR_PERIOD() external pure returns (uint256) {\n        return StakeModuleLib.MAX_VALIDATOR_PERIOD;\n    }\n\n    function $SWITCH_LATENCY() external pure returns (uint256) {\n        return StakeModuleLib.SWITCH_LATENCY;\n    }\n\n    function $PRISON_SENTENCE() external pure returns (uint256) {\n        return StakeModuleLib.PRISON_SENTENCE;\n    }\n\n    function $_authenticate(uint256 DATASTORE,uint256 _id,bool _expectCONTROLLER,bool _expectMaintainer,bool[2] calldata _restrictionMap) external view {\n        StakeModuleLib._authenticate($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_expectCONTROLLER,_expectMaintainer,_restrictionMap);\n    }\n\n    function $initiateOperator(uint256 DATASTORE,uint256 id,uint256 fee,uint256 validatorPeriod,address maintainer) external payable {\n        StakeModuleLib.initiateOperator($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,fee,validatorPeriod,maintainer);\n    }\n\n    function $initiatePool(uint256 self,uint256 DATASTORE,uint256 fee,uint256 middlewareVersion,address maintainer,bytes calldata name,bytes calldata middleware_data,bool[3] calldata config) external payable returns (uint256 poolId) {\n        (poolId) = StakeModuleLib.initiatePool($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],fee,middlewareVersion,maintainer,name,middleware_data,config);\n        emit return$initiatePool(poolId);\n    }\n\n    function $_setgETHMiddleware(uint256 self,uint256 DATASTORE,uint256 id,address _middleware) external payable {\n        StakeModuleLib._setgETHMiddleware($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,_middleware);\n    }\n\n    function $_deploygETHMiddleware(uint256 self,uint256 DATASTORE,uint256 _id,uint256 _versionId,bytes calldata _middleware_data) external payable {\n        StakeModuleLib._deploygETHMiddleware($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_versionId,_middleware_data);\n    }\n\n    function $_deployGeodePackage(uint256 self,uint256 DATASTORE,uint256 _poolId,uint256 _type,bytes calldata _package_data) external payable returns (address packageInstance) {\n        (packageInstance) = StakeModuleLib._deployGeodePackage($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId,_type,_package_data);\n        emit return$_deployGeodePackage(packageInstance);\n    }\n\n    function $_deployWithdrawalContract(uint256 self,uint256 DATASTORE,uint256 _poolId) external payable {\n        StakeModuleLib._deployWithdrawalContract($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId);\n    }\n\n    function $deployLiquidityPool(uint256 self,uint256 DATASTORE,uint256 poolId) external payable {\n        StakeModuleLib.deployLiquidityPool($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId);\n    }\n\n    function $setPoolVisibility(uint256 DATASTORE,uint256 poolId,bool makePrivate) external payable {\n        StakeModuleLib.setPoolVisibility($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,makePrivate);\n    }\n\n    function $setWhitelist(uint256 DATASTORE,uint256 poolId,address whitelist) external payable {\n        StakeModuleLib.setWhitelist($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,whitelist);\n    }\n\n    function $isPrivatePool(uint256 DATASTORE,uint256 poolId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isPrivatePool($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId);\n    }\n\n    function $isWhitelisted(uint256 DATASTORE,uint256 poolId,address staker) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isWhitelisted($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,staker);\n    }\n\n    function $_setMaintainer(uint256 DATASTORE,uint256 _id,address _newMaintainer) external payable {\n        StakeModuleLib._setMaintainer($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_newMaintainer);\n    }\n\n    function $changeMaintainer(uint256 DATASTORE,uint256 id,address newMaintainer) external payable {\n        StakeModuleLib.changeMaintainer($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,newMaintainer);\n    }\n\n    function $getMaintenanceFee(uint256 DATASTORE,uint256 id) external view returns (uint256 fee) {\n        (fee) = StakeModuleLib.getMaintenanceFee($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id);\n    }\n\n    function $_setMaintenanceFee(uint256 DATASTORE,uint256 _id,uint256 _newFee) external payable {\n        StakeModuleLib._setMaintenanceFee($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_newFee);\n    }\n\n    function $switchMaintenanceFee(uint256 DATASTORE,uint256 id,uint256 newFee) external payable {\n        StakeModuleLib.switchMaintenanceFee($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,newFee);\n    }\n\n    function $_increaseWalletBalance(uint256 DATASTORE,uint256 _id,uint256 _value) external payable {\n        StakeModuleLib._increaseWalletBalance($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_value);\n    }\n\n    function $_decreaseWalletBalance(uint256 DATASTORE,uint256 _id,uint256 _value) external payable {\n        StakeModuleLib._decreaseWalletBalance($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_id,_value);\n    }\n\n    function $increaseWalletBalance(uint256 DATASTORE,uint256 id) external payable returns (bool success) {\n        (success) = StakeModuleLib.increaseWalletBalance($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id);\n        emit return$increaseWalletBalance(success);\n    }\n\n    function $decreaseWalletBalance(uint256 DATASTORE,uint256 id,uint256 value) external payable returns (bool success) {\n        (success) = StakeModuleLib.decreaseWalletBalance($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id,value);\n        emit return$decreaseWalletBalance(success);\n    }\n\n    function $getValidatorPeriod(uint256 DATASTORE,uint256 id) external view returns (uint256 period) {\n        (period) = StakeModuleLib.getValidatorPeriod($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],id);\n    }\n\n    function $_setValidatorPeriod(uint256 DATASTORE,uint256 _operatorId,uint256 _newPeriod) external payable {\n        StakeModuleLib._setValidatorPeriod($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_operatorId,_newPeriod);\n    }\n\n    function $switchValidatorPeriod(uint256 DATASTORE,uint256 operatorId,uint256 newPeriod) external payable {\n        StakeModuleLib.switchValidatorPeriod($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],operatorId,newPeriod);\n    }\n\n    function $isPrisoned(uint256 DATASTORE,uint256 operatorId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isPrisoned($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],operatorId);\n    }\n\n    function $_imprison(uint256 DATASTORE,uint256 _operatorId,bytes calldata _proof) external payable {\n        StakeModuleLib._imprison($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_operatorId,_proof);\n    }\n\n    function $blameOperator(uint256 self,uint256 DATASTORE,bytes calldata pk) external payable {\n        StakeModuleLib.blameOperator($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],pk);\n    }\n\n    function $operatorAllowance(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 operatorId) external view returns (uint256 remValidators) {\n        (remValidators) = StakeModuleLib.operatorAllowance($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,operatorId);\n    }\n\n    function $_setFallbackOperator(uint256 DATASTORE,uint256 poolId,uint256 operatorId) external payable {\n        StakeModuleLib._setFallbackOperator($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,operatorId);\n    }\n\n    function $_approveOperator(uint256 DATASTORE,uint256 poolId,uint256 operatorId,uint256 allowance) external payable returns (uint256 oldAllowance) {\n        (oldAllowance) = StakeModuleLib._approveOperator($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,operatorId,allowance);\n        emit return$_approveOperator(oldAllowance);\n    }\n\n    function $delegate(uint256 DATASTORE,uint256 poolId,uint256[] calldata operatorIds,uint256[] calldata allowances,uint256 fallbackOperator) external payable {\n        StakeModuleLib.delegate($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,operatorIds,allowances,fallbackOperator);\n    }\n\n    function $_isGeodePackageIsolated(address _packageAddress) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib._isGeodePackageIsolated(_packageAddress);\n    }\n\n    function $_getLiquidityPool(uint256 DATASTORE,uint256 _poolId) external view returns (ILiquidityPool ret0) {\n        (ret0) = StakeModuleLib._getLiquidityPool($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId);\n    }\n\n    function $isPriceValid(uint256 self,uint256 poolId) external view returns (bool isValid) {\n        (isValid) = StakeModuleLib.isPriceValid($v_StakeModuleLib_PooledStaking[self],poolId);\n    }\n\n    function $isMintingAllowed(uint256 self,uint256 DATASTORE,uint256 poolId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isMintingAllowed($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId);\n    }\n\n    function $_mintgETH(uint256 self,uint256 DATASTORE,uint256 _poolId,uint256 _ethAmount) external payable returns (uint256 mintedgETH) {\n        (mintedgETH) = StakeModuleLib._mintgETH($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId,_ethAmount);\n        emit return$_mintgETH(mintedgETH);\n    }\n\n    function $_buyback(uint256 DATASTORE,uint256 _poolId,uint256 _maxEthToSell,uint256 _deadline) external payable returns (uint256 remETH, uint256 boughtgETH) {\n        (remETH, boughtgETH) = StakeModuleLib._buyback($v_DataStoreModuleLib_IsolatedStorage[DATASTORE],_poolId,_maxEthToSell,_deadline);\n        emit return$_buyback(remETH, boughtgETH);\n    }\n\n    function $deposit(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 mingETH,uint256 deadline,address receiver) external payable returns (uint256 boughtgETH, uint256 mintedgETH) {\n        (boughtgETH, mintedgETH) = StakeModuleLib.deposit($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,mingETH,deadline,receiver);\n        emit return$deposit(boughtgETH, mintedgETH);\n    }\n\n    function $_canStake(uint256 self,bytes calldata _pubkey,uint256 _verificationIndex) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib._canStake($v_StakeModuleLib_PooledStaking[self],_pubkey,_verificationIndex);\n    }\n\n    function $canStake(uint256 self,bytes calldata pubkey) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.canStake($v_StakeModuleLib_PooledStaking[self],pubkey);\n    }\n\n    function $proposeStake(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 operatorId,bytes[] calldata pubkeys,bytes[] calldata signatures1,bytes[] calldata signatures31) external payable {\n        StakeModuleLib.proposeStake($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],poolId,operatorId,pubkeys,signatures1,signatures31);\n    }\n\n    function $stake(uint256 self,uint256 DATASTORE,uint256 operatorId,bytes[] calldata pubkeys) external payable {\n        StakeModuleLib.stake($v_StakeModuleLib_PooledStaking[self],$v_DataStoreModuleLib_IsolatedStorage[DATASTORE],operatorId,pubkeys);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/modules/StakeModule/StakeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/Portal/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../contracts/Portal/globals/macros.sol\";\nimport \"../../../../contracts/Portal/interfaces/IgETH.sol\";\nimport \"../../../../contracts/Portal/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/Portal/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../contracts/Portal/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"../../../../@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"../../../../@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../../../../@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nabstract contract $StakeModule is StakeModule {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC1155Receiver_init() external {\n        super.__ERC1155Receiver_init();\n    }\n\n    function $__ERC1155Receiver_init_unchained() external {\n        super.__ERC1155Receiver_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/Portal/Portal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/Portal/Portal.sol\";\nimport \"../../contracts/Portal/globals/id_type.sol\";\nimport \"../../contracts/Portal/interfaces/modules/IGeodeModule.sol\";\nimport \"../../contracts/Portal/interfaces/IPortal.sol\";\nimport \"../../contracts/Portal/interfaces/modules/IStakeModule.sol\";\nimport \"../../contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../contracts/Portal/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../contracts/Portal/modules/StakeModule/StakeModule.sol\";\n\ncontract $Portal is Portal {\n    bytes32 public __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() {}\n\n    function $_IMPLEMENTATION_SLOT() external pure returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    function $_ADMIN_SLOT() external pure returns (bytes32) {\n        return _ADMIN_SLOT;\n    }\n\n    function $_BEACON_SLOT() external pure returns (bytes32) {\n        return _BEACON_SLOT;\n    }\n\n    function $__Portal_init(address _governance,address _senate,address _gETH,address _oracle_position,bytes calldata versionName) external {\n        super.__Portal_init(_governance,_senate,_gETH,_oracle_position,versionName);\n    }\n\n    function $__Portal_init_unchained() external {\n        super.__Portal_init_unchained();\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(bytes calldata versionName) external {\n        super._setContractVersion(versionName);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,bytes calldata versionName) external {\n        super._handleUpgrade(proposed_implementation,versionName);\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $__ERC1967Upgrade_init() external {\n        super.__ERC1967Upgrade_init();\n    }\n\n    function $__ERC1967Upgrade_init_unchained() external {\n        super.__ERC1967Upgrade_init_unchained();\n    }\n\n    function $_getImplementation() external view returns (address ret0) {\n        (ret0) = super._getImplementation();\n    }\n\n    function $_upgradeTo(address newImplementation) external {\n        super._upgradeTo(newImplementation);\n    }\n\n    function $_upgradeToAndCall(address newImplementation,bytes calldata data,bool forceCall) external {\n        super._upgradeToAndCall(newImplementation,data,forceCall);\n    }\n\n    function $_upgradeToAndCallUUPS(address newImplementation,bytes calldata data,bool forceCall) external {\n        super._upgradeToAndCallUUPS(newImplementation,data,forceCall);\n    }\n\n    function $_getAdmin() external view returns (address ret0) {\n        (ret0) = super._getAdmin();\n    }\n\n    function $_changeAdmin(address newAdmin) external {\n        super._changeAdmin(newAdmin);\n    }\n\n    function $_getBeacon() external view returns (address ret0) {\n        (ret0) = super._getBeacon();\n    }\n\n    function $_upgradeBeaconToAndCall(address newBeacon,bytes calldata data,bool forceCall) external {\n        super._upgradeBeaconToAndCall(newBeacon,data,forceCall);\n    }\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC1155Receiver_init() external {\n        super.__ERC1155Receiver_init();\n    }\n\n    function $__ERC1155Receiver_init_unchained() external {\n        super.__ERC1155Receiver_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint8 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts/Portal/globals/id_type.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n/**\n * @notice ID_TYPE is an internal library that acts like an ENUM.\n *\n * @dev Used within the limited upgradability pattern:\n *\n * NONE & GAP: should not be used.\n *\n * Dual Governance:\n * * SENATE: points to a proposal that will update the current SENATE address of a package(or Portal).\n * * CONTRACT_UPGRADE: proposal to change the given contract's implementation.\n *\n * Users:\n * * OPERATOR: permissionned Node Operators (hosted on Portal).\n * * POOL: permissionless staking pools (hosted on Portal).\n *\n * Packages: (hosted on StakeModuleLib)\n * * An ID can only point to 1(one) Package version' implementation address at a given point.\n * * Can be upgraded by a dual governance, via pullUpgrade.\n * * * Portal's dual governance consists of a Governance Token(governance) and a Senate(senate).\n * * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\n * * Built by utilizing the Modules.\n * * LiquidityPool and WithdrawalContract are some examples.\n *\n * Middlewares: (hosted on StakeModuleLib)\n * * An ID can point to multiple Middleware version' implementation address at the same time.\n * * Can not be upgraded.\n * * Do not have any guides to build really.\n * * Currently only gETHMiddlewares\n *\n *  Limits:\n *  * We simply set limits to separate a group of types from others. Like Packages and Middlewares.\n *\n * @dev all LIMIT parameters are exclusive, prevents double usage.\n */\nlibrary ID_TYPE {\n  /// @notice TYPE 0: *invalid*\n  uint256 internal constant NONE = 0;\n\n  /// @notice TYPE 1: Senate\n  uint256 internal constant SENATE = 1;\n\n  /// @notice TYPE 2: Contract Upgrade\n  uint256 internal constant CONTRACT_UPGRADE = 2;\n\n  /// @notice TYPE 3: *gap*: formally represented the admin contract. reserved to be never used.\n  uint256 internal constant __GAP__ = 3;\n\n  /// --\n\n  /// @notice TYPE 4: USER: Permissionned Node Operator\n  uint256 internal constant OPERATOR = 4;\n\n  /// @notice TYPE 5: USER: Staking Pool\n  uint256 internal constant POOL = 5;\n\n  /// --\n\n  /// @notice TYPE 10000: Limit: exclusive, minimum TYPE that will be percieved as a package\n  uint256 internal constant LIMIT_MIN_PACKAGE = 10000;\n\n  /// @notice TYPE 10011: Package: Portal is also a package\n  uint256 internal constant PACKAGE_PORTAL = 10001;\n\n  /// @notice TYPE 10011: Package: The Withdrawal Credential Contract\n  uint256 internal constant PACKAGE_WITHDRAWAL_CONTRACT = 10011;\n\n  /// @notice TYPE 10021: Package: A Liquidity Pool\n  uint256 internal constant PACKAGE_LIQUIDITY_POOL = 10021;\n\n  /// @notice TYPE 19999: Limit: exclusive, maximum TYPE that will be percieved as a package\n  uint256 internal constant LIMIT_MAX_PACKAGE = 19999;\n\n  /// --\n\n  /// @notice TYPE 20000: Limit: exclusive, minimum TYPE that will be percieved as a middleware\n  uint256 internal constant LIMIT_MIN_MIDDLEWARE = 20000;\n\n  /// @notice TYPE 20031: Middleware: A new gETH interface\n  uint256 internal constant MIDDLEWARE_GETH = 20011;\n\n  /// @notice TYPE 29999: Limit: exclusive, maximum TYPE that will be percieved as a middleware\n  uint256 internal constant LIMIT_MAX_MIDDLEWARE = 29999;\n}\n"
    },
    "contracts/Portal/globals/macros.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// no floats in solidity. If needed, PERCENTAGE_DENOMINATOR always represents \"1\" (100%)\nuint256 constant PERCENTAGE_DENOMINATOR = 10 ** 10;\n"
    },
    "contracts/Portal/globals/reserved_key_space.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n/**\n * @notice Reserved Key Space for DataStoreModule\n * * helps preventing potential dev mistakes.\n * * helps keeping track of them.\n * * limits keys to bytes32.\n *\n * @dev utilize a key with rks.key\n * @dev keep this list in alphabetical order, per module.\n * @dev NEVER name your variables something else other than *its string value*.\n * @dev ! array keys with readUint returns the lenght of the array !\n */\nlibrary RESERVED_KEY_SPACE {\n  /**\n   * @dev reserved on GeodeModuleLib\n   */\n\n  /**\n   * @custom:type address\n   * @custom:definition representing body of an id\n   */\n  bytes32 internal constant CONTROLLER = \"CONTROLLER\";\n\n  /**\n   * @custom:type bytes\n   * @custom:definition base of an id\n   */\n  bytes32 internal constant NAME = \"NAME\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition identifier for an id, based on ID_TYPEs\n   */\n  bytes32 internal constant TYPE = \"TYPE\";\n\n  /**\n   * @dev reserved on StakeModuleLib\n   */\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition number of active validators run by an operator for a pool\n   */\n  bytes32 internal constant activeValidators = \"activeValidators\";\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition max amount of validators for an operator to run, for a specific pool.\n   */\n  bytes32 internal constant allowance = \"allowance\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition special operator that has max allowance, if threshold is hit for the pool\n   */\n  bytes32 internal constant fallbackOperator = \"fallbackOperator\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition fee of the pool or operator, will be shadowed by priorFee if switching\n   */\n  bytes32 internal constant fee = \"fee\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition effective timestamp pointing to the latest delayed fee change\n   */\n  bytes32 internal constant feeSwitch = \"feeSwitch\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition the timestamp of an \"user\" TYPE id\n   */\n  bytes32 internal constant initiated = \"initiated\";\n\n  /**\n   * @custom:type address\n   * @custom:definition bound liquidity pool of a pool\n   */\n  bytes32 internal constant liquidityPool = \"liquidityPool\";\n\n  /**\n   * @custom:type address\n   * @custom:definition hot wallet for pool and operators, automatooor\n   */\n  bytes32 internal constant maintainer = \"maintainer\";\n\n  /**\n   * @custom:type address array, direct call returns length\n   * @custom:definition contracts with more than one versions, ex: gETHMiddlewares of a pool\n   */\n  bytes32 internal constant middlewares = \"middlewares\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition effective timestamp pointing to the latest delayed validator period change\n   */\n  bytes32 internal constant periodSwitch = \"periodSwitch\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition fee that will be effective if fee is currently switching\n   */\n  bytes32 internal constant priorFee = \"priorFee\";\n\n  /**\n   * @custom:type address\n   * @custom:definition fee that will be effective if validatorPeriod is currently switching\n   */\n  bytes32 internal constant priorPeriod = \"priorPeriod\";\n\n  /**\n   * @custom:type uint, bool\n   * @custom:definition 1(true) if id is a private pool\n   */\n  bytes32 internal constant privatePool = \"privatePool\";\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition proposed validator count for\n   */\n  bytes32 internal constant proposedValidators = \"proposedValidators\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition timestamp of the date of the latest imprisonment for an operator\n   */\n  bytes32 internal constant release = \"release\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition 32 eth is secured, per proposed-but-not-yet-activated validator\n   */\n  bytes32 internal constant secured = \"secured\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition collateral waiting to be staked, in wei\n   */\n  bytes32 internal constant surplus = \"surplus\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition sum of all allowances for a pool\n   */\n\n  bytes32 internal constant totalAllowance = \"totalAllowance\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition seconds, time that passes before the expected exit is reached for a validator\n   */\n  bytes32 internal constant validatorPeriod = \"validatorPeriod\";\n\n  /**\n   * @custom:type bytes array, direct call returns length\n   * @custom:definition lists all (any state) validators' pubkeys for a pool, or an operator\n   */\n  bytes32 internal constant validators = \"validators\";\n\n  /**\n   * @custom:type address\n   * @custom:definition custodian of validator funds for a pool\n   */\n  bytes32 internal constant withdrawalContract = \"withdrawalContract\";\n\n  /**\n   * @custom:type bytes\n   * @custom:definition derived from withdrawalContract\n   */\n  bytes32 internal constant withdrawalCredential = \"withdrawalCredential\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition size of the internal wallet, which accrues fees etc. in wei\n   */\n  bytes32 internal constant wallet = \"wallet\";\n\n  /**\n   * @custom:type address\n   * @custom:definition whitelist contract for the pool\n   */\n  bytes32 internal constant whitelist = \"whitelist\";\n\n  /**\n   * @dev reserved on OracleExtensionLib\n   */\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition number of alienated validators run by an operator for a pool\n   */\n  bytes32 internal constant alienValidators = \"alienValidators\";\n}\n"
    },
    "contracts/Portal/globals/validator_state.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n/**\n * @notice VALIDATOR_STATE: keeping track of validators within The Staking Library.\n */\nlibrary VALIDATOR_STATE {\n  /// @notice STATE 0: *invalid*\n  uint8 internal constant NONE = 0;\n\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract.\n  uint8 internal constant PROPOSED = 1;\n\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator.\n  uint8 internal constant ACTIVE = 2;\n\n  /// @notice STATE 3: validator is called to be exited.\n  uint8 internal constant EXIT_REQUESTED = 3;\n\n  /// @notice STATE 4: validator is fully exited.\n  uint8 internal constant EXITED = 4;\n\n  /// @notice STATE 69: proposal was malicious(alien). Maybe faulty signatures or probably (https://bit.ly/3Tkc6UC)\n  uint8 internal constant ALIENATED = 69;\n}\n"
    },
    "contracts/Portal/helpers/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity =0.8.7;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n    {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint8)\n    {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint16)\n    {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint64)\n    {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint96)\n    {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint128)\n    {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/Portal/helpers/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// external\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20BurnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user shares when providing liquidity to LPP.\n * @dev Only LPP contracts should initialize and own LPToken contracts.\n */\ncontract LPToken is ERC20BurnableUpgradeable, OwnableUpgradeable {\n  ///@custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes this LPToken contract with the given name and symbol\n   * @dev The caller of this function will become the owner. A Swap contract should call this\n   * in its initializer function.\n   * @param name name of this token\n   * @param symbol symbol of this token\n   */\n  function initialize(string memory name, string memory symbol) external initializer {\n    __Context_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n    __ERC20Burnable_init_unchained();\n    __Ownable_init_unchained();\n  }\n\n  /**\n   * @notice Mints the given amount of LPToken to the recipient.\n   * @dev only owner can call this mint function\n   * @param recipient address of account to receive the tokens\n   * @param amount amount of tokens to mint\n   */\n  function mint(address recipient, uint256 amount) external onlyOwner {\n    require(amount != 0, \"LPToken: cannot mint 0\");\n    _mint(recipient, amount);\n  }\n\n  /**\n   * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n   * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\n   * This assumes the owner is set to a Swap contract's address.\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable) {\n    require(to != address(this), \"LPToken: cannot send to itself\");\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "contracts/Portal/helpers/test/mocks/OracleExtensionLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\nimport {StakeModuleLib} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {OracleExtensionLib} from \"../../../modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport {DataStoreModuleLib} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract OracleExtensionLibMock is StakeModule {\n  using StakeModuleLib for StakeModuleLib.PooledStaking;\n  using OracleExtensionLib for StakeModuleLib.PooledStaking;\n  using DataStoreModuleLib for DataStoreModuleLib.IsolatedStorage;\n\n  function initialize(address _gETH_position, address _oracle_position) external initializer {\n    __StakeModule_init(_gETH_position, _oracle_position);\n  }\n\n  function pause() external virtual override {\n    _pause();\n  }\n\n  function unpause() external virtual override {\n    _unpause();\n  }\n\n  /**\n   * @custom:section                           ** DATA MANIPULATORS **\n   */\n  function $writeUint(uint256 _id, bytes32 _key, uint256 _data) external {\n    DATASTORE.writeUint(_id, _key, _data);\n  }\n\n  function $writeBytes(uint256 _id, bytes32 _key, bytes calldata _data) external {\n    DATASTORE.writeBytes(_id, _key, _data);\n  }\n\n  function $writeAddress(uint256 _id, bytes32 _key, address _data) external {\n    DATASTORE.writeAddress(_id, _key, _data);\n  }\n\n  function $set_ORACLE_POSITION(address _data) external {\n    STAKE.ORACLE_POSITION = _data;\n  }\n\n  function $set_VALIDATORS_INDEX(uint256 _data) external {\n    STAKE.VALIDATORS_INDEX = _data;\n  }\n\n  function $set_VERIFICATION_INDEX(uint256 _data) external {\n    STAKE.VERIFICATION_INDEX = _data;\n  }\n\n  function $set_MONOPOLY_THRESHOLD(uint256 _data) external {\n    STAKE.MONOPOLY_THRESHOLD = _data;\n  }\n\n  function $set_ORACLE_UPDATE_TIMESTAMP(uint256 _data) external {\n    STAKE.ORACLE_UPDATE_TIMESTAMP = _data;\n  }\n\n  function $set_package(uint256 _type, uint256 package) external {\n    STAKE.packages[_type] = package;\n  }\n\n  function $set_middleware(uint256 _type, uint256 middleware) external {\n    STAKE.middlewares[_type][middleware] = true;\n  }\n\n  function $set_PricePerShare(uint256 price, uint256 poolId) external {\n    STAKE.gETH.setPricePerShare(price, poolId);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL **\n   */\n  function $_alienateValidator(bytes calldata _pk) external {\n    return STAKE._alienateValidator(DATASTORE, STAKE.VERIFICATION_INDEX, _pk);\n  }\n\n  function $_sanityCheck(uint256 _id, uint256 _newPrice) external {\n    return STAKE._sanityCheck(DATASTORE, _id, _newPrice);\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/Portal/helpers/test/mocks/StakeModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\nimport {StakeModuleLib} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {DataStoreModuleLib} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract StakeModuleLibMock is StakeModule {\n  using StakeModuleLib for StakeModuleLib.PooledStaking;\n  using DataStoreModuleLib for DataStoreModuleLib.IsolatedStorage;\n\n  event return$_buyback(uint256 remETH, uint256 boughtgETH);\n\n  event return$initiatePool(uint256 poolId);\n\n  event return$deposit(uint256 boughtgETH, uint256 mintedgETH);\n\n  function initialize(address _gETH_position, address _oracle_position) external initializer {\n    __StakeModule_init(_gETH_position, _oracle_position);\n  }\n\n  function pause() external virtual override {\n    _pause();\n  }\n\n  function unpause() external virtual override {\n    _unpause();\n  }\n\n  /**\n   * @custom:section                           ** DATA MANIPULATORS **\n   */\n  function $writeUint(uint256 _id, bytes32 _key, uint256 _data) external {\n    DATASTORE.writeUint(_id, _key, _data);\n  }\n\n  function $writeBytes(uint256 _id, bytes32 _key, bytes calldata _data) external {\n    DATASTORE.writeBytes(_id, _key, _data);\n  }\n\n  function $writeAddress(uint256 _id, bytes32 _key, address _data) external {\n    DATASTORE.writeAddress(_id, _key, _data);\n  }\n\n  function $set_ORACLE_POSITION(address _data) external {\n    STAKE.ORACLE_POSITION = _data;\n  }\n\n  function $set_VALIDATORS_INDEX(uint256 _data) external {\n    STAKE.VALIDATORS_INDEX = _data;\n  }\n\n  function $set_VERIFICATION_INDEX(uint256 _data) external {\n    STAKE.VERIFICATION_INDEX = _data;\n  }\n\n  function $set_MONOPOLY_THRESHOLD(uint256 _data) external {\n    STAKE.MONOPOLY_THRESHOLD = _data;\n  }\n\n  function $set_ORACLE_UPDATE_TIMESTAMP(uint256 _data) external {\n    STAKE.ORACLE_UPDATE_TIMESTAMP = _data;\n  }\n\n  function $set_package(uint256 _type, uint256 package) external {\n    STAKE.packages[_type] = package;\n  }\n\n  function $set_middleware(uint256 _type, uint256 middleware) external {\n    STAKE.middlewares[_type][middleware] = true;\n  }\n\n  function $set_PricePerShare(uint256 price, uint256 poolId) external {\n    STAKE.gETH.setPricePerShare(price, poolId);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL TO EXTERNAL **\n   */\n\n  function $_authenticate(\n    uint256 _id,\n    bool _expectCONTROLLER,\n    bool _expectMaintainer,\n    bool[2] memory _restrictionMap\n  ) external view {\n    StakeModuleLib._authenticate(\n      DATASTORE,\n      _id,\n      _expectCONTROLLER,\n      _expectMaintainer,\n      _restrictionMap\n    );\n  }\n\n  function $_setgETHMiddleware(uint256 id, address _middleware) external {\n    STAKE._setgETHMiddleware(DATASTORE, id, _middleware);\n  }\n\n  function $_deploygETHMiddleware(\n    uint256 _id,\n    uint256 _versionId,\n    bytes memory _middleware_data\n  ) external {\n    STAKE._deploygETHMiddleware(DATASTORE, _id, _versionId, _middleware_data);\n  }\n\n  function $_deployGeodePackage(\n    uint256 _type,\n    uint256 _poolId,\n    bytes memory _package_data\n  ) external returns (address packageInstance) {\n    return STAKE._deployGeodePackage(DATASTORE, _type, _poolId, _package_data);\n  }\n\n  function $_deployWithdrawalContract(uint256 _poolId) external {\n    STAKE._deployWithdrawalContract(DATASTORE, _poolId);\n  }\n\n  function $_setMaintainer(uint256 _id, address _newMaintainer) external {\n    StakeModuleLib._setMaintainer(DATASTORE, _id, _newMaintainer);\n  }\n\n  function $_setMaintenanceFee(uint256 _id, uint256 _newFee) external {\n    StakeModuleLib._setMaintenanceFee(DATASTORE, _id, _newFee);\n  }\n\n  function $_increaseWalletBalance(uint256 _id, uint256 _value) external {\n    StakeModuleLib._increaseWalletBalance(DATASTORE, _id, _value);\n  }\n\n  function $_decreaseWalletBalance(uint256 _id, uint256 _value) external {\n    StakeModuleLib._decreaseWalletBalance(DATASTORE, _id, _value);\n  }\n\n  function $_imprison(uint256 _operatorId, bytes calldata _proof) external {\n    StakeModuleLib._imprison(DATASTORE, _operatorId, _proof);\n  }\n\n  function $_setValidatorPeriod(uint256 _operatorId, uint256 _newPeriod) external {\n    StakeModuleLib._setValidatorPeriod(DATASTORE, _operatorId, _newPeriod);\n  }\n\n  function $_setFallbackOperator(uint256 poolId, uint256 operatorId) external {\n    StakeModuleLib._setFallbackOperator(DATASTORE, poolId, operatorId);\n  }\n\n  function $_approveOperator(\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 allowance\n  ) external returns (uint256 oldAllowance) {\n    return StakeModuleLib._approveOperator(DATASTORE, poolId, operatorId, allowance);\n  }\n\n  function $_mintgETH(uint256 _poolId, uint256 _ethAmount) external returns (uint256 mintedgETH) {\n    return STAKE._mintgETH(DATASTORE, _poolId, _ethAmount);\n  }\n\n  function $_buyback(\n    uint256 _poolId,\n    uint256 _maxEthToSell,\n    uint256 _deadline\n  ) external payable returns (uint256 remETH, uint256 boughtgETH) {\n    (remETH, boughtgETH) = StakeModuleLib._buyback(DATASTORE, _poolId, _maxEthToSell, _deadline);\n    emit return$_buyback(remETH, boughtgETH);\n  }\n\n  function $_canStake(\n    bytes calldata _pubkey,\n    uint256 _verificationIndex\n  ) external view returns (bool) {\n    return STAKE._canStake(_pubkey, _verificationIndex);\n  }\n\n  /**\n   * @custom:section                           ** FOR RETURN STATEMENTS **\n   */\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable virtual override whenNotPaused returns (uint256 poolId) {\n    poolId = STAKE.initiatePool(\n      DATASTORE,\n      fee,\n      middlewareVersion,\n      maintainer,\n      NAME,\n      middleware_data,\n      config\n    );\n    emit return$initiatePool(poolId);\n  }\n\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  )\n    external\n    payable\n    virtual\n    override\n    whenNotPaused\n    nonReentrant\n    returns (uint256 boughtgETH, uint256 mintedgETH)\n  {\n    (boughtgETH, mintedgETH) = STAKE.deposit(DATASTORE, poolId, mingETH, deadline, receiver);\n    emit return$deposit(boughtgETH, mintedgETH);\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/Portal/interfaces/helpers/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n/** This interface is designed to be compatible with the Vyper version.\n * @notice This is the Ethereum 2.0 deposit contract interface.\n * For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\n */\ninterface IDepositContract {\n  /**\n   * @notice Submit a Phase 0 DepositData object.\n   * @param pubkey A BLS12-381 public key.\n   * @param withdrawal_credentials Commitment to a public key for withdrawals.\n   * @param signature A BLS12-381 signature.\n   * @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n   *Used as a protection against malformed input.\n   */\n  function deposit(\n    bytes calldata pubkey,\n    bytes calldata withdrawal_credentials,\n    bytes calldata signature,\n    bytes32 deposit_data_root\n  ) external payable;\n}\n"
    },
    "contracts/Portal/interfaces/helpers/IERC1155PausableBurnableSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n\ninterface IERC1155Burnable is IERC165, IERC1155, IERC1155MetadataURI {\n  function burn(address account, uint256 id, uint256 value) external;\n\n  function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\n}\n\ninterface IERC1155Supply is IERC165, IERC1155, IERC1155MetadataURI {\n  function totalSupply(uint256 id) external view returns (uint256);\n\n  function exists(uint256 id) external view returns (bool);\n}\n\ninterface IERC1155PausableBurnableSupply is IERC1155Burnable, IERC1155Supply {\n  function setURI(string memory newuri) external;\n\n  function pause() external;\n\n  function unpause() external;\n\n  function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\n\n  function mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) external;\n}\n"
    },
    "contracts/Portal/interfaces/helpers/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\ninterface IWhitelist {\n  function isAllowed(address) external view returns (bool);\n}\n"
    },
    "contracts/Portal/interfaces/IgETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\nimport {IERC1155PausableBurnableSupply} from \"./helpers/IERC1155PausableBurnableSupply.sol\";\n\ninterface IgETH is IERC1155PausableBurnableSupply {\n  function denominator() external view returns (uint256);\n\n  function isMiddleware(address middleware, uint256 id) external view returns (bool);\n\n  function setMiddleware(address middleware, uint256 id, bool isSet) external;\n\n  function isAvoider(address account, uint256 id) external view returns (bool);\n\n  function avoidMiddlewares(uint256 id, bool isAvoid) external;\n\n  function pricePerShare(uint256 id) external view returns (uint256);\n\n  function priceUpdateTimestamp(uint256 id) external view returns (uint256);\n\n  function setPricePerShare(uint256 price, uint256 id) external;\n\n  function transferUriSetterRole(address newUriSetter) external;\n\n  function transferPauserRole(address newPauser) external;\n\n  function transferMinterRole(address newMinter) external;\n\n  function transferOracleRole(address newOracle) external;\n\n  function transferMiddlewareManagerRole(address newMiddlewareManager) external;\n}\n"
    },
    "contracts/Portal/interfaces/IPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\nimport {IGeodeModule} from \"./modules/IGeodeModule.sol\";\nimport {IStakeModule} from \"./modules/IStakeModule.sol\";\n\ninterface IPortal is IStakeModule, IGeodeModule {\n  function pausegETH() external;\n\n  function unpausegETH() external;\n\n  function pushUpgrade(uint256 packageType) external returns (bytes memory versionName);\n\n  function releasePrisoned(uint256 operatorId) external;\n\n  function setGovernanceFee(uint256 newFee) external;\n}\n"
    },
    "contracts/Portal/interfaces/middlewares/IgETHMiddleware.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\ninterface IgETHMiddleware {\n  function initialize(uint256 id_, address erc1155_, bytes memory data) external;\n}\n"
    },
    "contracts/Portal/interfaces/modules/IDataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\ninterface IDataStoreModule {\n  function generateId(string calldata _name, uint256 _type) external pure returns (uint256 id);\n\n  function getKey(uint256 _id, bytes32 _param) external pure returns (bytes32 key);\n\n  function allIdsByType(uint256 _type, uint256 _index) external view returns (uint256);\n\n  function allIdsByTypeLength(uint256 _type) external view returns (uint256);\n\n  function readUint(uint256 id, bytes32 key) external view returns (uint256 data);\n\n  function readAddress(uint256 id, bytes32 key) external view returns (address data);\n\n  function readBytes(uint256 id, bytes32 key) external view returns (bytes memory data);\n\n  function readUintArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (uint256 data);\n\n  function readBytesArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (bytes memory data);\n\n  function readAddressArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (address data);\n}\n"
    },
    "contracts/Portal/interfaces/modules/IGeodeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {IDataStoreModule} from \"./IDataStoreModule.sol\";\nimport {GeodeModuleLib as GML} from \"../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\n\ninterface IGeodeModule is IDataStoreModule {\n  function isolationMode() external view returns (bool);\n\n  function GeodeParams()\n    external\n    view\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType\n    );\n\n  function getContractVersion() external view returns (uint256);\n\n  function getProposal(uint256 id) external view returns (GML.Proposal memory proposal);\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external returns (uint256 id);\n\n  function rescueSenate(address _newSenate) external;\n\n  function approveProposal(\n    uint256 id\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\n\n  function changeSenate(address _newSenate) external;\n\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\n}\n"
    },
    "contracts/Portal/interfaces/modules/ILiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\ninterface ILiquidityModule {\n  function pause() external;\n\n  function unpause() external;\n\n  function LiquidityParams()\n    external\n    view\n    returns (\n      address gETH,\n      address lpToken,\n      uint256 pooledTokenId,\n      uint256 initialA,\n      uint256 futureA,\n      uint256 initialATime,\n      uint256 futureATime,\n      uint256 swapFee,\n      uint256 adminFee\n    );\n\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getBalance(uint8 index) external view returns (uint256);\n\n  function getDebt() external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function getAdminBalance(uint256 index) external view returns (uint256);\n\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateTokenAmount(\n    uint256[2] calldata amounts,\n    bool deposit\n  ) external view returns (uint256);\n\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory);\n\n  function calculateRemoveLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount);\n\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function addLiquidity(\n    uint256[2] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[2] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[2] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[2] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function withdrawAdminFees(address receiver) external;\n\n  function setAdminFee(uint256 newAdminFee) external;\n\n  function setSwapFee(uint256 newSwapFee) external;\n\n  function rampA(uint256 futureA, uint256 futureTime) external;\n\n  function stopRampA() external;\n}\n"
    },
    "contracts/Portal/interfaces/modules/IStakeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {IDataStoreModule} from \"./IDataStoreModule.sol\";\nimport {StakeModuleLib as SML} from \"../../modules/StakeModule/libs/StakeModuleLib.sol\";\n\ninterface IStakeModule is IDataStoreModule {\n  function pause() external;\n\n  function unpause() external;\n\n  function StakeParams()\n    external\n    view\n    returns (\n      address gETH,\n      address oraclePosition,\n      uint256 validatorsIndex,\n      uint256 verificationIndex,\n      uint256 monopolyThreshold,\n      uint256 oracleUpdateTimestamp,\n      uint256 dailyPriceIncreaseLimit,\n      uint256 dailyPriceDecreaseLimit,\n      uint256 governanceFee,\n      bytes32 priceMerkleRoot,\n      bytes32 balanceMerkleRoot\n    );\n\n  function getValidator(bytes calldata pubkey) external view returns (SML.Validator memory);\n\n  function getPackageVersion(uint256 _type) external view returns (uint256);\n\n  function isMiddleware(uint256 _type, uint256 _version) external view returns (bool);\n\n  function initiateOperator(\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external payable;\n\n  function deployLiquidityPool(uint256 poolId) external;\n\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable returns (uint256 poolId);\n\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external;\n\n  function setWhitelist(uint256 poolId, address whitelist) external;\n\n  function changeMaintainer(uint256 poolId, address newMaintainer) external;\n\n  function getMaintenanceFee(uint256 id) external view returns (uint256);\n\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\n\n  function increaseWalletBalance(uint256 id) external payable returns (bool);\n\n  function decreaseWalletBalance(uint256 id, uint256 value) external returns (bool);\n\n  function isPrisoned(uint256 operatorId) external view returns (bool);\n\n  function blameOperator(bytes calldata pk) external;\n\n  function getValidatorPeriod(uint256 id) external view returns (uint256);\n\n  function switchValidatorPeriod(uint256 operatorId, uint256 newPeriod) external;\n\n  function operatorAllowance(uint256 poolId, uint256 operatorId) external view returns (uint256);\n\n  function delegate(\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances,\n    uint256 fallbackOperator\n  ) external;\n\n  function isWhitelisted(uint256 poolId, address staker) external view returns (bool);\n\n  function isPrivatePool(uint256 poolId) external view returns (bool);\n\n  function isPriceValid(uint256 poolId) external view returns (bool);\n\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\n\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  ) external payable returns (uint256 boughtgETH, uint256 mintedgETH);\n\n  function canStake(bytes calldata pubkey) external view returns (bool);\n\n  function proposeStake(\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external;\n\n  function stake(uint256 operatorId, bytes[] calldata pubkeys) external;\n\n  function updateVerificationIndex(\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external;\n\n  function regulateOperators(uint256[] calldata feeThefts, bytes[] calldata proofs) external;\n\n  function reportBeacon(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external;\n\n  function priceSync(uint256 poolId, uint256 price, bytes32[] calldata priceProof) external;\n\n  function priceSyncBatch(\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external;\n}\n"
    },
    "contracts/Portal/interfaces/packages/IGeodePackage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {IGeodeModule} from \"../modules/IGeodeModule.sol\";\nimport {IPortal} from \"../IPortal.sol\";\n\ninterface IGeodePackage is IGeodeModule {\n  function initialize(\n    uint256 poolId,\n    address owner,\n    bytes calldata versionName,\n    bytes memory data\n  ) external;\n\n  function getPortal() external view returns (IPortal);\n\n  function getPoolId() external view returns (uint256);\n\n  function getProposedVersion() external view returns (uint256);\n\n  function pullUpgrade() external;\n}\n"
    },
    "contracts/Portal/interfaces/packages/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\nimport {ILiquidityModule} from \"../modules/ILiquidityModule.sol\";\nimport {IGeodePackage} from \"./IGeodePackage.sol\";\n\ninterface ILiquidityPool is ILiquidityModule, IGeodePackage {}\n"
    },
    "contracts/Portal/modules/DataStoreModule/DataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// interfaces\nimport {IDataStoreModule} from \"../../interfaces/modules/IDataStoreModule.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"./libs/DataStoreModuleLib.sol\";\n// external\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title DSM: DataStore Module\n *\n * @notice A storage management tool designed to create a safe and scalable storage layout\n * for upgradable contracts with various types of data classes (users,packages,definitions).\n *\n * @dev review: this module delegates its functionality to DSML (DataStoreModuleLib).\n * DSM or DSML has NO access control.\n *\n * @dev There are no additional functionalities implemented seperately from the library.\n *\n * @dev NO function needs to be overriden when inherited.\n *\n * @dev __DataStoreModule_init (or _unchained) call is NOT NECESSARY when inherited.\n *\n * @dev No storage-altering external/public functions are exposed here, only view/pure external functions.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract DataStoreModule is IDataStoreModule, Initializable {\n  using DSML for DSML.IsolatedStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  DSML.IsolatedStorage internal DATASTORE;\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  function __DataStoreModule_init() internal onlyInitializing {}\n\n  function __DataStoreModule_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @custom:section                           ** HELPER FUNCTIONS **\n   *\n   * @custom:visibility -> pure-external\n   */\n\n  /**\n   * @notice useful function for string inputs - returns same with the DSML.generateId\n   * @dev id is generated by keccak(name, type)\n   */\n  function generateId(\n    string calldata _name,\n    uint256 _type\n  ) external pure virtual override returns (uint256 id) {\n    id = uint256(keccak256(abi.encodePacked(_name, _type)));\n  }\n\n  /**\n   * @notice useful view function for string inputs - returns same with the DSML.generateId\n   */\n  function getKey(\n    uint256 _id,\n    bytes32 _param\n  ) external pure virtual override returns (bytes32 key) {\n    return DSML.getKey(_id, _param);\n  }\n\n  /**\n   * @custom:section                           ** DATA GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @dev useful for outside reach, shouldn't be used within contracts as a referance\n   * @return allIdsByType is an array of IDs of the given TYPE from Datastore,\n   * returns a specific index\n   */\n  function allIdsByType(\n    uint256 _type,\n    uint256 _index\n  ) external view virtual override returns (uint256) {\n    return DATASTORE.allIdsByType[_type][_index];\n  }\n\n  function allIdsByTypeLength(uint256 _type) external view virtual override returns (uint256) {\n    return DATASTORE.allIdsByType[_type].length;\n  }\n\n  function readUint(uint256 id, bytes32 key) external view virtual override returns (uint256 data) {\n    data = DATASTORE.readUint(id, key);\n  }\n\n  function readAddress(\n    uint256 id,\n    bytes32 key\n  ) external view virtual override returns (address data) {\n    data = DATASTORE.readAddress(id, key);\n  }\n\n  function readBytes(\n    uint256 id,\n    bytes32 key\n  ) external view virtual override returns (bytes memory data) {\n    data = DATASTORE.readBytes(id, key);\n  }\n\n  /**\n   * @custom:section                           ** ARRAY GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function readUintArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (uint256 data) {\n    data = DATASTORE.readUintArray(id, key, index);\n  }\n\n  function readBytesArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (bytes memory data) {\n    data = DATASTORE.readBytesArray(id, key, index);\n  }\n\n  function readAddressArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (address data) {\n    data = DATASTORE.readAddressArray(id, key, index);\n  }\n}\n"
    },
    "contracts/Portal/modules/DataStoreModule/libs/DataStoreModuleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.7;\n\n/**\n * @title DSML: DataStore Module Library\n *\n * @notice A Storage Management Library created for the contracts and modules that inherits DataStoreModule (DSM).\n * Enables Dynamic Structs with unlimited key space.\n * Provides an Isolated Storage Layout with IDs and KEYs.\n * Focusing on upgradable contracts with various data types to create a\n * * sustainable development environment.\n * In summary, extra gas cost that would be saved with Storage packing are\n * * ignored to create dynamic structs.\n *\n * @dev Distinct id and key pairs SHOULD return different storage slots. No collisions!\n * @dev IDs are the representation of an entity with any given key as properties.\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\n * @dev review: For a safer development process, NEVER use the IsolatedStorage with strings. Refer to globals/reserved_key_space.sol\n *\n * @dev While it is a good practice for keeping a record;\n * * TYPE for ID is NOT mandatory, an ID might not have an explicit type.\n * * e.g., When a relational data is added with getKey, like allowance, it has a unique ID but no TYPE.\n * * Thus there are no checks for types or keys.\n *\n * @dev readUint(id, arrayName) returns the lenght of array.\n *\n * @dev Contracts relying on this library must use DataStoreModuleLib.IsolatedStorage\n * @dev This is an internal library, requires NO deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary DataStoreModuleLib {\n  /**\n   * @notice Main Struct for reading/writing operations for given (id, key) pairs.\n   *\n   * @param allIdsByType type => id[], optional categorization for IDs, can be directly accessed.\n   * @param uintData keccak(id, key) =>  returns uint256\n   * @param bytesData keccak(id, key) => returns bytes\n   * @param addressData keccak(id, key) =>  returns address\n   * @param __gap keep the struct size at 16\n   *\n   * @dev any other storage type can be expressed as uint or bytes. E.g., bools are 0/1 as uints.\n   */\n  struct IsolatedStorage {\n    mapping(uint256 => uint256[]) allIdsByType;\n    mapping(bytes32 => uint256) uintData;\n    mapping(bytes32 => bytes) bytesData;\n    mapping(bytes32 => address) addressData;\n    uint256[12] __gap;\n  }\n\n  /**\n   * @custom:section                           ** HELPERS **\n   *\n   * @custom:visibility -> pure-internal\n   */\n\n  /**\n   * @notice generalized method of generating an ID\n   *\n   * @dev Some TYPEs may require permissionless creation, allowing anyone to claim any ID;\n   * meaning malicious actors can claim names to mislead people. To prevent this\n   * TYPEs will be considered during ID generation.\n   */\n  function generateId(bytes memory _name, uint256 _type) internal pure returns (uint256 id) {\n    id = uint256(keccak256(abi.encodePacked(_name, _type)));\n  }\n\n  /**\n   * @notice hash of given ID and a KEY defines the key for the IsolatedStorage\n   * @return key bytes32, hash.\n   **/\n  function getKey(uint256 id, bytes32 param) internal pure returns (bytes32 key) {\n    key = keccak256(abi.encodePacked(id, param));\n  }\n\n  /**\n   * @custom:section                           ** DATA GETTERS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  function readUint(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (uint256 data) {\n    data = self.uintData[getKey(_id, _key)];\n  }\n\n  function readBytes(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (bytes memory data) {\n    data = self.bytesData[getKey(_id, _key)];\n  }\n\n  function readAddress(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (address data) {\n    data = self.addressData[getKey(_id, _key)];\n  }\n\n  /**\n   * @custom:section                           ** ARRAY GETTERS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  function readUintArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (uint256 data) {\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\n  }\n\n  function readBytesArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (bytes memory data) {\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\n  }\n\n  function readAddressArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (address data) {\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\n  }\n\n  /**\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @custom:subsection                        ** DATA SETTERS **\n   */\n\n  function writeUint(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _data\n  ) internal {\n    self.uintData[getKey(_id, _key)] = _data;\n  }\n\n  function addUint(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _addend\n  ) internal {\n    self.uintData[getKey(_id, _key)] += _addend;\n  }\n\n  function subUint(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _minuend\n  ) internal {\n    self.uintData[getKey(_id, _key)] -= _minuend;\n  }\n\n  function writeBytes(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes memory _data\n  ) internal {\n    self.bytesData[getKey(_id, _key)] = _data;\n  }\n\n  function writeAddress(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address _data\n  ) internal {\n    self.addressData[getKey(_id, _key)] = _data;\n  }\n\n  /**\n   * @custom:subsection                        ** ARRAY SETTERS **\n   */\n\n  function appendUintArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  function appendBytesArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  function appendAddressArray(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  /**\n   * @custom:subsection                        ** BATCH ARRAY SETTERS **\n   */\n\n  function appendUintArrayBatch(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    for (uint256 i = 0; i < _data.length; ) {\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n\n  function appendBytesArrayBatch(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    for (uint256 i = 0; i < _data.length; ) {\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n\n  function appendAddressArrayBatch(\n    IsolatedStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    for (uint256 i = 0; i < _data.length; ) {\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n}\n"
    },
    "contracts/Portal/modules/GeodeModule/GeodeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {ID_TYPE} from \"../../globals/id_type.sol\";\n// interfaces\nimport {IGeodeModule} from \"../../interfaces/modules/IGeodeModule.sol\";\n// libraries\nimport {GeodeModuleLib as GML} from \"./libs/GeodeModuleLib.sol\";\nimport {DataStoreModuleLib as DSML} from \"../DataStoreModule/libs/DataStoreModuleLib.sol\";\n// contracts\nimport {DataStoreModule} from \"../DataStoreModule/DataStoreModule.sol\";\n// external\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title GM: Geode Module\n *\n * @notice Base logic for Upgradable Packages:\n * * Dual Governance with Senate+Governance: Governance proposes, Senate approves.\n * * Limited Upgradability built on top of UUPS via Dual Governance.\n *\n * @dev review: this module delegates its functionality to GML (GeodeModuleLib):\n * GML has onlyGovernance, onlySenate, onlyController modifiers for access control.\n *\n * @dev There are 1 additional functionalities implemented seperately from the library:\n * Mutating UUPS pattern to fit Limited Upgradability:\n * 1. New implementation contract is proposed with CONTRACT_UPGRADE (TYPE 2), refer to globals/id_type.sol.\n * 2. Proposal is approved by the contract owner, Senate.\n * 3. approveProposal calls _handleUpgrade which mimics UUPS.upgradeTo:\n * 3.1. Checks the implementation address with _authorizeUpgrade, also preventing any UUPS upgrades.\n * 3.2. Upgrades the contract with no function to call afterwards.\n * 3.3. Sets contract version. Note that, mentioned version is different from version defined within UUPS\n * * & does not increase linearly like one might expect.\n *\n * @dev 1 function needs to be overriden when inherited: isolationMode. (also refer to approveProposal)\n *\n * @dev __GeodeModule_init (or _unchained) call is NECESSARY when inherited.\n * However, deployer MUST call initializer after upgradeTo call,\n * SHOULD NOT call initializer on upgradeToAndCall or new ERC1967Proxy calls.\n *\n * @dev This module inherits DataStoreModule.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract GeodeModule is IGeodeModule, DataStoreModule, UUPSUpgradeable {\n  using GML for GML.DualGovernance;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  GML.DualGovernance internal GEODE;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event ContractVersionSet(uint256 version);\n\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n  event Approved(uint256 ID);\n  event NewSenate(address senate, uint256 expiry);\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   */\n  function isolationMode() external view virtual override returns (bool);\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  function __GeodeModule_init(\n    address governance,\n    address senate,\n    uint256 senateExpiry,\n    uint256 packageType,\n    bytes calldata initVersionName\n  ) internal onlyInitializing {\n    __UUPSUpgradeable_init();\n    __DataStoreModule_init();\n    __GeodeModule_init_unchained(governance, senate, senateExpiry, packageType, initVersionName);\n  }\n\n  /**\n   * @dev This function uses _getImplementation(), clearly deployer SHOULD NOT call initializer on\n   * upgradeToAndCall or new ERC1967Proxy calls. _getImplementation() returns 0 then.\n   * @dev GOVERNANCE and SENATE set to msg.sender at beginning, can not propose+approve otherwise.\n   * @dev native approveProposal(public) is not used here. Because it has an _handleUpgrade,\n   * however initialization does not require UUPS.upgradeTo.\n   */\n  function __GeodeModule_init_unchained(\n    address governance,\n    address senate,\n    uint256 senateExpiry,\n    uint256 packageType,\n    bytes calldata initVersionName\n  ) internal onlyInitializing {\n    require(governance != address(0), \"GM:governance can not be zero\");\n    require(senate != address(0), \"GM:senate can not be zero\");\n    require(senateExpiry > block.timestamp, \"GM:low senateExpiry\");\n    require(packageType != 0, \"GM:packageType can not be zero\");\n    require(initVersionName.length != 0, \"GM:initVersionName can not be empty\");\n\n    GEODE.GOVERNANCE = msg.sender;\n    GEODE.SENATE = msg.sender;\n\n    GEODE.SENATE_EXPIRY = senateExpiry;\n    GEODE.PACKAGE_TYPE = packageType;\n\n    uint256 initVersion = GEODE.propose(\n      DATASTORE,\n      _getImplementation(),\n      ID_TYPE.CONTRACT_UPGRADE,\n      initVersionName,\n      1 days\n    );\n\n    GEODE.approveProposal(DATASTORE, initVersion);\n\n    _setContractVersion(initVersionName);\n\n    GEODE.GOVERNANCE = governance;\n    GEODE.SENATE = senate;\n  }\n\n  /**\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @dev required by the OZ UUPS module, improved by the Geode Module.\n   */\n  function _authorizeUpgrade(address proposed_implementation) internal virtual override {\n    require(\n      GEODE.isUpgradeAllowed(proposed_implementation, _getImplementation()),\n      \"GM:not allowed to upgrade\"\n    );\n  }\n\n  function _setContractVersion(bytes memory versionName) internal virtual {\n    uint256 newVersion = DSML.generateId(versionName, GEODE.PACKAGE_TYPE);\n    GEODE.CONTRACT_VERSION = newVersion;\n\n    emit ContractVersionSet(newVersion);\n  }\n\n  /**\n   * @dev Would use the public upgradeTo() call, which does _authorizeUpgrade and _upgradeToAndCallUUPS,\n   * but it is external, OZ have not made it public yet.\n   */\n  function _handleUpgrade(\n    address proposed_implementation,\n    bytes memory versionName\n  ) internal virtual {\n    _authorizeUpgrade(proposed_implementation);\n    _upgradeToAndCallUUPS(proposed_implementation, new bytes(0), false);\n    _setContractVersion(versionName);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  // TODO: maybe seperate this? why not.\n  function GeodeParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType\n    )\n  {\n    governance = GEODE.GOVERNANCE;\n    senate = GEODE.SENATE;\n    approvedUpgrade = GEODE.APPROVED_UPGRADE;\n    senateExpiry = GEODE.SENATE_EXPIRY;\n    packageType = GEODE.PACKAGE_TYPE;\n  }\n\n  function getContractVersion() public view virtual override returns (uint256) {\n    return GEODE.CONTRACT_VERSION;\n  }\n\n  function getProposal(\n    uint256 id\n  ) external view virtual override returns (GML.Proposal memory proposal) {\n    proposal = GEODE.getProposal(id);\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   *\n   * @custom:visibility -> public/external\n   */\n\n  /**\n   * @custom:subsection                        ** ONLY GOVERNANCE **\n   *\n   */\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) public virtual override returns (uint256 id) {\n    id = GEODE.propose(DATASTORE, _CONTROLLER, _TYPE, _NAME, duration);\n  }\n\n  function rescueSenate(address _newSenate) external virtual override {\n    GEODE.rescueSenate(_newSenate);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY SENATE **\n   */\n\n  /**\n   * @dev handles TYPE 2 proposals by upgrading the contract immediately.\n   */\n  function approveProposal(\n    uint256 id\n  ) public virtual override returns (address _controller, uint256 _type, bytes memory _name) {\n    (_controller, _type, _name) = GEODE.approveProposal(DATASTORE, id);\n\n    if (_type == ID_TYPE.CONTRACT_UPGRADE) {\n      _handleUpgrade(_controller, _name);\n    }\n  }\n\n  function changeSenate(address _newSenate) external virtual override {\n    GEODE.changeSenate(_newSenate);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY CONTROLLER **\n   */\n\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external virtual override {\n    GML.changeIdCONTROLLER(DATASTORE, id, newCONTROLLER);\n  }\n}\n"
    },
    "contracts/Portal/modules/GeodeModule/libs/GeodeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {PERCENTAGE_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\n\n/**\n * @title GML: Geode Module Library\n *\n * @notice Dual Governance & Limited Upgradability:\n * Administration of the Isolated Storage with a Dual Governance consisting a Governance and a Senate.\n * Administration of a UUPS contract with Limited Upgradability for Packages like Portal, LiquidityPool.\n *\n * @dev review: DataStoreModule for the IsolatedStorage logic.\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\n *\n * @dev SENATE_EXPIRY is not mandatory to utilize. Simply set it to MAX_UINT256 if rescueSenate is not needed.\n *\n * @dev There are 3 ways to set a new Senate:\n * 1. With a proposal TYPE 1. Proposal's controller becomes the new Senate, refreshes the expiry.\n * 2. Current Senate can call changeSenate, which doesn't change the expiry\n * 3. As a circuit breaker: If senate is expired, then rescue senate can be called by governance.\n * @dev Currently, there are no way to set a new Governance.\n *\n *\n * @dev Contracts relying on this library must use GeodeModuleLib.DualGovernance\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary GeodeModuleLib {\n  using DSML for DSML.IsolatedStorage;\n\n  /**\n   * @custom:section                           ** STRUCTS **\n   */\n\n  /**\n   * @notice Giving the control of a specific ID to proposed CONTROLLER.\n   *\n   * @param TYPE: refer to globals/id_type.sol\n   * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\n   * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\n   * @param NAME: DataStore generates ID by keccak(name, type)\n   * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\n   * * Expired proposals can not be approved by Senate\n   * * Expired proposals can not be overriden by new proposals\n   **/\n  struct Proposal {\n    address CONTROLLER;\n    uint256 TYPE;\n    bytes NAME;\n    uint256 deadline;\n  }\n\n  /**\n   * @notice Dual Governance allows 2 parties to manage a package with proposals and approvals.\n   * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\n   * Suggests updates, such as new operators, contract upgrades, a new Senate (without any permission to force them)\n   * @param SENATE An address that protects the users by controlling the state of governance, contract updates and other crucial changes\n   * @param APPROVED_UPGRADE only 1 implementation contract SHOULD be \"approved\" at any given time.\n   * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Might not be utilized. Limited by MAX_SENATE_PERIOD\n   * @param PACKAGE_TYPE every package has a specific TYPE. Defined in globals/id_type.sol\n   * @param CONTRACT_VERSION always refers to the upgrade proposal ID. Does NOT increase uniformly like one might expect.\n   * @param proposals till approved, proposals are kept separated from the Isolated Storage\n   * @param __gap keep the struct size at 16\n   **/\n  struct DualGovernance {\n    address GOVERNANCE;\n    address SENATE;\n    address APPROVED_UPGRADE;\n    uint256 SENATE_EXPIRY;\n    uint256 PACKAGE_TYPE;\n    uint256 CONTRACT_VERSION;\n    mapping(uint256 => Proposal) proposals;\n    uint256[9] __gap;\n  }\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice a proposal can have a duration between 1 days to 4 weeks (inclusive)\n  uint32 public constant MIN_PROPOSAL_DURATION = 1 days;\n  uint32 public constant MAX_PROPOSAL_DURATION = 4 weeks;\n\n  /// @notice if expiry is utilized, a senate can be active for a year.\n  /// @dev \"MAX\" underlines a new senate can be set without expecting an expiry\n  uint32 public constant MAX_SENATE_PERIOD = 365 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n  event Approved(uint256 ID);\n  event NewSenate(address senate, uint256 expiry);\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyGovernance(DualGovernance storage self) {\n    require(msg.sender == self.GOVERNANCE, \"GML:GOVERNANCE role needed\");\n    _;\n  }\n\n  modifier onlySenate(DualGovernance storage self) {\n    require(msg.sender == self.SENATE, \"GML:SENATE role needed\");\n    require(block.timestamp < self.SENATE_EXPIRY, \"GML:SENATE expired\");\n    _;\n  }\n\n  modifier onlyController(DSML.IsolatedStorage storage DATASTORE, uint256 id) {\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"GML:CONTROLLER role needed\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @notice Check if it is allowed to change the package version to given proposedImplementation.\n   * @dev provided for _authorizeUpgrade\n   * @dev currentImplementation should always be UUPS._getImplementation()\n   * @dev currentImplementation or zero as proposedImplementation will return false\n   **/\n  function isUpgradeAllowed(\n    DualGovernance storage self,\n    address proposedImplementation,\n    address currentImplementation\n  ) external view returns (bool) {\n    return\n      (self.APPROVED_UPGRADE != address(0)) &&\n      (proposedImplementation != currentImplementation) &&\n      (self.APPROVED_UPGRADE == proposedImplementation);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function getProposal(\n    DualGovernance storage self,\n    uint256 id\n  ) external view returns (Proposal memory) {\n    return self.proposals[id];\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   */\n\n  /**\n   * @custom:subsection                        ** INTERNAL **\n   *\n   * @custom:visibility -> internal\n   */\n  function _setSenate(DualGovernance storage self, address _newSenate, uint256 _expiry) internal {\n    self.SENATE = _newSenate;\n    self.SENATE_EXPIRY = _expiry;\n\n    emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY GOVERNANCE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice generates a new ID with given TYPE and NAME, proposes it to be owned by a CONTROLLER.\n   * @dev DATASTORE[id] will not be updated until the proposal is approved\n   * @dev Proposals can NEVER be overriden\n   */\n  function propose(\n    DualGovernance storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external onlyGovernance(self) returns (uint256 id) {\n    id = DSML.generateId(_NAME, _TYPE);\n\n    require(self.proposals[id].deadline == 0, \"GML:already proposed\");\n    require((DATASTORE.readBytes(id, rks.NAME)).length == 0, \"GML:ID already exist\");\n    require(_CONTROLLER != address(0), \"GML:CONTROLLER can NOT be ZERO\");\n    require(\n      (_TYPE != ID_TYPE.NONE) && (_TYPE != ID_TYPE.__GAP__) && (_TYPE != ID_TYPE.POOL),\n      \"GML:TYPE is NONE, GAP or POOL\"\n    );\n    require(\n      (duration >= MIN_PROPOSAL_DURATION) && (duration <= MAX_PROPOSAL_DURATION),\n      \"GML:invalid proposal duration\"\n    );\n\n    uint256 _deadline = block.timestamp + duration;\n\n    self.proposals[id] = Proposal({\n      CONTROLLER: _CONTROLLER,\n      TYPE: _TYPE,\n      NAME: _NAME,\n      deadline: _deadline\n    });\n\n    emit Proposed(_TYPE, id, _CONTROLLER, _deadline);\n  }\n\n  /**\n   * @notice changes Senate in a scenerio where the current Senate acts maliciously!\n   * * We are sure this will not be the case, but creating a method for possible recovery is a must.\n   * @notice Normally, Governance creates Senate Proposals frequently to signal it does not have\n   * * any intent of malicious overtake.\n   * note: If Governance does not send a Senate Proposal \"a while\" before the SENATE_EXPIRY,\n   * * we recommend users to take their money out.\n   * @dev Obviously, Governance needs to wait for SENATE_EXPIRY.\n   * @dev Refreshes the expiry\n   */\n  function rescueSenate(\n    DualGovernance storage self,\n    address _newSenate\n  ) external onlyGovernance(self) {\n    require(block.timestamp > self.SENATE_EXPIRY, \"GML:cannot rescue yet\");\n\n    _setSenate(self, _newSenate, block.timestamp + MAX_SENATE_PERIOD);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY SENATE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice approves a proposal and records given data to DataStore\n   * @notice specific changes for the reserved types (1,2,3) are implemented here,\n   * any other addition should take place in Portal, as not related. Note that GM has additional logic for TYPE 2 approvals.\n   * @param id given ID proposal that has will be approved by Senate\n   * @dev Senate is not able to approve approved proposals\n   * @dev Senate is not able to approve expired proposals\n   */\n  function approveProposal(\n    DualGovernance storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id\n  ) external onlySenate(self) returns (address _controller, uint256 _type, bytes memory _name) {\n    require(self.proposals[id].deadline > block.timestamp, \"GML:NOT an active proposal\");\n\n    _controller = self.proposals[id].CONTROLLER;\n    _type = self.proposals[id].TYPE;\n    _name = self.proposals[id].NAME;\n\n    DATASTORE.writeUint(id, rks.TYPE, _type);\n    DATASTORE.writeAddress(id, rks.CONTROLLER, _controller);\n    DATASTORE.writeBytes(id, rks.NAME, _name);\n    DATASTORE.allIdsByType[_type].push(id);\n\n    if (_type == ID_TYPE.SENATE) {\n      _setSenate(self, _controller, block.timestamp + MAX_SENATE_PERIOD);\n    } else if (_type == ID_TYPE.CONTRACT_UPGRADE) {\n      self.APPROVED_UPGRADE = _controller;\n    }\n\n    // important\n    self.proposals[id].deadline = block.timestamp;\n\n    emit Approved(id);\n  }\n\n  /**\n   * @notice It is useful to be able to change the Senate's address without changing the expiry.\n   * @dev Does not change the expiry\n   */\n  function changeSenate(DualGovernance storage self, address _newSenate) external onlySenate(self) {\n    _setSenate(self, _newSenate, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:section                           ** ONLY CONTROLLER **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice change the CONTROLLER of an ID\n   * @dev this operation can not be reverted by the old CONTROLLER!!!\n   * @dev can not provide address(0), try 0x000000000000000000000000000000000000dEaD\n   */\n  function changeIdCONTROLLER(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    address newCONTROLLER\n  ) external onlyController(DATASTORE, id) {\n    require(newCONTROLLER != address(0), \"GML:CONTROLLER can not be zero\");\n\n    DATASTORE.writeAddress(id, rks.CONTROLLER, newCONTROLLER);\n\n    emit ControllerChanged(id, newCONTROLLER);\n  }\n}\n"
    },
    "contracts/Portal/modules/StakeModule/libs/DepositContractLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// interfaces\nimport {IDepositContract} from \"../../../interfaces/helpers/IDepositContract.sol\";\n// libraries\nimport {BytesLib} from \"../../../helpers/BytesLib.sol\";\n\n/**\n * @title DCL: Deposit Contract Library\n *\n * @notice Includes constants & functions that helps to the deposit process.\n *\n * @dev DEPOSIT_CONTRACT is chain specific and should be changed before deployments.\n *\n * @dev This is an internal library, requires NO deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary DepositContractLib {\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  IDepositContract internal constant DEPOSIT_CONTRACT =\n    IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b);\n  uint256 internal constant PUBKEY_LENGTH = 48;\n  uint256 internal constant SIGNATURE_LENGTH = 96;\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\n\n  /**\n   * @custom:section                           ** FUNCTIONS **\n   */\n\n  /**\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\n   * @param _b Memory array of size 32 .. 64\n   */\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\n    assert(_b.length >= 32 && _b.length <= 64);\n    if (64 == _b.length) return _b;\n\n    bytes memory zero32 = new bytes(32);\n    assembly {\n      mstore(add(zero32, 0x20), 0)\n    }\n\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\n    else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\n  }\n\n  /**\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\n   * @param _value Number less than `2**64` for compatibility reasons\n   */\n  function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n    result = 0;\n    uint256 temp_value = _value;\n    for (uint256 i = 0; i < 8; ++i) {\n      result = (result << 8) | (temp_value & 0xFF);\n      temp_value >>= 8;\n    }\n\n    assert(0 == temp_value); // fully converted\n    result <<= (24 * 8);\n  }\n\n  function _getDepositDataRoot(\n    bytes memory _pubkey,\n    bytes memory _withdrawalCredentials,\n    bytes memory _signature,\n    uint256 _stakeAmount\n  ) internal pure returns (bytes32) {\n    require(_stakeAmount >= 1 ether, \"DepositContract: deposit value too low\");\n    require(_stakeAmount % 1 gwei == 0, \"DepositContract: deposit value not multiple of gwei\");\n\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\n    bytes32 signatureRoot = sha256(\n      abi.encodePacked(\n        sha256(BytesLib.slice(_signature, 0, 64)),\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n      )\n    );\n\n    bytes32 depositDataRoot = sha256(\n      abi.encodePacked(\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n        sha256(abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot))\n      )\n    );\n\n    return depositDataRoot;\n  }\n\n  /**\n   * @notice converts an address to withdrawal credential, used on validator creation\n   */\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\n    uint256 w = 1 << 248;\n\n    return abi.encodePacked(bytes32(w) | bytes32(uint256(uint160(address(wcAddress)))));\n  }\n\n  /**\n   * @notice deposit to DEPOSIT_CONTRACT and initiate a validator.\n   */\n  function depositValidator(\n    bytes calldata pubkey,\n    bytes memory withdrawalCredential,\n    bytes memory signature,\n    uint256 amount\n  ) internal {\n    DEPOSIT_CONTRACT.deposit{value: amount}(\n      pubkey,\n      withdrawalCredential,\n      signature,\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\n    );\n  }\n}\n"
    },
    "contracts/Portal/modules/StakeModule/libs/OracleExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {PERCENTAGE_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {VALIDATOR_STATE} from \"../../../globals/validator_state.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {DepositContractLib as DCL} from \"./DepositContractLib.sol\";\nimport {StakeModuleLib as SML} from \"./StakeModuleLib.sol\";\n// external\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title OEL: Oracle Extension Library\n *\n * @notice An extension to SML\n * @notice Oracle, named Telescope, handles some operations for The Staking Library,\n * * using the logic explained below.\n *\n * @dev review: DataStoreModule for the IsolatedStorage logic.\n * @dev review: StakeModuleLib for base staking logic.\n *\n * @dev Telescope is currently responsible from 4 tasks:\n * * Updating the on-chain price of all pools with a MerkleRoot for minting operations\n * * Updating the on-chain balances info of all pools with a MerkleRoot for withdrawal operations\n * * Confirming validator proposals\n * * Regulating the Node Operators\n *\n * 1. updateVerificationIndex: Confirming validator proposals\n * * 2 step process is essential to prevent the frontrunning with a problematic withdrawalCredential: https://bit.ly/3Tkc6UC\n * * Simply, all proposed validator has an index bound to them,\n * * n representing the latest proposal: (0,n]\n * * Telescope verifies the validator data provided in proposeStake:\n * * especially sig1, sig31 and withdrawal credentials.\n * * Telescope confirms the latest index verified and states the faulty validator proposals (aliens)\n * * If a validator proposal is faulty then it's state is set to 69, refer to globals/validator_state.sol\n *\n * 2. regulateOperators: Regulating the Operators\n * * Operators can act faulty in many different ways. To prevent such actions,\n * * Telescope regulates them with well defined limitations.\n * * Currently only issue is the fee theft, meaning operator have not\n * * used the withdrawal contract for miner fees or MEV boost.\n * * There can be other restrictions in the future.\n *\n * 2. reportBeacon: Continous Data from Beacon chain: Price Merkle Root & Balances Merkle Root & # of active validators\n * * 1. Oracle Nodes calculate the price of its derivative, according to the validator data such as balance and fees.\n * * 2. If a pool doesn't have a validator, price kept same.\n * * 3. A merkle tree is constructed with the order of allIdsByType array.\n * * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root.\n * * 5. Anyone can update the price of the derivative  by calling priceSync() functions with correct merkle proofs\n * * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update.\n * * 7. Updates the regulation around Monopolies and provides BALANCE_MERKLE_ROOT to be used within withdrawal process.\n *\n * @dev External functions have OracleOnly modifier, except priceSync and priceSyncBatch.\n *\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary OracleExtensionLib {\n  using DSML for DSML.IsolatedStorage;\n  using SML for SML.PooledStaking;\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n  /// @notice effective on MONOPOLY_THRESHOLD, limiting the active validators: Set to 1%\n  uint256 public constant MONOPOLY_RATIO = PERCENTAGE_DENOMINATOR / 100;\n\n  /// @notice sensible value for the minimum beacon chain validators. No reasoning.\n  uint256 public constant MIN_VALIDATOR_COUNT = 50000;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Alienated(bytes pubkey);\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\n  event FeeTheft(uint256 indexed id, bytes proofs);\n  event OracleReported(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 monopolyThreshold\n  );\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyOracle(SML.PooledStaking storage STAKE) {\n    require(msg.sender == STAKE.ORACLE_POSITION, \"OEL:sender NOT ORACLE\");\n    _;\n  }\n\n  /**\n   * @custom:section                                       ** VERIFICATION INDEX **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   *\n   * @notice \"Alien\" is a validator that is created with a faulty withdrawal\n   * credential or signatures, this is a malicious act.\n   * @notice Alienation results in imprisonment for the operator of the faulty validator proposal.\n   * @dev While alienating a validator we should adjust the 'surplus' and 'secured'\n   * balances of the pool accordingly\n   * @dev We should adjust the 'proposedValidators' to fix allowances.\n   */\n  function _alienateValidator(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 verificationIndex,\n    bytes calldata _pk\n  ) internal {\n    require(STAKE.validators[_pk].index <= verificationIndex, \"OEL:unexpected index\");\n    require(\n      STAKE.validators[_pk].state == VALIDATOR_STATE.PROPOSED,\n      \"OEL:NOT all pubkeys are pending\"\n    );\n\n    uint256 operatorId = STAKE.validators[_pk].operatorId;\n    SML._imprison(DATASTORE, operatorId, _pk);\n\n    uint256 poolId = STAKE.validators[_pk].poolId;\n    DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT);\n    DATASTORE.addUint(poolId, rks.surplus, DCL.DEPOSIT_AMOUNT);\n\n    DATASTORE.subUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), 1);\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.alienValidators), 1);\n\n    STAKE.validators[_pk].state = VALIDATOR_STATE.ALIENATED;\n\n    emit Alienated(_pk);\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice Updating VERIFICATION_INDEX, signaling that it is safe to activate\n   * the validator proposals with lower index than new VERIFICATION_INDEX\n   * @param validatorVerificationIndex (inclusive) index of the highest validator that is verified to be activated\n   * @param alienatedPubkeys faulty proposals within the range of new and old verification indexes.\n   */\n  function updateVerificationIndex(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external onlyOracle(STAKE) {\n    require(STAKE.VALIDATORS_INDEX >= validatorVerificationIndex, \"OEL:high VERIFICATION_INDEX\");\n    require(validatorVerificationIndex > STAKE.VERIFICATION_INDEX, \"OEL:low VERIFICATION_INDEX\");\n\n    for (uint256 i = 0; i < alienatedPubkeys.length; ++i) {\n      _alienateValidator(STAKE, DATASTORE, validatorVerificationIndex, alienatedPubkeys[i]);\n    }\n\n    STAKE.VERIFICATION_INDEX = validatorVerificationIndex;\n    emit VerificationIndexUpdated(validatorVerificationIndex);\n  }\n\n  /**\n   * @dev                                       ** REGULATING OPERATORS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice regulating operators, currently only regulation is towards fee theft, can add more stuff in the future.\n   * @param feeThefts Operator ids who have stolen MEV or block rewards detected\n   * @param proofs  BlockNumber, tx or any other referance as a proof\n   * @dev Stuff here result in imprisonment\n   */\n  function regulateOperators(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256[] calldata feeThefts,\n    bytes[] calldata proofs\n  ) external onlyOracle(STAKE) {\n    require(feeThefts.length == proofs.length, \"OEL:invalid proofs\");\n\n    for (uint256 i = 0; i < feeThefts.length; ++i) {\n      SML._imprison(DATASTORE, feeThefts[i], proofs[i]);\n\n      emit FeeTheft(feeThefts[i], proofs[i]);\n    }\n  }\n\n  /**\n   * @custom:section                           ** CONTINUOUS UPDATES **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT.\n   * Also reports all of the validator balances with a BALANCE_MERKLE_ROOT.\n   * Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD\n   *\n   * @param allValidatorsCount Number of all validators within BeaconChain, all of them.\n   * Prevents monopolies.\n   */\n  function reportBeacon(\n    SML.PooledStaking storage STAKE,\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external onlyOracle(STAKE) {\n    require(allValidatorsCount > MIN_VALIDATOR_COUNT, \"OEL:low validator count\");\n\n    STAKE.PRICE_MERKLE_ROOT = priceMerkleRoot;\n    STAKE.BALANCE_MERKLE_ROOT = balanceMerkleRoot;\n    STAKE.ORACLE_UPDATE_TIMESTAMP = block.timestamp;\n\n    uint256 newThreshold = (allValidatorsCount * MONOPOLY_RATIO) / PERCENTAGE_DENOMINATOR;\n    STAKE.MONOPOLY_THRESHOLD = newThreshold;\n\n    emit OracleReported(priceMerkleRoot, balanceMerkleRoot, newThreshold);\n  }\n\n  /**\n   * @custom:section                           **  PRICE UPDATE **\n   *\n   * @dev Permissionless.\n   */\n\n  /**\n   * @custom:visibility -> view-internal\n   *\n   * @dev in order to prevent faulty updates to the derivative prices there are boundaries to price updates.\n   * 1. Price should not be increased more than DAILY_PRICE_INCREASE_LIMIT\n   *  with the factor of how many days since priceUpdateTimestamp has past.\n   * 2. Price should not be decreased more than DAILY_PRICE_DECREASE_LIMIT\n   *  with the factor of how many days since priceUpdateTimestamp has past.\n   *\n   * @dev Worth noting, if price drops more than x%, UP TO (slashing percentage/x) days deposits/withdrawals are halted.\n   * Example:\n   * * A pool can have only one validator, it can get slashed.\n   * * Lets say max decrease is 5%, and 50% is slashed.\n   * * Then deposits/withdrawals are halted for 10 days.\n   * This is not a bug, but a safe circuit-breaker.\n   * This logic have effects the withdrawal contract logic.\n   */\n  function _sanityCheck(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _newPrice\n  ) internal view {\n    require(DATASTORE.readUint(_id, rks.TYPE) == ID_TYPE.POOL, \"OEL:not a pool?\");\n\n    uint256 lastUpdate = STAKE.gETH.priceUpdateTimestamp(_id);\n    uint256 dayPercentSinceUpdate = ((block.timestamp - lastUpdate) * PERCENTAGE_DENOMINATOR) /\n      1 days;\n\n    uint256 curPrice = STAKE.gETH.pricePerShare(_id);\n\n    uint256 maxPriceIncrease = ((curPrice *\n      STAKE.DAILY_PRICE_INCREASE_LIMIT *\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\n\n    uint256 maxPriceDecrease = ((curPrice *\n      STAKE.DAILY_PRICE_DECREASE_LIMIT *\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\n\n    require(\n      (_newPrice + maxPriceDecrease >= curPrice) && (_newPrice <= curPrice + maxPriceIncrease),\n      \"OEL:price is insane, price update is halted\"\n    );\n  }\n\n  /**\n   * @custom:visibility -> internal\n   *\n   * @notice syncing the price of g-derivatives after checking the merkle proofs and the sanity of the price.\n   * @param _price price of the derivative denominated in gETH.denominator()\n   * @param _priceProof merkle proofs\n   */\n  function _priceSync(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _price,\n    bytes32[] calldata _priceProof\n  ) internal {\n    require(\n      STAKE.ORACLE_UPDATE_TIMESTAMP > STAKE.gETH.priceUpdateTimestamp(_poolId),\n      \"OEL:no price change\"\n    );\n\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_poolId, _price))));\n    require(\n      MerkleProof.verify(_priceProof, STAKE.PRICE_MERKLE_ROOT, leaf),\n      \"OEL:NOT all proofs are valid\"\n    );\n\n    _sanityCheck(STAKE, DATASTORE, _poolId, _price);\n\n    STAKE.gETH.setPricePerShare(_price, _poolId);\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice external function to set a derivative price on Portal\n   * @param price price of the derivative denominated in gETH.denominator()\n   * @param priceProof merkle proofs\n   */\n  function priceSync(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external {\n    _priceSync(STAKE, DATASTORE, poolId, price, priceProof);\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice external function to set a multiple derivatives price at once, saves gas.\n   * @param prices price of the derivative denominated in gETH.denominator()\n   * @param priceProofs merkle proofs\n   */\n  function priceSyncBatch(\n    SML.PooledStaking storage STAKE,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external {\n    require(poolIds.length == prices.length);\n    require(poolIds.length == priceProofs.length);\n\n    for (uint256 i = 0; i < poolIds.length; ++i) {\n      _priceSync(STAKE, DATASTORE, poolIds[i], prices[i], priceProofs[i]);\n    }\n  }\n}\n"
    },
    "contracts/Portal/modules/StakeModule/libs/StakeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {PERCENTAGE_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {VALIDATOR_STATE} from \"../../../globals/validator_state.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {DepositContractLib as DCL} from \"./DepositContractLib.sol\";\n// interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\nimport {IgETHMiddleware} from \"../../../interfaces/middlewares/IgETHMiddleware.sol\";\nimport {IGeodePackage} from \"../../../interfaces/packages/IGeodePackage.sol\";\nimport {ILiquidityPool} from \"../../../interfaces/packages/ILiquidityPool.sol\";\nimport {IWhitelist} from \"../../../interfaces/helpers/IWhitelist.sol\";\n// external\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @title SML: The Staking Library\n *\n * @notice Creating a global standard for Staking, allowing anyone to OWN a trustless staking pool,\n * improving the user experience for stakers and removing the \"need\" for centralized or decentralized intermediaries.\n * * Exclusively contains functions related to:\n * * 1. Initiators and Configurable Staking Pools.\n * * 2. Pool and Operator management.\n * * 3. Validator Delegation.\n * * 4. Depositing.\n * * 5. Staking Operations.\n *\n * @dev review: DataStoreModule for the IsolatedStorage logic.\n * @dev review: OracleExtensionLib for oracle logic.\n *\n * @dev Every pool is isolated and every validator is unique. Segregate all the risk.\n *\n * @dev CONTROLLER and Maintainer:\n * CONTROLLER is the owner of an ID, it manages the pool/operator. Its security is exteremely important.\n * maintainer is the worker, can be used to automate some daily tasks:\n * * distributing validators for Staking Pools or creating validators for Operators.\n * * not so crucial in terms of security.\n *\n * @dev Users:\n * Type 4 : Permissioned Operators\n * * Needs to be onboarded by the Dual Governance (Senate + Governance).\n * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\n * * Can participate in the Operator Marketplace after initiation.\n * * Can utilize maintainers for staking operations.\n *\n * Type 5 : Permissionless Configurable Staking Pools\n * * Permissionless to create.\n * * Can utilize powers of packages and middlewares such as Bound Liquidity Pools, gETHMiddlewares etc.\n * * Can be public or private, can use a whitelist if private.\n * * Can utilize maintainers for validator distribution on Operator Marketplace.\n * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\n * * accruing rewards and keeping Staked Ether safe and isolated.\n *\n * @dev Packages:\n * An ID can only point to 1(one) Package version at a time.\n * Built by utilizing the Modules!\n * Can be upgraded by a dual governance, via pullUpgrade.\n * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\n *\n * Type 10011 : Withdrawal Contract\n * * Mandatory.\n * * CONTROLLER is the implementation contract position (always)\n * * Version Release Requires the approval of Senate\n * * Upgrading to a new version is optional for pool owners.\n * * * Staking Pools are in \"Isolation Mode\" until their Withdrawal Contract is upgraded.\n * * * Meaning, no more Depositing or Validator Proposal can happen.\n * * Custodian of the validator funds after creation, including any type of rewards and fees.\n *\n * Type 10021 : Liquidity Pool implementation\n * * Optional.\n * * CONTROLLER is the implementation contract position (always)\n * * Version Release Requires the approval of Senate\n * * Upgrading to a new version is optional for pool owners.\n * * * Liquidity Pools are in \"Isolation Mode\" until upgraded.\n *\n * @dev Middlewares:\n * Can support many different versions that can be utilized by the Pool Owners.\n * No particular way to build one.\n * Can not be upgraded.\n * Currently only gETHMiddlewares.\n *\n * Type 20011 : gETHMiddleware\n * * Optional.\n * * CONTROLLER is the implementation contract position (always)\n * * Requires the approval of Senate\n * * Currently should be utilized on initiation.\n *\n * @dev Contracts relying on this library must initialize StakeUtils.PooledStaking\n *\n * @dev Functions are protected with authentication function\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary StakeModuleLib {\n  using DSML for DSML.IsolatedStorage;\n\n  /**\n   * @custom:section                           ** STRUCTS **\n   */\n\n  /**\n   * @notice Helper Struct to pack constant data that does not change per validator on batch proposals\n   * * needed for that famous Solidity feature.\n   */\n  struct ConstantValidatorData {\n    uint64 index;\n    uint64 period;\n    uint256 poolFee;\n    uint256 operatorFee;\n    uint256 governanceFee;\n    bytes withdrawalCredential;\n  }\n\n  /**\n   * @param state state of the validator, refer to globals.sol\n   * @param index representing this validator's placement on the chronological order of the validators proposals\n   * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\n   * @param period the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\n   * @param poolId needed for withdrawal_credential\n   * @param operatorId needed for staking after allowance\n   * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\n   * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\n   * @param governanceFee although governance fee is zero right now, all fees are crucial for the price calculation by the oracle.\n   * @param signature31 BLS12-381 signature for the validator, used when the remaining 31 ETH is sent on validator activation.\n   **/\n  struct Validator {\n    uint64 state;\n    uint64 index;\n    uint64 createdAt;\n    uint64 period;\n    uint256 poolId;\n    uint256 operatorId;\n    uint256 poolFee;\n    uint256 operatorFee;\n    uint256 governanceFee;\n    bytes signature31;\n  }\n\n  /**\n   * @param gETH constant, ERC1155, all Geode Staking Derivatives.\n   * @param ORACLE_POSITION constant, address of the Oracle https://github.com/Geodefi/Telescope-Eth\n   * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\n   * * Includes all validators: proposed, active, alienated, exited.\n   * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\n   * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\n   * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\n   * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval, per second.\n   * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval, per second.\n   * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, updated by the Holy Oracle.\n   * @param GOVERNANCE_FEE **reserved** Although it is 0 right now, It can be updated in the future.\n   * @param BALANCE_MERKLE_ROOT merkle root of the balances and other validator related data, useful on withdrawals, updated by the Holy Oracle.\n   * @param validators pubkey => Validator, contains all the data about proposed, alienated, active, exit-called and fully exited validators.\n   * @param packages TYPE => version id, pointing to the latest versions of the given package.\n   * * Like default Withdrawal Contract version.\n   * @param middlewares TYPE => version id => isAllowed, useful to check if given version of the middleware can be used.\n   * * Like all the whitelisted gETHMiddlewares.\n   * @param __gap keep the struct size at 16\n   **/\n  struct PooledStaking {\n    IgETH gETH;\n    address ORACLE_POSITION;\n    uint256 VALIDATORS_INDEX;\n    uint256 VERIFICATION_INDEX;\n    uint256 MONOPOLY_THRESHOLD;\n    uint256 ORACLE_UPDATE_TIMESTAMP;\n    uint256 DAILY_PRICE_INCREASE_LIMIT;\n    uint256 DAILY_PRICE_DECREASE_LIMIT;\n    uint256 GOVERNANCE_FEE;\n    bytes32 PRICE_MERKLE_ROOT;\n    bytes32 BALANCE_MERKLE_ROOT;\n    mapping(bytes => Validator) validators;\n    mapping(uint256 => uint256) packages;\n    mapping(uint256 => mapping(uint256 => bool)) middlewares;\n    uint256[2] __gap;\n  }\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice limiting the GOVERNANCE_FEE to 5%\n  uint256 public constant MAX_GOVERNANCE_FEE = (PERCENTAGE_DENOMINATOR * 5) / 100;\n\n  /// @notice limiting the pool and operator maintenance fee, 10%\n  uint256 public constant MAX_MAINTENANCE_FEE = (PERCENTAGE_DENOMINATOR * 10) / 100;\n\n  /// @notice effective on allowance per operator, prevents overflow. Exclusive, save gas with +1.\n  uint256 public constant MAX_ALLOWANCE = 10 ** 6 + 1;\n\n  /// @notice if a pool has 80% of its allowances filled, fallback operator is active.\n  uint256 public constant FALLBACK_THRESHOLD = (PERCENTAGE_DENOMINATOR * 80) / 100;\n\n  /// @notice price of gETH is only valid for 24H, minting is not allowed afterwards.\n  uint256 public constant PRICE_EXPIRY = 24 hours;\n\n  /// @notice ignoring any buybacks if the Liquidity Pool has a low debt\n  uint256 public constant IGNORABLE_DEBT = 1 ether;\n\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 2 years\n  uint256 public constant MIN_VALIDATOR_PERIOD = 3 * 30 days;\n  uint256 public constant MAX_VALIDATOR_PERIOD = 2 * 365 days;\n\n  /// @notice some parameter changes are effective after a delay\n  uint256 public constant SWITCH_LATENCY = 3 days;\n\n  /// @notice limiting the access for Operators in case of bad/malicious/faulty behaviour\n  uint256 public constant PRISON_SENTENCE = 14 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\n  event VisibilitySet(uint256 id, bool isPrivate);\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId);\n  event Prisoned(uint256 indexed operatorId, bytes proof, uint256 releaseTimestamp);\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\n  event Stake(bytes[] pubkeys);\n\n  /**\n   * @custom:section                           ** AUTHENTICATION **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  /**\n   * @notice restricts the access to given function based on TYPE and msg.sender\n   * @param _expectCONTROLLER restricts the access to only CONTROLLER.\n   * @param _expectMaintainer restricts the access to only maintainer.\n   * @param _restrictionMap Restricts which TYPEs can pass the authentication.\n   * * [0: Operator = TYPE(4), 1: Pool = TYPE(5)]\n   * @dev can only be used after an ID is initiated\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators can not access.\n   */\n  function _authenticate(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    bool _expectCONTROLLER,\n    bool _expectMaintainer,\n    bool[2] memory _restrictionMap\n  ) internal view {\n    require(DATASTORE.readUint(_id, rks.initiated) != 0, \"SML:not initiated\");\n\n    uint256 typeOfId = DATASTORE.readUint(_id, rks.TYPE);\n\n    if (typeOfId == ID_TYPE.OPERATOR) {\n      require(_restrictionMap[0], \"SML:TYPE NOT allowed\");\n      if (_expectCONTROLLER || _expectMaintainer) {\n        require(!isPrisoned(DATASTORE, _id), \"SML:prisoned, get in touch with governance\");\n      }\n    } else if (typeOfId == ID_TYPE.POOL) {\n      require(_restrictionMap[1], \"SML:TYPE NOT allowed\");\n    } else revert(\"SML:invalid TYPE\");\n\n    if (_expectMaintainer) {\n      require(\n        msg.sender == DATASTORE.readAddress(_id, rks.maintainer),\n        \"SML:sender NOT maintainer\"\n      );\n      return;\n    }\n\n    if (_expectCONTROLLER) {\n      require(\n        msg.sender == DATASTORE.readAddress(_id, rks.CONTROLLER),\n        \"SML:sender NOT CONTROLLER\"\n      );\n      return;\n    }\n  }\n\n  /**\n   * @custom:section                           ** OPERATOR INITIATOR **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice initiates ID as a Permissionned Node Operator\n   * @notice requires ID to be approved as a node operator with a specific CONTROLLER\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%\n   * @param validatorPeriod the expected maximum staking interval. This value should between\n   * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above.\n   * Operator can unstake at any given point before this period ends.\n   * If operator disobeys this rule, it can be prisoned with blameOperator()\n   * @param maintainer an address that automates daily operations, a script, a contract...\n   * @dev operators can fund their internal wallet on initiation by simply sending some ether.\n   */\n  function initiateOperator(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external {\n    require(DATASTORE.readUint(id, rks.initiated) == 0, \"SML:already initiated\");\n    require(DATASTORE.readUint(id, rks.TYPE) == ID_TYPE.OPERATOR, \"SML:TYPE NOT allowed\");\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"SML:sender NOT CONTROLLER\");\n\n    DATASTORE.writeUint(id, rks.initiated, block.timestamp);\n\n    _setMaintenanceFee(DATASTORE, id, fee);\n    _setValidatorPeriod(DATASTORE, id, validatorPeriod);\n    _setMaintainer(DATASTORE, id, maintainer);\n    _increaseWalletBalance(DATASTORE, id, msg.value);\n\n    emit IdInitiated(id, ID_TYPE.OPERATOR);\n  }\n\n  /**\n   * @custom:section                           ** STAKING POOL INITIATOR **\n   *\n   * @dev this section also contains the helper functions for packages and middlewares.\n   */\n\n  /**\n   * @notice Creates a Configurable Trustless Staking Pool!\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\n   * @param middlewareVersion Pool creators can choose any allowed version as their gETHMiddleware\n   * @param maintainer an address that automates daily operations, a script, a contract... not so critical.\n   * @param name is utilized while generating an ID for the Pool, similar to any other ID generation.\n   * @param middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\n   * @param config array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]\n   * @dev checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.\n   * @dev requires exactly 1 validator worth of funds to be deposited on initiation, prevent sybil attacks.\n   */\n  function initiatePool(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata name,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external returns (uint256 poolId) {\n    require(msg.value == DCL.DEPOSIT_AMOUNT, \"SML:need 1 validator worth of funds\");\n\n    poolId = DSML.generateId(name, ID_TYPE.POOL);\n    require(DATASTORE.readUint(poolId, rks.initiated) == 0, \"SML:already initiated\");\n    require(poolId > 10 ** 9, \"SML:Wow! Low pool id\");\n\n    DATASTORE.writeUint(poolId, rks.initiated, block.timestamp);\n\n    DATASTORE.writeUint(poolId, rks.TYPE, ID_TYPE.POOL);\n    DATASTORE.writeAddress(poolId, rks.CONTROLLER, msg.sender);\n    DATASTORE.writeBytes(poolId, rks.NAME, name);\n    DATASTORE.allIdsByType[ID_TYPE.POOL].push(poolId);\n\n    _setMaintainer(DATASTORE, poolId, maintainer);\n    _setMaintenanceFee(DATASTORE, poolId, fee);\n\n    // deploy a withdrawal Contract - mandatory\n    _deployWithdrawalContract(self, DATASTORE, poolId);\n\n    if (config[0]) {\n      // set pool to private\n      setPoolVisibility(DATASTORE, poolId, true);\n    }\n    if (config[1]) {\n      // deploy a gETH middleware(erc20 etc.) - optional\n      _deploygETHMiddleware(self, DATASTORE, poolId, middlewareVersion, middleware_data);\n    }\n    if (config[2]) {\n      // deploy a bound liquidity pool - optional\n      deployLiquidityPool(self, DATASTORE, poolId);\n    }\n\n    // initially 1 ETHER = 1 ETHER\n    self.gETH.setPricePerShare(1 ether, poolId);\n\n    // mint gETH and send back to the caller\n    uint256 mintedgETH = _mintgETH(self, DATASTORE, poolId, msg.value);\n    self.gETH.safeTransferFrom(address(this), msg.sender, poolId, mintedgETH, \"\");\n\n    emit IdInitiated(poolId, ID_TYPE.POOL);\n  }\n\n  /**\n   * @custom:subsection                           ** POOL INITIATOR HELPERS **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set a gETHMiddleware\n   * @param _middleware address of the new gETHMiddleware for given ID\n   * @dev every middleware has a unique index within the middlewares dynamic array.\n   * @dev if ever unset, SHOULD replace the implementation with address(0) for obvious security reasons.\n   */\n  function _setgETHMiddleware(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    address _middleware\n  ) internal {\n    require(!self.gETH.isMiddleware(_middleware, id), \"SML:already middleware\");\n\n    DATASTORE.appendAddressArray(id, rks.middlewares, _middleware);\n\n    self.gETH.setMiddleware(_middleware, id, true);\n  }\n\n  /**\n   * @notice deploys a new gETHMiddleware by cloning (no upgradability)\n   * @param _id gETH id, also required for IgETHMiddleware.initialize\n   * @param _versionId provided version id, can use any as a middleware if allowed for TYPE = MIDDLEWARE_GETH\n   * @param _middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\n   * @dev currrently, can NOT deploy a middleware after initiation, thus only used by the initiator.\n   * @dev currrently, can NOT unset a middleware.\n   */\n  function _deploygETHMiddleware(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _versionId,\n    bytes memory _middleware_data\n  ) internal {\n    require(_versionId > 0);\n    require(self.middlewares[ID_TYPE.MIDDLEWARE_GETH][_versionId], \"SML:not a middleware\");\n\n    address newgETHMiddleware = Clones.clone(DATASTORE.readAddress(_versionId, rks.CONTROLLER));\n\n    IgETHMiddleware(newgETHMiddleware).initialize(_id, address(self.gETH), _middleware_data);\n\n    _setgETHMiddleware(self, DATASTORE, _id, newgETHMiddleware);\n\n    // isolate the contract from middleware risk for ID\n    self.gETH.avoidMiddlewares(_id, true);\n  }\n\n  /**\n   * @notice deploys a new package for given id with given type from packages mapping.\n   * @param _type given package type\n   * @param _poolId pool id, required for IGeodePackage.initialize\n   * @param _package_data packages might require additional data on initialization\n   * @dev no cloning because GeodePackages has Limited Upgradability (based on UUPS)\n   */\n  function _deployGeodePackage(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _type,\n    bytes memory _package_data\n  ) internal returns (address packageInstance) {\n    uint256 versionId = self.packages[_type];\n    require(versionId > 0);\n\n    packageInstance = address(\n      new ERC1967Proxy(DATASTORE.readAddress(versionId, rks.CONTROLLER), \"\")\n    );\n    // we don't call on deployment because initialize uses _getImplementation() which is not available\n    IGeodePackage(packageInstance).initialize(\n      _poolId,\n      DATASTORE.readAddress(_poolId, rks.CONTROLLER),\n      DATASTORE.readBytes(versionId, rks.NAME),\n      _package_data\n    );\n  }\n\n  /**\n   * @notice Deploys a Withdrawal Contract that will be used as a withdrawal credential on validator creation\n   * @dev every pool requires a Withdrawal Contract, thus this function is only used by the initiator\n   */\n  function _deployWithdrawalContract(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId\n  ) internal {\n    require(\n      DATASTORE.readAddress(_poolId, rks.withdrawalContract) == address(0),\n      \"SML:already deployed\"\n    );\n\n    address wp = _deployGeodePackage(\n      self,\n      DATASTORE,\n      _poolId,\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\n      bytes(\"\")\n    );\n\n    DATASTORE.writeAddress(_poolId, rks.withdrawalContract, wp);\n    DATASTORE.writeBytes(_poolId, rks.withdrawalCredential, DCL.addressToWC(wp));\n  }\n\n  /**\n   * @custom:subsection                           ** BOUND LIQUIDITY POOL **\n   *\n   * @custom:visibility -> public\n   */\n\n  /**\n   * @notice deploys a bound liquidity pool for a staking pool, if it does not have one.\n   * @dev gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)\n   * @dev unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well\n   * @dev _package_data of a liquidity pool is only the staking pool's name.\n   */\n  function deployLiquidityPool(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId\n  ) public {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(DATASTORE.readAddress(poolId, rks.liquidityPool) == address(0), \"SML:already deployed\");\n\n    address lp = _deployGeodePackage(\n      self,\n      DATASTORE,\n      poolId,\n      ID_TYPE.PACKAGE_LIQUIDITY_POOL,\n      DATASTORE.readBytes(poolId, rks.NAME)\n    );\n\n    DATASTORE.writeAddress(poolId, rks.liquidityPool, lp);\n    // approve gETH so we can use it in buybacks\n    self.gETH.setApprovalForAll(lp, true);\n  }\n\n  /**\n   * @custom:subsection                           ** BOUND LIQUIDITY POOL **\n   */\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice changes the visibility of the pool\n   * @param makePrivate true if pool should be private, false for public pools\n   * @dev whitelist is cleared when pool is set to public, to prevent legacy bugs if ever made private again.\n   * Note private pools can whitelist addresses with the help of a third party contract.\n   */\n  function setPoolVisibility(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    bool makePrivate\n  ) public {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(makePrivate != isPrivatePool(DATASTORE, poolId), \"SML:already set\");\n\n    DATASTORE.writeUint(poolId, rks.privatePool, makePrivate ? 1 : 0);\n\n    if (!makePrivate) {\n      DATASTORE.writeAddress(poolId, rks.whitelist, address(0));\n    }\n\n    emit VisibilitySet(poolId, makePrivate);\n  }\n\n  /**\n   * @notice private pools can whitelist addresses with the help of a third party contract.\n   * @dev Whitelisting contracts should implement IWhitelist interface.\n   */\n  function setWhitelist(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    address whitelist\n  ) external {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(isPrivatePool(DATASTORE, poolId), \"SML:must be private pool\");\n\n    DATASTORE.writeAddress(poolId, rks.whitelist, whitelist);\n  }\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice returns true if the pool is private\n   */\n  function isPrivatePool(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId\n  ) public view returns (bool) {\n    return (DATASTORE.readUint(poolId, rks.privatePool) == 1);\n  }\n\n  /**\n   * @notice checks if the Whitelist allows staker to use given private pool\n   * @dev Owner of the pool doesn't need whitelisting\n   * @dev Otherwise requires a whitelisting address to be set\n   */\n  function isWhitelisted(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    address staker\n  ) public view returns (bool) {\n    if (DATASTORE.readAddress(poolId, rks.CONTROLLER) == staker) {\n      return true;\n    }\n\n    address whitelist = DATASTORE.readAddress(poolId, rks.whitelist);\n    require(whitelist != address(0), \"SML:no whitelist\");\n\n    return IWhitelist(whitelist).isAllowed(staker);\n  }\n\n  /**\n   * @custom:section                           ** ID MANAGEMENT **\n   *\n   */\n\n  /**\n   * @custom:subsection                           ** MAINTAINER **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Set the maintainer address on initiation or later\n   * @param _newMaintainer address of the new maintainer\n   */\n  function _setMaintainer(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    address _newMaintainer\n  ) internal {\n    require(_newMaintainer != address(0), \"SML:maintainer can NOT be zero\");\n\n    DATASTORE.writeAddress(_id, rks.maintainer, _newMaintainer);\n    emit MaintainerChanged(_id, _newMaintainer);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\n   * @dev there can only be 1 maintainer per ID.\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\n   * @dev we don't use _authenticate here because malicious maintainers can imprison operators\n   * * and prevent them entering here, smh.\n   */\n  function changeMaintainer(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    address newMaintainer\n  ) external {\n    require(DATASTORE.readUint(id, rks.initiated) != 0, \"SML:ID is not initiated\");\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"SML:sender NOT CONTROLLER\");\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\n    require(typeOfId == ID_TYPE.OPERATOR || typeOfId == ID_TYPE.POOL, \"SML:invalid TYPE\");\n\n    _setMaintainer(DATASTORE, id, newMaintainer);\n  }\n\n  /**\n   * @custom:subsection                           ** FEE **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\n   *\n   * @dev respecs to the switching delay.\n   *\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\n   */\n  function getMaintenanceFee(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id\n  ) public view returns (uint256 fee) {\n    if (DATASTORE.readUint(id, rks.feeSwitch) > block.timestamp) {\n      return DATASTORE.readUint(id, rks.priorFee);\n    }\n    return DATASTORE.readUint(id, rks.fee);\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set fee with NO DELAY\n   */\n  function _setMaintenanceFee(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _newFee\n  ) internal {\n    require(_newFee <= MAX_MAINTENANCE_FEE, \"SML:> MAX_MAINTENANCE_FEE \");\n    DATASTORE.writeUint(_id, rks.fee, _newFee);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\n   * @dev Can NOT be called again while its currently switching.\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\n   */\n  function switchMaintenanceFee(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    uint256 newFee\n  ) external {\n    _authenticate(DATASTORE, id, true, false, [true, true]);\n\n    require(block.timestamp > DATASTORE.readUint(id, rks.feeSwitch), \"SML:currently switching\");\n\n    DATASTORE.writeUint(id, rks.priorFee, DATASTORE.readUint(id, rks.fee));\n    DATASTORE.writeUint(id, rks.feeSwitch, block.timestamp + SWITCH_LATENCY);\n\n    _setMaintenanceFee(DATASTORE, id, newFee);\n\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\n  }\n\n  /**\n   * @custom:subsection                           ** INTERNAL WALLET **\n   *\n   * @dev Internal wallet of an ID accrues fees over time.\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Simply increases the balance of an IDs Maintainer wallet\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\n   */\n  function _increaseWalletBalance(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _value\n  ) internal {\n    DATASTORE.addUint(_id, rks.wallet, _value);\n  }\n\n  /**\n   * @notice To decrease the balance of an Operator's wallet internally\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\n   */\n  function _decreaseWalletBalance(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _value\n  ) internal {\n    require(DATASTORE.readUint(_id, rks.wallet) >= _value, \"SML:insufficient wallet balance\");\n    DATASTORE.subUint(_id, rks.wallet, _value);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice external function to increase the internal wallet balance\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\n   */\n  function increaseWalletBalance(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id\n  ) external returns (bool success) {\n    _authenticate(DATASTORE, id, false, false, [true, true]);\n    _increaseWalletBalance(DATASTORE, id, msg.value);\n    success = true;\n  }\n\n  /**\n   * @notice external function to decrease the internal wallet balance\n   * @dev only CONTROLLER can decrease the balance externally,\n   * @return success if the amount was sent and deducted\n   */\n  function decreaseWalletBalance(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id,\n    uint256 value\n  ) external returns (bool success) {\n    _authenticate(DATASTORE, id, true, false, [true, true]);\n\n    require(address(this).balance >= value, \"SML:insufficient contract balance\");\n\n    _decreaseWalletBalance(DATASTORE, id, value);\n    address controller = DATASTORE.readAddress(id, rks.CONTROLLER);\n\n    (success, ) = payable(controller).call{value: value}(\"\");\n    require(success, \"SML:Failed to send ETH\");\n  }\n\n  /**\n   * @custom:subsection                           ** OPERATORS PERIOD **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  function getValidatorPeriod(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 id\n  ) public view returns (uint256 period) {\n    if (DATASTORE.readUint(id, rks.periodSwitch) > block.timestamp) {\n      return DATASTORE.readUint(id, rks.priorPeriod);\n    }\n    return DATASTORE.readUint(id, rks.validatorPeriod);\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set validator period with NO DELAY\n   */\n  function _setValidatorPeriod(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _operatorId,\n    uint256 _newPeriod\n  ) internal {\n    require(_newPeriod >= MIN_VALIDATOR_PERIOD, \"SML:< MIN_VALIDATOR_PERIOD\");\n    require(_newPeriod <= MAX_VALIDATOR_PERIOD, \"SML:> MAX_VALIDATOR_PERIOD\");\n\n    DATASTORE.writeUint(_operatorId, rks.validatorPeriod, _newPeriod);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\n   */\n  function switchValidatorPeriod(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 operatorId,\n    uint256 newPeriod\n  ) external {\n    _authenticate(DATASTORE, operatorId, true, false, [true, false]);\n\n    require(\n      block.timestamp > DATASTORE.readUint(operatorId, rks.periodSwitch),\n      \"SML:currently switching\"\n    );\n\n    DATASTORE.writeUint(\n      operatorId,\n      rks.priorPeriod,\n      DATASTORE.readUint(operatorId, rks.validatorPeriod)\n    );\n    DATASTORE.writeUint(operatorId, rks.periodSwitch, block.timestamp + SWITCH_LATENCY);\n\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\n\n    emit ValidatorPeriodSwitched(operatorId, newPeriod, block.timestamp + SWITCH_LATENCY);\n  }\n\n  /**\n   * @custom:section                           ** PRISON **\n   *\n   * When node operators act in a malicious way, which can also be interpereted as\n   * an honest mistake like using a faulty signature, Oracle imprisons the operator.\n   * These conditions are:\n   * * 1. Created a malicious validator(alien): faulty withdrawal credential, faulty signatures etc.\n   * * 2. Have not respect the validatorPeriod (or blamed for some other valid case)\n   * * 3. Stole block fees or MEV boost rewards from the pool\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice Checks if the given operator is Prisoned\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\n   */\n  function isPrisoned(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 operatorId\n  ) public view returns (bool) {\n    return (block.timestamp < DATASTORE.readUint(operatorId, rks.release));\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Put an operator in prison\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\n   */\n  function _imprison(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _operatorId,\n    bytes calldata _proof\n  ) internal {\n    _authenticate(DATASTORE, _operatorId, false, false, [true, false]);\n\n    DATASTORE.writeUint(_operatorId, rks.release, block.timestamp + PRISON_SENTENCE);\n\n    emit Prisoned(_operatorId, _proof, block.timestamp + PRISON_SENTENCE);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice allows imprisoning an Operator if the validator have not been exited until expected exit\n   * @dev anyone can call this function while the state is ACTIVE\n   * @dev if operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned\n   *\n   * @dev this function lacks 2 other punishable acts:\n   * 1. while state is PROPOSED: validator proposed, it is passed, but haven't been created even tho it has been a MAX_BEACON_DELAY\n   * 2. while state is EXIT_REQUESTED:  validator requested exit, but it haven't been executed even tho it has been MAX_BEACON_DELAY\n   */\n  function blameOperator(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    bytes calldata pk\n  ) external {\n    require(\n      self.validators[pk].state == VALIDATOR_STATE.ACTIVE,\n      \"SML:validator is never activated\"\n    );\n    require(\n      block.timestamp > self.validators[pk].createdAt + self.validators[pk].period,\n      \"SML:validator is active\"\n    );\n\n    _imprison(DATASTORE, self.validators[pk].operatorId, pk);\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR DELEGATION **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice maximum number of remaining operator allowance that the given Operator is allowed to create for given Pool\n   * @dev an operator can not create new validators if:\n   * * 1. if operator is a monopoly\n   * * 2. allowance is filled\n   * * * But if operator is set as a fallback, it can if FALLBACK_THRESHOLD (80%) is reached on all allowances.\n   * @dev If operator withdraws a validator, then able to create a new one.\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\n   */\n  function operatorAllowance(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId\n  ) public view returns (uint256 remValidators) {\n    // monopoly check\n    {\n      // readUint for an array gives us length\n      uint256 numOperatorValidators = DATASTORE.readUint(operatorId, rks.validators);\n      uint256 monopoly_threshold = self.MONOPOLY_THRESHOLD;\n      if (numOperatorValidators >= monopoly_threshold) {\n        return 0;\n      } else {\n        remValidators = monopoly_threshold - numOperatorValidators;\n      }\n    }\n\n    // fallback check\n    {\n      if (operatorId == DATASTORE.readUint(poolId, rks.fallbackOperator)) {\n        // readUint for an array gives us length\n        uint256 numPoolValidators = DATASTORE.readUint(poolId, rks.validators);\n        uint256 totalAllowance = DATASTORE.readUint(poolId, rks.totalAllowance);\n        if (\n          totalAllowance == 0 ||\n          (((numPoolValidators * PERCENTAGE_DENOMINATOR) / totalAllowance) >= FALLBACK_THRESHOLD)\n        ) {\n          return remValidators;\n        }\n      }\n    }\n\n    // approval check\n    {\n      uint256 allowance = DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.allowance));\n      uint256 pooledValidators = DATASTORE.readUint(\n        poolId,\n        DSML.getKey(operatorId, rks.proposedValidators)\n      ) + DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.activeValidators));\n      if (pooledValidators >= allowance) {\n        return 0;\n      } else {\n        uint256 remAllowance = allowance - pooledValidators;\n        if (remValidators > remAllowance) {\n          remValidators = remAllowance;\n        }\n      }\n    }\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  function _setFallbackOperator(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId\n  ) internal {\n    DATASTORE.writeUint(poolId, rks.fallbackOperator, operatorId);\n    emit FallbackOperator(poolId, operatorId);\n  }\n\n  function _approveOperator(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 allowance\n  ) internal returns (uint256 oldAllowance) {\n    bytes32 allowanceKey = DSML.getKey(operatorId, rks.allowance);\n\n    oldAllowance = DATASTORE.readUint(poolId, allowanceKey);\n    DATASTORE.writeUint(poolId, allowanceKey, allowance);\n\n    emit Delegation(poolId, operatorId, allowance);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\n   * * This number can be set again at any given point in the future.\n   * @param poolId the gETH id of the Pool\n   * @param operatorIds array of Operator IDs to allow them create validators\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\n   * @dev When decreased the approved validator count below current active+proposed validators,\n   * operator can NOT create new validators.\n   */\n  function delegate(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances,\n    uint256 fallbackOperator\n  ) external {\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\n    require(operatorIds.length == allowances.length, \"SML:allowances should match\");\n    for (uint256 i = 0; i < operatorIds.length; ) {\n      require(\n        DATASTORE.readUint(operatorIds[i], rks.TYPE) == ID_TYPE.OPERATOR,\n        \"SML:id not operator\"\n      );\n      require(allowances[i] < MAX_ALLOWANCE, \"SML:> MAX_ALLOWANCE, set fallback\");\n      unchecked {\n        i += 1;\n      }\n    }\n\n    if (fallbackOperator != 0) {\n      require(\n        DATASTORE.readUint(fallbackOperator, rks.TYPE) == ID_TYPE.OPERATOR,\n        \"SML:fallback not operator\"\n      );\n    }\n\n    uint256 newCumulativeSubset;\n    uint256 oldCumulativeSubset;\n    for (uint256 i = 0; i < operatorIds.length; ) {\n      newCumulativeSubset += allowances[i];\n      oldCumulativeSubset += _approveOperator(DATASTORE, poolId, operatorIds[i], allowances[i]);\n      unchecked {\n        i += 1;\n      }\n    }\n\n    if (newCumulativeSubset > oldCumulativeSubset) {\n      DATASTORE.addUint(poolId, rks.totalAllowance, newCumulativeSubset - oldCumulativeSubset);\n    } else if (newCumulativeSubset < oldCumulativeSubset) {\n      DATASTORE.subUint(poolId, rks.totalAllowance, oldCumulativeSubset - newCumulativeSubset);\n    }\n\n    _setFallbackOperator(DATASTORE, poolId, fallbackOperator);\n  }\n\n  /**\n   * @custom:section                           ** POOLING  **\n   */\n\n  /**\n   * @custom:subsection                           ** DEPOSIT HELPERS **\n   */\n\n  /**\n   * @custom:visibility -> view-internal\n   */\n\n  function _isGeodePackageIsolated(address _packageAddress) internal view returns (bool) {\n    return IGeodePackage(_packageAddress).isolationMode();\n  }\n\n  /**\n   * @notice returns wrapped bound liquidity pool. If deployed, if not in isolationMode.\n   * @dev returns address(0) if no pool or it is under isolation\n   */\n  function _getLiquidityPool(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId\n  ) internal view returns (ILiquidityPool) {\n    address liqPool = DATASTORE.readAddress(_poolId, rks.liquidityPool);\n    if (liqPool == address(0)) {\n      return ILiquidityPool(address(0));\n    } else if (_isGeodePackageIsolated(liqPool)) {\n      return ILiquidityPool(address(0));\n    } else {\n      return ILiquidityPool(liqPool);\n    }\n  }\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice returns true if the price is valid:\n   * - last price syncinc happened less than 24h\n   * - there has been no oracle reports since the last update\n   *\n   * @dev known bug / feature: if there have been no oracle updates,\n   * * this function will return true.\n   *\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\n   *    : false\n   */\n  function isPriceValid(\n    PooledStaking storage self,\n    uint256 poolId\n  ) public view returns (bool isValid) {\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\n    unchecked {\n      isValid =\n        lastupdate + PRICE_EXPIRY >= block.timestamp &&\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\n    }\n  }\n\n  /**\n   * @notice checks if staking is allowed in given staking pool\n   * @notice staking is not allowed if:\n   * 1. Price is not valid\n   * 2. WithdrawalContract is in Isolation Mode, can have many reasons\n   */\n  function isMintingAllowed(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId\n  ) public view returns (bool) {\n    return\n      (isPriceValid(self, poolId)) &&\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract)));\n  }\n\n  /**\n   * @custom:subsection                           ** DEPOSIT **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\n   * @dev fails if minting is not allowed: invalid price, or isolationMode.\n   */\n  function _mintgETH(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _ethAmount\n  ) internal returns (uint256 mintedgETH) {\n    require(isMintingAllowed(self, DATASTORE, _poolId), \"SML:minting is not allowed\");\n\n    uint256 price = self.gETH.pricePerShare(_poolId);\n    require(price > 0, \"SML:price is zero?\");\n\n    mintedgETH = (((_ethAmount * self.gETH.denominator()) / price));\n    self.gETH.mint(address(this), _poolId, mintedgETH, \"\");\n    DATASTORE.addUint(_poolId, rks.surplus, _ethAmount);\n  }\n\n  /**\n   * @notice conducts a buyback using the given liquidity pool\n   * @param _poolId id of the gETH that will be bought\n   * @param _maxEthToSell max ETH amount to sell in the liq pool\n   * @param _deadline TX is expected to revert by Swap.sol if not meet\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\n   * as index 0 is ETH and index 1 is gETH!\n   */\n  function _buyback(\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _maxEthToSell,\n    uint256 _deadline\n  ) internal returns (uint256 remETH, uint256 boughtgETH) {\n    ILiquidityPool LP = _getLiquidityPool(DATASTORE, _poolId);\n    // skip if no liquidity pool is found\n    if (address(LP) != address(0)) {\n      uint256 debt = LP.getDebt();\n      // skip if debt is too low\n      if (debt > IGNORABLE_DEBT) {\n        if (_maxEthToSell > debt) {\n          // if debt is lower, then only sell debt\n          remETH = _maxEthToSell - debt;\n        } else {\n          // if eth is lower, then sell all eth, remETH already 0\n          debt = _maxEthToSell;\n        }\n        // SWAP in LP\n        boughtgETH = LP.swap{value: debt}(0, 1, debt, 0, _deadline);\n      } else {\n        remETH = _maxEthToSell;\n      }\n    } else {\n      remETH = _maxEthToSell;\n    }\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Allowing users to deposit into a staking pool.\n   * @notice If a pool is not public only the maintainer can deposit.\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\n   * @param mingETH liquidity pool parameter\n   * @param deadline liquidity pool parameter\n   * @dev an example for minting + buybacks\n   * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\n   * * debt  msgValue\n   * * 100   10  => buyback\n   * * 100   100 => buyback\n   * * 10    100 => buyback + mint\n   * * 1     x   => mint\n   * * 0.5   x   => mint\n   * * 0     x   => mint\n   */\n  function deposit(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\n    require(deadline > block.timestamp, \"SML:deadline not met\");\n    require(receiver != address(0), \"SML:receiver is zero address\");\n\n    if (isPrivatePool(DATASTORE, poolId)) {\n      require(isWhitelisted(DATASTORE, poolId, msg.sender), \"SML:sender NOT whitelisted\");\n    }\n\n    uint256 remEth = msg.value;\n    (remEth, boughtgETH) = _buyback(DATASTORE, poolId, remEth, deadline);\n\n    if (remEth > 0) {\n      mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\n    }\n\n    require(boughtgETH + mintedgETH >= mingETH, \"SML:less than minimum\");\n\n    // send back to user\n    self.gETH.safeTransferFrom(address(this), receiver, poolId, boughtgETH + mintedgETH, \"\");\n\n    emit Deposit(poolId, boughtgETH, mintedgETH);\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR CREATION **\n   *\n   * @dev Creation of a Validator takes 2 steps: propose and beacon stake.\n   * Before entering stake() function, _canStake verifies the eligibility of\n   * given pubKey that is proposed by an operator with proposeStake function.\n   * Eligibility is defined by an optimistic alienation, check OracleUtils._alienateValidator() for info.\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n\n  /**\n   * @notice internal function to check if a validator can use the pool funds\n   *\n   *  @param _pubkey BLS12-381 public key of the validator\n   *  @return true if:\n   *   - pubkey should be proposed\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\n   *   - validator's index should be covered by VERIFICATION_INDEX. Updated by Telescope.\n   * Note: while distributing the rewards, if a validator has 1 Eth, it is safe to assume that the balance belongs to Operator\n   */\n  function _canStake(\n    PooledStaking storage self,\n    bytes calldata _pubkey,\n    uint256 _verificationIndex\n  ) internal view returns (bool) {\n    return\n      (self.validators[_pubkey].state == VALIDATOR_STATE.PROPOSED) &&\n      (self.validators[_pubkey].index <= _verificationIndex);\n  }\n\n  /**\n   * @notice external function to check if a validator can use the pool funds\n   */\n  function canStake(\n    PooledStaking storage self,\n    bytes calldata pubkey\n  ) external view returns (bool) {\n    return _canStake(self, pubkey, self.VERIFICATION_INDEX);\n  }\n\n  /**\n   * @dev -> external\n   */\n\n  /**\n   * @notice Validator Credentials Proposal function, first step of crating validators.\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\n   * * it is optimistically allowed to take funds from staking pools.\n   *\n   * @param poolId the id of the staking pool\n   * @param operatorId the id of the Operator whose maintainer calling this function\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\n   * maintainer balance\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on stake() function call\n   *\n   * @dev DCL.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCL.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\n   * 31 Ether will be staked after verification of oracles. 32 in total.\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\n   * @dev ProposeStake requires enough funds within Wallet.\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 50)\n   */\n  function proposeStake(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external {\n    // checks\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\n    require(\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract))),\n      \"SML:withdrawalContract is isolated\"\n    );\n\n    uint256 pkLen = pubkeys.length;\n\n    require((pkLen > 0) && (pkLen <= DCL.MAX_DEPOSITS_PER_CALL), \"SML:1 - 50 validators\");\n\n    require(\n      pkLen == signatures1.length && pkLen == signatures31.length,\n      \"SML:invalid input length\"\n    );\n\n    require(\n      operatorAllowance(self, DATASTORE, poolId, operatorId) >= pkLen,\n      \"SML:insufficient allowance\"\n    );\n\n    require(\n      DATASTORE.readUint(poolId, rks.surplus) >= DCL.DEPOSIT_AMOUNT * pkLen,\n      \"SML:NOT enough surplus\"\n    );\n\n    for (uint256 i = 0; i < pkLen; ) {\n      require(pubkeys[i].length == DCL.PUBKEY_LENGTH, \"SML:PUBKEY_LENGTH ERROR\");\n      require(signatures1[i].length == DCL.SIGNATURE_LENGTH, \"SML:SIGNATURE_LENGTH ERROR\");\n      require(signatures31[i].length == DCL.SIGNATURE_LENGTH, \"SML:SIGNATURE_LENGTH ERROR\");\n      unchecked {\n        i += 1;\n      }\n    }\n\n    ConstantValidatorData memory valData = ConstantValidatorData({\n      index: uint64(self.VALIDATORS_INDEX + 1),\n      period: uint64(getValidatorPeriod(DATASTORE, operatorId)),\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\n      governanceFee: self.GOVERNANCE_FEE,\n      withdrawalCredential: DATASTORE.readBytes(poolId, rks.withdrawalCredential)\n    });\n\n    for (uint256 i = 0; i < pkLen; ) {\n      require(\n        self.validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\n        \"SML: used or alienated pk\"\n      );\n\n      self.validators[pubkeys[i]] = Validator(\n        VALIDATOR_STATE.PROPOSED,\n        valData.index + uint64(i),\n        uint64(block.timestamp),\n        valData.period,\n        poolId,\n        operatorId,\n        valData.poolFee,\n        valData.operatorFee,\n        valData.governanceFee,\n        signatures31[i]\n      );\n\n      DCL.depositValidator(\n        pubkeys[i],\n        valData.withdrawalCredential,\n        signatures1[i],\n        DCL.DEPOSIT_AMOUNT_PRESTAKE\n      );\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    _decreaseWalletBalance(DATASTORE, operatorId, (pkLen * DCL.DEPOSIT_AMOUNT_PRESTAKE));\n\n    DATASTORE.subUint(poolId, rks.surplus, (pkLen * DCL.DEPOSIT_AMOUNT));\n    DATASTORE.addUint(poolId, rks.secured, (pkLen * DCL.DEPOSIT_AMOUNT));\n\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), pkLen);\n    DATASTORE.appendBytesArrayBatch(poolId, rks.validators, pubkeys);\n    DATASTORE.appendBytesArrayBatch(operatorId, rks.validators, pubkeys);\n\n    self.VALIDATORS_INDEX += pkLen;\n\n    emit StakeProposal(poolId, operatorId, pubkeys);\n  }\n\n  /**\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\n   *\n   *  @param operatorId the id of the Operator whose maintainer calling this function\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\n   *\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\n   *  pk1, pk2, pk3 from pool1\n   *  pk4, pk5 from pool2\n   *  pk6 from pool3\n   *  seperate them in similar groups as much as possible.\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 50)\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\n   */\n  function stake(\n    PooledStaking storage self,\n    DSML.IsolatedStorage storage DATASTORE,\n    uint256 operatorId,\n    bytes[] calldata pubkeys\n  ) external {\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\n\n    require(\n      (pubkeys.length > 0) && (pubkeys.length <= DCL.MAX_DEPOSITS_PER_CALL),\n      \"SML:1 - 50 validators\"\n    );\n\n    {\n      uint256 _verificationIndex = self.VERIFICATION_INDEX;\n      for (uint256 j = 0; j < pubkeys.length; ) {\n        require(\n          _canStake(self, pubkeys[j], _verificationIndex),\n          \"SML:NOT all pubkeys are stakeable\"\n        );\n\n        unchecked {\n          j += 1;\n        }\n      }\n    }\n\n    {\n      bytes32 activeValKey = DSML.getKey(operatorId, rks.activeValidators);\n      bytes32 proposedValKey = DSML.getKey(operatorId, rks.proposedValidators);\n      uint256 poolId = self.validators[pubkeys[0]].poolId;\n      bytes memory withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\n\n      uint256 lastIdChange = 0;\n      for (uint256 i = 0; i < pubkeys.length; ) {\n        uint256 newPoolId = self.validators[pubkeys[i]].poolId;\n        if (poolId != newPoolId) {\n          uint256 sinceLastIdChange;\n\n          unchecked {\n            sinceLastIdChange = i - lastIdChange;\n          }\n\n          DATASTORE.subUint(poolId, rks.secured, (DCL.DEPOSIT_AMOUNT * (sinceLastIdChange)));\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\n\n          lastIdChange = i;\n          poolId = newPoolId;\n          withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\n        }\n\n        DCL.depositValidator(\n          pubkeys[i],\n          withdrawalCredential,\n          self.validators[pubkeys[i]].signature31,\n          (DCL.DEPOSIT_AMOUNT - DCL.DEPOSIT_AMOUNT_PRESTAKE)\n        );\n\n        self.validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\n\n        unchecked {\n          i += 1;\n        }\n      }\n      {\n        uint256 sinceLastIdChange;\n        unchecked {\n          sinceLastIdChange = pubkeys.length - lastIdChange;\n        }\n        if (sinceLastIdChange > 0) {\n          DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT * (sinceLastIdChange));\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\n        }\n      }\n\n      _increaseWalletBalance(DATASTORE, operatorId, DCL.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length);\n\n      emit Stake(pubkeys);\n    }\n  }\n}\n"
    },
    "contracts/Portal/modules/StakeModule/StakeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {PERCENTAGE_DENOMINATOR} from \"../../globals/macros.sol\";\n// interfaces\nimport {IgETH} from \"../../interfaces/IgETH.sol\";\nimport {IStakeModule} from \"../../interfaces/modules/IStakeModule.sol\";\n// libraries\nimport {StakeModuleLib as SML} from \"./libs/StakeModuleLib.sol\";\nimport {OracleExtensionLib as OEL} from \"./libs/OracleExtensionLib.sol\";\n// contracts\nimport {DataStoreModule} from \"../DataStoreModule/DataStoreModule.sol\";\n// external\nimport {ERC1155HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title SM: Stake Module\n *\n * @notice Liquid staking for everyone.\n * * pooling and staking for staking derivatives\n * * validator delegation and operator onboarding\n * * oracle operations such as pricing\n *\n * @dev review: this module delegates its functionality to SML (StakeModuleLib).\n * * SML has authenticate function for access control.\n * @dev review: OEL (OracleExtensionLib) is an extension for oracle operations.\n * @dev review: DCL (DepositContractLib) is an helper for validator creation.\n *\n * @dev There are 1 additional functionality implemented seperately from the library:\n * * check price validity and accept proofs for updating the price (refer to deposit function).\n * * However, this module inherits and implements nonReentrant & whenNotPaused modifiers.\n * * SM has pausability and expects inheriting contract to provide the access control mechanism.\n *\n * @dev 2 functions need to be overriden when inherited: pause, unpause.\n *\n * @dev __StakeModule_init (or _unchained) call is NECESSARY when inherited.\n *\n * @dev This module inherits DataStoreModule.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract StakeModule is\n  IStakeModule,\n  DataStoreModule,\n  ERC1155HolderUpgradeable,\n  PausableUpgradeable,\n  ReentrancyGuardUpgradeable\n{\n  using SML for SML.PooledStaking;\n  using OEL for SML.PooledStaking;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do NOT have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  SML.PooledStaking internal STAKE;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\n  event VisibilitySet(uint256 id, bool isPrivate);\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId);\n  event Prisoned(uint256 indexed operatorId, bytes proof, uint256 releaseTimestamp);\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\n  event Stake(bytes[] pubkeys);\n\n  event Alienated(bytes pubkey);\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\n  event FeeTheft(uint256 indexed id, bytes proofs);\n  event OracleReported(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 monopolyThreshold\n  );\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   */\n  function pause() external virtual override;\n\n  function unpause() external virtual override;\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n  function __StakeModule_init(address _gETH, address _oracle_position) internal onlyInitializing {\n    __ReentrancyGuard_init();\n    __Pausable_init();\n    __ERC1155Holder_init();\n    __DataStoreModule_init();\n    __StakeModule_init_unchained(_gETH, _oracle_position);\n  }\n\n  function __StakeModule_init_unchained(\n    address _gETH,\n    address _oracle_position\n  ) internal onlyInitializing {\n    require(_gETH != address(0));\n    require(_oracle_position != address(0));\n    STAKE.gETH = IgETH(_gETH);\n    STAKE.ORACLE_POSITION = _oracle_position;\n    STAKE.DAILY_PRICE_INCREASE_LIMIT = (7 * PERCENTAGE_DENOMINATOR) / 100;\n    STAKE.DAILY_PRICE_DECREASE_LIMIT = (7 * PERCENTAGE_DENOMINATOR) / 100;\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function StakeParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address gETH,\n      address oraclePosition,\n      uint256 validatorsIndex,\n      uint256 verificationIndex,\n      uint256 monopolyThreshold,\n      uint256 oracleUpdateTimestamp,\n      uint256 dailyPriceIncreaseLimit,\n      uint256 dailyPriceDecreaseLimit,\n      uint256 governanceFee,\n      bytes32 priceMerkleRoot,\n      bytes32 balanceMerkleRoot\n    )\n  {\n    gETH = address(STAKE.gETH);\n    oraclePosition = STAKE.ORACLE_POSITION;\n    validatorsIndex = STAKE.VALIDATORS_INDEX;\n    verificationIndex = STAKE.VERIFICATION_INDEX;\n    monopolyThreshold = STAKE.MONOPOLY_THRESHOLD;\n    oracleUpdateTimestamp = STAKE.ORACLE_UPDATE_TIMESTAMP;\n    dailyPriceIncreaseLimit = STAKE.DAILY_PRICE_INCREASE_LIMIT;\n    dailyPriceDecreaseLimit = STAKE.DAILY_PRICE_DECREASE_LIMIT;\n    governanceFee = STAKE.GOVERNANCE_FEE;\n    priceMerkleRoot = STAKE.PRICE_MERKLE_ROOT;\n    balanceMerkleRoot = STAKE.BALANCE_MERKLE_ROOT;\n  }\n\n  function getValidator(\n    bytes calldata pubkey\n  ) external view virtual override returns (SML.Validator memory) {\n    return STAKE.validators[pubkey];\n  }\n\n  function getPackageVersion(uint256 _type) external view virtual override returns (uint256) {\n    return STAKE.packages[_type];\n  }\n\n  function isMiddleware(\n    uint256 _type,\n    uint256 _version\n  ) external view virtual override returns (bool) {\n    return STAKE.middlewares[_type][_version];\n  }\n\n  /**\n   * @custom:section                           ** OPERATOR INITIATORS **\n   *\n   * @custom:visibility -> external\n   */\n  function initiateOperator(\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external payable virtual override whenNotPaused nonReentrant {\n    SML.initiateOperator(DATASTORE, id, fee, validatorPeriod, maintainer);\n  }\n\n  /**\n   * @custom:section                           ** STAKING POOL INITIATOR **\n   *\n   * @custom:visibility -> external\n   */\n\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable virtual override whenNotPaused returns (uint256 poolId) {\n    poolId = STAKE.initiatePool(\n      DATASTORE,\n      fee,\n      middlewareVersion,\n      maintainer,\n      NAME,\n      middleware_data,\n      config\n    );\n  }\n\n  /**\n   * @custom:subsection                           ** POOL VISIBILITY **\n   */\n\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external virtual override {\n    SML.setPoolVisibility(DATASTORE, poolId, makePrivate);\n  }\n\n  function setWhitelist(uint256 poolId, address whitelist) external virtual override {\n    SML.setWhitelist(DATASTORE, poolId, whitelist);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function isPrivatePool(uint256 poolId) external view virtual override returns (bool) {\n    return SML.isPrivatePool(DATASTORE, poolId);\n  }\n\n  function isWhitelisted(\n    uint256 poolId,\n    address staker\n  ) external view virtual override returns (bool) {\n    return SML.isWhitelisted(DATASTORE, poolId, staker);\n  }\n\n  /**\n   * @custom:subsection                           ** BOUND LIQUIDITY POOL **\n   */\n\n  function deployLiquidityPool(uint256 poolId) external virtual override whenNotPaused {\n    STAKE.deployLiquidityPool(DATASTORE, poolId);\n  }\n\n  /**\n   * @custom:section                           ** ID MANAGEMENT **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @custom:subsection                           ** MAINTAINER **\n   */\n\n  function changeMaintainer(\n    uint256 poolId,\n    address newMaintainer\n  ) external virtual override whenNotPaused {\n    SML.changeMaintainer(DATASTORE, poolId, newMaintainer);\n  }\n\n  /**\n   * @custom:subsection                           ** FEE **\n   */\n\n  function switchMaintenanceFee(\n    uint256 id,\n    uint256 newFee\n  ) external virtual override whenNotPaused {\n    SML.switchMaintenanceFee(DATASTORE, id, newFee);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function getMaintenanceFee(uint256 id) external view virtual override returns (uint256) {\n    return SML.getMaintenanceFee(DATASTORE, id);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL WALLET **\n   */\n\n  function increaseWalletBalance(\n    uint256 id\n  ) external payable virtual override whenNotPaused nonReentrant returns (bool) {\n    return SML.increaseWalletBalance(DATASTORE, id);\n  }\n\n  function decreaseWalletBalance(\n    uint256 id,\n    uint256 value\n  ) external virtual override nonReentrant returns (bool) {\n    return SML.decreaseWalletBalance(DATASTORE, id, value);\n  }\n\n  /**\n   * @custom:section                           ** OPERATORS PERIOD **\n   *\n   * @custom:visibility -> external\n   */\n\n  function switchValidatorPeriod(\n    uint256 operatorId,\n    uint256 newPeriod\n  ) external virtual override whenNotPaused {\n    SML.switchValidatorPeriod(DATASTORE, operatorId, newPeriod);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function getValidatorPeriod(uint256 id) external view virtual override returns (uint256) {\n    return SML.getValidatorPeriod(DATASTORE, id);\n  }\n\n  /**\n   * @custom:section                           ** PRISON **\n   *\n   * @custom:visibility -> external\n   */\n  function blameOperator(bytes calldata pk) external virtual override whenNotPaused {\n    STAKE.blameOperator(DATASTORE, pk);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function isPrisoned(uint256 operatorId) external view virtual override returns (bool) {\n    return SML.isPrisoned(DATASTORE, operatorId);\n  }\n\n  /**\n   * @custom:section                           ** DELEGATION **\n   *\n   * @custom:visibility -> external\n   */\n\n  function delegate(\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances,\n    uint256 fallbackOperator\n  ) external virtual override whenNotPaused {\n    SML.delegate(DATASTORE, poolId, operatorIds, allowances, fallbackOperator);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function operatorAllowance(\n    uint256 poolId,\n    uint256 operatorId\n  ) external view virtual override returns (uint256) {\n    return STAKE.operatorAllowance(DATASTORE, poolId, operatorId);\n  }\n\n  /**\n   * @custom:section                           ** DEPOSIT GETTERS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function isPriceValid(uint256 poolId) external view virtual override returns (bool) {\n    return STAKE.isPriceValid(poolId);\n  }\n\n  function isMintingAllowed(uint256 poolId) external view virtual override returns (bool) {\n    return STAKE.isMintingAllowed(DATASTORE, poolId);\n  }\n\n  /**\n   * @custom:section                           ** POOLING OPERATIONS **\n   *\n   * @custom:visibility -> external\n   */\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  )\n    external\n    payable\n    virtual\n    override\n    whenNotPaused\n    nonReentrant\n    returns (uint256 boughtgETH, uint256 mintedgETH)\n  {\n    if (!STAKE.isPriceValid(poolId)) {\n      STAKE.priceSync(DATASTORE, poolId, price, priceProof);\n    }\n\n    (boughtgETH, mintedgETH) = STAKE.deposit(DATASTORE, poolId, mingETH, deadline, receiver);\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR CREATION **\n   *\n   * @custom:visibility -> external\n   */\n  function proposeStake(\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external virtual override whenNotPaused {\n    STAKE.proposeStake(DATASTORE, poolId, operatorId, pubkeys, signatures1, signatures31);\n  }\n\n  function stake(\n    uint256 operatorId,\n    bytes[] calldata pubkeys\n  ) external virtual override whenNotPaused {\n    STAKE.stake(DATASTORE, operatorId, pubkeys);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function canStake(bytes calldata pubkey) external view virtual override returns (bool) {\n    return STAKE.canStake(pubkey);\n  }\n\n  /**\n   * @custom:section                           ** ORACLE OPERATIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  function updateVerificationIndex(\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external virtual override whenNotPaused {\n    STAKE.updateVerificationIndex(DATASTORE, validatorVerificationIndex, alienatedPubkeys);\n  }\n\n  function regulateOperators(\n    uint256[] calldata feeThefts,\n    bytes[] calldata proofs\n  ) external virtual override whenNotPaused {\n    STAKE.regulateOperators(DATASTORE, feeThefts, proofs);\n  }\n\n  function reportBeacon(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external virtual override whenNotPaused {\n    STAKE.reportBeacon(priceMerkleRoot, balanceMerkleRoot, allValidatorsCount);\n  }\n\n  function priceSync(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external virtual override whenNotPaused {\n    STAKE.priceSync(DATASTORE, poolId, price, priceProof);\n  }\n\n  function priceSyncBatch(\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external virtual override whenNotPaused {\n    STAKE.priceSyncBatch(DATASTORE, poolIds, prices, priceProofs);\n  }\n}\n"
    },
    "contracts/Portal/Portal.sol": {
      "content": "//                 \n//       \n//                          \n//                            \n//                     \n//                            \n//\n\n// SPDX-License-Identifier: MIT\npragma solidity =0.8.7;\n\n// globals\nimport {ID_TYPE} from \"./globals/id_type.sol\";\n// interfaces\nimport {IGeodeModule} from \"./interfaces/modules/IGeodeModule.sol\";\nimport {IPortal} from \"./interfaces/IPortal.sol\";\nimport {IStakeModule} from \"./interfaces/modules/IStakeModule.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"./modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {GeodeModuleLib as GML} from \"./modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport {StakeModuleLib as SML} from \"./modules/StakeModule/libs/StakeModuleLib.sol\";\n// contracts\nimport {GeodeModule} from \"./modules/GeodeModule/GeodeModule.sol\";\nimport {StakeModule} from \"./modules/StakeModule/StakeModule.sol\";\n\n/**\n * @title Geode Portal: Geode Module + Stake Module\n *\n * @notice Global standard for staking with on chain delegation and customizable staking pools.\n * Management of the state of the protocol governance through dual governance and proposals.\n * Version management and distribution of packages used by the staking pools.\n *\n * @dev TYPE: PACKAGE_PORTAL\n * @dev Portal is a special package that is deployed once. Does not utilize IGeodePackage interface.\n *\n * @dev review: GM for The Limited Upgradability through Dual Governance:\n * * Governance is a governance token.\n * * Senate is a multisig, planned to be a contract that allows pool CONTROLLERs to maintain power.\n * * Senate expiry is effective.\n *\n * @dev review: SM for Staking logic.\n *\n * @dev There are 2 functionalities that are implemented here:\n * * Special Governance functions for Portal:\n * * * Pausing gETH, pausing Portal, releasing prisoned operators,and seting a governance fee.\n * * Push end of the version management logic via pull->push.\n * * * approveProposal changes the package version or allows specified middleware.\n * * * pushUpgrade creates a contract upgrade proposal on the package, and requires package owner to approve it.\n *\n * @dev authentication:\n * * GeodeModule has OnlyGovernance, OnlySenate and OnlyController checks with modifiers.\n * * StakeModuleLib has \"authenticate()\" function which checks for Maintainers, Controllers, and TYPE.\n * * OracleModuleLib has OnlyOracle checks with a modifier.\n * * Portal has an OnlyGovernance check on : pause, unpause, pausegETH, unpausegETH, setGovernanceFee, releasePrisoned.\n *\n * @author Ice Bear & Crash Bandicoot\n */\ncontract Portal is IPortal, StakeModule, GeodeModule {\n  using DSML for DSML.IsolatedStorage;\n  using GML for GML.DualGovernance;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Released(uint256 operatorId);\n  event GovernanceFeeSet(uint256 fee);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyGovernance() {\n    require(msg.sender == GEODE.SENATE, \"Portal:sender NOT governance\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  ///@custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address _governance,\n    address _senate,\n    address _gETH,\n    address _oracle_position,\n    bytes calldata versionName\n  ) public virtual initializer {\n    __Portal_init(_governance, _senate, _gETH, _oracle_position, versionName);\n  }\n\n  function __Portal_init(\n    address _governance,\n    address _senate,\n    address _gETH,\n    address _oracle_position,\n    bytes calldata versionName\n  ) internal onlyInitializing {\n    __GeodeModule_init(\n      _governance,\n      _senate,\n      block.timestamp + GML.MAX_SENATE_PERIOD,\n      ID_TYPE.PACKAGE_PORTAL,\n      versionName\n    );\n    __StakeModule_init(_gETH, _oracle_position);\n    __Portal_init_unchained();\n  }\n\n  function __Portal_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @dev GeodeModule override\n   *\n   * @notice Isolation Mode is an external view function signaling other contracts\n   * * to isolate themselves from Portal. For example, withdrawalContract will not fetch upgrades.\n   * @return isRecovering true if isolationMode is active:\n   * * 1. Portal is paused\n   * * 2. Portal needs to be upgraded\n   * * 3. Senate expired\n   */\n  function isolationMode()\n    external\n    view\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (bool)\n  {\n    return (paused() ||\n      GEODE.APPROVED_UPGRADE != _getImplementation() ||\n      block.timestamp > GEODE.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:section                           ** GOVERNANCE FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  function pause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _pause();\n  }\n\n  function unpause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _unpause();\n  }\n\n  function pausegETH() external virtual override onlyGovernance {\n    STAKE.gETH.pause();\n  }\n\n  function unpausegETH() external virtual override onlyGovernance {\n    STAKE.gETH.unpause();\n  }\n\n  /**\n   * @notice releases an imprisoned operator immidately\n   * @dev in different situations such as a faulty imprisonment or coordinated testing periods\n   * * Governance can release the prisoners\n   * @dev onlyGovernance SHOULD be checked in Portal\n   */\n  function releasePrisoned(uint256 operatorId) external virtual override onlyGovernance {\n    DATASTORE.writeUint(operatorId, \"release\", block.timestamp);\n\n    emit Released(operatorId);\n  }\n\n  function setGovernanceFee(uint256 newFee) external virtual override onlyGovernance {\n    require(newFee <= SML.MAX_GOVERNANCE_FEE, \"Portal:> MAX_GOVERNANCE_FEE\");\n    require(block.timestamp > 1714514461, \"Portal:not yet\");\n\n    STAKE.GOVERNANCE_FEE = newFee;\n\n    emit GovernanceFeeSet(newFee);\n  }\n\n  /**\n   * @custom:section                           ** PACKAGE VERSION MANAGEMENT **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice approves a specific proposal\n   * @dev OnlySenate is checked inside the GeodeModule\n   */\n  function approveProposal(\n    uint256 id\n  )\n    public\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (address _controller, uint256 _type, bytes memory _name)\n  {\n    (_controller, _type, _name) = super.approveProposal(id);\n\n    if (_type > ID_TYPE.LIMIT_MIN_PACKAGE && _type < ID_TYPE.LIMIT_MAX_PACKAGE) {\n      STAKE.packages[_type] = id;\n    } else if (_type > ID_TYPE.LIMIT_MIN_MIDDLEWARE && _type < ID_TYPE.LIMIT_MAX_MIDDLEWARE) {\n      STAKE.middlewares[_type][id] = true;\n    }\n  }\n\n  function pushUpgrade(\n    uint256 packageType\n  ) external virtual override whenNotPaused nonReentrant returns (bytes memory versionName) {\n    require(\n      packageType > ID_TYPE.LIMIT_MIN_PACKAGE && packageType < ID_TYPE.LIMIT_MAX_PACKAGE,\n      \"PORTAL:invalid package type\"\n    );\n\n    uint256 currentPackageVersion = STAKE.packages[packageType];\n    versionName = DATASTORE.readBytes(currentPackageVersion, \"NAME\");\n\n    uint256 id = IGeodeModule(msg.sender).propose(\n      DATASTORE.readAddress(currentPackageVersion, \"CONTROLLER\"),\n      ID_TYPE.CONTRACT_UPGRADE,\n      versionName,\n      GML.MAX_PROPOSAL_DURATION\n    );\n\n    require(id > 0, \"PORTAL:cannot push upgrade\");\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n\n  /**\n   * @notice keep the contract size at 50\n   */\n  uint256[50] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}