{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts-exposed/gETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../contracts/gETH.sol\";\nimport \"../contracts/helpers/ERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../contracts/interfaces/IgETH.sol\";\nimport \"../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../contracts/globals/macros.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract $gETH is gETH {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    event return$_grantRole(bool ret0);\n\n    event return$_revokeRole(bool ret0);\n\n    constructor(string memory _name, string memory _symbol, string memory _uri) gETH(_name, _symbol, _uri) payable {\n    }\n\n    function $_setMiddleware(address _middleware,uint256 _id,bool _isSet) external {\n        super._setMiddleware(_middleware,_id,_isSet);\n    }\n\n    function $_setPricePerShare(uint256 _price,uint256 _id) external {\n        super._setPricePerShare(_price,_id);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 amount,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data);\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $_checkRole(bytes32 role) external view {\n        super._checkRole(role);\n    }\n\n    function $_checkRole(bytes32 role,address account) external view {\n        super._checkRole(role,account);\n    }\n\n    function $_setRoleAdmin(bytes32 role,bytes32 adminRole) external {\n        super._setRoleAdmin(role,adminRole);\n    }\n\n    function $_grantRole(bytes32 role,address account) external returns (bool ret0) {\n        (ret0) = super._grantRole(role,account);\n        emit return$_grantRole(ret0);\n    }\n\n    function $_revokeRole(bytes32 role,address account) external returns (bool ret0) {\n        (ret0) = super._revokeRole(role,account);\n        emit return$_revokeRole(ret0);\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/globals/id_type.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/globals/id_type.sol\";\n\ncontract $ID_TYPE {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $NONE() external pure returns (uint256) {\n        return ID_TYPE.NONE;\n    }\n\n    function $SENATE() external pure returns (uint256) {\n        return ID_TYPE.SENATE;\n    }\n\n    function $LIMIT_MIN_USER() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MIN_USER;\n    }\n\n    function $OPERATOR() external pure returns (uint256) {\n        return ID_TYPE.OPERATOR;\n    }\n\n    function $POOL() external pure returns (uint256) {\n        return ID_TYPE.POOL;\n    }\n\n    function $LIMIT_MAX_USER() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MAX_USER;\n    }\n\n    function $LIMIT_MIN_PACKAGE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MIN_PACKAGE;\n    }\n\n    function $PACKAGE_PORTAL() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_PORTAL;\n    }\n\n    function $PACKAGE_WITHDRAWAL_CONTRACT() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT;\n    }\n\n    function $PACKAGE_LIQUIDITY_POOL() external pure returns (uint256) {\n        return ID_TYPE.PACKAGE_LIQUIDITY_POOL;\n    }\n\n    function $LIMIT_MAX_PACKAGE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MAX_PACKAGE;\n    }\n\n    function $LIMIT_MIN_MIDDLEWARE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MIN_MIDDLEWARE;\n    }\n\n    function $MIDDLEWARE_GETH() external pure returns (uint256) {\n        return ID_TYPE.MIDDLEWARE_GETH;\n    }\n\n    function $LIMIT_MAX_MIDDLEWARE() external pure returns (uint256) {\n        return ID_TYPE.LIMIT_MAX_MIDDLEWARE;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/globals/reserved_key_space.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/globals/reserved_key_space.sol\";\n\ncontract $RESERVED_KEY_SPACE {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $CONTROLLER() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.CONTROLLER;\n    }\n\n    function $NAME() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.NAME;\n    }\n\n    function $TYPE() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.TYPE;\n    }\n\n    function $activeValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.activeValidators;\n    }\n\n    function $allowance() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.allowance;\n    }\n\n    function $fallbackOperator() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.fallbackOperator;\n    }\n\n    function $fallbackThreshold() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.fallbackThreshold;\n    }\n\n    function $fee() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.fee;\n    }\n\n    function $feeSwitch() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.feeSwitch;\n    }\n\n    function $initiated() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.initiated;\n    }\n\n    function $liquidityPool() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.liquidityPool;\n    }\n\n    function $yieldReceiver() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.yieldReceiver;\n    }\n\n    function $maintainer() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.maintainer;\n    }\n\n    function $middlewares() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.middlewares;\n    }\n\n    function $periodSwitch() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.periodSwitch;\n    }\n\n    function $priorFee() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.priorFee;\n    }\n\n    function $priorPeriod() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.priorPeriod;\n    }\n\n    function $privatePool() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.privatePool;\n    }\n\n    function $proposedValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.proposedValidators;\n    }\n\n    function $release() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.release;\n    }\n\n    function $secured() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.secured;\n    }\n\n    function $surplus() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.surplus;\n    }\n\n    function $totalAllowance() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.totalAllowance;\n    }\n\n    function $validatorPeriod() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.validatorPeriod;\n    }\n\n    function $validators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.validators;\n    }\n\n    function $withdrawalContract() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.withdrawalContract;\n    }\n\n    function $withdrawalCredential() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.withdrawalCredential;\n    }\n\n    function $wallet() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.wallet;\n    }\n\n    function $whitelist() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.whitelist;\n    }\n\n    function $alienValidators() external pure returns (bytes32) {\n        return RESERVED_KEY_SPACE.alienValidators;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/globals/validator_state.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/globals/validator_state.sol\";\n\ncontract $VALIDATOR_STATE {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $NONE() external pure returns (uint8) {\n        return VALIDATOR_STATE.NONE;\n    }\n\n    function $PROPOSED() external pure returns (uint8) {\n        return VALIDATOR_STATE.PROPOSED;\n    }\n\n    function $ACTIVE() external pure returns (uint8) {\n        return VALIDATOR_STATE.ACTIVE;\n    }\n\n    function $EXIT_REQUESTED() external pure returns (uint8) {\n        return VALIDATOR_STATE.EXIT_REQUESTED;\n    }\n\n    function $EXITED() external pure returns (uint8) {\n        return VALIDATOR_STATE.EXITED;\n    }\n\n    function $ALIENATED() external pure returns (uint8) {\n        return VALIDATOR_STATE.ALIENATED;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/helpers/BytesLib.sol\";\n\ncontract $BytesLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => bytes) internal $v_bytes;\n\n    constructor() payable {\n    }\n\n    function $concat(bytes calldata _preBytes,bytes calldata _postBytes) external pure returns (bytes memory ret0) {\n        (ret0) = BytesLib.concat(_preBytes,_postBytes);\n    }\n\n    function $concatStorage(uint256 _preBytes,bytes calldata _postBytes) external payable {\n        BytesLib.concatStorage($v_bytes[_preBytes],_postBytes);\n    }\n\n    function $slice(bytes calldata _bytes,uint256 _start,uint256 _length) external pure returns (bytes memory ret0) {\n        (ret0) = BytesLib.slice(_bytes,_start,_length);\n    }\n\n    function $toAddress(bytes calldata _bytes,uint256 _start) external pure returns (address ret0) {\n        (ret0) = BytesLib.toAddress(_bytes,_start);\n    }\n\n    function $toUint8(bytes calldata _bytes,uint256 _start) external pure returns (uint8 ret0) {\n        (ret0) = BytesLib.toUint8(_bytes,_start);\n    }\n\n    function $toUint16(bytes calldata _bytes,uint256 _start) external pure returns (uint16 ret0) {\n        (ret0) = BytesLib.toUint16(_bytes,_start);\n    }\n\n    function $toUint32(bytes calldata _bytes,uint256 _start) external pure returns (uint32 ret0) {\n        (ret0) = BytesLib.toUint32(_bytes,_start);\n    }\n\n    function $toUint64(bytes calldata _bytes,uint256 _start) external pure returns (uint64 ret0) {\n        (ret0) = BytesLib.toUint64(_bytes,_start);\n    }\n\n    function $toUint96(bytes calldata _bytes,uint256 _start) external pure returns (uint96 ret0) {\n        (ret0) = BytesLib.toUint96(_bytes,_start);\n    }\n\n    function $toUint128(bytes calldata _bytes,uint256 _start) external pure returns (uint128 ret0) {\n        (ret0) = BytesLib.toUint128(_bytes,_start);\n    }\n\n    function $toUint256(bytes calldata _bytes,uint256 _start) external pure returns (uint256 ret0) {\n        (ret0) = BytesLib.toUint256(_bytes,_start);\n    }\n\n    function $toBytes32(bytes calldata _bytes,uint256 _start) external pure returns (bytes32 ret0) {\n        (ret0) = BytesLib.toBytes32(_bytes,_start);\n    }\n\n    function $equal(bytes calldata _preBytes,bytes calldata _postBytes) external pure returns (bool ret0) {\n        (ret0) = BytesLib.equal(_preBytes,_postBytes);\n    }\n\n    function $equalStorage(uint256 _preBytes,bytes calldata _postBytes) external view returns (bool ret0) {\n        (ret0) = BytesLib.equalStorage($v_bytes[_preBytes],_postBytes);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/ERC1155PausableBurnableSupply.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/helpers/ERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract $ERC1155 is ERC1155 {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(string memory uri_) ERC1155(uri_) payable {\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,value,data);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n\ncontract $ERC1155Pausable is ERC1155Pausable {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(string memory uri_) ERC1155(uri_) payable {\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,value,data);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n\ncontract $ERC1155Burnable is ERC1155Burnable {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(string memory uri_) ERC1155(uri_) payable {\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,value,data);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n\ncontract $ERC1155Supply is ERC1155Supply {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(string memory uri_) ERC1155(uri_) payable {\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,value,data);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n\ncontract $ERC1155PausableBurnableSupply is ERC1155PausableBurnableSupply {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    event return$_grantRole(bool ret0);\n\n    event return$_revokeRole(bool ret0);\n\n    constructor(string memory uri_) ERC1155PausableBurnableSupply(uri_) payable {\n    }\n\n    function $_update(address from,address to,uint256[] calldata ids,uint256[] calldata values) external {\n        super._update(from,to,ids,values);\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $_checkRole(bytes32 role) external view {\n        super._checkRole(role);\n    }\n\n    function $_checkRole(bytes32 role,address account) external view {\n        super._checkRole(role,account);\n    }\n\n    function $_setRoleAdmin(bytes32 role,bytes32 adminRole) external {\n        super._setRoleAdmin(role,adminRole);\n    }\n\n    function $_grantRole(bytes32 role,address account) external returns (bool ret0) {\n        (ret0) = super._grantRole(role,account);\n        emit return$_grantRole(ret0);\n    }\n\n    function $_revokeRole(bytes32 role,address account) external returns (bool ret0) {\n        (ret0) = super._revokeRole(role,account);\n        emit return$_revokeRole(ret0);\n    }\n\n    function $_updateWithAcceptanceCheck(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._updateWithAcceptanceCheck(from,to,ids,values,data);\n    }\n\n    function $_safeTransferFrom(address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._safeTransferFrom(from,to,id,value,data);\n    }\n\n    function $_safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._safeBatchTransferFrom(from,to,ids,values,data);\n    }\n\n    function $_setURI(string calldata newuri) external {\n        super._setURI(newuri);\n    }\n\n    function $_mint(address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._mint(to,id,value,data);\n    }\n\n    function $_mintBatch(address to,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external {\n        super._mintBatch(to,ids,values,data);\n    }\n\n    function $_burn(address from,uint256 id,uint256 value) external {\n        super._burn(from,id,value);\n    }\n\n    function $_burnBatch(address from,uint256[] calldata ids,uint256[] calldata values) external {\n        super._burnBatch(from,ids,values);\n    }\n\n    function $_setApprovalForAll(address owner,address operator,bool approved) external {\n        super._setApprovalForAll(owner,operator,approved);\n    }\n\n    function $_doSafeTransferAcceptanceCheck(address operator,address from,address to,uint256 id,uint256 value,bytes calldata data) external {\n        super._doSafeTransferAcceptanceCheck(operator,from,to,id,value,data);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/ERC1155ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/ERC1155ReceiverMock.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $ERC1155ReceiverMock is ERC1155ReceiverMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(bytes4 recRetval, bytes4 batRetval, RevertType error) ERC1155ReceiverMock(recRetval, batRetval, error) payable {\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/FreshSlotModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/FreshSlotModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/helpers/test/mocks/interfaces/IFreshSlotModule.sol\";\nimport \"../../../../contracts/helpers/test/mocks/FreshSlotModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\nabstract contract $FreshSlotModule is FreshSlotModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $FRESH_STRUCT() external view returns (FreshSlotStruct memory) {\n        return FRESH_STRUCT;\n    }\n\n    function $__FreshSlotModule_init(uint256 value) external {\n        super.__FreshSlotModule_init(value);\n    }\n\n    function $__FreshSlotModule_init_unchained(uint256 value) external {\n        super.__FreshSlotModule_init_unchained(value);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/FreshSlotModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/FreshSlotModuleLib.sol\";\n\ncontract $FreshSlotModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => FreshSlotStruct) internal $v_FreshSlotStruct;\n\n    constructor() payable {\n    }\n\n    function $setFreshSlot(uint256 self,uint256 value) external payable {\n        FreshSlotModuleLib.setFreshSlot($v_FreshSlotStruct[self],value);\n    }\n\n    function $getFreshSlot(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = FreshSlotModuleLib.getFreshSlot($v_FreshSlotStruct[self]);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/GeodeModuleLibV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/GeodeModuleLibV3_0_Mock.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\n\ncontract $GeodeModuleLibV3_0_Mock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => DualGovernanceV3_0_Mock) internal $v_DualGovernanceV3_0_Mock;\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    event return$propose(uint256 id);\n\n    event return$approveProposal(address _controller, uint256 _type, bytes _name);\n\n    constructor() payable {\n    }\n\n    function $MIN_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLibV3_0_Mock.MIN_PROPOSAL_DURATION;\n    }\n\n    function $MAX_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLibV3_0_Mock.MAX_PROPOSAL_DURATION;\n    }\n\n    function $MAX_SENATE_PERIOD() external pure returns (uint32) {\n        return GeodeModuleLibV3_0_Mock.MAX_SENATE_PERIOD;\n    }\n\n    function $setFreshSlot(uint256 self,uint256 value) external payable {\n        GeodeModuleLibV3_0_Mock.setFreshSlot($v_DualGovernanceV3_0_Mock[self],value);\n    }\n\n    function $getFreshSlot(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = GeodeModuleLibV3_0_Mock.getFreshSlot($v_DualGovernanceV3_0_Mock[self]);\n    }\n\n    function $isUpgradeAllowed(uint256 self,address proposedImplementation,address currentImplementation) external view returns (bool ret0) {\n        (ret0) = GeodeModuleLibV3_0_Mock.isUpgradeAllowed($v_DualGovernanceV3_0_Mock[self],proposedImplementation,currentImplementation);\n    }\n\n    function $getProposal(uint256 self,uint256 id) external view returns (Proposal memory ret0) {\n        (ret0) = GeodeModuleLibV3_0_Mock.getProposal($v_DualGovernanceV3_0_Mock[self],id);\n    }\n\n    function $_setSenate(uint256 self,address _newSenate,uint256 _expiry) external payable {\n        GeodeModuleLibV3_0_Mock._setSenate($v_DualGovernanceV3_0_Mock[self],_newSenate,_expiry);\n    }\n\n    function $propose(uint256 self,uint256 DATASTORE,address _CONTROLLER,uint256 _TYPE,bytes calldata _NAME,uint256 duration) external payable returns (uint256 id) {\n        (id) = GeodeModuleLibV3_0_Mock.propose($v_DualGovernanceV3_0_Mock[self],$v_DataStoreModuleStorage[DATASTORE],_CONTROLLER,_TYPE,_NAME,duration);\n        emit return$propose(id);\n    }\n\n    function $rescueSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLibV3_0_Mock.rescueSenate($v_DualGovernanceV3_0_Mock[self],_newSenate);\n    }\n\n    function $approveProposal(uint256 self,uint256 DATASTORE,uint256 id) external payable returns (address _controller, uint256 _type, bytes memory _name) {\n        (_controller, _type, _name) = GeodeModuleLibV3_0_Mock.approveProposal($v_DualGovernanceV3_0_Mock[self],$v_DataStoreModuleStorage[DATASTORE],id);\n        emit return$approveProposal(_controller, _type, _name);\n    }\n\n    function $changeSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLibV3_0_Mock.changeSenate($v_DualGovernanceV3_0_Mock[self],_newSenate);\n    }\n\n    function $changeIdCONTROLLER(uint256 DATASTORE,uint256 id,address newCONTROLLER) external payable {\n        GeodeModuleLibV3_0_Mock.changeIdCONTROLLER($v_DataStoreModuleStorage[DATASTORE],id,newCONTROLLER);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/GeodeModuleMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/GeodeModuleMock.sol\";\nimport \"../../../../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\n\ncontract $GeodeModuleMock is GeodeModuleMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/GeodeUpgradedMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/GeodeUpgradedMock.sol\";\nimport \"../../../../contracts/helpers/test/mocks/GeodeModuleMock.sol\";\nimport \"../../../../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\ncontract $GeodeUpgradedMock is GeodeUpgradedMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/LiquidityModuleMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/LiquidityModuleMock.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/LiquidityModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/helpers/ILPToken.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/helpers.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\ncontract $LiquidityModuleMock is LiquidityModuleMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $_getLiquidityModuleStorage() external pure returns (LiquidityModuleStorage memory $) {\n        ($) = super._getLiquidityModuleStorage();\n    }\n\n    function $__LiquidityModule_init(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__LiquidityModule_init_unchained(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init_unchained(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/OracleExtensionLibMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/OracleExtensionLibMock.sol\";\nimport \"../../../../contracts/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\n\ncontract $OracleExtensionLibMock is OracleExtensionLibMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/StakeModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/StakeModuleLibMock.sol\";\nimport \"../../../../contracts/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../../../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\ncontract $StakeModuleLibMock is StakeModuleLibMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/helpers/test/mocks/WithdrawalModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/helpers/test/mocks/WithdrawalModuleLibMock.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/WithdrawalModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../../contracts/interfaces/modules/IWithdrawalModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/StakeModule.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/structs/utils.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../../../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\ncontract $WithdrawalModuleLibMock is WithdrawalModuleLibMock {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__WithdrawalModule_init(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__WithdrawalModule_init_unchained(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init_unchained(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/helpers/test/nonERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/helpers/test/nonERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract $nonERC1155Receiver is nonERC1155Receiver {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(uint256 id_, address gETH_) nonERC1155Receiver(id_, gETH_) payable {\n    }\n\n    function $_burn(address account,uint256 amount) external {\n        super._burn(account,amount);\n    }\n\n    function $_transfer(address sender,address recipient,uint256 amount) external {\n        super._transfer(sender,recipient,amount);\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/middlewares/ERC20RebaseMiddleware.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/middlewares/ERC20RebaseMiddleware.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../contracts/globals/macros.sol\";\nimport \"../../contracts/interfaces/IgETH.sol\";\nimport \"../../contracts/helpers/BytesLib.sol\";\nimport \"../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $ERC20RebaseMiddleware is ERC20RebaseMiddleware {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__ERC20RebaseMiddleware_init(uint256 id_,address gETH_,string calldata name_,string calldata symbol_) external {\n        super.__ERC20RebaseMiddleware_init(id_,gETH_,name_,symbol_);\n    }\n\n    function $__ERC20RebaseMiddleware_init_unchained(uint256 id_,address gETH_,string calldata name_,string calldata symbol_) external {\n        super.__ERC20RebaseMiddleware_init_unchained(id_,gETH_,name_,symbol_);\n    }\n\n    function $_transfer(address from,address to,uint256 value) external {\n        super._transfer(from,to,value);\n    }\n\n    function $_update(address from,address to,uint256 value) external {\n        super._update(from,to,value);\n    }\n\n    function $_approve(address owner,address spender,uint256 value) external {\n        super._approve(owner,spender,value);\n    }\n\n    function $_approve(address owner,address spender,uint256 value,bool emitEvent) external {\n        super._approve(owner,spender,value,emitEvent);\n    }\n\n    function $_spendAllowance(address owner,address spender,uint256 value) external {\n        super._spendAllowance(owner,spender,value);\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/middlewares/ERC20RebasePermitMiddleware.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/middlewares/ERC20RebasePermitMiddleware.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"../../contracts/middlewares/ERC20RebaseMiddleware.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport \"../../contracts/globals/macros.sol\";\nimport \"../../contracts/interfaces/IgETH.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $ERC20RebasePermitMiddleware is ERC20RebasePermitMiddleware {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    event return$_useNonce(uint256 ret0);\n\n    constructor() payable {\n    }\n\n    function $__ERC20RebasePermitMiddleware_init(uint256 id_,address gETH_,string calldata name_,string calldata symbol_) external {\n        super.__ERC20RebasePermitMiddleware_init(id_,gETH_,name_,symbol_);\n    }\n\n    function $__ERC20RebasePermitMiddleware_init_unchained() external {\n        super.__ERC20RebasePermitMiddleware_init_unchained();\n    }\n\n    function $__Nonces_init() external {\n        super.__Nonces_init();\n    }\n\n    function $__Nonces_init_unchained() external {\n        super.__Nonces_init_unchained();\n    }\n\n    function $_useNonce(address owner) external returns (uint256 ret0) {\n        (ret0) = super._useNonce(owner);\n        emit return$_useNonce(ret0);\n    }\n\n    function $_useCheckedNonce(address owner,uint256 nonce) external {\n        super._useCheckedNonce(owner,nonce);\n    }\n\n    function $__EIP712_init(string calldata name,string calldata version) external {\n        super.__EIP712_init(name,version);\n    }\n\n    function $__EIP712_init_unchained(string calldata name,string calldata version) external {\n        super.__EIP712_init_unchained(name,version);\n    }\n\n    function $_domainSeparatorV4() external view returns (bytes32 ret0) {\n        (ret0) = super._domainSeparatorV4();\n    }\n\n    function $_hashTypedDataV4(bytes32 structHash) external view returns (bytes32 ret0) {\n        (ret0) = super._hashTypedDataV4(structHash);\n    }\n\n    function $_EIP712Name() external view returns (string memory ret0) {\n        (ret0) = super._EIP712Name();\n    }\n\n    function $_EIP712Version() external view returns (string memory ret0) {\n        (ret0) = super._EIP712Version();\n    }\n\n    function $_EIP712NameHash() external view returns (bytes32 ret0) {\n        (ret0) = super._EIP712NameHash();\n    }\n\n    function $_EIP712VersionHash() external view returns (bytes32 ret0) {\n        (ret0) = super._EIP712VersionHash();\n    }\n\n    function $__ERC20RebaseMiddleware_init(uint256 id_,address gETH_,string calldata name_,string calldata symbol_) external {\n        super.__ERC20RebaseMiddleware_init(id_,gETH_,name_,symbol_);\n    }\n\n    function $__ERC20RebaseMiddleware_init_unchained(uint256 id_,address gETH_,string calldata name_,string calldata symbol_) external {\n        super.__ERC20RebaseMiddleware_init_unchained(id_,gETH_,name_,symbol_);\n    }\n\n    function $_transfer(address from,address to,uint256 value) external {\n        super._transfer(from,to,value);\n    }\n\n    function $_update(address from,address to,uint256 value) external {\n        super._update(from,to,value);\n    }\n\n    function $_approve(address owner,address spender,uint256 value) external {\n        super._approve(owner,spender,value);\n    }\n\n    function $_approve(address owner,address spender,uint256 value,bool emitEvent) external {\n        super._approve(owner,spender,value,emitEvent);\n    }\n\n    function $_spendAllowance(address owner,address spender,uint256 value) external {\n        super._spendAllowance(owner,spender,value);\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/DataStoreModule/DataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $DataStoreModule is DataStoreModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/DataStoreModule/libs/DataStoreModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\n\ncontract $DataStoreModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    constructor() payable {\n    }\n\n    function $generateId(bytes calldata _name,uint256 _type) external pure returns (uint256 id) {\n        (id) = DataStoreModuleLib.generateId(_name,_type);\n    }\n\n    function $getKey(uint256 id,bytes32 param) external pure returns (bytes32 key) {\n        (key) = DataStoreModuleLib.getKey(id,param);\n    }\n\n    function $readUint(uint256 self,uint256 _id,bytes32 _key) external view returns (uint256 data) {\n        (data) = DataStoreModuleLib.readUint($v_DataStoreModuleStorage[self],_id,_key);\n    }\n\n    function $readBytes(uint256 self,uint256 _id,bytes32 _key) external view returns (bytes memory data) {\n        (data) = DataStoreModuleLib.readBytes($v_DataStoreModuleStorage[self],_id,_key);\n    }\n\n    function $readAddress(uint256 self,uint256 _id,bytes32 _key) external view returns (address data) {\n        (data) = DataStoreModuleLib.readAddress($v_DataStoreModuleStorage[self],_id,_key);\n    }\n\n    function $readUintArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (uint256 data) {\n        (data) = DataStoreModuleLib.readUintArray($v_DataStoreModuleStorage[self],_id,_key,_index);\n    }\n\n    function $readBytesArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (bytes memory data) {\n        (data) = DataStoreModuleLib.readBytesArray($v_DataStoreModuleStorage[self],_id,_key,_index);\n    }\n\n    function $readAddressArray(uint256 self,uint256 _id,bytes32 _key,uint256 _index) external view returns (address data) {\n        (data) = DataStoreModuleLib.readAddressArray($v_DataStoreModuleStorage[self],_id,_key,_index);\n    }\n\n    function $writeUint(uint256 self,uint256 _id,bytes32 _key,uint256 _data) external payable {\n        DataStoreModuleLib.writeUint($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $addUint(uint256 self,uint256 _id,bytes32 _key,uint256 _addend) external payable {\n        DataStoreModuleLib.addUint($v_DataStoreModuleStorage[self],_id,_key,_addend);\n    }\n\n    function $subUint(uint256 self,uint256 _id,bytes32 _key,uint256 _minuend) external payable {\n        DataStoreModuleLib.subUint($v_DataStoreModuleStorage[self],_id,_key,_minuend);\n    }\n\n    function $writeBytes(uint256 self,uint256 _id,bytes32 _key,bytes calldata _data) external payable {\n        DataStoreModuleLib.writeBytes($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $writeAddress(uint256 self,uint256 _id,bytes32 _key,address _data) external payable {\n        DataStoreModuleLib.writeAddress($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendUintArray(uint256 self,uint256 _id,bytes32 _key,uint256 _data) external payable {\n        DataStoreModuleLib.appendUintArray($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendBytesArray(uint256 self,uint256 _id,bytes32 _key,bytes calldata _data) external payable {\n        DataStoreModuleLib.appendBytesArray($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendAddressArray(uint256 self,uint256 _id,bytes32 _key,address _data) external payable {\n        DataStoreModuleLib.appendAddressArray($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendUintArrayBatch(uint256 self,uint256 _id,bytes32 _key,uint256[] calldata _data) external payable {\n        DataStoreModuleLib.appendUintArrayBatch($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendBytesArrayBatch(uint256 self,uint256 _id,bytes32 _key,bytes[] calldata _data) external payable {\n        DataStoreModuleLib.appendBytesArrayBatch($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    function $appendAddressArrayBatch(uint256 self,uint256 _id,bytes32 _key,address[] calldata _data) external payable {\n        DataStoreModuleLib.appendAddressArrayBatch($v_DataStoreModuleStorage[self],_id,_key,_data);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/GeodeModule/GeodeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../contracts/globals/id_type.sol\";\nimport \"../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../../contracts/globals/reserved_key_space.sol\";\n\nabstract contract $GeodeModule is GeodeModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/GeodeModule/libs/GeodeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract $GeodeModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => GeodeModuleStorage) internal $v_GeodeModuleStorage;\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    event return$propose(uint256 id);\n\n    event return$approveProposal(address _controller, uint256 _type, bytes _name);\n\n    constructor() payable {\n    }\n\n    function $MIN_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLib.MIN_PROPOSAL_DURATION;\n    }\n\n    function $MAX_PROPOSAL_DURATION() external pure returns (uint32) {\n        return GeodeModuleLib.MAX_PROPOSAL_DURATION;\n    }\n\n    function $MAX_SENATE_PERIOD() external pure returns (uint32) {\n        return GeodeModuleLib.MAX_SENATE_PERIOD;\n    }\n\n    function $isUpgradeAllowed(uint256 self,address proposedImplementation,address currentImplementation) external view returns (bool ret0) {\n        (ret0) = GeodeModuleLib.isUpgradeAllowed($v_GeodeModuleStorage[self],proposedImplementation,currentImplementation);\n    }\n\n    function $getProposal(uint256 self,uint256 id) external view returns (Proposal memory ret0) {\n        (ret0) = GeodeModuleLib.getProposal($v_GeodeModuleStorage[self],id);\n    }\n\n    function $_setSenate(uint256 self,address _newSenate,uint256 _expiry) external payable {\n        GeodeModuleLib._setSenate($v_GeodeModuleStorage[self],_newSenate,_expiry);\n    }\n\n    function $propose(uint256 self,uint256 DATASTORE,address _CONTROLLER,uint256 _TYPE,bytes calldata _NAME,uint256 duration) external payable returns (uint256 id) {\n        (id) = GeodeModuleLib.propose($v_GeodeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_CONTROLLER,_TYPE,_NAME,duration);\n        emit return$propose(id);\n    }\n\n    function $rescueSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLib.rescueSenate($v_GeodeModuleStorage[self],_newSenate);\n    }\n\n    function $approveProposal(uint256 self,uint256 DATASTORE,uint256 id) external payable returns (address _controller, uint256 _type, bytes memory _name) {\n        (_controller, _type, _name) = GeodeModuleLib.approveProposal($v_GeodeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],id);\n        emit return$approveProposal(_controller, _type, _name);\n    }\n\n    function $changeSenate(uint256 self,address _newSenate) external payable {\n        GeodeModuleLib.changeSenate($v_GeodeModuleStorage[self],_newSenate);\n    }\n\n    function $changeIdCONTROLLER(uint256 DATASTORE,uint256 id,address newCONTROLLER) external payable {\n        GeodeModuleLib.changeIdCONTROLLER($v_DataStoreModuleStorage[DATASTORE],id,newCONTROLLER);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/LiquidityModule/libs/AmplificationLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/helpers/ILPToken.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/helpers.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $AmplificationLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => LiquidityModuleStorage) internal $v_LiquidityModuleStorage;\n\n    constructor() payable {\n    }\n\n    function $A_PRECISION() external pure returns (uint256) {\n        return AmplificationLib.A_PRECISION;\n    }\n\n    function $MAX_A() external pure returns (uint256) {\n        return AmplificationLib.MAX_A;\n    }\n\n    function $MAX_A_CHANGE() external pure returns (uint256) {\n        return AmplificationLib.MAX_A_CHANGE;\n    }\n\n    function $MIN_RAMP_TIME() external pure returns (uint256) {\n        return AmplificationLib.MIN_RAMP_TIME;\n    }\n\n    function $getA(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = AmplificationLib.getA($v_LiquidityModuleStorage[self]);\n    }\n\n    function $getAPrecise(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = AmplificationLib.getAPrecise($v_LiquidityModuleStorage[self]);\n    }\n\n    function $_getAPrecise(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = AmplificationLib._getAPrecise($v_LiquidityModuleStorage[self]);\n    }\n\n    function $rampA(uint256 self,uint256 futureA_,uint256 futureTime_) external payable {\n        AmplificationLib.rampA($v_LiquidityModuleStorage[self],futureA_,futureTime_);\n    }\n\n    function $stopRampA(uint256 self) external payable {\n        AmplificationLib.stopRampA($v_LiquidityModuleStorage[self]);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/LiquidityModule/libs/LiquidityModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/helpers/ILPToken.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/structs/helpers.sol\";\nimport \"../../../../contracts/modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $LiquidityModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => LiquidityModuleStorage) internal $v_LiquidityModuleStorage;\n\n    event return$swap(uint256 ret0);\n\n    event return$addLiquidity(uint256 ret0);\n\n    event return$removeLiquidity(uint256[2] ret0);\n\n    event return$removeLiquidityOneToken(uint256 ret0);\n\n    event return$removeLiquidityImbalance(uint256 ret0);\n\n    constructor() payable {\n    }\n\n    function $MAX_SWAP_FEE() external pure returns (uint256) {\n        return LiquidityModuleLib.MAX_SWAP_FEE;\n    }\n\n    function $MAX_ADMIN_FEE() external pure returns (uint256) {\n        return LiquidityModuleLib.MAX_ADMIN_FEE;\n    }\n\n    function $MAX_LOOP_LIMIT() external pure returns (uint256) {\n        return LiquidityModuleLib.MAX_LOOP_LIMIT;\n    }\n\n    function $within1(uint256 a,uint256 b) external pure returns (bool ret0) {\n        (ret0) = LiquidityModuleLib.within1(a,b);\n    }\n\n    function $difference(uint256 a,uint256 b) external pure returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.difference(a,b);\n    }\n\n    function $getYD(uint256 a,uint8 tokenIndex,uint256[2] calldata xp,uint256 d) external pure returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getYD(a,tokenIndex,xp,d);\n    }\n\n    function $getD(uint256[2] calldata xp,uint256 a) external pure returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getD(xp,a);\n    }\n\n    function $getY(uint256 preciseA,uint8 tokenIndexFrom,uint8 tokenIndexTo,uint256 x,uint256[2] calldata xp) external pure returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getY(preciseA,tokenIndexFrom,tokenIndexTo,x,xp);\n    }\n\n    function $_pricedIn(uint256 self,uint256 balance,uint256 i) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib._pricedIn($v_LiquidityModuleStorage[self],balance,i);\n    }\n\n    function $_pricedOut(uint256 self,uint256 balance,uint256 i) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib._pricedOut($v_LiquidityModuleStorage[self],balance,i);\n    }\n\n    function $_pricedInBatch(uint256 self,uint256[2] calldata balances) external view returns (uint256[2] memory _p) {\n        (_p) = LiquidityModuleLib._pricedInBatch($v_LiquidityModuleStorage[self],balances);\n    }\n\n    function $_pricedOutBatch(uint256 self,uint256[2] calldata balances) external view returns (uint256[2] memory _p) {\n        (_p) = LiquidityModuleLib._pricedOutBatch($v_LiquidityModuleStorage[self],balances);\n    }\n\n    function $_getDebt(uint256 self,uint256[2] calldata xp,uint256 a) external view returns (uint256 debt) {\n        (debt) = LiquidityModuleLib._getDebt($v_LiquidityModuleStorage[self],xp,a);\n    }\n\n    function $getDebt(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getDebt($v_LiquidityModuleStorage[self]);\n    }\n\n    function $_calculateRemoveLiquidity(uint256[2] calldata balances,uint256 amount,uint256 totalSupply) external pure returns (uint256[2] memory amounts) {\n        (amounts) = LiquidityModuleLib._calculateRemoveLiquidity(balances,amount,totalSupply);\n    }\n\n    function $_calculateWithdrawOneToken(uint256 self,uint256 tokenAmount,uint8 tokenIndex,uint256 totalSupply) external view returns (uint256 ret0, uint256 ret1) {\n        (ret0, ret1) = LiquidityModuleLib._calculateWithdrawOneToken($v_LiquidityModuleStorage[self],tokenAmount,tokenIndex,totalSupply);\n    }\n\n    function $_calculateSwap(uint256 self,uint8 tokenIndexFrom,uint8 tokenIndexTo,uint256 dx,uint256[2] calldata balances) external view returns (uint256 dy, uint256 dyFee) {\n        (dy, dyFee) = LiquidityModuleLib._calculateSwap($v_LiquidityModuleStorage[self],tokenIndexFrom,tokenIndexTo,dx,balances);\n    }\n\n    function $calculateWithdrawOneToken(uint256 self,uint256 tokenAmount,uint8 tokenIndex) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.calculateWithdrawOneToken($v_LiquidityModuleStorage[self],tokenAmount,tokenIndex);\n    }\n\n    function $calculateWithdrawOneTokenDY(uint256 self,uint8 tokenIndex,uint256 tokenAmount,uint256 totalSupply) external view returns (uint256 ret0, uint256 ret1, uint256 ret2) {\n        (ret0, ret1, ret2) = LiquidityModuleLib.calculateWithdrawOneTokenDY($v_LiquidityModuleStorage[self],tokenIndex,tokenAmount,totalSupply);\n    }\n\n    function $getVirtualPrice(uint256 self) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getVirtualPrice($v_LiquidityModuleStorage[self]);\n    }\n\n    function $calculateSwap(uint256 self,uint8 tokenIndexFrom,uint8 tokenIndexTo,uint256 dx) external view returns (uint256 dy) {\n        (dy) = LiquidityModuleLib.calculateSwap($v_LiquidityModuleStorage[self],tokenIndexFrom,tokenIndexTo,dx);\n    }\n\n    function $calculateRemoveLiquidity(uint256 self,uint256 amount) external view returns (uint256[2] memory ret0) {\n        (ret0) = LiquidityModuleLib.calculateRemoveLiquidity($v_LiquidityModuleStorage[self],amount);\n    }\n\n    function $calculateTokenAmount(uint256 self,uint256[2] calldata amounts,bool deposit) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.calculateTokenAmount($v_LiquidityModuleStorage[self],amounts,deposit);\n    }\n\n    function $getAdminBalance(uint256 self,uint256 index) external view returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.getAdminBalance($v_LiquidityModuleStorage[self],index);\n    }\n\n    function $swap(uint256 self,uint8 tokenIndexFrom,uint8 tokenIndexTo,uint256 dx,uint256 minDy) external payable returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.swap($v_LiquidityModuleStorage[self],tokenIndexFrom,tokenIndexTo,dx,minDy);\n        emit return$swap(ret0);\n    }\n\n    function $addLiquidity(uint256 self,uint256[2] calldata amounts,uint256 minToMint) external payable returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.addLiquidity($v_LiquidityModuleStorage[self],amounts,minToMint);\n        emit return$addLiquidity(ret0);\n    }\n\n    function $removeLiquidity(uint256 self,uint256 amount,uint256[2] calldata minAmounts) external payable returns (uint256[2] memory ret0) {\n        (ret0) = LiquidityModuleLib.removeLiquidity($v_LiquidityModuleStorage[self],amount,minAmounts);\n        emit return$removeLiquidity(ret0);\n    }\n\n    function $removeLiquidityOneToken(uint256 self,uint256 tokenAmount,uint8 tokenIndex,uint256 minAmount) external payable returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.removeLiquidityOneToken($v_LiquidityModuleStorage[self],tokenAmount,tokenIndex,minAmount);\n        emit return$removeLiquidityOneToken(ret0);\n    }\n\n    function $removeLiquidityImbalance(uint256 self,uint256[2] calldata amounts,uint256 maxBurnAmount) external payable returns (uint256 ret0) {\n        (ret0) = LiquidityModuleLib.removeLiquidityImbalance($v_LiquidityModuleStorage[self],amounts,maxBurnAmount);\n        emit return$removeLiquidityImbalance(ret0);\n    }\n\n    function $withdrawAdminFees(uint256 self,address receiver) external payable {\n        LiquidityModuleLib.withdrawAdminFees($v_LiquidityModuleStorage[self],receiver);\n    }\n\n    function $setAdminFee(uint256 self,uint256 newAdminFee) external payable {\n        LiquidityModuleLib.setAdminFee($v_LiquidityModuleStorage[self],newAdminFee);\n    }\n\n    function $setSwapFee(uint256 self,uint256 newSwapFee) external payable {\n        LiquidityModuleLib.setSwapFee($v_LiquidityModuleStorage[self],newSwapFee);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/LiquidityModule/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/modules/LiquidityModule/LiquidityModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../contracts/interfaces/helpers/ILPToken.sol\";\nimport \"../../../contracts/modules/LiquidityModule/structs/storage.sol\";\nimport \"../../../contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport \"../../../contracts/modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport \"../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../contracts/globals/macros.sol\";\nimport \"../../../contracts/modules/LiquidityModule/structs/helpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\nabstract contract $LiquidityModule is LiquidityModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $_getLiquidityModuleStorage() external pure returns (LiquidityModuleStorage memory $) {\n        ($) = super._getLiquidityModuleStorage();\n    }\n\n    function $__LiquidityModule_init(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__LiquidityModule_init_unchained(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init_unchained(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/StakeModule/libs/DepositContractLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\n\ncontract $DepositContractLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $DEPOSIT_CONTRACT() external pure returns (IDepositContract) {\n        return DepositContractLib.DEPOSIT_CONTRACT;\n    }\n\n    function $PUBKEY_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.PUBKEY_LENGTH;\n    }\n\n    function $SIGNATURE_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.SIGNATURE_LENGTH;\n    }\n\n    function $WITHDRAWAL_CREDENTIALS_LENGTH() external pure returns (uint256) {\n        return DepositContractLib.WITHDRAWAL_CREDENTIALS_LENGTH;\n    }\n\n    function $DEPOSIT_AMOUNT() external pure returns (uint256) {\n        return DepositContractLib.DEPOSIT_AMOUNT;\n    }\n\n    function $DEPOSIT_AMOUNT_PRESTAKE() external pure returns (uint256) {\n        return DepositContractLib.DEPOSIT_AMOUNT_PRESTAKE;\n    }\n\n    function $MAX_DEPOSITS_PER_CALL() external pure returns (uint256) {\n        return DepositContractLib.MAX_DEPOSITS_PER_CALL;\n    }\n\n    function $_pad64(bytes calldata _b) external pure returns (bytes memory ret0) {\n        (ret0) = DepositContractLib._pad64(_b);\n    }\n\n    function $_toLittleEndian64(uint256 _value) external pure returns (uint256 result) {\n        (result) = DepositContractLib._toLittleEndian64(_value);\n    }\n\n    function $_getDepositDataRoot(bytes calldata _pubkey,bytes calldata _withdrawalCredentials,bytes calldata _signature,uint256 _stakeAmount) external pure returns (bytes32 ret0) {\n        (ret0) = DepositContractLib._getDepositDataRoot(_pubkey,_withdrawalCredentials,_signature,_stakeAmount);\n    }\n\n    function $addressToWC(address wcAddress) external pure returns (bytes memory ret0) {\n        (ret0) = DepositContractLib.addressToWC(wcAddress);\n    }\n\n    function $depositValidator(bytes calldata pubkey,bytes calldata withdrawalCredential,bytes calldata signature,uint256 amount) external payable {\n        DepositContractLib.depositValidator(pubkey,withdrawalCredential,signature,amount);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/StakeModule/libs/InitiatorExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $InitiatorExtensionLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => StakeModuleStorage) internal $v_StakeModuleStorage;\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    event return$initiatePool(uint256 poolId);\n\n    event return$_deployGeodePackage(address packageInstance);\n\n    constructor() payable {\n    }\n\n    function $setInitiationDeposit(uint256 self,uint256 initiationDeposit) external payable {\n        InitiatorExtensionLib.setInitiationDeposit($v_StakeModuleStorage[self],initiationDeposit);\n    }\n\n    function $initiateOperator(uint256 DATASTORE,uint256 id,uint256 fee,uint256 validatorPeriod,address maintainer) external payable {\n        InitiatorExtensionLib.initiateOperator($v_DataStoreModuleStorage[DATASTORE],id,fee,validatorPeriod,maintainer);\n    }\n\n    function $initiatePool(uint256 self,uint256 DATASTORE,uint256 fee,uint256 middlewareVersion,address maintainer,bytes calldata name,bytes calldata middleware_data,bool[3] calldata config) external payable returns (uint256 poolId) {\n        (poolId) = InitiatorExtensionLib.initiatePool($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],fee,middlewareVersion,maintainer,name,middleware_data,config);\n        emit return$initiatePool(poolId);\n    }\n\n    function $_setgETHMiddleware(uint256 self,uint256 DATASTORE,uint256 id,address _middleware) external payable {\n        InitiatorExtensionLib._setgETHMiddleware($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],id,_middleware);\n    }\n\n    function $_deploygETHMiddleware(uint256 self,uint256 DATASTORE,uint256 _id,uint256 _versionId,bytes calldata _middleware_data) external payable {\n        InitiatorExtensionLib._deploygETHMiddleware($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_id,_versionId,_middleware_data);\n    }\n\n    function $_deployGeodePackage(uint256 self,uint256 DATASTORE,uint256 _poolId,uint256 _type,bytes calldata _package_data) external payable returns (address packageInstance) {\n        (packageInstance) = InitiatorExtensionLib._deployGeodePackage($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_poolId,_type,_package_data);\n        emit return$_deployGeodePackage(packageInstance);\n    }\n\n    function $_deployWithdrawalContract(uint256 self,uint256 DATASTORE,uint256 _poolId) external payable {\n        InitiatorExtensionLib._deployWithdrawalContract($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_poolId);\n    }\n\n    function $_deployLiquidityPool(uint256 self,uint256 DATASTORE,uint256 poolId) external payable {\n        InitiatorExtensionLib._deployLiquidityPool($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId);\n    }\n\n    function $deployLiquidityPool(uint256 self,uint256 DATASTORE,uint256 poolId) external payable {\n        InitiatorExtensionLib.deployLiquidityPool($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/StakeModule/libs/OracleExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $OracleExtensionLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => StakeModuleStorage) internal $v_StakeModuleStorage;\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    constructor() payable {\n    }\n\n    function $MONOPOLY_RATIO() external pure returns (uint256) {\n        return OracleExtensionLib.MONOPOLY_RATIO;\n    }\n\n    function $MIN_VALIDATOR_COUNT() external pure returns (uint256) {\n        return OracleExtensionLib.MIN_VALIDATOR_COUNT;\n    }\n\n    function $PRISON_SENTENCE() external pure returns (uint256) {\n        return OracleExtensionLib.PRISON_SENTENCE;\n    }\n\n    function $_alienateValidator(uint256 self,uint256 DATASTORE,uint256 verificationIndex,bytes calldata _pk) external payable {\n        OracleExtensionLib._alienateValidator($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],verificationIndex,_pk);\n    }\n\n    function $updateVerificationIndex(uint256 self,uint256 DATASTORE,uint256 validatorVerificationIndex,bytes[] calldata alienatedPubkeys) external payable {\n        OracleExtensionLib.updateVerificationIndex($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],validatorVerificationIndex,alienatedPubkeys);\n    }\n\n    function $_imprison(uint256 DATASTORE,uint256 _operatorId,bytes calldata _proof) external payable {\n        OracleExtensionLib._imprison($v_DataStoreModuleStorage[DATASTORE],_operatorId,_proof);\n    }\n\n    function $blameProposal(uint256 self,uint256 DATASTORE,bytes calldata pk) external payable {\n        OracleExtensionLib.blameProposal($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],pk);\n    }\n\n    function $blameExit(uint256 self,uint256 DATASTORE,bytes calldata pk,uint256 beaconBalance,uint256 withdrawnBalance,bytes32[] calldata balanceProof) external payable {\n        OracleExtensionLib.blameExit($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],pk,beaconBalance,withdrawnBalance,balanceProof);\n    }\n\n    function $regulateOperators(uint256 self,uint256 DATASTORE,uint256[] calldata feeThefts,bytes[] calldata proofs) external payable {\n        OracleExtensionLib.regulateOperators($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],feeThefts,proofs);\n    }\n\n    function $reportBeacon(uint256 self,bytes32 priceMerkleRoot,bytes32 balanceMerkleRoot,uint256 allValidatorsCount) external payable {\n        OracleExtensionLib.reportBeacon($v_StakeModuleStorage[self],priceMerkleRoot,balanceMerkleRoot,allValidatorsCount);\n    }\n\n    function $_sanityCheck(uint256 self,uint256 DATASTORE,uint256 _id,uint256 _newPrice) external view {\n        OracleExtensionLib._sanityCheck($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_id,_newPrice);\n    }\n\n    function $_priceSync(uint256 self,uint256 DATASTORE,uint256 _poolId,uint256 _price,bytes32[] calldata _priceProof) external payable {\n        OracleExtensionLib._priceSync($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_poolId,_price,_priceProof);\n    }\n\n    function $priceSync(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 price,bytes32[] calldata priceProof) external payable {\n        OracleExtensionLib.priceSync($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,price,priceProof);\n    }\n\n    function $priceSyncBatch(uint256 self,uint256 DATASTORE,uint256[] calldata poolIds,uint256[] calldata prices,bytes32[][] calldata priceProofs) external payable {\n        OracleExtensionLib.priceSyncBatch($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolIds,prices,priceProofs);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/StakeModule/libs/StakeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../../contracts/globals/id_type.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $StakeModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => StakeModuleStorage) internal $v_StakeModuleStorage;\n\n    mapping(uint256 => DataStoreModuleStorage) internal $v_DataStoreModuleStorage;\n\n    event return$increaseWalletBalance(bool success);\n\n    event return$decreaseWalletBalance(bool success);\n\n    event return$_approveOperator(uint256 oldAllowance);\n\n    event return$_mintgETH(uint256 mintedgETH);\n\n    event return$_buyback(uint256 remETH, uint256 boughtgETH);\n\n    event return$deposit(uint256 boughtgETH, uint256 mintedgETH);\n\n    event return$requestExit(bool ret0);\n\n    constructor() payable {\n    }\n\n    function $MAX_POOL_INFRASTRUCTURE_FEE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_POOL_INFRASTRUCTURE_FEE;\n    }\n\n    function $MAX_BEACON_DELAY() external pure returns (uint256) {\n        return StakeModuleLib.MAX_BEACON_DELAY;\n    }\n\n    function $MAX_MAINTENANCE_FEE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_MAINTENANCE_FEE;\n    }\n\n    function $MAX_ALLOWANCE() external pure returns (uint256) {\n        return StakeModuleLib.MAX_ALLOWANCE;\n    }\n\n    function $PRICE_EXPIRY() external pure returns (uint256) {\n        return StakeModuleLib.PRICE_EXPIRY;\n    }\n\n    function $IGNORABLE_DEBT() external pure returns (uint256) {\n        return StakeModuleLib.IGNORABLE_DEBT;\n    }\n\n    function $MIN_VALIDATOR_PERIOD() external pure returns (uint256) {\n        return StakeModuleLib.MIN_VALIDATOR_PERIOD;\n    }\n\n    function $MAX_VALIDATOR_PERIOD() external pure returns (uint256) {\n        return StakeModuleLib.MAX_VALIDATOR_PERIOD;\n    }\n\n    function $SWITCH_LATENCY() external pure returns (uint256) {\n        return StakeModuleLib.SWITCH_LATENCY;\n    }\n\n    function $setBeaconDelays(uint256 self,uint256 entry,uint256 exit) external payable {\n        StakeModuleLib.setBeaconDelays($v_StakeModuleStorage[self],entry,exit);\n    }\n\n    function $setInfrastructureFee(uint256 self,uint256 _type,uint256 fee) external payable {\n        StakeModuleLib.setInfrastructureFee($v_StakeModuleStorage[self],_type,fee);\n    }\n\n    function $_authenticate(uint256 DATASTORE,uint256 _id,bool _expectCONTROLLER,bool _expectMaintainer,bool[2] calldata _restrictionMap) external view {\n        StakeModuleLib._authenticate($v_DataStoreModuleStorage[DATASTORE],_id,_expectCONTROLLER,_expectMaintainer,_restrictionMap);\n    }\n\n    function $setPoolVisibility(uint256 DATASTORE,uint256 poolId,bool makePrivate) external payable {\n        StakeModuleLib.setPoolVisibility($v_DataStoreModuleStorage[DATASTORE],poolId,makePrivate);\n    }\n\n    function $setWhitelist(uint256 DATASTORE,uint256 poolId,address whitelist) external payable {\n        StakeModuleLib.setWhitelist($v_DataStoreModuleStorage[DATASTORE],poolId,whitelist);\n    }\n\n    function $isPrivatePool(uint256 DATASTORE,uint256 poolId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isPrivatePool($v_DataStoreModuleStorage[DATASTORE],poolId);\n    }\n\n    function $isWhitelisted(uint256 DATASTORE,uint256 poolId,address staker) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isWhitelisted($v_DataStoreModuleStorage[DATASTORE],poolId,staker);\n    }\n\n    function $setYieldReceiver(uint256 DATASTORE,uint256 poolId,address yieldReceiver) external payable {\n        StakeModuleLib.setYieldReceiver($v_DataStoreModuleStorage[DATASTORE],poolId,yieldReceiver);\n    }\n\n    function $_setMaintainer(uint256 DATASTORE,uint256 _id,address _newMaintainer) external payable {\n        StakeModuleLib._setMaintainer($v_DataStoreModuleStorage[DATASTORE],_id,_newMaintainer);\n    }\n\n    function $changeMaintainer(uint256 DATASTORE,uint256 id,address newMaintainer) external payable {\n        StakeModuleLib.changeMaintainer($v_DataStoreModuleStorage[DATASTORE],id,newMaintainer);\n    }\n\n    function $getMaintenanceFee(uint256 DATASTORE,uint256 id) external view returns (uint256 fee) {\n        (fee) = StakeModuleLib.getMaintenanceFee($v_DataStoreModuleStorage[DATASTORE],id);\n    }\n\n    function $_setMaintenanceFee(uint256 DATASTORE,uint256 _id,uint256 _newFee) external payable {\n        StakeModuleLib._setMaintenanceFee($v_DataStoreModuleStorage[DATASTORE],_id,_newFee);\n    }\n\n    function $switchMaintenanceFee(uint256 DATASTORE,uint256 id,uint256 newFee) external payable {\n        StakeModuleLib.switchMaintenanceFee($v_DataStoreModuleStorage[DATASTORE],id,newFee);\n    }\n\n    function $_increaseWalletBalance(uint256 DATASTORE,uint256 _id,uint256 _value) external payable {\n        StakeModuleLib._increaseWalletBalance($v_DataStoreModuleStorage[DATASTORE],_id,_value);\n    }\n\n    function $_decreaseWalletBalance(uint256 DATASTORE,uint256 _id,uint256 _value) external payable {\n        StakeModuleLib._decreaseWalletBalance($v_DataStoreModuleStorage[DATASTORE],_id,_value);\n    }\n\n    function $increaseWalletBalance(uint256 DATASTORE,uint256 id) external payable returns (bool success) {\n        (success) = StakeModuleLib.increaseWalletBalance($v_DataStoreModuleStorage[DATASTORE],id);\n        emit return$increaseWalletBalance(success);\n    }\n\n    function $decreaseWalletBalance(uint256 DATASTORE,uint256 id,uint256 value) external payable returns (bool success) {\n        (success) = StakeModuleLib.decreaseWalletBalance($v_DataStoreModuleStorage[DATASTORE],id,value);\n        emit return$decreaseWalletBalance(success);\n    }\n\n    function $getValidatorPeriod(uint256 DATASTORE,uint256 id) external view returns (uint256 period) {\n        (period) = StakeModuleLib.getValidatorPeriod($v_DataStoreModuleStorage[DATASTORE],id);\n    }\n\n    function $_setValidatorPeriod(uint256 DATASTORE,uint256 _operatorId,uint256 _newPeriod) external payable {\n        StakeModuleLib._setValidatorPeriod($v_DataStoreModuleStorage[DATASTORE],_operatorId,_newPeriod);\n    }\n\n    function $switchValidatorPeriod(uint256 DATASTORE,uint256 operatorId,uint256 newPeriod) external payable {\n        StakeModuleLib.switchValidatorPeriod($v_DataStoreModuleStorage[DATASTORE],operatorId,newPeriod);\n    }\n\n    function $isPrisoned(uint256 DATASTORE,uint256 operatorId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isPrisoned($v_DataStoreModuleStorage[DATASTORE],operatorId);\n    }\n\n    function $operatorAllowance(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 operatorId) external view returns (uint256 remValidators) {\n        (remValidators) = StakeModuleLib.operatorAllowance($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,operatorId);\n    }\n\n    function $_approveOperator(uint256 DATASTORE,uint256 poolId,uint256 operatorId,uint256 allowance) external payable returns (uint256 oldAllowance) {\n        (oldAllowance) = StakeModuleLib._approveOperator($v_DataStoreModuleStorage[DATASTORE],poolId,operatorId,allowance);\n        emit return$_approveOperator(oldAllowance);\n    }\n\n    function $delegate(uint256 DATASTORE,uint256 poolId,uint256[] calldata operatorIds,uint256[] calldata allowances) external payable {\n        StakeModuleLib.delegate($v_DataStoreModuleStorage[DATASTORE],poolId,operatorIds,allowances);\n    }\n\n    function $setFallbackOperator(uint256 DATASTORE,uint256 poolId,uint256 operatorId,uint256 fallbackThreshold) external payable {\n        StakeModuleLib.setFallbackOperator($v_DataStoreModuleStorage[DATASTORE],poolId,operatorId,fallbackThreshold);\n    }\n\n    function $_isGeodePackageIsolated(address _packageAddress) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib._isGeodePackageIsolated(_packageAddress);\n    }\n\n    function $_getLiquidityPool(uint256 DATASTORE,uint256 _poolId) external view returns (ILiquidityPool ret0) {\n        (ret0) = StakeModuleLib._getLiquidityPool($v_DataStoreModuleStorage[DATASTORE],_poolId);\n    }\n\n    function $isPriceValid(uint256 self,uint256 poolId) external view returns (bool isValid) {\n        (isValid) = StakeModuleLib.isPriceValid($v_StakeModuleStorage[self],poolId);\n    }\n\n    function $isMintingAllowed(uint256 self,uint256 DATASTORE,uint256 poolId) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.isMintingAllowed($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId);\n    }\n\n    function $_mintgETH(uint256 self,uint256 DATASTORE,uint256 _poolId,uint256 _ethAmount) external payable returns (uint256 mintedgETH) {\n        (mintedgETH) = StakeModuleLib._mintgETH($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],_poolId,_ethAmount);\n        emit return$_mintgETH(mintedgETH);\n    }\n\n    function $_buyback(uint256 DATASTORE,uint256 _poolId,uint256 _maxEthToSell,uint256 _deadline) external payable returns (uint256 remETH, uint256 boughtgETH) {\n        (remETH, boughtgETH) = StakeModuleLib._buyback($v_DataStoreModuleStorage[DATASTORE],_poolId,_maxEthToSell,_deadline);\n        emit return$_buyback(remETH, boughtgETH);\n    }\n\n    function $deposit(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 mingETH,uint256 deadline,address receiver) external payable returns (uint256 boughtgETH, uint256 mintedgETH) {\n        (boughtgETH, mintedgETH) = StakeModuleLib.deposit($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,mingETH,deadline,receiver);\n        emit return$deposit(boughtgETH, mintedgETH);\n    }\n\n    function $_canStake(uint256 self,bytes calldata _pubkey,uint256 _verificationIndex) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib._canStake($v_StakeModuleStorage[self],_pubkey,_verificationIndex);\n    }\n\n    function $canStake(uint256 self,bytes calldata pubkey) external view returns (bool ret0) {\n        (ret0) = StakeModuleLib.canStake($v_StakeModuleStorage[self],pubkey);\n    }\n\n    function $proposeStake(uint256 self,uint256 DATASTORE,uint256 poolId,uint256 operatorId,bytes[] calldata pubkeys,bytes[] calldata signatures1,bytes[] calldata signatures31) external payable {\n        StakeModuleLib.proposeStake($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,operatorId,pubkeys,signatures1,signatures31);\n    }\n\n    function $stake(uint256 self,uint256 DATASTORE,uint256 operatorId,bytes[] calldata pubkeys) external payable {\n        StakeModuleLib.stake($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],operatorId,pubkeys);\n    }\n\n    function $requestExit(uint256 self,uint256 DATASTORE,uint256 poolId,bytes calldata pk) external payable returns (bool ret0) {\n        (ret0) = StakeModuleLib.requestExit($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,pk);\n        emit return$requestExit(ret0);\n    }\n\n    function $finalizeExit(uint256 self,uint256 DATASTORE,uint256 poolId,bytes calldata pk) external payable {\n        StakeModuleLib.finalizeExit($v_StakeModuleStorage[self],$v_DataStoreModuleStorage[DATASTORE],poolId,pk);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/StakeModule/StakeModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/modules/StakeModule/StakeModule.sol\";\nimport \"../../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../contracts/globals/macros.sol\";\nimport \"../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../../../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"../../../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../contracts/globals/id_type.sol\";\nimport \"../../../contracts/globals/validator_state.sol\";\nimport \"../../../contracts/globals/reserved_key_space.sol\";\nimport \"../../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../../../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../../../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\nabstract contract $StakeModule is StakeModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../../contracts/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../../../contracts/globals/macros.sol\";\nimport \"../../../../contracts/globals/validator_state.sol\";\nimport \"../../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/structs/utils.sol\";\nimport \"../../../../contracts/modules/WithdrawalModule/structs/storage.sol\";\nimport \"../../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract $WithdrawalModuleLib {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    mapping(uint256 => WithdrawalModuleStorage) internal $v_WithdrawalModuleStorage;\n\n    event return$_requestExit(bool ret0);\n\n    event return$_checkAndRequestExit(uint256 ret0);\n\n    event return$_enqueue(uint256 index);\n\n    event return$enqueue(uint256 index);\n\n    event return$enqueueBatch(uint256[] indexes);\n\n    event return$_dequeue(uint256 claimableETH);\n\n    event return$_distributeFees(uint256 extra);\n\n    constructor() payable {\n    }\n\n    function $MIN_EXIT_THRESHOLD() external pure returns (uint256) {\n        return WithdrawalModuleLib.MIN_EXIT_THRESHOLD;\n    }\n\n    function $MIN_REQUEST_SIZE() external pure returns (uint256) {\n        return WithdrawalModuleLib.MIN_REQUEST_SIZE;\n    }\n\n    function $_getPortal(uint256 self) external view returns (IPortal ret0) {\n        (ret0) = WithdrawalModuleLib._getPortal($v_WithdrawalModuleStorage[self]);\n    }\n\n    function $canFinalizeExit(uint256 self,bytes calldata pubkey) external view returns (bool ret0) {\n        (ret0) = WithdrawalModuleLib.canFinalizeExit($v_WithdrawalModuleStorage[self],pubkey);\n    }\n\n    function $_requestExit(uint256 self,bytes calldata pubkey) external payable returns (bool ret0) {\n        (ret0) = WithdrawalModuleLib._requestExit($v_WithdrawalModuleStorage[self],pubkey);\n        emit return$_requestExit(ret0);\n    }\n\n    function $_finalizeExit(uint256 self,bytes calldata pubkey) external payable {\n        WithdrawalModuleLib._finalizeExit($v_WithdrawalModuleStorage[self],pubkey);\n    }\n\n    function $_checkAndRequestExit(uint256 self,bytes calldata pubkey,uint256 commonPoll) external payable returns (uint256 ret0) {\n        (ret0) = WithdrawalModuleLib._checkAndRequestExit($v_WithdrawalModuleStorage[self],pubkey,commonPoll);\n        emit return$_checkAndRequestExit(ret0);\n    }\n\n    function $setExitThreshold(uint256 self,uint256 newThreshold) external payable {\n        WithdrawalModuleLib.setExitThreshold($v_WithdrawalModuleStorage[self],newThreshold);\n    }\n\n    function $getValidatorThreshold(uint256 self,bytes calldata pubkey) external view returns (uint256 threshold, uint256 beaconBalancePriced) {\n        (threshold, beaconBalancePriced) = WithdrawalModuleLib.getValidatorThreshold($v_WithdrawalModuleStorage[self],pubkey);\n    }\n\n    function $_vote(uint256 self,uint256 index,bytes calldata pubkey,uint256 size) external payable {\n        WithdrawalModuleLib._vote($v_WithdrawalModuleStorage[self],index,pubkey,size);\n    }\n\n    function $_enqueue(uint256 self,uint256 trigger,uint256 size,address owner) external payable returns (uint256 index) {\n        (index) = WithdrawalModuleLib._enqueue($v_WithdrawalModuleStorage[self],trigger,size,owner);\n        emit return$_enqueue(index);\n    }\n\n    function $enqueue(uint256 self,uint256 size,bytes calldata pubkey,address owner) external payable returns (uint256 index) {\n        (index) = WithdrawalModuleLib.enqueue($v_WithdrawalModuleStorage[self],size,pubkey,owner);\n        emit return$enqueue(index);\n    }\n\n    function $enqueueBatch(uint256 self,uint256[] calldata sizes,bytes[] calldata pubkeys,address owner) external payable returns (uint256[] memory indexes) {\n        (indexes) = WithdrawalModuleLib.enqueueBatch($v_WithdrawalModuleStorage[self],sizes,pubkeys,owner);\n        emit return$enqueueBatch(indexes);\n    }\n\n    function $transferRequest(uint256 self,uint256 index,address newOwner) external payable {\n        WithdrawalModuleLib.transferRequest($v_WithdrawalModuleStorage[self],index,newOwner);\n    }\n\n    function $fulfillable(uint256 self,uint256 index,uint256 qRealized,uint256 qFulfilled) external view returns (uint256 ret0) {\n        (ret0) = WithdrawalModuleLib.fulfillable($v_WithdrawalModuleStorage[self],index,qRealized,qFulfilled);\n    }\n\n    function $_fulfill(uint256 self,uint256 index) external payable {\n        WithdrawalModuleLib._fulfill($v_WithdrawalModuleStorage[self],index);\n    }\n\n    function $_fulfillBatch(uint256 self,uint256[] calldata indexes,uint256 qRealized,uint256 qFulfilled,uint256 qPrice) external payable {\n        WithdrawalModuleLib._fulfillBatch($v_WithdrawalModuleStorage[self],indexes,qRealized,qFulfilled,qPrice);\n    }\n\n    function $fulfill(uint256 self,uint256 index) external payable {\n        WithdrawalModuleLib.fulfill($v_WithdrawalModuleStorage[self],index);\n    }\n\n    function $fulfillBatch(uint256 self,uint256[] calldata indexes) external payable {\n        WithdrawalModuleLib.fulfillBatch($v_WithdrawalModuleStorage[self],indexes);\n    }\n\n    function $_dequeue(uint256 self,uint256 index) external payable returns (uint256 claimableETH) {\n        (claimableETH) = WithdrawalModuleLib._dequeue($v_WithdrawalModuleStorage[self],index);\n        emit return$_dequeue(claimableETH);\n    }\n\n    function $dequeue(uint256 self,uint256 index,address receiver) external payable {\n        WithdrawalModuleLib.dequeue($v_WithdrawalModuleStorage[self],index,receiver);\n    }\n\n    function $dequeueBatch(uint256 self,uint256[] calldata indexes,address receiver) external payable {\n        WithdrawalModuleLib.dequeueBatch($v_WithdrawalModuleStorage[self],indexes,receiver);\n    }\n\n    function $_distributeFees(uint256 self,Validator calldata val,uint256 reportedWithdrawn,uint256 processedWithdrawn) external payable returns (uint256 extra) {\n        (extra) = WithdrawalModuleLib._distributeFees($v_WithdrawalModuleStorage[self],val,reportedWithdrawn,processedWithdrawn);\n        emit return$_distributeFees(extra);\n    }\n\n    function $_realizeProcessedEther(uint256 self,uint256 processedBalance) external payable {\n        WithdrawalModuleLib._realizeProcessedEther($v_WithdrawalModuleStorage[self],processedBalance);\n    }\n\n    function $processValidators(uint256 self,bytes[] calldata pubkeys,uint256[] calldata beaconBalances,uint256[] calldata withdrawnBalances,bytes32[][] calldata balanceProofs) external payable {\n        WithdrawalModuleLib.processValidators($v_WithdrawalModuleStorage[self],pubkeys,beaconBalances,withdrawnBalances,balanceProofs);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/modules/WithdrawalModule/WithdrawalModule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../../contracts/modules/WithdrawalModule/WithdrawalModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../../contracts/interfaces/modules/IWithdrawalModule.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../../contracts/interfaces/IgETH.sol\";\nimport \"../../../contracts/interfaces/IPortal.sol\";\nimport \"../../../contracts/modules/WithdrawalModule/structs/storage.sol\";\nimport \"../../../contracts/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\nimport \"../../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../../contracts/modules/WithdrawalModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../../contracts/globals/macros.sol\";\nimport \"../../../contracts/globals/validator_state.sol\";\nimport \"../../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport \"../../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"../../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../../contracts/helpers/BytesLib.sol\";\n\nabstract contract $WithdrawalModule is WithdrawalModule {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__WithdrawalModule_init(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__WithdrawalModule_init_unchained(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init_unchained(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-exposed/packages/LiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/packages/LiquidityPool.sol\";\nimport \"../../contracts/modules/LiquidityModule/LiquidityModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../contracts/globals/id_type.sol\";\nimport \"../../contracts/globals/macros.sol\";\nimport \"../../contracts/globals/reserved_key_space.sol\";\nimport \"../../contracts/interfaces/IPortal.sol\";\nimport \"../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../contracts/modules/LiquidityModule/structs/storage.sol\";\nimport \"../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../contracts/modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport \"../../contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../../contracts/interfaces/IgETH.sol\";\nimport \"../../contracts/interfaces/helpers/ILPToken.sol\";\nimport \"../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../contracts/modules/LiquidityModule/structs/helpers.sol\";\nimport \"../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\ncontract $LiquidityPool is LiquidityPool {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(address _gETHPos, address _portalPos, address _LPTokenRef) LiquidityPool(_gETHPos, _portalPos, _LPTokenRef) payable {\n    }\n\n    function $gETHPos() external view returns (address) {\n        return gETHPos;\n    }\n\n    function $portalPos() external view returns (address) {\n        return portalPos;\n    }\n\n    function $LPTokenRef() external view returns (address) {\n        return LPTokenRef;\n    }\n\n    function $__LiquidityPool_init(uint256 pooledTokenId,address poolOwner,bytes calldata versionName,bytes calldata data) external {\n        super.__LiquidityPool_init(pooledTokenId,poolOwner,versionName,data);\n    }\n\n    function $__LiquidityPool_init_unchained() external {\n        super.__LiquidityPool_init_unchained();\n    }\n\n    function $_getLiquidityModuleStorage() external pure returns (LiquidityModuleStorage memory $) {\n        ($) = super._getLiquidityModuleStorage();\n    }\n\n    function $__LiquidityModule_init(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__LiquidityModule_init_unchained(address _gETH_position,address _lpToken_referance,uint256 _pooledTokenId,uint256 _A,uint256 _swapFee,string calldata _poolName) external {\n        super.__LiquidityModule_init_unchained(_gETH_position,_lpToken_referance,_pooledTokenId,_A,_swapFee,_poolName);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/packages/WithdrawalContract.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/packages/WithdrawalContract.sol\";\nimport \"../../contracts/modules/WithdrawalModule/WithdrawalModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../contracts/interfaces/packages/IWithdrawalContract.sol\";\nimport \"../../contracts/interfaces/modules/IWithdrawalModule.sol\";\nimport \"../../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../../contracts/globals/id_type.sol\";\nimport \"../../contracts/globals/reserved_key_space.sol\";\nimport \"../../contracts/interfaces/IPortal.sol\";\nimport \"../../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../../contracts/modules/WithdrawalModule/structs/storage.sol\";\nimport \"../../contracts/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../contracts/interfaces/IgETH.sol\";\nimport \"../../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"../../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../../contracts/modules/WithdrawalModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../../contracts/globals/macros.sol\";\nimport \"../../contracts/globals/validator_state.sol\";\nimport \"../../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"../../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"../../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\ncontract $WithdrawalContract is WithdrawalContract {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor(address _gETHPos, address _portalPos) WithdrawalContract(_gETHPos, _portalPos) payable {\n    }\n\n    function $gETHPos() external view returns (address) {\n        return gETHPos;\n    }\n\n    function $portalPos() external view returns (address) {\n        return portalPos;\n    }\n\n    function $__WithdrawalContract_init(uint256 poolId,address poolOwner,bytes calldata versionName) external {\n        super.__WithdrawalContract_init(poolId,poolOwner,versionName);\n    }\n\n    function $__WithdrawalContract_init_unchained() external {\n        super.__WithdrawalContract_init_unchained();\n    }\n\n    function $__WithdrawalModule_init(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__WithdrawalModule_init_unchained(address _gETH_position,address _portal_position,uint256 _poolId) external {\n        super.__WithdrawalModule_init_unchained(_gETH_position,_portal_position,_poolId);\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts-exposed/Portal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../contracts/Portal.sol\";\nimport \"../contracts/modules/StakeModule/StakeModule.sol\";\nimport \"../contracts/modules/GeodeModule/GeodeModule.sol\";\nimport \"../contracts/modules/DataStoreModule/DataStoreModule.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../contracts/interfaces/IPortal.sol\";\nimport \"../contracts/interfaces/modules/IStakeModule.sol\";\nimport \"../contracts/interfaces/modules/IGeodeModule.sol\";\nimport \"../contracts/interfaces/modules/IDataStoreModule.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport \"../contracts/globals/id_type.sol\";\nimport \"../contracts/modules/DataStoreModule/structs/storage.sol\";\nimport \"../contracts/modules/GeodeModule/structs/storage.sol\";\nimport \"../contracts/modules/StakeModule/structs/storage.sol\";\nimport \"../contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport \"../contracts/modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport \"../contracts/modules/StakeModule/libs/StakeModuleLib.sol\";\nimport \"../contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport \"../contracts/globals/macros.sol\";\nimport \"../contracts/interfaces/IgETH.sol\";\nimport \"../contracts/modules/StakeModule/structs/utils.sol\";\nimport \"../contracts/modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport \"../contracts/modules/GeodeModule/structs/utils.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../contracts/globals/reserved_key_space.sol\";\nimport \"../contracts/globals/validator_state.sol\";\nimport \"../contracts/interfaces/packages/IGeodePackage.sol\";\nimport \"../contracts/interfaces/packages/ILiquidityPool.sol\";\nimport \"../contracts/interfaces/helpers/IWhitelist.sol\";\nimport \"../contracts/modules/StakeModule/structs/helpers.sol\";\nimport \"../contracts/modules/StakeModule/libs/DepositContractLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"../contracts/interfaces/middlewares/IgETHMiddleware.sol\";\nimport \"../contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"../contracts/interfaces/modules/ILiquidityModule.sol\";\nimport \"../contracts/interfaces/helpers/IDepositContract.sol\";\nimport \"../contracts/helpers/BytesLib.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\ncontract $Portal is Portal {\n    bytes32 public constant __hh_exposed_bytecode_marker = \"hardhat-exposed\";\n\n    constructor() payable {\n    }\n\n    function $__Portal_init(address _governance,address _senate,address _gETH,address _oracle_position,bytes calldata versionName) external {\n        super.__Portal_init(_governance,_senate,_gETH,_oracle_position,versionName);\n    }\n\n    function $__Portal_init_unchained() external {\n        super.__Portal_init_unchained();\n    }\n\n    function $__StakeModule_init(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init(_gETH,_oracle_position);\n    }\n\n    function $__StakeModule_init_unchained(address _gETH,address _oracle_position) external {\n        super.__StakeModule_init_unchained(_gETH,_oracle_position);\n    }\n\n    function $__GeodeModule_init(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $__GeodeModule_init_unchained(address governance,address senate,uint256 senateExpiry,uint256 packageType,bytes calldata initVersionName) external {\n        super.__GeodeModule_init_unchained(governance,senate,senateExpiry,packageType,initVersionName);\n    }\n\n    function $_authorizeUpgrade(address proposed_implementation) external {\n        super._authorizeUpgrade(proposed_implementation);\n    }\n\n    function $_setContractVersion(uint256 id) external {\n        super._setContractVersion(id);\n    }\n\n    function $_handleUpgrade(address proposed_implementation,uint256 id) external {\n        super._handleUpgrade(proposed_implementation,id);\n    }\n\n    function $__DataStoreModule_init() external {\n        super.__DataStoreModule_init();\n    }\n\n    function $__DataStoreModule_init_unchained() external {\n        super.__DataStoreModule_init_unchained();\n    }\n\n    function $__Pausable_init() external {\n        super.__Pausable_init();\n    }\n\n    function $__Pausable_init_unchained() external {\n        super.__Pausable_init_unchained();\n    }\n\n    function $_requireNotPaused() external view {\n        super._requireNotPaused();\n    }\n\n    function $_requirePaused() external view {\n        super._requirePaused();\n    }\n\n    function $_pause() external {\n        super._pause();\n    }\n\n    function $_unpause() external {\n        super._unpause();\n    }\n\n    function $__Context_init() external {\n        super.__Context_init();\n    }\n\n    function $__Context_init_unchained() external {\n        super.__Context_init_unchained();\n    }\n\n    function $_msgSender() external view returns (address ret0) {\n        (ret0) = super._msgSender();\n    }\n\n    function $_msgData() external view returns (bytes memory ret0) {\n        (ret0) = super._msgData();\n    }\n\n    function $__ReentrancyGuard_init() external {\n        super.__ReentrancyGuard_init();\n    }\n\n    function $__ReentrancyGuard_init_unchained() external {\n        super.__ReentrancyGuard_init_unchained();\n    }\n\n    function $_reentrancyGuardEntered() external view returns (bool ret0) {\n        (ret0) = super._reentrancyGuardEntered();\n    }\n\n    function $__ERC1155Holder_init() external {\n        super.__ERC1155Holder_init();\n    }\n\n    function $__ERC1155Holder_init_unchained() external {\n        super.__ERC1155Holder_init_unchained();\n    }\n\n    function $__ERC165_init() external {\n        super.__ERC165_init();\n    }\n\n    function $__ERC165_init_unchained() external {\n        super.__ERC165_init_unchained();\n    }\n\n    function $__UUPSUpgradeable_init() external {\n        super.__UUPSUpgradeable_init();\n    }\n\n    function $__UUPSUpgradeable_init_unchained() external {\n        super.__UUPSUpgradeable_init_unchained();\n    }\n\n    function $_checkProxy() external view {\n        super._checkProxy();\n    }\n\n    function $_checkNotDelegated() external view {\n        super._checkNotDelegated();\n    }\n\n    function $_checkInitializing() external view {\n        super._checkInitializing();\n    }\n\n    function $_disableInitializers() external {\n        super._disableInitializers();\n    }\n\n    function $_getInitializedVersion() external view returns (uint64 ret0) {\n        (ret0) = super._getInitializedVersion();\n    }\n\n    function $_isInitializing() external view returns (bool ret0) {\n        (ret0) = super._isInitializing();\n    }\n}\n"
    },
    "contracts/gETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - interfaces\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n// internal - globals\nimport {gETH_DENOMINATOR} from \"./globals/macros.sol\";\n// internal - interfaces\nimport {IERC1155Burnable} from \"./interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\nimport {IgETH} from \"./interfaces/IgETH.sol\";\n// internal - contracts\nimport {ERC1155, ERC1155Burnable, ERC1155PausableBurnableSupply} from \"./helpers/ERC1155PausableBurnableSupply.sol\";\n\n/**\n * @title gETH : Geodefi Liquid Staking Derivatives\n *\n * @dev gETH is chain-agnostic, meaning it can be used on any evm chain (given the correct name and symbol).\n *\n * @dev gETH is immutable, it cannot be upgraded.\n *\n * @dev gETH is a special ERC1155 contract with additional functionalities:\n * gETHMiddlewares:\n * * Most important functionality gETH provides:\n * * Allowing any other contract to provide additional functionality\n * * around the balance and price data, such as using an ID like ERC20.\n * * This addition effectively result in changes in\n * * safeTransferFrom(), burn(), _doSafeTransferAcceptanceCheck()\n * * functions, reasoning is in the comments.\n * Avoiders:\n * * If one wants to remain unbound from gETHMiddlewares,\n * * it can be done so by calling \"avoidMiddlewares\" function.\n * PricePerShare:\n * * Keeping track of the ratio between the derivative\n * * and the underlaying staked asset, Ether.\n * Denominator:\n * * ERC1155 does not have decimals and it is not wise to use the name convention\n * * but we need to provide some information on how to denominate the balances, price, etc.\n *\n * @dev review ERC1155PausableBurnableSupply, which is generated with Openzeppelin wizard.\n *\n * @author Ice Bear & Crash Bandicoot\n */\ncontract gETH is IgETH, ERC1155PausableBurnableSupply {\n  /**\n   * @custom:section                           ** ERRORS **\n   */\n  error gETHZeroId();\n  error gETHInvalidMiddleware(address middleware);\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n  uint256 private immutable DENOMINATOR = gETH_DENOMINATOR;\n  bytes32 public immutable MIDDLEWARE_MANAGER_ROLE = keccak256(\"MIDDLEWARE_MANAGER_ROLE\");\n  bytes32 public immutable ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   */\n\n  string public name;\n  string public symbol;\n  /**\n   * @notice Mapping from pool IDs to gETHMiddleware implementation addresses\n   * @dev There can be multiple Middlewares for 1 staking pool.\n   * @dev ADDED for gETH\n   **/\n  mapping(uint256 => mapping(address => bool)) private _middlewares;\n\n  /**\n   * @notice Mapping of user addresses who chose to restrict the access of Middlewares\n   * @dev ADDED for gETH\n   **/\n  mapping(address => mapping(uint256 => bool)) private _avoiders;\n\n  /**\n   * @notice shows the underlying ETH for 1 staked gETH for a given asset ID\n   * @dev Freshly created IDs should return 1e18 since initally 1 ETH = 1 gETH\n   * @dev ADDED for gETH\n   **/\n  mapping(uint256 => uint256) private _pricePerShare;\n  /**\n   * @notice ID to timestamp, pointing the second that the latest price update happened\n   * @dev ADDED for gETH\n   **/\n  mapping(uint256 => uint256) private _priceUpdateTimestamp;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event PriceUpdated(uint256 id, uint256 pricePerShare, uint256 updateTimestamp);\n  event MiddlewareSet(uint256 id, address middleware, bool isSet);\n  event Avoider(address avoider, uint256 id, bool isAvoid);\n\n  /**\n   * @custom:section                           ** CONSTRUCTOR **\n   */\n  /**\n   * @notice Sets name, symbol, uri and grants necessary roles.\n   * @param _name chain specific name: Geode Staked Ether, geode Staked Avax etc.\n   * @param _symbol chain specific symbol of the staking derivative: gETH, gGNO, gAVAX, etc.\n   **/\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    string memory _uri\n  ) ERC1155PausableBurnableSupply(_uri) {\n    name = _name;\n    symbol = _symbol;\n\n    _grantRole(keccak256(\"MIDDLEWARE_MANAGER_ROLE\"), _msgSender());\n    _grantRole(keccak256(\"ORACLE_ROLE\"), _msgSender());\n  }\n\n  /**\n   * @custom:section                           ** DENOMINATOR **\n   *\n   * @custom:visibility -> view\n   */\n  /**\n   * @notice a centralized denominator for all contract using gETH\n   * @dev ERC1155 does not have a decimals, and it is not wise to use the same name\n   * @dev ADDED for gETH\n   */\n  function denominator() public view virtual override returns (uint256) {\n    return DENOMINATOR;\n  }\n\n  /**\n   * @custom:section                           ** MIDDLEWARES **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice Check if an address is approved as a middleware for an ID\n   * @dev ADDED for gETH\n   */\n  function isMiddleware(\n    address middleware,\n    uint256 id\n  ) public view virtual override returns (bool) {\n    return _middlewares[id][middleware];\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @dev Only authorized parties should set the middleware\n   * @dev ADDED for gETH\n   */\n  function _setMiddleware(address _middleware, uint256 _id, bool _isSet) internal virtual {\n    _middlewares[_id][_middleware] = _isSet;\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @notice Set an address of a contract that will\n   * act as a middleware on gETH contract for a specific ID\n   * @param middleware Address of the contract that will act as a middleware\n   * @param isSet true: sets as a middleware, false: unsets\n   * @dev ADDED for gETH\n   */\n  function setMiddleware(\n    address middleware,\n    uint256 id,\n    bool isSet\n  ) external virtual override onlyRole(MIDDLEWARE_MANAGER_ROLE) {\n    if (middleware == address(0) || middleware.code.length == 0) {\n      revert gETHInvalidMiddleware(middleware);\n    }\n\n    _setMiddleware(middleware, id, isSet);\n\n    emit MiddlewareSet(id, middleware, isSet);\n  }\n\n  /**\n   * @custom:section                           ** AVOIDERS **\n   */\n  /**\n   * @custom:visibility -> view-public\n   */\n  /**\n   * @notice Checks if the given address restricts the affect of the middlewares on their gETH\n   * @param account the potential avoider\n   * @dev ADDED for gETH\n   **/\n  function isAvoider(address account, uint256 id) public view virtual override returns (bool) {\n    return _avoiders[account][id];\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @notice Restrict any affect of middlewares on the tokens of caller\n   * @param isAvoid true: restrict middlewares, false: allow middlewares\n   * @dev ADDED for gETH\n   **/\n  function avoidMiddlewares(uint256 id, bool isAvoid) external virtual override {\n    address account = _msgSender();\n\n    _avoiders[account][id] = isAvoid;\n\n    emit Avoider(account, id, isAvoid);\n  }\n\n  /**\n   * @custom:section                           ** PRICE **\n   */\n\n  /**\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @dev ADDED for gETH\n   * @return price of the derivative in terms of underlying token, Ether\n   */\n  function pricePerShare(uint256 id) external view virtual override returns (uint256) {\n    return _pricePerShare[id];\n  }\n\n  /**\n   * @dev ADDED for gETH\n   * @return timestamp of the latest price update for given ID\n   */\n  function priceUpdateTimestamp(uint256 id) external view virtual override returns (uint256) {\n    return _priceUpdateTimestamp[id];\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @dev ADDED for gETH\n   */\n  function _setPricePerShare(uint256 _price, uint256 _id) internal virtual {\n    _pricePerShare[_id] = _price;\n    _priceUpdateTimestamp[_id] = block.timestamp;\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Only ORACLE can call this function and set price\n   * @dev ADDED for gETH\n   */\n  function setPricePerShare(\n    uint256 price,\n    uint256 id\n  ) external virtual override onlyRole(ORACLE_ROLE) {\n    if (id == 0) {\n      revert gETHZeroId();\n    }\n\n    _setPricePerShare(price, id);\n\n    emit PriceUpdated(id, price, block.timestamp);\n  }\n\n  /**\n   * @custom:section                           ** ROLES **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice transfers the authorized party for setting a new uri.\n   * @dev URI_SETTER is basically a superuser, there can be only 1 at a given time,\n   * @dev intended as \"Governance/DAO\"\n   */\n  function transferUriSetterRole(\n    address newUriSetter\n  ) external virtual override onlyRole(URI_SETTER_ROLE) {\n    _grantRole(URI_SETTER_ROLE, newUriSetter);\n    renounceRole(URI_SETTER_ROLE, _msgSender());\n  }\n\n  /**\n   * @notice transfers the authorized party for Pausing operations.\n   * @dev PAUSER is basically a superUser, there can be only 1 at a given time,\n   * @dev intended as \"Portal\"\n   */\n  function transferPauserRole(address newPauser) external virtual override onlyRole(PAUSER_ROLE) {\n    _grantRole(PAUSER_ROLE, newPauser);\n    renounceRole(PAUSER_ROLE, _msgSender());\n  }\n\n  /**\n   * @notice transfers the authorized party for Minting operations related to minting\n   * @dev MINTER is basically a superUser, there can be only 1 at a given time,\n   * @dev intended as \"Portal\"\n   */\n  function transferMinterRole(address newMinter) external virtual override onlyRole(MINTER_ROLE) {\n    _grantRole(MINTER_ROLE, newMinter);\n    renounceRole(MINTER_ROLE, _msgSender());\n  }\n\n  /**\n   * @notice transfers the authorized party for Oracle operations related to pricing\n   * @dev ORACLE is basically a superUser, there can be only 1 at a given time,\n   * @dev intended as \"Portal\"\n   */\n  function transferOracleRole(address newOracle) external virtual override onlyRole(ORACLE_ROLE) {\n    _grantRole(ORACLE_ROLE, newOracle);\n    renounceRole(ORACLE_ROLE, _msgSender());\n  }\n\n  /**\n   * @notice transfers the authorized party for middleware management\n   * @dev MIDDLEWARE MANAGER is basically a superUser, there can be only 1 at a given time,\n   * @dev intended as \"Portal\"\n   */\n  function transferMiddlewareManagerRole(\n    address newMiddlewareManager\n  ) external virtual override onlyRole(MIDDLEWARE_MANAGER_ROLE) {\n    _grantRole(MIDDLEWARE_MANAGER_ROLE, newMiddlewareManager);\n    renounceRole(MIDDLEWARE_MANAGER_ROLE, _msgSender());\n  }\n\n  /**\n   * @custom:section                           ** OVERRIDES **\n   *\n   * @dev middleware of a specific ID can move funds between accounts without approval.\n   * So, we will be overriding 2 functions:\n   * * safeTransferFrom\n   * * burn\n   * note safeBatchTransferFrom is not need to be overriden,\n   * as a middleware should not do batch transfers.\n   *\n   * @dev middlewares should handle transfer checks internally.\n   * Because of this we want to remove the SafeTransferAcceptanceCheck if the caller is a middleware.\n   * However, overriding _doSafeTransferAcceptanceCheck was not possible, so we copy pasted OZ contracts and\n   * made it internal virtual.\n   * note _doSafeBatchTransferAcceptanceCheck is not need to be overriden,\n   * as a middleware should not do batch transfers.\n   */\n\n  /**\n   * @dev CHANGED for gETH\n   * @dev ADDED if (!isMiddleware) check\n   * @dev See ERC1155 _doSafeTransferAcceptanceCheck:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cffb2f1ddcd87efd68effc92cfd336c5145acabd/contracts/token/ERC1155/ERC1155.sol#L381\n   */\n  function _doSafeTransferAcceptanceCheck(\n    address operator,\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) internal virtual override {\n    if (!(isMiddleware(operator, id))) {\n      super._doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n  }\n\n  /**\n   * @dev CHANGED for gETH\n   * @dev ADDED \"((!isMiddleware(sender, id)) || isAvoider(from, id))\" pass condition\n   * @dev See ERC1155 safeTransferFrom:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cffb2f1ddcd87efd68effc92cfd336c5145acabd/contracts/token/ERC1155/ERC1155.sol#L109C29-L109C29\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n  ) public virtual override(ERC1155, IERC1155) {\n    address sender = _msgSender();\n\n    if (from != sender && !isApprovedForAll(from, sender)) {\n      if ((!isMiddleware(sender, id)) || isAvoider(from, id)) {\n        revert ERC1155MissingApprovalForAll(sender, from);\n      }\n    }\n\n    _safeTransferFrom(from, to, id, value, data);\n  }\n\n  /**\n   * @dev CHANGED for gETH\n   * @dev ADDED \"((!(isMiddleware(sender, id))) || (isAvoider(account, id)))\" pass condition\n   * @dev See ERC1155Burnable burn:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cffb2f1ddcd87efd68effc92cfd336c5145acabd/contracts/token/ERC1155/extensions/ERC1155Burnable.sol#L13C1-L19C6\n   */\n  function burn(\n    address account,\n    uint256 id,\n    uint256 value\n  ) public virtual override(ERC1155Burnable, IERC1155Burnable) {\n    address sender = _msgSender();\n\n    if (account != sender && !isApprovedForAll(account, sender)) {\n      if ((!isMiddleware(sender, id)) || isAvoider(account, id)) {\n        revert ERC1155MissingApprovalForAll(sender, account);\n      }\n    }\n\n    _burn(account, id, value);\n  }\n}\n"
    },
    "contracts/globals/id_type.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice ID_TYPE is an internal library that acts like an ENUM.\n *\n * @dev Used within the limited upgradability pattern:\n *\n * NONE & GAP: should not be used.\n *\n * Dual Governance:\n * * SENATE: points to a proposal that will update the current SENATE address of a package(or Portal).\n * * CONTRACT UPGRADE: proposal to change the given contract's implementation. TYPE should be package's TYPE.\n *\n * Users:\n * * OPERATOR: permissionned Node Operators (hosted on Portal).\n * * POOL: permissionless staking pools (hosted on Portal).\n *\n * Packages: (hosted on StakeModuleLib)\n * * An ID can only point to 1(one) Package version' implementation address at a given point.\n * * Can be upgraded by a dual governance, via pullUpgrade.\n * * * Portal's dual governance consists of a Governance Token(governance) and a Senate(senate).\n * * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\n * * Built by utilizing the Modules.\n * * LiquidityPool and WithdrawalContract are some examples.\n *\n * Middlewares: (hosted on StakeModuleLib)\n * * An ID can point to multiple Middleware version' implementation address at the same time.\n * * Cannot be upgraded.\n * * Do not have any guides to build really.\n * * Currently only gETHMiddlewares\n *\n *  Limits:\n *  * We simply set limits to separate a group of types from others. Like Packages and Middlewares.\n *\n * @dev all LIMIT parameters are exclusive, prevents double usage.\n */\nlibrary ID_TYPE {\n  /// @notice TYPE 0: *invalid*\n  uint256 internal constant NONE = 0;\n\n  /// @notice TYPE 1: Senate\n  uint256 internal constant SENATE = 1;\n\n  /// --\n\n  /// @notice TYPE 3: Limit: exclusive, minimum TYPE that will be percieved as a user\n  uint256 internal constant LIMIT_MIN_USER = 3;\n\n  /// @notice TYPE 4: USER: Permissionned Node Operator\n  uint256 internal constant OPERATOR = 4;\n\n  /// @notice TYPE 5: USER: Staking Pool\n  uint256 internal constant POOL = 5;\n\n  /// @notice TYPE 9999: Limit: exclusive, maximum TYPE that will be percieved as a user\n  uint256 internal constant LIMIT_MAX_USER = 9999;\n\n  /// --\n\n  /// @notice TYPE 10000: Limit: exclusive, minimum TYPE that will be percieved as a package\n  uint256 internal constant LIMIT_MIN_PACKAGE = 10000;\n\n  /// @notice TYPE 10001: Package: Portal is also a package\n  uint256 internal constant PACKAGE_PORTAL = 10001;\n\n  /// @notice TYPE 10011: Package: The Withdrawal Credential Contract\n  uint256 internal constant PACKAGE_WITHDRAWAL_CONTRACT = 10011;\n\n  /// @notice TYPE 10021: Package: A Liquidity Pool\n  uint256 internal constant PACKAGE_LIQUIDITY_POOL = 10021;\n\n  /// @notice TYPE 19999: Limit: exclusive, maximum TYPE that will be percieved as a package\n  uint256 internal constant LIMIT_MAX_PACKAGE = 19999;\n\n  /// --\n\n  /// @notice TYPE 20000: Limit: exclusive, minimum TYPE that will be percieved as a middleware\n  uint256 internal constant LIMIT_MIN_MIDDLEWARE = 20000;\n\n  /// @notice TYPE 20011: Middleware: A new gETH interface\n  uint256 internal constant MIDDLEWARE_GETH = 20011;\n\n  /// @notice TYPE 29999: Limit: exclusive, maximum TYPE that will be percieved as a middleware\n  uint256 internal constant LIMIT_MAX_MIDDLEWARE = 29999;\n}\n"
    },
    "contracts/globals/macros.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// no floats in solidity. If needed, PERCENTAGE_DENOMINATOR always represents \"1\" (100%)\nuint256 constant PERCENTAGE_DENOMINATOR = 1e10;\n\nuint256 constant gETH_DENOMINATOR = 1e18;\n"
    },
    "contracts/globals/reserved_key_space.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice Reserved Key Space for DataStoreModule\n * * helps preventing potential dev mistakes.\n * * helps keeping track of them.\n * * limits keys to bytes32.\n *\n * @dev utilize a key with rks.key\n * @dev keep this list in alphabetical order, per module.\n * @dev NEVER name your variables something else other than *its string value*.\n * @dev ! array keys with readUint returns the lenght of the array !\n */\nlibrary RESERVED_KEY_SPACE {\n  /**\n   * @dev reserved on GeodeModuleLib\n   */\n\n  /**\n   * @custom:type address\n   * @custom:definition representing body of an id\n   */\n  bytes32 internal constant CONTROLLER = \"CONTROLLER\";\n\n  /**\n   * @custom:type bytes\n   * @custom:definition base of an id\n   */\n  bytes32 internal constant NAME = \"NAME\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition identifier for an id, based on ID_TYPEs\n   */\n  bytes32 internal constant TYPE = \"TYPE\";\n\n  /**\n   * @dev reserved on StakeModuleLib\n   */\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition number of active validators run by an operator for a pool\n   */\n  bytes32 internal constant activeValidators = \"activeValidators\";\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition max amount of validators for an operator to run, for a specific pool.\n   */\n  bytes32 internal constant allowance = \"allowance\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition special operator that has max allowance, if threshold is hit for the pool\n   */\n  bytes32 internal constant fallbackOperator = \"fallbackOperator\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition treshold calculated with given percentage value for fallback operator to be activated\n   */\n  bytes32 internal constant fallbackThreshold = \"fallbackThreshold\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition fee of the pool or operator, will be shadowed by priorFee if switching\n   */\n  bytes32 internal constant fee = \"fee\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition effective timestamp pointing to the latest delayed fee change\n   */\n  bytes32 internal constant feeSwitch = \"feeSwitch\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition the initiation timestamp of a \"user\" TYPE id\n   */\n  bytes32 internal constant initiated = \"initiated\";\n\n  /**\n   * @custom:type address\n   * @custom:definition bound liquidity pool of a pool\n   */\n  bytes32 internal constant liquidityPool = \"liquidityPool\";\n\n  /**\n   * @custom:type address\n   * @custom:definition receiver address for yield seperation functionality\n   * * will receive minted gETH to given receiver instead of increasing pricePerShare\n   */\n  bytes32 internal constant yieldReceiver = \"yieldReceiver\";\n\n  /**\n   * @custom:type address\n   * @custom:definition hot wallet for pool and operators, automatooor\n   */\n  bytes32 internal constant maintainer = \"maintainer\";\n\n  /**\n   * @custom:type address array, direct call returns length\n   * @custom:definition contracts with more than one versions, ex: gETHMiddlewares of a pool\n   */\n  bytes32 internal constant middlewares = \"middlewares\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition effective timestamp pointing to the latest delayed validator period change\n   */\n  bytes32 internal constant periodSwitch = \"periodSwitch\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition fee that will be effective if fee is currently switching\n   */\n  bytes32 internal constant priorFee = \"priorFee\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition period that will be effective if validatorPeriod is currently switching\n   */\n  bytes32 internal constant priorPeriod = \"priorPeriod\";\n\n  /**\n   * @custom:type uint, bool\n   * @custom:definition 1(true) if id is a private pool\n   */\n  bytes32 internal constant privatePool = \"privatePool\";\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition proposed validator count for pool-operator pair.\n   */\n  bytes32 internal constant proposedValidators = \"proposedValidators\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition timestamp of the date of the latest imprisonment for an operator\n   */\n  bytes32 internal constant release = \"release\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition 32 eth is secured, per proposed-but-not-yet-activated validator\n   */\n  bytes32 internal constant secured = \"secured\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition collateral waiting to be staked, in wei\n   */\n  bytes32 internal constant surplus = \"surplus\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition sum of all allowances for a pool\n   */\n\n  bytes32 internal constant totalAllowance = \"totalAllowance\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition seconds, time that passes before the expected exit is reached for a validator\n   */\n  bytes32 internal constant validatorPeriod = \"validatorPeriod\";\n\n  /**\n   * @custom:type bytes array, direct call returns length\n   * @custom:definition lists all (any state) validators' pubkeys for a pool, or an operator\n   */\n  bytes32 internal constant validators = \"validators\";\n\n  /**\n   * @custom:type address\n   * @custom:definition custodian of validator funds for a pool\n   */\n  bytes32 internal constant withdrawalContract = \"withdrawalContract\";\n\n  /**\n   * @custom:type bytes\n   * @custom:definition derived from withdrawalContract\n   */\n  bytes32 internal constant withdrawalCredential = \"withdrawalCredential\";\n\n  /**\n   * @custom:type uint\n   * @custom:definition size of the internal wallet, which accrues fees etc. in wei\n   */\n  bytes32 internal constant wallet = \"wallet\";\n\n  /**\n   * @custom:type address\n   * @custom:definition whitelist contract for the pool\n   */\n  bytes32 internal constant whitelist = \"whitelist\";\n\n  /**\n   * @dev reserved on OracleExtensionLib\n   */\n\n  /**\n   * @custom:type uint, relational, pool[operator]\n   * @custom:definition number of alienated validators run by an operator for a pool\n   */\n  bytes32 internal constant alienValidators = \"alienValidators\";\n}\n"
    },
    "contracts/globals/validator_state.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice VALIDATOR_STATE: keeping track of validators within The Staking Library.\n */\nlibrary VALIDATOR_STATE {\n  /// @notice STATE 0: *invalid*\n  uint8 internal constant NONE = 0;\n\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract.\n  uint8 internal constant PROPOSED = 1;\n\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator.\n  uint8 internal constant ACTIVE = 2;\n\n  /// @notice STATE 3: validator is called to be exited.\n  uint8 internal constant EXIT_REQUESTED = 3;\n\n  /// @notice STATE 4: validator is fully exited.\n  uint8 internal constant EXITED = 4;\n\n  /// @notice STATE 69: proposal was malicious(alien). Maybe faulty signatures or probably frontrunning (https://bit.ly/3Tkc6UC)\n  uint8 internal constant ALIENATED = 69;\n}\n"
    },
    "contracts/helpers/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity =0.8.20;\n\nlibrary BytesLib {\n  function concat(\n    bytes memory _preBytes,\n    bytes memory _postBytes\n  ) internal pure returns (bytes memory) {\n    bytes memory tempBytes;\n\n    assembly {\n      // Get a location of some free memory and store it in tempBytes as\n      // Solidity does for memory variables.\n      tempBytes := mload(0x40)\n\n      // Store the length of the first bytes array at the beginning of\n      // the memory for tempBytes.\n      let length := mload(_preBytes)\n      mstore(tempBytes, length)\n\n      // Maintain a memory counter for the current write location in the\n      // temp bytes array by adding the 32 bytes for the array length to\n      // the starting location.\n      let mc := add(tempBytes, 0x20)\n      // Stop copying when the memory counter reaches the length of the\n      // first bytes array.\n      let end := add(mc, length)\n\n      for {\n        // Initialize a copy counter to the start of the _preBytes data,\n        // 32 bytes into its memory.\n        let cc := add(_preBytes, 0x20)\n      } lt(mc, end) {\n        // Increase both counters by 32 bytes each iteration.\n        mc := add(mc, 0x20)\n        cc := add(cc, 0x20)\n      } {\n        // Write the _preBytes data into the tempBytes memory 32 bytes\n        // at a time.\n        mstore(mc, mload(cc))\n      }\n\n      // Add the length of _postBytes to the current length of tempBytes\n      // and store it as the new length in the first 32 bytes of the\n      // tempBytes memory.\n      length := mload(_postBytes)\n      mstore(tempBytes, add(length, mload(tempBytes)))\n\n      // Move the memory counter back from a multiple of 0x20 to the\n      // actual end of the _preBytes data.\n      mc := end\n      // Stop copying when the memory counter reaches the new combined\n      // length of the arrays.\n      end := add(mc, length)\n\n      for {\n        let cc := add(_postBytes, 0x20)\n      } lt(mc, end) {\n        mc := add(mc, 0x20)\n        cc := add(cc, 0x20)\n      } {\n        mstore(mc, mload(cc))\n      }\n\n      // Update the free-memory pointer by padding our last write location\n      // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n      // next 32 byte block, then round down to the nearest multiple of\n      // 32. If the sum of the length of the two arrays is zero then add\n      // one before rounding down to leave a blank 32 bytes (the length block with 0).\n      mstore(\n        0x40,\n        and(\n          add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n          not(31) // Round down to the nearest 32 bytes.\n        )\n      )\n    }\n\n    return tempBytes;\n  }\n\n  function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n    assembly {\n      // Read the first 32 bytes of _preBytes storage, which is the length\n      // of the array. (We don't need to use the offset into the slot\n      // because arrays use the entire slot.)\n      let fslot := sload(_preBytes.slot)\n      // Arrays of 31 bytes or less have an even value in their slot,\n      // while longer arrays have an odd value. The actual length is\n      // the slot divided by two for odd values, and the lowest order\n      // byte divided by two for even values.\n      // If the slot is even, bitwise and the slot with 255 and divide by\n      // two to get the length. If the slot is odd, bitwise and the slot\n      // with -1 and divide by two.\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n      let mlength := mload(_postBytes)\n      let newlength := add(slength, mlength)\n      // slength can contain both the length and contents of the array\n      // if length < 32 bytes so let's prepare for that\n      // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n      switch add(lt(slength, 32), lt(newlength, 32))\n      case 2 {\n        // Since the new array still fits in the slot, we just need to\n        // update the contents of the slot.\n        // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n        sstore(\n          _preBytes.slot,\n          // all the modifications to the slot are inside this\n          // next block\n          add(\n            // we can just add to the slot contents because the\n            // bytes we want to change are the LSBs\n            fslot,\n            add(\n              mul(\n                div(\n                  // load the bytes from memory\n                  mload(add(_postBytes, 0x20)),\n                  // zero all bytes to the right\n                  exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n              ),\n              // increase length by the double of the memory\n              // bytes length\n              mul(mlength, 2)\n            )\n          )\n        )\n      }\n      case 1 {\n        // The stored value fits in the slot, but the combined value\n        // will exceed it.\n        // get the keccak hash to get the contents of the array\n        mstore(0x0, _preBytes.slot)\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n        // save new length\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n        // The contents of the _postBytes array start 32 bytes into\n        // the structure. Our first read should obtain the `submod`\n        // bytes that can fit into the unused space in the last word\n        // of the stored array. To get this, we read 32 bytes starting\n        // from `submod`, so the data we read overlaps with the array\n        // contents by `submod` bytes. Masking the lowest-order\n        // `submod` bytes allows us to add that value directly to the\n        // stored value.\n\n        let submod := sub(32, slength)\n        let mc := add(_postBytes, submod)\n        let end := add(_postBytes, mlength)\n        let mask := sub(exp(0x100, submod), 1)\n\n        sstore(\n          sc,\n          add(\n            and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n            and(mload(mc), mask)\n          )\n        )\n\n        for {\n          mc := add(mc, 0x20)\n          sc := add(sc, 1)\n        } lt(mc, end) {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } {\n          sstore(sc, mload(mc))\n        }\n\n        mask := exp(0x100, sub(mc, end))\n\n        sstore(sc, mul(div(mload(mc), mask), mask))\n      }\n      default {\n        // get the keccak hash to get the contents of the array\n        mstore(0x0, _preBytes.slot)\n        // Start copying to the last used word of the stored array.\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n        // save new length\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n        // Copy over the first `submod` bytes of the new data as in\n        // case 1 above.\n        let slengthmod := mod(slength, 32)\n        let mlengthmod := mod(mlength, 32)\n        let submod := sub(32, slengthmod)\n        let mc := add(_postBytes, submod)\n        let end := add(_postBytes, mlength)\n        let mask := sub(exp(0x100, submod), 1)\n\n        sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n        for {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } lt(mc, end) {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } {\n          sstore(sc, mload(mc))\n        }\n\n        mask := exp(0x100, sub(mc, end))\n\n        sstore(sc, mul(div(mload(mc), mask), mask))\n      }\n    }\n  }\n\n  function slice(\n    bytes memory _bytes,\n    uint256 _start,\n    uint256 _length\n  ) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n    bytes memory tempBytes;\n\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n        tempBytes := mload(0x40)\n\n        // The first word of the slice result is potentially a partial\n        // word read from the original array. To read it, we calculate\n        // the length of that partial word and start copying that many\n        // bytes into the array. The first word we copy will start with\n        // data we don't care about, but the last `lengthmod` bytes will\n        // land at the beginning of the contents of the new array. When\n        // we're done copying, we overwrite the full first word with\n        // the actual length of the slice.\n        let lengthmod := and(_length, 31)\n\n        // The multiplication in the next line is necessary\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\n        // the following copy loop was copying the origin's length\n        // and then ending prematurely not copying everything it should.\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n\n        for {\n          // The multiplication in the next line has the same exact purpose\n          // as the one above.\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n\n        mstore(tempBytes, _length)\n\n        //update free-memory pointer\n        //allocating the array padded to 32 bytes like the compiler does now\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      //if we want a zero-length slice let's just return a zero-length array\n      default {\n        tempBytes := mload(0x40)\n        //zero out the 32 bytes slice we are about to return\n        //we need to do it because Solidity does not garbage collect\n        mstore(tempBytes, 0)\n\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n\n    return tempBytes;\n  }\n\n  function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n    require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n    address tempAddress;\n\n    assembly {\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n    }\n\n    return tempAddress;\n  }\n\n  function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n    require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n    uint8 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x1), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n    require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n    uint16 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x2), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n    require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n    uint32 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x4), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n    require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n    uint64 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x8), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n    require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n    uint96 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0xc), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n    require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n    uint128 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x10), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n    require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n    uint256 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x20), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n    require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n    bytes32 tempBytes32;\n\n    assembly {\n      tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n    }\n\n    return tempBytes32;\n  }\n\n  function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n    bool success = true;\n\n    assembly {\n      let length := mload(_preBytes)\n\n      // if lengths don't match the arrays are not equal\n      switch eq(length, mload(_postBytes))\n      case 1 {\n        // cb is a circuit breaker in the for loop since there's\n        //  no said feature for inline assembly loops\n        // cb = 1 - don't breaker\n        // cb = 0 - break\n        let cb := 1\n\n        let mc := add(_preBytes, 0x20)\n        let end := add(mc, length)\n\n        for {\n          let cc := add(_postBytes, 0x20)\n          // the next line is the loop condition:\n          // while(uint256(mc < end) + cb == 2)\n        } eq(add(lt(mc, end), cb), 2) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          // if any of these checks fails then arrays are not equal\n          if iszero(eq(mload(mc), mload(cc))) {\n            // unsuccess:\n            success := 0\n            cb := 0\n          }\n        }\n      }\n      default {\n        // unsuccess:\n        success := 0\n      }\n    }\n\n    return success;\n  }\n\n  function equalStorage(\n    bytes storage _preBytes,\n    bytes memory _postBytes\n  ) internal view returns (bool) {\n    bool success = true;\n\n    assembly {\n      // we know _preBytes_offset is 0\n      let fslot := sload(_preBytes.slot)\n      // Decode the length of the stored array like in concatStorage().\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n      let mlength := mload(_postBytes)\n\n      // if lengths don't match the arrays are not equal\n      switch eq(slength, mlength)\n      case 1 {\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n        if iszero(iszero(slength)) {\n          switch lt(slength, 32)\n          case 1 {\n            // blank the last byte which is the length\n            fslot := mul(div(fslot, 0x100), 0x100)\n\n            if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n              // unsuccess:\n              success := 0\n            }\n          }\n          default {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n            let cb := 1\n\n            // get the keccak hash to get the contents of the array\n            mstore(0x0, _preBytes.slot)\n            let sc := keccak256(0x0, 0x20)\n\n            let mc := add(_postBytes, 0x20)\n            let end := add(mc, mlength)\n\n            // the next line is the loop condition:\n            // while(uint256(mc < end) + cb == 2)\n            for {\n\n            } eq(add(lt(mc, end), cb), 2) {\n              sc := add(sc, 1)\n              mc := add(mc, 0x20)\n            } {\n              if iszero(eq(sload(sc), mload(mc))) {\n                // unsuccess:\n                success := 0\n                cb := 0\n              }\n            }\n          }\n        }\n      }\n      default {\n        // unsuccess:\n        success := 0\n      }\n    }\n\n    return success;\n  }\n}\n"
    },
    "contracts/helpers/ERC1155PausableBurnableSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\n\n// External\n// Dependencies: ERC1155\n//  * interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n//  * libraries\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\n//  * contracts\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n// Dependencies: ERC1155Pausable\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n// Dependencies: ERC1155PausableBurnableSupply\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n// Internal - interfaces\nimport {IERC1155Burnable, IERC1155Supply, IERC1155PausableBurnableSupply} from \"../interfaces/helpers/IERC1155PausableBurnableSupply.sol\";\n\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n  using Arrays for uint256[];\n  using Arrays for address[];\n\n  mapping(uint256 id => mapping(address account => uint256)) private _balances;\n\n  mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\n\n  // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n  string private _uri;\n\n  /**\n   * @dev See {_setURI}.\n   */\n  constructor(string memory uri_) {\n    _setURI(uri_);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(ERC165, IERC165) returns (bool) {\n    return\n      interfaceId == type(IERC1155).interfaceId ||\n      interfaceId == type(IERC1155MetadataURI).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC1155MetadataURI-uri}.\n   *\n   * This implementation returns the same URI for *all* token types. It relies\n   * on the token type ID substitution mechanism\n   * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n   *\n   * Clients calling this function must replace the `\\{id\\}` substring with the\n   * actual token type ID.\n   */\n  function uri(uint256 /* id */) public view virtual returns (string memory) {\n    return _uri;\n  }\n\n  /**\n   * @dev See {IERC1155-balanceOf}.\n   */\n  function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n    return _balances[id][account];\n  }\n\n  /**\n   * @dev See {IERC1155-balanceOfBatch}.\n   *\n   * Requirements:\n   *\n   * - `accounts` and `ids` must have the same length.\n   */\n  function balanceOfBatch(\n    address[] memory accounts,\n    uint256[] memory ids\n  ) public view virtual returns (uint256[] memory) {\n    if (accounts.length != ids.length) {\n      revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n    }\n\n    uint256[] memory batchBalances = new uint256[](accounts.length);\n\n    for (uint256 i = 0; i < accounts.length; ++i) {\n      batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n    }\n\n    return batchBalances;\n  }\n\n  /**\n   * @dev See {IERC1155-setApprovalForAll}.\n   */\n  function setApprovalForAll(address operator, bool approved) public virtual {\n    _setApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n   * @dev See {IERC1155-isApprovedForAll}.\n   */\n  function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n    return _operatorApprovals[account][operator];\n  }\n\n  /**\n   * @dev See {IERC1155-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n  ) public virtual {\n    address sender = _msgSender();\n    if (from != sender && !isApprovedForAll(from, sender)) {\n      revert ERC1155MissingApprovalForAll(sender, from);\n    }\n    _safeTransferFrom(from, to, id, value, data);\n  }\n\n  /**\n   * @dev See {IERC1155-safeBatchTransferFrom}.\n   */\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) public virtual {\n    address sender = _msgSender();\n    if (from != sender && !isApprovedForAll(from, sender)) {\n      revert ERC1155MissingApprovalForAll(sender, from);\n    }\n    _safeBatchTransferFrom(from, to, ids, values, data);\n  }\n\n  /**\n   * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n   * (or `to`) is the zero address.\n   *\n   * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n   *\n   * Requirements:\n   *\n   * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n   *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n   * - `ids` and `values` must have the same length.\n   *\n   * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual {\n    if (ids.length != values.length) {\n      revert ERC1155InvalidArrayLength(ids.length, values.length);\n    }\n\n    address operator = _msgSender();\n\n    for (uint256 i = 0; i < ids.length; ++i) {\n      uint256 id = ids.unsafeMemoryAccess(i);\n      uint256 value = values.unsafeMemoryAccess(i);\n\n      if (from != address(0)) {\n        uint256 fromBalance = _balances[id][from];\n        if (fromBalance < value) {\n          revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n        }\n        unchecked {\n          // Overflow not possible: value <= fromBalance\n          _balances[id][from] = fromBalance - value;\n        }\n      }\n\n      if (to != address(0)) {\n        _balances[id][to] += value;\n      }\n    }\n\n    if (ids.length == 1) {\n      uint256 id = ids.unsafeMemoryAccess(0);\n      uint256 value = values.unsafeMemoryAccess(0);\n      emit TransferSingle(operator, from, to, id, value);\n    } else {\n      emit TransferBatch(operator, from, to, ids, values);\n    }\n  }\n\n  /**\n   * @dev Version of {_update} that performs the token acceptance check by calling\n   * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n   * contains code (eg. is a smart contract at the moment of execution).\n   *\n   * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n   * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n   * overriding {_update} instead.\n   */\n  function _updateWithAcceptanceCheck(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) internal virtual {\n    _update(from, to, ids, values);\n    if (to != address(0)) {\n      address operator = _msgSender();\n      if (ids.length == 1) {\n        uint256 id = ids.unsafeMemoryAccess(0);\n        uint256 value = values.unsafeMemoryAccess(0);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\n      } else {\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\n      }\n    }\n  }\n\n  /**\n   * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n   *\n   * Emits a {TransferSingle} event.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n   * acceptance magic value.\n   */\n  function _safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n  ) internal {\n    if (to == address(0)) {\n      revert ERC1155InvalidReceiver(address(0));\n    }\n    if (from == address(0)) {\n      revert ERC1155InvalidSender(address(0));\n    }\n    (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n    _updateWithAcceptanceCheck(from, to, ids, values, data);\n  }\n\n  /**\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n   *\n   * Emits a {TransferBatch} event.\n   *\n   * Requirements:\n   *\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n   * acceptance magic value.\n   * - `ids` and `values` must have the same length.\n   */\n  function _safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) internal {\n    if (to == address(0)) {\n      revert ERC1155InvalidReceiver(address(0));\n    }\n    if (from == address(0)) {\n      revert ERC1155InvalidSender(address(0));\n    }\n    _updateWithAcceptanceCheck(from, to, ids, values, data);\n  }\n\n  /**\n   * @dev Sets a new URI for all token types, by relying on the token type ID\n   * substitution mechanism\n   * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n   *\n   * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n   * URI or any of the values in the JSON file at said URI will be replaced by\n   * clients with the token type ID.\n   *\n   * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n   * interpreted by clients as\n   * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n   * for token type ID 0x4cce0.\n   *\n   * See {uri}.\n   *\n   * Because these URIs cannot be meaningfully represented by the {URI} event,\n   * this function emits no events.\n   */\n  function _setURI(string memory newuri) internal virtual {\n    _uri = newuri;\n  }\n\n  /**\n   * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n   *\n   * Emits a {TransferSingle} event.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n   * acceptance magic value.\n   */\n  function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n    if (to == address(0)) {\n      revert ERC1155InvalidReceiver(address(0));\n    }\n    (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n    _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n  }\n\n  /**\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n   *\n   * Emits a {TransferBatch} event.\n   *\n   * Requirements:\n   *\n   * - `ids` and `values` must have the same length.\n   * - `to` cannot be the zero address.\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n   * acceptance magic value.\n   */\n  function _mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) internal {\n    if (to == address(0)) {\n      revert ERC1155InvalidReceiver(address(0));\n    }\n    _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n  }\n\n  /**\n   * @dev Destroys a `value` amount of tokens of type `id` from `from`\n   *\n   * Emits a {TransferSingle} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `from` must have at least `value` amount of tokens of type `id`.\n   */\n  function _burn(address from, uint256 id, uint256 value) internal {\n    if (from == address(0)) {\n      revert ERC1155InvalidSender(address(0));\n    }\n    (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n    _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n  }\n\n  /**\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n   *\n   * Emits a {TransferBatch} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `from` must have at least `value` amount of tokens of type `id`.\n   * - `ids` and `values` must have the same length.\n   */\n  function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n    if (from == address(0)) {\n      revert ERC1155InvalidSender(address(0));\n    }\n    _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n  }\n\n  /**\n   * @dev Approve `operator` to operate on all of `owner` tokens\n   *\n   * Emits an {ApprovalForAll} event.\n   *\n   * Requirements:\n   *\n   * - `operator` cannot be the zero address.\n   */\n  function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n    if (operator == address(0)) {\n      revert ERC1155InvalidOperator(address(0));\n    }\n    _operatorApprovals[owner][operator] = approved;\n    emit ApprovalForAll(owner, operator, approved);\n  }\n\n  /**\n   * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\n   * if it contains code at the moment of execution.\n   */\n  function _doSafeTransferAcceptanceCheck(\n    address operator,\n    address from,\n    address to,\n    uint256 id,\n    uint256 value,\n    bytes memory data\n  ) internal virtual {\n    if (to.code.length > 0) {\n      try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (\n        bytes4 response\n      ) {\n        if (response != IERC1155Receiver.onERC1155Received.selector) {\n          // Tokens rejected\n          revert ERC1155InvalidReceiver(to);\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          // non-ERC1155Receiver implementer\n          revert ERC1155InvalidReceiver(to);\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\n   * if it contains code at the moment of execution.\n   */\n  function _doSafeBatchTransferAcceptanceCheck(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values,\n    bytes memory data\n  ) private {\n    if (to.code.length > 0) {\n      try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n        bytes4 response\n      ) {\n        if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n          // Tokens rejected\n          revert ERC1155InvalidReceiver(to);\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          // non-ERC1155Receiver implementer\n          revert ERC1155InvalidReceiver(to);\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Creates an array in memory with only one value for each of the elements provided.\n   */\n  function _asSingletonArrays(\n    uint256 element1,\n    uint256 element2\n  ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Load the free memory pointer\n      array1 := mload(0x40)\n      // Set array length to 1\n      mstore(array1, 1)\n      // Store the single element at the next word after the length (where content starts)\n      mstore(add(array1, 0x20), element1)\n\n      // Repeat for next array locating it right after the first array\n      array2 := add(array1, 0x40)\n      mstore(array2, 1)\n      mstore(add(array2, 0x20), element2)\n\n      // Update the free memory pointer by pointing after the second array\n      mstore(0x40, add(array2, 0x40))\n    }\n  }\n}\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n  /**\n   * @dev See {ERC1155-_update}.\n   *\n   * Requirements:\n   *\n   * - the contract must not be paused.\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual override whenNotPaused {\n    super._update(from, to, ids, values);\n  }\n}\n\nabstract contract ERC1155Burnable is IERC1155Burnable, ERC1155 {\n  function burn(address account, uint256 id, uint256 value) public virtual override {\n    if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n      revert ERC1155MissingApprovalForAll(_msgSender(), account);\n    }\n\n    _burn(account, id, value);\n  }\n\n  function burnBatch(\n    address account,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) public virtual {\n    if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n      revert ERC1155MissingApprovalForAll(_msgSender(), account);\n    }\n\n    _burnBatch(account, ids, values);\n  }\n}\n\nabstract contract ERC1155Supply is IERC1155Supply, ERC1155 {\n  mapping(uint256 id => uint256) private _totalSupply;\n  uint256 private _totalSupplyAll;\n\n  /**\n   * @dev Total value of tokens in with a given id.\n   */\n  function totalSupply(uint256 id) public view virtual returns (uint256) {\n    return _totalSupply[id];\n  }\n\n  /**\n   * @dev Total value of tokens.\n   */\n  function totalSupply() public view virtual returns (uint256) {\n    return _totalSupplyAll;\n  }\n\n  /**\n   * @dev Indicates whether any token exist with a given id, or not.\n   */\n  function exists(uint256 id) public view virtual returns (bool) {\n    return totalSupply(id) > 0;\n  }\n\n  /**\n   * @dev See {ERC1155-_update}.\n   */\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal virtual override {\n    super._update(from, to, ids, values);\n\n    if (from == address(0)) {\n      uint256 totalMintValue = 0;\n      for (uint256 i = 0; i < ids.length; ++i) {\n        uint256 value = values[i];\n        // Overflow check required: The rest of the code assumes that totalSupply never overflows\n        _totalSupply[ids[i]] += value;\n        totalMintValue += value;\n      }\n      // Overflow check required: The rest of the code assumes that totalSupplyAll never overflows\n      _totalSupplyAll += totalMintValue;\n    }\n\n    if (to == address(0)) {\n      uint256 totalBurnValue = 0;\n      for (uint256 i = 0; i < ids.length; ++i) {\n        uint256 value = values[i];\n\n        unchecked {\n          // Overflow not possible: values[i] <= balanceOf(from, ids[i]) <= totalSupply(ids[i])\n          _totalSupply[ids[i]] -= value;\n          // Overflow not possible: sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n          totalBurnValue += value;\n        }\n      }\n      unchecked {\n        // Overflow not possible: totalBurnValue = sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n        _totalSupplyAll -= totalBurnValue;\n      }\n    }\n  }\n}\n\n/**\n * @notice Base contract for gETH.\n * @dev Above contracts are taken from Openzeppelin.\n * @dev Only difference is _doSafeTransferAcceptanceCheck is being internal virtual instead of private, because we want to be able to override it in gETH:\n * ERC1155:\n * * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cffb2f1ddcd87efd68effc92cfd336c5145acabd/contracts/token/ERC1155/ERC1155.sol#1\n * ERC1155Pausable:\n * * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/37afdc8910f2853426c20e504ecfe5d992e21813/contracts/token/ERC1155/extensions/ERC1155Pausable.sol#L1\n * ERC1155Burnable:\n * * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/37afdc8910f2853426c20e504ecfe5d992e21813/contracts/token/ERC1155/extensions/ERC1155Burnable.sol#L1\n * ERC1155Supply:\n * * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/37afdc8910f2853426c20e504ecfe5d992e21813/contracts/token/ERC1155/extensions/ERC1155Supply.sol#L1\n *\n * @dev Below contract ERC1155PausableBurnableSupply is created with openzeppelin wizard:\n * + Mintable\n * + Burnable\n * + Supply Tracking\n * + Pausable\n * + Updatable URI\n * + Roles\n * Additionally, its constructor is changed for some gas savings.\n */\ncontract ERC1155PausableBurnableSupply is\n  IERC1155PausableBurnableSupply,\n  ERC1155,\n  AccessControl,\n  ERC1155Pausable,\n  ERC1155Burnable,\n  ERC1155Supply\n{\n  bytes32 public immutable URI_SETTER_ROLE = keccak256(\"URI_SETTER_ROLE\");\n  bytes32 public immutable PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public immutable MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor(string memory uri_) ERC1155(uri_) {\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _grantRole(keccak256(\"URI_SETTER_ROLE\"), msg.sender);\n    _grantRole(keccak256(\"PAUSER_ROLE\"), msg.sender);\n    _grantRole(keccak256(\"MINTER_ROLE\"), msg.sender);\n  }\n\n  function setURI(string memory newuri) public override onlyRole(URI_SETTER_ROLE) {\n    _setURI(newuri);\n  }\n\n  function pause() public override onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() public override onlyRole(PAUSER_ROLE) {\n    _unpause();\n  }\n\n  function mint(\n    address account,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public override onlyRole(MINTER_ROLE) {\n    _mint(account, id, amount, data);\n  }\n\n  function mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public override onlyRole(MINTER_ROLE) {\n    _mintBatch(to, ids, amounts, data);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function _update(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory values\n  ) internal override(ERC1155, ERC1155Pausable, ERC1155Supply) {\n    super._update(from, to, ids, values);\n  }\n\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view override(ERC1155, AccessControl, IERC165) returns (bool) {\n    return super.supportsInterface(interfaceId);\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/ERC1155ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\ncontract ERC1155ReceiverMock is ERC165, IERC1155Receiver {\n  enum RevertType {\n    None,\n    RevertWithoutMessage,\n    RevertWithMessage,\n    RevertWithCustomError,\n    Panic\n  }\n\n  bytes4 private immutable _recRetval;\n  bytes4 private immutable _batRetval;\n  RevertType private immutable _error;\n\n  event Received(\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes data,\n    uint256 gas\n  );\n  event BatchReceived(\n    address operator,\n    address from,\n    uint256[] ids,\n    uint256[] values,\n    bytes data,\n    uint256 gas\n  );\n  error CustomError(bytes4);\n\n  constructor(bytes4 recRetval, bytes4 batRetval, RevertType error) {\n    _recRetval = recRetval;\n    _batRetval = batRetval;\n    _error = error;\n  }\n\n  function onERC1155Received(\n    address operator,\n    address from,\n    uint256 id,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bytes4) {\n    if (_error == RevertType.RevertWithoutMessage) {\n      revert();\n    } else if (_error == RevertType.RevertWithMessage) {\n      revert(\"ERC1155ReceiverMock: reverting on receive\");\n    } else if (_error == RevertType.RevertWithCustomError) {\n      revert CustomError(_recRetval);\n    } else if (_error == RevertType.Panic) {\n      uint256 a = uint256(0) / uint256(0);\n      a;\n    }\n\n    emit Received(operator, from, id, value, data, gasleft());\n    return _recRetval;\n  }\n\n  function onERC1155BatchReceived(\n    address operator,\n    address from,\n    uint256[] calldata ids,\n    uint256[] calldata values,\n    bytes calldata data\n  ) external returns (bytes4) {\n    if (_error == RevertType.RevertWithoutMessage) {\n      revert();\n    } else if (_error == RevertType.RevertWithMessage) {\n      revert(\"ERC1155ReceiverMock: reverting on batch receive\");\n    } else if (_error == RevertType.RevertWithCustomError) {\n      revert CustomError(_recRetval);\n    } else if (_error == RevertType.Panic) {\n      uint256 a = uint256(0) / uint256(0);\n      a;\n    }\n\n    emit BatchReceived(operator, from, ids, values, data, gasleft());\n    return _batRetval;\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/FreshSlotModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {FreshSlotModuleLib as FSL, FreshSlotStruct} from \"./FreshSlotModuleLib.sol\";\nimport {IFreshSlotModule} from \"./interfaces/IFreshSlotModule.sol\";\n\n// external\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nabstract contract FreshSlotModule is IFreshSlotModule, UUPSUpgradeable, PausableUpgradeable {\n  using FSL for FreshSlotStruct;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  FreshSlotStruct internal FRESH_STRUCT;\n\n  function __FreshSlotModule_init(uint256 value) internal {\n    __Pausable_init();\n    __FreshSlotModule_init_unchained(value);\n  }\n\n  function __FreshSlotModule_init_unchained(uint256 value) internal {\n    FRESH_STRUCT.setFreshSlot(value);\n  }\n\n  function setFreshSlot(uint256 value) external override {\n    FRESH_STRUCT.setFreshSlot(value);\n  }\n\n  function getFreshSlot() external view override returns (uint256) {\n    return FRESH_STRUCT.getFreshSlot();\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/FreshSlotModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nstruct FreshSlotStruct {\n  uint256 freshSlot;\n  uint256[9] __gap;\n}\n\nlibrary FreshSlotModuleLib {\n  function setFreshSlot(FreshSlotStruct storage self, uint256 value) external {\n    self.freshSlot = value;\n  }\n\n  function getFreshSlot(FreshSlotStruct storage self) external view returns (uint256) {\n    return self.freshSlot;\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/GeodeModuleLibV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// structs\nimport {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\n// globals\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// libraries\nimport {DataStoreModuleLib as DSML} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {Proposal} from \"../../../modules/GeodeModule/structs/utils.sol\";\n\n/**\n * @notice Storage struct for the Dual Governance logic\n * @dev Dual Governance allows 2 parties to manage a package with proposals and approvals.\n * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\n * Suggests updates, such as new operators, contract/package upgrades, a new Senate (without any permission to force them)\n * @param SENATE An address that protects the users by controlling the state of governance, contract updates and other crucial changes\n * @param APPROVED_UPGRADE only 1 implementation contract SHOULD be \"approved\" at any given time.\n * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Might not be utilized. Limited by MAX_SENATE_PERIOD\n * @param PACKAGE_TYPE every package has a specific TYPE. Defined in globals/id_type.sol\n * @param CONTRACT_VERSION always refers to the upgrade proposal ID. Does not increase uniformly like one might expect.\n * @param proposals till approved, proposals are kept separated from the Isolated Storage\n * @param __gap keep the struct size at 16\n **/\nstruct DualGovernanceV3_0_Mock {\n  address GOVERNANCE;\n  address SENATE;\n  address APPROVED_UPGRADE;\n  uint256 SENATE_EXPIRY;\n  uint256 PACKAGE_TYPE;\n  uint256 CONTRACT_VERSION;\n  mapping(uint256 => Proposal) proposals;\n  uint256 freshSlot;\n  uint256[8] __gap;\n}\n\n/**\n * @title GML: Geode Module Library\n *\n * @notice Dual Governance & Limited Upgradability:\n * Administration of the Isolated Storage with a Dual Governance consisting a Governance and a Senate.\n * Administration of a UUPS contract with Limited Upgradability for Packages like Portal, LiquidityPool.\n *\n * @dev review: DataStoreModule for the id based isolated storage logic.\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\n *\n * @dev SENATE_EXPIRY is not mandatory to utilize. Simply set it to MAX_UINT256 if rescueSenate is not needed.\n *\n * @dev There are 3 ways to set a new Senate:\n * 1. With a proposal TYPE 1. Proposal's controller becomes the new Senate, refreshes the expiry.\n * 2. Current Senate can call changeSenate, which doesn't change the expiry\n * 3. As a circuit breaker: If senate is expired, then rescue senate can be called by governance.\n * @dev Currently, there are no way to set a new Governance.\n *\n *\n * @dev Contracts relying on this library must use GeodeModuleLib.GeodeModuleStorage\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary GeodeModuleLibV3_0_Mock {\n  using DSML for DataStoreModuleStorage;\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice a proposal can have a duration between 1 days to 4 weeks (inclusive)\n  uint32 internal constant MIN_PROPOSAL_DURATION = 1 days;\n  uint32 internal constant MAX_PROPOSAL_DURATION = 4 weeks;\n\n  /// @notice if expiry is utilized, a senate can be active for a year.\n  /// @dev \"MAX\" underlines a new senate can be set without expecting an expiry\n  uint32 internal constant MAX_SENATE_PERIOD = 365 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n  event Approved(uint256 ID);\n  event NewSenate(address senate, uint256 expiry);\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyGovernance(DualGovernanceV3_0_Mock storage self) {\n    require(msg.sender == self.GOVERNANCE, \"GML:GOVERNANCE role needed\");\n    _;\n  }\n\n  modifier onlySenate(DualGovernanceV3_0_Mock storage self) {\n    require(msg.sender == self.SENATE, \"GML:SENATE role needed\");\n    require(block.timestamp < self.SENATE_EXPIRY, \"GML:SENATE expired\");\n    _;\n  }\n\n  modifier onlyController(DataStoreModuleStorage storage DATASTORE, uint256 id) {\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"GML:CONTROLLER role needed\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function setFreshSlot(DualGovernanceV3_0_Mock storage self, uint256 value) external {\n    self.freshSlot = value;\n  }\n\n  function getFreshSlot(DualGovernanceV3_0_Mock storage self) external view returns (uint256) {\n    return self.freshSlot;\n  }\n\n  /**\n   * @notice Check if it is allowed to change the package version to given proposedImplementation.\n   * @dev provided for _authorizeUpgrade\n   * @dev currentImplementation should always be UUPS._getImplementation()\n   * @dev currentImplementation or zero as proposedImplementation will return false\n   **/\n  function isUpgradeAllowed(\n    DualGovernanceV3_0_Mock storage self,\n    address proposedImplementation,\n    address currentImplementation\n  ) external view returns (bool) {\n    return\n      (self.APPROVED_UPGRADE != address(0)) &&\n      (proposedImplementation != currentImplementation) &&\n      (self.APPROVED_UPGRADE == proposedImplementation);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function getProposal(\n    DualGovernanceV3_0_Mock storage self,\n    uint256 id\n  ) external view returns (Proposal memory) {\n    return self.proposals[id];\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   */\n\n  /**\n   * @custom:subsection                        ** INTERNAL **\n   *\n   * @custom:visibility -> internal\n   */\n  function _setSenate(\n    DualGovernanceV3_0_Mock storage self,\n    address _newSenate,\n    uint256 _expiry\n  ) internal {\n    require(_newSenate != address(0), \"GML:Senate cannot be zero address\");\n    self.SENATE = _newSenate;\n    self.SENATE_EXPIRY = _expiry;\n\n    emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY GOVERNANCE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice generates a new ID with given TYPE and NAME, proposes it to be owned by a CONTROLLER.\n   * @dev DATASTORE[id] will not be updated until the proposal is approved\n   * @dev Proposals can NEVER be overriden\n   */\n  function propose(\n    DualGovernanceV3_0_Mock storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external onlyGovernance(self) returns (uint256 id) {\n    id = DSML.generateId(_NAME, _TYPE);\n\n    require(self.proposals[id].deadline == 0, \"GML:already proposed\");\n    require((DATASTORE.readBytes(id, rks.NAME)).length == 0, \"GML:ID already exist\");\n    require(_CONTROLLER != address(0), \"GML:CONTROLLER cannot be ZERO\");\n    require((_TYPE != ID_TYPE.NONE) && (_TYPE != ID_TYPE.POOL), \"GML:TYPE is NONE or POOL\");\n    require(\n      (duration >= MIN_PROPOSAL_DURATION) && (duration <= MAX_PROPOSAL_DURATION),\n      \"GML:invalid proposal duration\"\n    );\n\n    uint256 _deadline = block.timestamp + duration;\n\n    self.proposals[id] = Proposal({\n      CONTROLLER: _CONTROLLER,\n      TYPE: _TYPE,\n      NAME: _NAME,\n      deadline: _deadline\n    });\n\n    emit Proposed(_TYPE, id, _CONTROLLER, _deadline);\n  }\n\n  /**\n   * @notice changes Senate in a scenerio where the current Senate acts maliciously!\n   * * We are sure this will not be the case, but creating a method for possible recovery is a must.\n   * @notice Normally, Governance creates Senate Proposals frequently to signal it does not have\n   * * any intent of malicious overtake.\n   * note: If Governance does not send a Senate Proposal \"a while\" before the SENATE_EXPIRY,\n   * * we recommend users to take their money out.\n   * @dev Obviously, Governance needs to wait for SENATE_EXPIRY.\n   * @dev Refreshes the expiry\n   */\n  function rescueSenate(\n    DualGovernanceV3_0_Mock storage self,\n    address _newSenate\n  ) external onlyGovernance(self) {\n    require(block.timestamp > self.SENATE_EXPIRY, \"GML:cannot rescue yet\");\n\n    _setSenate(self, _newSenate, block.timestamp + MAX_SENATE_PERIOD);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY SENATE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice approves a proposal and records given data to DataStore\n   * @notice specific changes for the reserved types (1, 2, 3) are implemented here,\n   * any other addition should take place in Portal, as not related.\n   * Note that GM has additional logic for package type approvals.\n   * @param id given ID proposal that has will be approved by Senate\n   * @dev Senate is not able to approve approved proposals\n   * @dev Senate is not able to approve expired proposals\n   */\n  function approveProposal(\n    DualGovernanceV3_0_Mock storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id\n  ) external onlySenate(self) returns (address _controller, uint256 _type, bytes memory _name) {\n    require(self.proposals[id].deadline > block.timestamp, \"GML:not an active proposal\");\n\n    _controller = self.proposals[id].CONTROLLER;\n    _type = self.proposals[id].TYPE;\n    _name = self.proposals[id].NAME;\n\n    DATASTORE.writeUint(id, rks.TYPE, _type);\n    DATASTORE.writeAddress(id, rks.CONTROLLER, _controller);\n    DATASTORE.writeBytes(id, rks.NAME, _name);\n    DATASTORE.allIdsByType[_type].push(id);\n\n    if (_type == ID_TYPE.SENATE) {\n      _setSenate(self, _controller, block.timestamp + MAX_SENATE_PERIOD);\n    } else if (_type == self.PACKAGE_TYPE) {\n      self.APPROVED_UPGRADE = _controller;\n    }\n\n    // important\n    self.proposals[id].deadline = block.timestamp;\n\n    emit Approved(id);\n  }\n\n  /**\n   * @notice It is useful to be able to change the Senate's address without changing the expiry.\n   * @dev Does not change the expiry\n   */\n  function changeSenate(\n    DualGovernanceV3_0_Mock storage self,\n    address _newSenate\n  ) external onlySenate(self) {\n    _setSenate(self, _newSenate, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:section                           ** ONLY CONTROLLER **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice change the CONTROLLER of an ID\n   * @dev this operation cannot be reverted by the old CONTROLLER!!!\n   * @dev cannot provide address(0), try 0x000000000000000000000000000000000000dEaD\n   */\n  function changeIdCONTROLLER(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    address newCONTROLLER\n  ) external onlyController(DATASTORE, id) {\n    require(newCONTROLLER != address(0), \"GML:CONTROLLER cannot be zero\");\n\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\n    require(\n      typeOfId > ID_TYPE.LIMIT_MIN_USER && typeOfId < ID_TYPE.LIMIT_MAX_USER,\n      \"GML:ID TYPE is not user\"\n    );\n\n    DATASTORE.writeAddress(id, rks.CONTROLLER, newCONTROLLER);\n\n    emit ControllerChanged(id, newCONTROLLER);\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/GeodeModuleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - library\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n\nimport {GeodeModuleStorage} from \"../../../modules/GeodeModule/structs/storage.sol\";\nimport {GeodeModule} from \"../../../modules/GeodeModule/GeodeModule.sol\";\nimport {GeodeModuleLib} from \"../../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\n\ncontract GeodeModuleMock is GeodeModule {\n  using GeodeModuleLib for GeodeModuleStorage;\n\n  event return$propose(uint256 id);\n  event return$approveProposal(address controller, uint256 _type, bytes name);\n\n  /**\n   * @custom:section                           ** INTERNAL **\n   */\n\n  function initialize(\n    address governance,\n    address senate,\n    uint256 senateExpiry,\n    uint256 packageType,\n    bytes calldata initVersionName\n  ) external initializer {\n    __GeodeModule_init(governance, senate, senateExpiry, packageType, initVersionName);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL **\n   */\n  function isolationMode() external view virtual override returns (bool) {\n    return (_getGeodeModuleStorage().APPROVED_UPGRADE != ERC1967Utils.getImplementation() ||\n      block.timestamp > _getGeodeModuleStorage().SENATE_EXPIRY);\n  }\n\n  function isUpgradeAllowed(address proposedImplementation) public view virtual returns (bool) {\n    return\n      _getGeodeModuleStorage().isUpgradeAllowed(\n        proposedImplementation,\n        ERC1967Utils.getImplementation()\n      );\n  }\n\n  /**\n   * @custom:section                           ** FOR RETURN STATEMENTS **\n   */\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) public virtual override returns (uint256 id) {\n    id = super.propose(_CONTROLLER, _TYPE, _NAME, duration);\n    emit return$propose(id);\n  }\n\n  function approveProposal(\n    uint256 id\n  ) public virtual override returns (address _controller, uint256 _type, bytes memory _name) {\n    (_controller, _type, _name) = super.approveProposal(id);\n    emit return$approveProposal(_controller, _type, _name);\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/GeodeModuleV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {Proposal} from \"../../../modules/GeodeModule/structs/utils.sol\";\n// // globals\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// // interfaces\n// import {IGeodeModuleV3_0_Mock} from \"./interfaces/IGeodeModuleV3_0_Mock.sol\";\n// // libraries\n// import {GeodeModuleLibV3_0_Mock as GML, DualGovernanceV3_0_Mock} from \"./GeodeModuleLibV3_0_Mock.sol\";\n// import {DataStoreModuleLib as DSML} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n// // contracts\n// import {DataStoreModule} from \"../../../modules/DataStoreModule/DataStoreModule.sol\";\n// // external\n// import {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n// /**\n//  * @title GM: Geode Module\n//  *\n//  * @notice Base logic for Upgradable Packages:\n//  * * Dual Governance with Senate+Governance: Governance proposes, Senate approves.\n//  * * Limited Upgradability built on top of UUPS via Dual Governance.\n//  *\n//  * @dev review: this module delegates its functionality to GML (GeodeModuleLib):\n//  * GML has onlyGovernance, onlySenate, onlyController modifiers for access control.\n//  *\n//  * @dev There is 1 additional functionality implemented apart from the library:\n//  * Mutating UUPS pattern to fit Limited Upgradability:\n//  * 1. New implementation contract is proposed with its own package type within the limits, refer to globals/id_type.sol.\n//  * 2. Proposal is approved by the contract owner, Senate.\n//  * 3. approveProposal calls _handleUpgrade which mimics UUPS.upgradeTo:\n//  * 3.1. Checks the implementation address with _authorizeUpgrade, also preventing any UUPS upgrades.\n//  * 3.2. Upgrades the contract with no function to call afterwards.\n//  * 3.3. Sets contract version. Note that it does not increase linearly like one might expect.\n//  *\n//  * @dev 1 function needs to be overriden when inherited: isolationMode. (also refer to approveProposal)\n//  *\n//  * @dev __GeodeModule_init (or _unchained) call is NECESSARY when inherited.\n//  * However, deployer MUST call initializer after upgradeTo call,\n//  * should not call initializer on upgradeToAndCall or new ERC1967Proxy calls.\n//  *\n//  * @dev This module inherits DataStoreModule.\n//  *\n//  * @author Ice Bear & Crash Bandicoot\n//  */\n// abstract contract GeodeModuleV3_0_Mock is IGeodeModuleV3_0_Mock, UUPSUpgradeable, DataStoreModule {\n//   using GML for DualGovernanceV3_0_Mock;\n\n//   /**\n//    * @custom:section                           ** VARIABLES **\n//    *\n//    * @dev Do not add any other variables here. Modules do not have a gap.\n//    * Library's main struct has a gap, providing up to 16 storage slots for this module.\n//    */\n//   DualGovernanceV3_0_Mock internal GEODE;\n\n//   /**\n//    * @custom:section                           ** EVENTS **\n//    */\n//   event ContractVersionSet(uint256 version);\n\n//   event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n//   event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n//   event Approved(uint256 ID);\n//   event NewSenate(address senate, uint256 expiry);\n\n//   /**\n//    * @custom:section                           ** ABSTRACT FUNCTIONS **\n//    */\n//   function isolationMode() external view virtual override returns (bool);\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n\n//   function __GeodeModule_init(\n//     address governance,\n//     address senate,\n//     uint256 senateExpiry,\n//     uint256 packageType,\n//     bytes calldata initVersionName\n//   ) internal onlyInitializing {\n//     __UUPSUpgradeable_init();\n//     __DataStoreModule_init();\n//     __GeodeModule_init_unchained(governance, senate, senateExpiry, packageType, initVersionName);\n//   }\n\n//   /**\n//    * @dev This function uses _getImplementation(), clearly deployer should not call initializer on\n//    * upgradeToAndCall or new ERC1967Proxy calls. _getImplementation() returns 0 then.\n//    * @dev GOVERNANCE and SENATE set to msg.sender at beginning, cannot propose+approve otherwise.\n//    * @dev native approveProposal(public) is not used here. Because it has an _handleUpgrade,\n//    * however initialization does not require UUPS.upgradeTo.\n//    */\n//   function __GeodeModule_init_unchained(\n//     address governance,\n//     address senate,\n//     uint256 senateExpiry,\n//     uint256 packageType,\n//     bytes calldata initVersionName\n//   ) internal onlyInitializing {\n//     require(governance != address(0), \"GM:governance cannot be zero\");\n//     require(senate != address(0), \"GM:senate cannot be zero\");\n//     require(senateExpiry > block.timestamp, \"GM:low senateExpiry\");\n//     require(packageType != 0, \"GM:packageType cannot be zero\");\n//     require(initVersionName.length != 0, \"GM:initVersionName cannot be empty\");\n\n//     GEODE.GOVERNANCE = msg.sender;\n//     GEODE.SENATE = msg.sender;\n\n//     GEODE.SENATE_EXPIRY = senateExpiry;\n//     GEODE.PACKAGE_TYPE = packageType;\n\n//     uint256 initVersion = GEODE.propose(\n//       DATASTORE,\n//       ERC1967Utils.getImplementation(),\n//       packageType,\n//       initVersionName,\n//       1 days\n//     );\n\n//     GEODE.approveProposal(DATASTORE, initVersion);\n\n//     _setContractVersion(DSML.generateId(initVersionName, GEODE.PACKAGE_TYPE));\n\n//     GEODE.GOVERNANCE = governance;\n//     GEODE.SENATE = senate;\n//   }\n\n//   function __GeodeModule_initV3_0_Mock(uint256 value) internal onlyInitializing {\n//     GEODE.setFreshSlot(value);\n//   }\n\n//   function setFreshSlot(uint256 value) public virtual override {\n//     GEODE.setFreshSlot(value);\n//   }\n\n//   function getFreshSlot() external view virtual override returns (uint256) {\n//     return GEODE.getFreshSlot();\n//   }\n\n//   /**\n//    * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n//    *\n//    * @custom:visibility -> internal\n//    */\n\n//   /**\n//    * @dev required by the OZ UUPS module, improved by the Geode Module.\n//    */\n//   function _authorizeUpgrade(address proposed_implementation) internal virtual override {\n//     require(\n//       GEODE.isUpgradeAllowed(proposed_implementation, ERC1967Utils.getImplementation()),\n//       \"GM:not allowed to upgrade\"\n//     );\n//   }\n\n//   function _setContractVersion(uint256 id) internal virtual {\n//     GEODE.CONTRACT_VERSION = id;\n//     emit ContractVersionSet(id);\n//   }\n\n//   /**\n//    * @dev Would use the public upgradeTo() call, which does _authorizeUpgrade and _upgradeToAndCallUUPS,\n//    * but it is external, OZ have not made it public yet.\n//    */\n//   function _handleUpgrade(address proposed_implementation, uint256 id) internal virtual {\n//     upgradeToAndCall(proposed_implementation, \"\");\n//     _setContractVersion(id);\n//   }\n\n//   /**\n//    * @custom:section                           ** GETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> view-external\n//    */\n\n//   function GeodeParams()\n//     external\n//     view\n//     virtual\n//     override\n//     returns (\n//       address governance,\n//       address senate,\n//       address approvedUpgrade,\n//       uint256 senateExpiry,\n//       uint256 packageType\n//     )\n//   {\n//     governance = GEODE.GOVERNANCE;\n//     senate = GEODE.SENATE;\n//     approvedUpgrade = GEODE.APPROVED_UPGRADE;\n//     senateExpiry = GEODE.SENATE_EXPIRY;\n//     packageType = GEODE.PACKAGE_TYPE;\n//   }\n\n//   function getContractVersion() public view virtual override returns (uint256) {\n//     return GEODE.CONTRACT_VERSION;\n//   }\n\n//   function getProposal(\n//     uint256 id\n//   ) external view virtual override returns (Proposal memory proposal) {\n//     proposal = GEODE.getProposal(id);\n//   }\n\n//   /**\n//    * @custom:section                           ** SETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> public/external\n//    */\n\n//   /**\n//    * @custom:subsection                        ** ONLY GOVERNANCE **\n//    *\n//    */\n\n//   function propose(\n//     address _CONTROLLER,\n//     uint256 _TYPE,\n//     bytes calldata _NAME,\n//     uint256 duration\n//   ) public virtual override returns (uint256 id) {\n//     id = GEODE.propose(DATASTORE, _CONTROLLER, _TYPE, _NAME, duration);\n//   }\n\n//   function rescueSenate(address _newSenate) external virtual override {\n//     GEODE.rescueSenate(_newSenate);\n//   }\n\n//   /**\n//    * @custom:subsection                        ** ONLY SENATE **\n//    */\n\n//   /**\n//    * @dev handles PACKAGE_TYPE proposals by upgrading the contract immediately.\n//    */\n//   function approveProposal(\n//     uint256 id\n//   ) public virtual override returns (address _controller, uint256 _type, bytes memory _name) {\n//     (_controller, _type, _name) = GEODE.approveProposal(DATASTORE, id);\n\n//     if (_type == GEODE.PACKAGE_TYPE) {\n//       _handleUpgrade(_controller, id);\n//     }\n//   }\n\n//   function changeSenate(address _newSenate) external virtual override {\n//     GEODE.changeSenate(_newSenate);\n//   }\n\n//   /**\n//    * @custom:subsection                        ** ONLY CONTROLLER **\n//    */\n\n//   function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external virtual override {\n//     GML.changeIdCONTROLLER(DATASTORE, id, newCONTROLLER);\n//   }\n// }\n"
    },
    "contracts/helpers/test/mocks/GeodeUpgradedMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {GeodeModuleMock} from \"./GeodeModuleMock.sol\";\nimport {GeodeModuleLib} from \"../../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport {Proposal} from \"../../../modules/GeodeModule/structs/utils.sol\";\n\ncontract GeodeUpgradedMock is GeodeModuleMock {\n  ///  @custom:storage-location erc7201:geode.storage.GeodeModule\n  struct GeodeModuleUpgradedStorage {\n    address GOVERNANCE;\n    address SENATE;\n    address APPROVED_UPGRADE;\n    uint256 SENATE_EXPIRY;\n    uint256 PACKAGE_TYPE;\n    uint256 CONTRACT_VERSION;\n    mapping(uint256 => Proposal) proposals;\n    uint256 dumbStorageSlot;\n  }\n\n  using GeodeModuleLib for GeodeModuleUpgradedStorage;\n\n  bytes32 private constant GeodeModuleUpgradedStorageLocation =\n    0x121584cf2b7b1dee51ceaabc76cdefc72f829ce42dd8cc5282d8e9f009b04200;\n\n  function _getGeodeModuleUpgradedStorage()\n    internal\n    pure\n    returns (GeodeModuleUpgradedStorage storage $)\n  {\n    assembly {\n      $.slot := GeodeModuleUpgradedStorageLocation\n    }\n  }\n\n  function GeodeParamsV2()\n    external\n    view\n    virtual\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType,\n      uint256 dumbStorageSlot\n    )\n  {\n    GeodeModuleUpgradedStorage storage $ = _getGeodeModuleUpgradedStorage();\n\n    governance = $.GOVERNANCE;\n    senate = $.SENATE;\n    approvedUpgrade = $.APPROVED_UPGRADE;\n    senateExpiry = $.SENATE_EXPIRY;\n    packageType = $.PACKAGE_TYPE;\n    dumbStorageSlot = $.dumbStorageSlot;\n  }\n\n  function initialize2(uint value) external reinitializer(2) {\n    GeodeModuleUpgradedStorage storage $ = _getGeodeModuleUpgradedStorage();\n    $.dumbStorageSlot = value;\n  }\n\n  function setDumb(uint value) external {\n    GeodeModuleUpgradedStorage storage $ = _getGeodeModuleUpgradedStorage();\n    $.dumbStorageSlot = value;\n  }\n\n  function getDumb() external view returns (uint256) {\n    GeodeModuleUpgradedStorage storage $ = _getGeodeModuleUpgradedStorage();\n    return $.dumbStorageSlot;\n  }\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) public virtual override returns (uint256 id) {\n    require(0 == 1, \"This function is overriden!\");\n    return 0;\n  }\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IFreshSlotModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\ninterface IFreshSlotModule {\n  function setFreshSlot(uint256 value) external;\n\n  function getFreshSlot() external view returns (uint256);\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IGeodeModuleV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {IDataStoreModule} from \"../../../../interfaces/modules/IDataStoreModule.sol\";\nimport {Proposal} from \"../../../../modules/GeodeModule/structs/utils.sol\";\n\ninterface IGeodeModuleV3_0_Mock is IDataStoreModule {\n  function setFreshSlot(uint256 value) external;\n\n  function getFreshSlot() external view returns (uint256);\n\n  function isolationMode() external view returns (bool);\n\n  function GeodeParams()\n    external\n    view\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType\n    );\n\n  function getContractVersion() external view returns (uint256);\n\n  function getProposal(uint256 id) external view returns (Proposal memory proposal);\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external returns (uint256 id);\n\n  function rescueSenate(address _newSenate) external;\n\n  function approveProposal(\n    uint256 id\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\n\n  function changeSenate(address _newSenate) external;\n\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/ILiquidityPoolV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {ILiquidityModule} from \"../../../../interfaces/modules/ILiquidityModule.sol\";\nimport {IGeodePackage} from \"../../../../interfaces/packages/IGeodePackage.sol\";\n\ninterface ILiquidityPoolV2_0_Mock is IGeodePackage, ILiquidityModule {\n  function initializeV2_0_Mock(uint256 _freshSlot) external;\n\n  function setFreshSlot(uint256 value) external;\n\n  function getFreshSlot() external view returns (uint256);\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IPortalV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\nimport {IGeodeModule} from \"../../../../interfaces/modules/IGeodeModule.sol\";\nimport {IStakeModule} from \"../../../../interfaces/modules/IStakeModule.sol\";\n\ninterface IPortalV2_0_Mock is IStakeModule, IGeodeModule {\n  function initializeV2_0_Mock(uint256 value) external;\n\n  function setFreshSlot(uint256 value) external;\n\n  function getFreshSlot() external view returns (uint256);\n\n  function pausegETH() external;\n\n  function unpausegETH() external;\n\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\n\n  function releasePrisoned(uint256 operatorId) external;\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IPortalV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\nimport {IGeodeModuleV3_0_Mock} from \"./IGeodeModuleV3_0_Mock.sol\";\nimport {IStakeModule} from \"../../../../interfaces/modules/IStakeModule.sol\";\n\ninterface IPortalV3_0_Mock is IStakeModule, IGeodeModuleV3_0_Mock {\n  function initializeV3_0_Mock(uint256 value) external;\n\n  function pausegETH() external;\n\n  function unpausegETH() external;\n\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\n\n  function releasePrisoned(uint256 operatorId) external;\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IPortalV4_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\nimport {IGeodeModule} from \"../../../../interfaces/modules/IGeodeModule.sol\";\nimport {IStakeModule} from \"../../../../interfaces/modules/IStakeModule.sol\";\nimport {IFreshSlotModule} from \"./IFreshSlotModule.sol\";\n\ninterface IPortalV4_0_Mock is IStakeModule, IGeodeModule, IFreshSlotModule {\n  function initializeV4_0_Mock(uint256 value) external;\n\n  function pausegETH() external;\n\n  function unpausegETH() external;\n\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\n\n  function releasePrisoned(uint256 operatorId) external;\n}\n"
    },
    "contracts/helpers/test/mocks/interfaces/IWithdrawalContractV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {IWithdrawalModule} from \"../../../../interfaces/modules/IWithdrawalModule.sol\";\nimport {IGeodePackage} from \"../../../../interfaces/packages/IGeodePackage.sol\";\n\ninterface IWithdrawalContractV2_0_Mock is IGeodePackage, IWithdrawalModule {\n  function initializeV2_0_Mock(uint256 _freshSlot) external;\n\n  function setFreshSlot(uint256 value) external;\n\n  function getFreshSlot() external view returns (uint256);\n}\n"
    },
    "contracts/helpers/test/mocks/LiquidityModuleMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {LiquidityModuleStorage} from \"../../../modules/LiquidityModule/structs/storage.sol\";\nimport {LiquidityModule} from \"../../../modules/LiquidityModule/LiquidityModule.sol\";\nimport {LiquidityModuleLib as LML} from \"../../../modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\nimport {AmplificationLib as AL} from \"../../../modules/LiquidityModule/libs/AmplificationLib.sol\";\n\ncontract LiquidityModuleMock is LiquidityModule {\n  using LML for LiquidityModuleStorage;\n  using AL for LiquidityModuleStorage;\n\n  event return$swap(uint256 ret0);\n\n  event return$addLiquidity(uint256 ret0);\n\n  event return$removeLiquidity(uint256[2] ret0);\n\n  event return$removeLiquidityOneToken(uint256 ret0);\n\n  event return$removeLiquidityImbalance(uint256 ret0);\n\n  function initialize(\n    address _gETH_position,\n    address _lpToken_referance,\n    uint256 _pooledTokenId,\n    uint256 _initialA,\n    uint256 _swapFee,\n    string calldata _poolName\n  ) external initializer {\n    __LiquidityModule_init(\n      _gETH_position,\n      _lpToken_referance,\n      _pooledTokenId,\n      _initialA,\n      _swapFee,\n      _poolName\n    );\n  }\n\n  function pause() external virtual override {\n    _pause();\n  }\n\n  function unpause() external virtual override {\n    _unpause();\n  }\n\n  /**\n   * @custom:section                           ** FOR RETURN STATEMENTS **\n   */\n\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) public payable virtual override returns (uint256 ret0) {\n    (ret0) = super.swap(tokenIndexFrom, tokenIndexTo, dx, minDy, deadline);\n    emit return$swap(ret0);\n  }\n\n  function addLiquidity(\n    uint256[2] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) public payable override returns (uint256 ret0) {\n    (ret0) = super.addLiquidity(amounts, minToMint, deadline);\n    emit return$addLiquidity(ret0);\n  }\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[2] calldata minAmounts,\n    uint256 deadline\n  ) public override returns (uint256[2] memory ret0) {\n    (ret0) = super.removeLiquidity(amount, minAmounts, deadline);\n    emit return$removeLiquidity(ret0);\n  }\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) public override returns (uint256 ret0) {\n    (ret0) = super.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount, deadline);\n    emit return$removeLiquidityOneToken(ret0);\n  }\n\n  function removeLiquidityImbalance(\n    uint256[2] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) public override returns (uint256 ret0) {\n    (ret0) = super.removeLiquidityImbalance(amounts, maxBurnAmount, deadline);\n    emit return$removeLiquidityImbalance(ret0);\n  }\n\n  /**\n   * @custom:section                           ** LIQUIDITY POOL ADMIN **\n   */\n\n  function setSwapFee(uint256 newSwapFee) public virtual override {\n    _getLiquidityModuleStorage().setSwapFee(newSwapFee);\n  }\n\n  function setAdminFee(uint256 newAdminFee) public virtual override {\n    _getLiquidityModuleStorage().setAdminFee(newAdminFee);\n  }\n\n  function withdrawAdminFees(address receiver) public virtual override {\n    _getLiquidityModuleStorage().withdrawAdminFees(receiver);\n  }\n\n  function rampA(uint256 futureA, uint256 futureTime) public virtual override {\n    _getLiquidityModuleStorage().rampA(futureA, futureTime);\n  }\n\n  function stopRampA() public virtual override {\n    _getLiquidityModuleStorage().stopRampA();\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/helpers/test/mocks/LiquidityPoolV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {DualGovernance} from \"../../../modules/GeodeModule/structs/storage.sol\";\n// import {Swap} from \"../../../modules/LiquidityModule/structs/storage.sol\";\n// // globals\n// import {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// import {PERCENTAGE_DENOMINATOR} from \"../../../globals/macros.sol\";\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// // interfaces\n// import {IPortal} from \"../../../interfaces/IPortal.sol\";\n// import {ILiquidityPoolV2_0_Mock} from \"./interfaces/ILiquidityPoolV2_0_Mock.sol\";\n// import {IGeodeModule} from \"../../../interfaces/modules/IGeodeModule.sol\";\n// import {ILiquidityModule} from \"../../../interfaces/modules/ILiquidityModule.sol\";\n// // libraries\n// import {GeodeModuleLib as GML} from \"../../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\n// import {AmplificationLib as AL} from \"../../../modules/LiquidityModule/libs/AmplificationLib.sol\";\n// import {LiquidityModuleLib as LML} from \"../../../modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\n// // contracts\n// import {GeodeModule} from \"../../../modules/GeodeModule/GeodeModule.sol\";\n// import {LiquidityModule} from \"../../../modules/LiquidityModule/LiquidityModule.sol\";\n\n// /**\n//  * @title LPP: Liquidity Pool Package: Geode Module + Liquidity Module\n//  *\n//  * @notice LPP is a package that provides a liquidity pool for a staking pool created through Portal.\n//  *\n//  * @dev TYPE: PACKAGE_LIQUIDITY_POOL\n//  * @dev Utilizing IGeodePackage interface, meaning initialize function takes 3 parameters:\n//  * * * poolOwner: will be assigned as the senate of the package\n//  * * * pooledTokenId: used internally on LM and LML.\n//  * * * data: referances 1 parameter: name. Used to generate lpTokenName and lpTokenSymbol for __LM_init.\n//  *\n//  * @dev review: LM for StableSwap implementation. Also note:\n//  * * initial and future A coefficients are set as 60 (LM)\n//  * * trade fee set to 4 bips (LM)\n//  * * owner fee is set to 0 (LM)\n//  * * senate expiry is not effective (GM)\n//  *\n//  * @dev review: GM for The Limited Upgradability through Dual Governance:\n//  * * Governance is the Portal, package version controller.\n//  * * Senate is the Staking Pool Owner.\n//  *\n//  * @author Ice Bear & Crash Bandicoot\n//  */\n// contract LiquidityPoolV2_0_Mock is ILiquidityPoolV2_0_Mock, GeodeModule, LiquidityModule {\n//   using GML for DualGovernance;\n//   using AL for Swap;\n//   using LML for Swap;\n\n//   /**\n//    * @custom:section                           ** VARIABLES **\n//    *\n//    * @dev Following immutable parameters are set when the referance library implementation is deployed.\n//    * It is not desired to provide these package-specific not-changing parameters\n//    * accross all instances of the packages.\n//    * So, we will store them in the ref implementation contract of the package,\n//    * and fetch when needed on initialization of an instance.\n//    */\n//   /// @notice gETH position\n//   address internal immutable gETHPos;\n//   /// @notice Portal position\n//   address internal immutable portalPos;\n//   /// @notice LPToken implementation referance, needs to be cloned\n//   address internal immutable LPTokenRef;\n//   /// @notice LPP package type, useful for Limited Upgradability\n\n//   uint256 freshSlot;\n//   /**\n//    * @custom:section                           ** MODIFIERS **\n//    */\n\n//   modifier onlyOwner() {\n//     require(msg.sender == GEODE.SENATE, \"LPP:sender not owner\");\n//     _;\n//   }\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n\n//   /**\n//    * @custom:oz-upgrades-unsafe-allow constructor\n//    */\n//   constructor(address _gETHPos, address _portalPos, address _LPTokenRef) {\n//     require(_gETHPos != address(0), \"LPP:_gETHPos cannot be zero\");\n//     require(_portalPos != address(0), \"LPP:_portalPos cannot be zero\");\n//     require(_LPTokenRef != address(0), \"LPP:_LPTokenRef cannot be zero\");\n\n//     gETHPos = _gETHPos;\n//     portalPos = _portalPos;\n//     LPTokenRef = _LPTokenRef;\n\n//     _disableInitializers();\n//   }\n\n//   /**\n//    * @param data only poolName is required from Portal\n//    */\n//   function initialize(\n//     uint256 pooledTokenId,\n//     address poolOwner,\n//     bytes calldata versionName,\n//     bytes calldata data\n//   ) public virtual override initializer {\n//     __LiquidityPool_init(pooledTokenId, poolOwner, versionName, data);\n//   }\n\n//   function initializeV2_0_Mock(uint256 _freshSlot) public virtual override reinitializer(2) {\n//     setFreshSlot(_freshSlot);\n//   }\n\n//   function __LiquidityPool_init(\n//     uint256 pooledTokenId,\n//     address poolOwner,\n//     bytes calldata versionName,\n//     bytes calldata data\n//   ) internal onlyInitializing {\n//     __GeodeModule_init(\n//       portalPos,\n//       poolOwner,\n//       type(uint256).max,\n//       ID_TYPE.PACKAGE_LIQUIDITY_POOL,\n//       versionName\n//     );\n//     __LiquidityModule_init(\n//       gETHPos,\n//       LPTokenRef,\n//       pooledTokenId,\n//       60,\n//       (4 * PERCENTAGE_DENOMINATOR) / 10000,\n//       string(data)\n//     );\n//     __LiquidityPool_init_unchained();\n//   }\n\n//   function __LiquidityPool_init_unchained() internal onlyInitializing {}\n\n//   function setFreshSlot(uint256 value) public virtual override {\n//     freshSlot = value;\n//   }\n\n//   function getFreshSlot() external view virtual override returns (uint256) {\n//     return freshSlot;\n//   }\n\n//   /**\n//    * @custom:section                           ** GETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> view-public\n//    */\n\n//   /**\n//    * @notice get the gETH ID of the corresponding staking pool\n//    */\n//   function getPoolId() public view override returns (uint256) {\n//     return LIQUIDITY.pooledTokenId;\n//   }\n\n//   /**\n//    * @notice get Portal as a contract\n//    */\n//   function getPortal() public view override returns (IPortal) {\n//     return IPortal(GEODE.GOVERNANCE);\n//   }\n\n//   /**\n//    * @dev GeodeModule override\n//    */\n//   function getProposedVersion() public view virtual override returns (uint256) {\n//     return getPortal().getPackageVersion(GEODE.PACKAGE_TYPE);\n//   }\n\n//   /**\n//    * @dev GeodeModule override\n//    *\n//    * @custom:visibility -> view\n//    */\n//   function isolationMode()\n//     external\n//     view\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (bool)\n//   {\n//     if (paused()) {\n//       return true;\n//     }\n\n//     if (getContractVersion() != getProposedVersion()) {\n//       return true;\n//     }\n\n//     if (GEODE.APPROVED_UPGRADE != ERC1967Utils.getImplementation()) {\n//       return true;\n//     }\n\n//     if (getPortal().readAddress(getPoolId(), rks.CONTROLLER) != GEODE.SENATE) {\n//       return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * @custom:section                           ** ADMIN FUNCTIONS **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   /**\n//    * @custom:subsection                           ** UPGRADABILITY FUNCTIONS **\n//    */\n\n//   /**\n//    * @dev IGeodePackage override\n//    */\n//   function pullUpgrade() external virtual override onlyOwner {\n//     require(!(getPortal().isolationMode()), \"LPP:Portal is isolated\");\n//     require(getProposedVersion() != getContractVersion(), \"LPP:no upgrades\");\n\n//     uint256 id = getPortal().pushUpgrade(GEODE.PACKAGE_TYPE);\n//     approveProposal(id);\n//   }\n\n//   /**\n//    * @custom:subsection                           ** PAUSABILITY FUNCTIONS **\n//    */\n\n//   /**\n//    * @notice pausing the contract activates the isolationMode\n//    */\n//   function pause() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     _pause();\n//   }\n\n//   /**\n//    * @notice unpausing the contract deactivates the isolationMode\n//    */\n//   function unpause() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     _unpause();\n//   }\n\n//   /**\n//    * @custom:subsection                           ** LIQUIDITY POOL **\n//    *\n//    * @dev LM override\n//    */\n\n//   function setSwapFee(\n//     uint256 newSwapFee\n//   ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     LIQUIDITY.setSwapFee(newSwapFee);\n//   }\n\n//   function setAdminFee(\n//     uint256 newAdminFee\n//   ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     LIQUIDITY.setAdminFee(newAdminFee);\n//   }\n\n//   function withdrawAdminFees(\n//     address receiver\n//   ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     LIQUIDITY.withdrawAdminFees(receiver);\n//   }\n\n//   function rampA(\n//     uint256 futureA,\n//     uint256 futureTime\n//   ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     LIQUIDITY.rampA(futureA, futureTime);\n//   }\n\n//   function stopRampA() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n//     LIQUIDITY.stopRampA();\n//   }\n\n//   /**\n//    * @notice fallback functions\n//    */\n\n//   receive() external payable {}\n\n//   /**\n//    * @notice keep the total number of variables at 50\n//    */\n//   uint256[49] private __gap;\n// }\n"
    },
    "contracts/helpers/test/mocks/OracleExtensionLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"../../../modules/StakeModule/structs/storage.sol\";\nimport {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\nimport {InitiatorExtensionLib} from \"../../../modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport {StakeModuleLib} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {OracleExtensionLib} from \"../../../modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport {DataStoreModuleLib} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract OracleExtensionLibMock is StakeModule {\n  using StakeModuleLib for StakeModuleStorage;\n  using OracleExtensionLib for StakeModuleStorage;\n  using InitiatorExtensionLib for StakeModuleStorage;\n  using DataStoreModuleLib for DataStoreModuleStorage;\n\n  function initialize(address _gETH_position, address _oracle_position) external initializer {\n    __StakeModule_init(_gETH_position, _oracle_position);\n  }\n\n  function pause() external virtual override {\n    _pause();\n  }\n\n  function unpause() external virtual override {\n    _unpause();\n  }\n\n  function setInfrastructureFee(uint256 _type, uint256 fee) external virtual override {\n    _getStakeModuleStorage().setInfrastructureFee(_type, fee);\n  }\n\n  function setBeaconDelays(uint256 entry, uint256 exit) external virtual override {\n    _getStakeModuleStorage().setBeaconDelays(entry, exit);\n  }\n\n  function setInitiationDeposit(uint256 newInitiationDeposit) external virtual override {\n    _getStakeModuleStorage().setInitiationDeposit(newInitiationDeposit);\n  }\n\n  /**\n   * @custom:section                           ** DATA MANIPULATORS **\n   */\n  function $writeUint(uint256 _id, bytes32 _key, uint256 _data) external {\n    _getDataStoreModuleStorage().writeUint(_id, _key, _data);\n  }\n\n  function $writeBytes(uint256 _id, bytes32 _key, bytes calldata _data) external {\n    _getDataStoreModuleStorage().writeBytes(_id, _key, _data);\n  }\n\n  function $writeAddress(uint256 _id, bytes32 _key, address _data) external {\n    _getDataStoreModuleStorage().writeAddress(_id, _key, _data);\n  }\n\n  function $set_ORACLE_POSITION(address _data) external {\n    _getStakeModuleStorage().ORACLE_POSITION = _data;\n  }\n\n  function $set_VALIDATORS_INDEX(uint256 _data) external {\n    _getStakeModuleStorage().VALIDATORS_INDEX = _data;\n  }\n\n  function $set_VERIFICATION_INDEX(uint256 _data) external {\n    _getStakeModuleStorage().VERIFICATION_INDEX = _data;\n  }\n\n  function $set_MONOPOLY_THRESHOLD(uint256 _data) external {\n    _getStakeModuleStorage().MONOPOLY_THRESHOLD = _data;\n  }\n\n  function $set_ORACLE_UPDATE_TIMESTAMP(uint256 _data) external {\n    _getStakeModuleStorage().ORACLE_UPDATE_TIMESTAMP = _data;\n  }\n\n  function $set_package(uint256 _type, uint256 package) external {\n    _getStakeModuleStorage().packages[_type] = package;\n  }\n\n  function $set_middleware(uint256 _type, uint256 middleware) external {\n    _getStakeModuleStorage().middlewares[_type][middleware] = true;\n  }\n\n  function $set_PricePerShare(uint256 price, uint256 poolId) external {\n    _getStakeModuleStorage().gETH.setPricePerShare(price, poolId);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL **\n   */\n  function $_alienateValidator(bytes calldata _pk) external {\n    return\n      _getStakeModuleStorage()._alienateValidator(\n        _getDataStoreModuleStorage(),\n        _getStakeModuleStorage().VERIFICATION_INDEX,\n        _pk\n      );\n  }\n\n  function $_sanityCheck(uint256 _id, uint256 _newPrice) external view {\n    return _getStakeModuleStorage()._sanityCheck(_getDataStoreModuleStorage(), _id, _newPrice);\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/helpers/test/mocks/PortalV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\n// import {DualGovernance} from \"../../../modules/GeodeModule/structs/storage.sol\";\n// import {StakeModuleStorage} from \"../../../modules/StakeModule/structs/storage.sol\";\n// // globals\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// // interfaces\n// import {IPortalV2_0_Mock} from \"./interfaces/IPortalV2_0_Mock.sol\";\n// import {IGeodeModule} from \"../../../interfaces/modules/IGeodeModule.sol\";\n// import {IStakeModule} from \"../../../interfaces/modules/IStakeModule.sol\";\n// // libraries\n// import {DataStoreModuleLib as DSML} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n// import {GeodeModuleLib as GML} from \"../../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\n// import {StakeModuleLib as SML} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\n// // contracts\n// import {GeodeModule} from \"../../../modules/GeodeModule/GeodeModule.sol\";\n// import {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\n\n// contract PortalV2_0_Mock is IPortalV2_0_Mock, GeodeModule, StakeModule {\n//   using DSML for DataStoreModuleStorage;\n//   using GML for DualGovernance;\n//   using SML for StakeModuleStorage;\n\n//   uint256 freshSlot;\n//   /**\n//    * @custom:section                           ** EVENTS **\n//    */\n//   event Released(uint256 operatorId);\n//   event GovernanceFeeSet(uint256 fee);\n\n//   /**\n//    * @custom:section                           ** MODIFIERS **\n//    */\n//   modifier onlyGovernance() {\n//     require(msg.sender == GEODE.GOVERNANCE, \"PORTAL:sender not governance\");\n//     _;\n//   }\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n\n//   ///@custom:oz-upgrades-unsafe-allow constructor\n//   constructor() {\n//     _disableInitializers();\n//   }\n\n//   function initialize(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) public virtual initializer {\n//     __Portal_init(_governance, _senate, _gETH, _oracle_position, versionName);\n//   }\n\n//   /**\n//    * if you are going to need a reinitializer: bump the version. otherwise keep increasing the x in v2_x.\n//    */\n//   function initializeV2_0_Mock(uint256 value) external virtual override reinitializer(2) {\n//     setFreshSlot(value);\n//   }\n\n//   function __Portal_init(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) internal onlyInitializing {\n//     __GeodeModule_init(\n//       _governance,\n//       _senate,\n//       block.timestamp + GML.MAX_SENATE_PERIOD,\n//       ID_TYPE.PACKAGE_PORTAL,\n//       versionName\n//     );\n//     __StakeModule_init(_gETH, _oracle_position);\n//     __Portal_init_unchained();\n//   }\n\n//   function __Portal_init_unchained() internal onlyInitializing {}\n\n//   function setFreshSlot(uint256 value) public virtual override {\n//     freshSlot = value;\n//   }\n\n//   function getFreshSlot() external view virtual override returns (uint256) {\n//     return freshSlot;\n//   }\n\n//   /**\n//    * @custom:section                           ** GETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> view-external\n//    */\n\n//   /**\n//    * @dev GeodeModule override\n//    *\n//    * @notice Isolation Mode is an external view function signaling other contracts\n//    * * to isolate themselves from Portal. For example, withdrawalContract will not fetch upgrades.\n//    * @return isRecovering true if isolationMode is active:\n//    * * 1. Portal is paused\n//    * * 2. Portal needs to be upgraded\n//    * * 3. Senate expired\n//    */\n//   function isolationMode()\n//     external\n//     view\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (bool)\n//   {\n//     return (paused() ||\n//       GEODE.APPROVED_UPGRADE != ERC1967Utils.getImplementation() ||\n//       block.timestamp > GEODE.SENATE_EXPIRY);\n//   }\n\n//   /**\n//    * @custom:section                           ** GOVERNANCE FUNCTIONS **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   function pause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _pause();\n//   }\n\n//   function unpause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _unpause();\n//   }\n\n//   function pausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.pause();\n//   }\n\n//   function unpausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.unpause();\n//   }\n\n//   /**\n//    * @notice releases an imprisoned operator immediately\n//    * @dev in different situations such as a faulty imprisonment or coordinated testing periods\n//    * * Governance can release the prisoners\n//    * @dev onlyGovernance SHOULD be checked in Portal\n//    */\n//   function releasePrisoned(uint256 operatorId) external virtual override onlyGovernance {\n//     DATASTORE.writeUint(operatorId, \"release\", block.timestamp);\n\n//     emit Released(operatorId);\n//   }\n\n//   function setGovernanceFee(\n//     uint256 newFee,\n//     uint256 weight\n//   ) external virtual override onlyGovernance {\n//     STAKE.GOVERNANCE_FEE = newFee;\n\n//     setFreshSlot(newFee * weight);\n\n//     emit GovernanceFeeSet(newFee);\n//   }\n\n//   /**\n//    * @custom:section                           ** PACKAGE VERSION MANAGEMENT **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   /**\n//    * @notice approves a specific proposal\n//    * @dev OnlySenate is checked inside the GeodeModule\n//    */\n//   function approveProposal(\n//     uint256 id\n//   )\n//     public\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (address _controller, uint256 _type, bytes memory _name)\n//   {\n//     (_controller, _type, _name) = super.approveProposal(id);\n\n//     if (_type > ID_TYPE.LIMIT_MIN_PACKAGE && _type < ID_TYPE.LIMIT_MAX_PACKAGE) {\n//       STAKE.packages[_type] = id;\n//     } else if (_type > ID_TYPE.LIMIT_MIN_MIDDLEWARE && _type < ID_TYPE.LIMIT_MAX_MIDDLEWARE) {\n//       STAKE.middlewares[_type][id] = true;\n//     }\n//   }\n\n//   function pushUpgrade(\n//     uint256 packageType\n//   ) external virtual override nonReentrant whenNotPaused returns (uint256 id) {\n//     require(\n//       packageType > ID_TYPE.LIMIT_MIN_PACKAGE && packageType < ID_TYPE.LIMIT_MAX_PACKAGE,\n//       \"PORTAL:invalid package type\"\n//     );\n\n//     uint256 currentPackageVersion = STAKE.packages[packageType];\n\n//     id = IGeodeModule(msg.sender).propose(\n//       DATASTORE.readAddress(currentPackageVersion, \"CONTROLLER\"),\n//       packageType,\n//       DATASTORE.readBytes(currentPackageVersion, \"NAME\"),\n//       GML.MAX_PROPOSAL_DURATION\n//     );\n\n//     require(id > 0, \"PORTAL:cannot push upgrade\");\n//   }\n\n//   /**\n//    * @notice fallback functions\n//    */\n\n//   receive() external payable {}\n\n//   /**\n//    * @notice keep the total number of variables at 50\n//    */\n//   uint256[49] private __gap;\n// }\n"
    },
    "contracts/helpers/test/mocks/PortalV3_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\n// import {StakeModuleStorage} from \"../../../modules/StakeModule/structs/storage.sol\";\n// // globals\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// // interfaces\n// import {IPortalV3_0_Mock} from \"./interfaces/IPortalV3_0_Mock.sol\";\n// import {IGeodeModuleV3_0_Mock} from \"./interfaces/IGeodeModuleV3_0_Mock.sol\";\n// import {IStakeModule} from \"../../../interfaces/modules/IStakeModule.sol\";\n// // libraries\n// import {DataStoreModuleLib as DSML} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n// import {GeodeModuleLibV3_0_Mock as GML, DualGovernanceV3_0_Mock} from \"./GeodeModuleLibV3_0_Mock.sol\";\n// import {StakeModuleLib as SML} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\n// // contracts\n// import {GeodeModuleV3_0_Mock} from \"./GeodeModuleV3_0_Mock.sol\";\n// import {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\n\n// contract PortalV3_0_Mock is IPortalV3_0_Mock, GeodeModuleV3_0_Mock, StakeModule {\n//   using DSML for DataStoreModuleStorage;\n//   using GML for DualGovernanceV3_0_Mock;\n//   using SML for StakeModuleStorage;\n\n//   /**\n//    * @custom:section                           ** EVENTS **\n//    */\n//   event Released(uint256 operatorId);\n//   event GovernanceFeeSet(uint256 fee);\n\n//   /**\n//    * @custom:section                           ** MODIFIERS **\n//    */\n//   modifier onlyGovernance() {\n//     require(msg.sender == GEODE.GOVERNANCE, \"PORTAL:sender not governance\");\n//     _;\n//   }\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n\n//   ///@custom:oz-upgrades-unsafe-allow constructor\n//   constructor() {\n//     _disableInitializers();\n//   }\n\n//   function initialize(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) public virtual initializer {\n//     __Portal_init(_governance, _senate, _gETH, _oracle_position, versionName);\n//   }\n\n//   /**\n//    * if you are going to need a reinitializer: bump the version. otherwise keep increasing the x in v2_x.\n//    */\n//   function initializeV3_0_Mock(uint256 value) external virtual override reinitializer(2) {\n//     __GeodeModule_initV3_0_Mock(value);\n//   }\n\n//   function __Portal_init(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) internal onlyInitializing {\n//     __GeodeModule_init(\n//       _governance,\n//       _senate,\n//       block.timestamp + GML.MAX_SENATE_PERIOD,\n//       ID_TYPE.PACKAGE_PORTAL,\n//       versionName\n//     );\n//     __StakeModule_init(_gETH, _oracle_position);\n//     __Portal_init_unchained();\n//   }\n\n//   function __Portal_init_unchained() internal onlyInitializing {}\n\n//   /**\n//    * @custom:section                           ** GETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> view-external\n//    */\n\n//   /**\n//    * @dev GeodeModule override\n//    *\n//    * @notice Isolation Mode is an external view function signaling other contracts\n//    * * to isolate themselves from Portal. For example, withdrawalContract will not fetch upgrades.\n//    * @return isRecovering true if isolationMode is active:\n//    * * 1. Portal is paused\n//    * * 2. Portal needs to be upgraded\n//    * * 3. Senate expired\n//    */\n//   function isolationMode()\n//     external\n//     view\n//     virtual\n//     override(GeodeModuleV3_0_Mock, IGeodeModuleV3_0_Mock)\n//     returns (bool)\n//   {\n//     return (paused() ||\n//       GEODE.APPROVED_UPGRADE != ERC1967Utils.getImplementation() ||\n//       block.timestamp > GEODE.SENATE_EXPIRY);\n//   }\n\n//   /**\n//    * @custom:section                           ** GOVERNANCE FUNCTIONS **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   function pause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _pause();\n//   }\n\n//   function unpause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _unpause();\n//   }\n\n//   function pausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.pause();\n//   }\n\n//   function unpausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.unpause();\n//   }\n\n//   /**\n//    * @notice releases an imprisoned operator immediately\n//    * @dev in different situations such as a faulty imprisonment or coordinated testing periods\n//    * * Governance can release the prisoners\n//    * @dev onlyGovernance SHOULD be checked in Portal\n//    */\n//   function releasePrisoned(uint256 operatorId) external virtual override onlyGovernance {\n//     DATASTORE.writeUint(operatorId, \"release\", block.timestamp);\n\n//     emit Released(operatorId);\n//   }\n\n//   function setGovernanceFee(uint256 newFee) external virtual override onlyGovernance {\n//     require(newFee <= SML.MAX_GOVERNANCE_FEE, \"PORTAL:> MAX_GOVERNANCE_FEE\");\n//     require(block.timestamp > SML.GOVERNANCE_FEE_COMMENCEMENT, \"PORTAL:not yet.\");\n\n//     STAKE.GOVERNANCE_FEE = newFee;\n\n//     emit GovernanceFeeSet(newFee);\n//   }\n\n//   /**\n//    * @custom:section                           ** PACKAGE VERSION MANAGEMENT **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   /**\n//    * @notice approves a specific proposal\n//    * @dev OnlySenate is checked inside the GeodeModule\n//    */\n//   function approveProposal(\n//     uint256 id\n//   )\n//     public\n//     virtual\n//     override(GeodeModuleV3_0_Mock, IGeodeModuleV3_0_Mock)\n//     returns (address _controller, uint256 _type, bytes memory _name)\n//   {\n//     (_controller, _type, _name) = super.approveProposal(id);\n\n//     if (_type > ID_TYPE.LIMIT_MIN_PACKAGE && _type < ID_TYPE.LIMIT_MAX_PACKAGE) {\n//       STAKE.packages[_type] = id;\n//     } else if (_type > ID_TYPE.LIMIT_MIN_MIDDLEWARE && _type < ID_TYPE.LIMIT_MAX_MIDDLEWARE) {\n//       STAKE.middlewares[_type][id] = true;\n//     }\n//   }\n\n//   function pushUpgrade(\n//     uint256 packageType\n//   ) external virtual override nonReentrant whenNotPaused returns (uint256 id) {\n//     require(\n//       packageType > ID_TYPE.LIMIT_MIN_PACKAGE && packageType < ID_TYPE.LIMIT_MAX_PACKAGE,\n//       \"PORTAL:invalid package type\"\n//     );\n\n//     uint256 currentPackageVersion = STAKE.packages[packageType];\n\n//     id = IGeodeModuleV3_0_Mock(msg.sender).propose(\n//       DATASTORE.readAddress(currentPackageVersion, \"CONTROLLER\"),\n//       packageType,\n//       DATASTORE.readBytes(currentPackageVersion, \"NAME\"),\n//       GML.MAX_PROPOSAL_DURATION\n//     );\n\n//     require(id > 0, \"PORTAL:cannot push upgrade\");\n//   }\n\n//   /**\n//    * @notice fallback functions\n//    */\n\n//   receive() external payable {}\n\n//   /**\n//    * @notice keep the total number of variables at 50\n//    */\n//   uint256[50] private __gap;\n// }\n"
    },
    "contracts/helpers/test/mocks/PortalV4_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\n// import {DualGovernance} from \"../../../modules/GeodeModule/structs/storage.sol\";\n// import {StakeModuleStorage} from \"../../../modules/StakeModule/structs/storage.sol\";\n// // globals\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// // interfaces\n// import {IPortalV4_0_Mock} from \"./interfaces/IPortalV4_0_Mock.sol\";\n// import {IGeodeModule} from \"../../../interfaces/modules/IGeodeModule.sol\";\n// import {IStakeModule} from \"../../../interfaces/modules/IStakeModule.sol\";\n// // libraries\n// import {DataStoreModuleLib as DSML} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n// import {GeodeModuleLib as GML} from \"../../../modules/GeodeModule/libs/GeodeModuleLib.sol\";\n// import {StakeModuleLib as SML} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\n// import {FreshSlotModuleLib as FSL, FreshSlotStruct} from \"./FreshSlotModuleLib.sol\";\n\n// // contracts\n// import {GeodeModule} from \"../../../modules/GeodeModule/GeodeModule.sol\";\n// import {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\n// import {FreshSlotModule} from \"./FreshSlotModule.sol\";\n\n// contract PortalV4_0_Mock is IPortalV4_0_Mock, GeodeModule, StakeModule, FreshSlotModule {\n//   using DSML for DataStoreModuleStorage;\n//   using GML for DualGovernance;\n//   using SML for StakeModuleStorage;\n//   using FSL for FreshSlotStruct;\n\n//   /**\n//    * @custom:section                           ** EVENTS **\n//    */\n//   event Released(uint256 operatorId);\n//   event GovernanceFeeSet(uint256 fee);\n\n//   /**\n//    * @custom:section                           ** MODIFIERS **\n//    */\n//   modifier onlyGovernance() {\n//     require(msg.sender == GEODE.GOVERNANCE, \"PORTAL:sender not governance\");\n//     _;\n//   }\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n\n//   ///@custom:oz-upgrades-unsafe-allow constructor\n//   constructor() {\n//     _disableInitializers();\n//   }\n\n//   function initialize(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) public virtual initializer {\n//     __Portal_init(_governance, _senate, _gETH, _oracle_position, versionName);\n//   }\n\n//   /**\n//    * if you are going to need a reinitializer: bump the version. otherwise keep increasing the x in v2_x.\n//    */\n//   function initializeV4_0_Mock(uint256 value) external virtual override reinitializer(2) {\n//     __FreshSlotModule_init(value);\n//   }\n\n//   function __Portal_init(\n//     address _governance,\n//     address _senate,\n//     address _gETH,\n//     address _oracle_position,\n//     bytes calldata versionName\n//   ) internal onlyInitializing {\n//     __GeodeModule_init(\n//       _governance,\n//       _senate,\n//       block.timestamp + GML.MAX_SENATE_PERIOD,\n//       ID_TYPE.PACKAGE_PORTAL,\n//       versionName\n//     );\n//     __StakeModule_init(_gETH, _oracle_position);\n//     __Portal_init_unchained();\n//   }\n\n//   function __Portal_init_unchained() internal onlyInitializing {}\n\n//   /**\n//    * @custom:section                           ** GETTER FUNCTIONS **\n//    *\n//    * @custom:visibility -> view-external\n//    */\n\n//   /**\n//    * @dev GeodeModule override\n//    *\n//    * @notice Isolation Mode is an external view function signaling other contracts\n//    * * to isolate themselves from Portal. For example, withdrawalContract will not fetch upgrades.\n//    * @return isRecovering true if isolationMode is active:\n//    * * 1. Portal is paused\n//    * * 2. Portal needs to be upgraded\n//    * * 3. Senate expired\n//    */\n//   function isolationMode()\n//     external\n//     view\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (bool)\n//   {\n//     return (paused() ||\n//       GEODE.APPROVED_UPGRADE != ERC1967Utils.getImplementation() ||\n//       block.timestamp > GEODE.SENATE_EXPIRY);\n//   }\n\n//   /**\n//    * @custom:section                           ** GOVERNANCE FUNCTIONS **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   function pause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _pause();\n//   }\n\n//   function unpause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n//     _unpause();\n//   }\n\n//   function pausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.pause();\n//   }\n\n//   function unpausegETH() external virtual override onlyGovernance {\n//     STAKE.gETH.unpause();\n//   }\n\n//   /**\n//    * @notice releases an imprisoned operator immediately\n//    * @dev in different situations such as a faulty imprisonment or coordinated testing periods\n//    * * Governance can release the prisoners\n//    * @dev onlyGovernance SHOULD be checked in Portal\n//    */\n//   function releasePrisoned(uint256 operatorId) external virtual override onlyGovernance {\n//     DATASTORE.writeUint(operatorId, \"release\", block.timestamp);\n\n//     emit Released(operatorId);\n//   }\n\n//   function setGovernanceFee(uint256 newFee) external virtual override onlyGovernance {\n//     require(newFee <= SML.MAX_GOVERNANCE_FEE, \"PORTAL:> MAX_GOVERNANCE_FEE\");\n//     require(block.timestamp > SML.GOVERNANCE_FEE_COMMENCEMENT, \"PORTAL:not yet.\");\n\n//     STAKE.GOVERNANCE_FEE = newFee;\n\n//     emit GovernanceFeeSet(newFee);\n//   }\n\n//   /**\n//    * @custom:section                           ** PACKAGE VERSION MANAGEMENT **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   /**\n//    * @notice approves a specific proposal\n//    * @dev OnlySenate is checked inside the GeodeModule\n//    */\n//   function approveProposal(\n//     uint256 id\n//   )\n//     public\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (address _controller, uint256 _type, bytes memory _name)\n//   {\n//     (_controller, _type, _name) = super.approveProposal(id);\n\n//     if (_type > ID_TYPE.LIMIT_MIN_PACKAGE && _type < ID_TYPE.LIMIT_MAX_PACKAGE) {\n//       STAKE.packages[_type] = id;\n//     } else if (_type > ID_TYPE.LIMIT_MIN_MIDDLEWARE && _type < ID_TYPE.LIMIT_MAX_MIDDLEWARE) {\n//       STAKE.middlewares[_type][id] = true;\n//     }\n//   }\n\n//   function pushUpgrade(\n//     uint256 packageType\n//   ) external virtual override nonReentrant whenNotPaused returns (uint256 id) {\n//     require(\n//       packageType > ID_TYPE.LIMIT_MIN_PACKAGE && packageType < ID_TYPE.LIMIT_MAX_PACKAGE,\n//       \"PORTAL:invalid package type\"\n//     );\n\n//     uint256 currentPackageVersion = STAKE.packages[packageType];\n\n//     id = IGeodeModule(msg.sender).propose(\n//       DATASTORE.readAddress(currentPackageVersion, \"CONTROLLER\"),\n//       packageType,\n//       DATASTORE.readBytes(currentPackageVersion, \"NAME\"),\n//       GML.MAX_PROPOSAL_DURATION\n//     );\n\n//     require(id > 0, \"PORTAL:cannot push upgrade\");\n//   }\n\n//   /**\n//    * @notice fallback functions\n//    */\n\n//   receive() external payable {}\n\n//   /**\n//    * @notice keep the total number of variables at 50\n//    * @dev structs are storage sluts :)\n//    */\n//   uint256[40] private __gap;\n//   // IMPORTANT NOTE: For upgrade to work need to rearrange the gap variable.\n//   // It may be possible that we are using wrong gap initially\n// }\n"
    },
    "contracts/helpers/test/mocks/StakeModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// structs\nimport {StakeModuleStorage} from \"../../../modules/StakeModule/structs/storage.sol\";\nimport {DataStoreModuleStorage} from \"../../../modules/DataStoreModule/structs/storage.sol\";\n\nimport {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\nimport {StakeModuleLib} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {InitiatorExtensionLib} from \"../../../modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport {OracleExtensionLib} from \"../../../modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport {DataStoreModuleLib} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract StakeModuleLibMock is StakeModule {\n  using DataStoreModuleLib for DataStoreModuleStorage;\n  using StakeModuleLib for StakeModuleStorage;\n  using OracleExtensionLib for StakeModuleStorage;\n  using InitiatorExtensionLib for StakeModuleStorage;\n\n  event return$_buyback(uint256 remETH, uint256 boughtgETH);\n\n  event return$initiatePool(uint256 poolId);\n\n  event return$deposit(uint256 boughtgETH, uint256 mintedgETH);\n\n  function initialize(address _gETH_position, address _oracle_position) external initializer {\n    __StakeModule_init(_gETH_position, _oracle_position);\n  }\n\n  function pause() external virtual override {\n    _pause();\n  }\n\n  function unpause() external virtual override {\n    _unpause();\n  }\n\n  function setInfrastructureFee(uint256 _type, uint256 fee) external virtual override {\n    _getStakeModuleStorage().setInfrastructureFee(_type, fee);\n  }\n\n  function setBeaconDelays(uint256 entry, uint256 exit) external virtual override {\n    _getStakeModuleStorage().setBeaconDelays(entry, exit);\n  }\n\n  function setInitiationDeposit(uint256 newInitiationDeposit) external virtual override {\n    _getStakeModuleStorage().setInitiationDeposit(newInitiationDeposit);\n  }\n\n  /**\n   * @custom:section                           ** DATA MANIPULATORS **\n   */\n  function $writeUint(uint256 _id, bytes32 _key, uint256 _data) external {\n    _getDataStoreModuleStorage().writeUint(_id, _key, _data);\n  }\n\n  function $writeBytes(uint256 _id, bytes32 _key, bytes calldata _data) external {\n    _getDataStoreModuleStorage().writeBytes(_id, _key, _data);\n  }\n\n  function $writeAddress(uint256 _id, bytes32 _key, address _data) external {\n    _getDataStoreModuleStorage().writeAddress(_id, _key, _data);\n  }\n\n  function $set_VERIFICATION_INDEX(uint256 _data) external {\n    _getStakeModuleStorage().VERIFICATION_INDEX = _data;\n  }\n\n  function $set_MONOPOLY_THRESHOLD(uint256 _data) external {\n    _getStakeModuleStorage().MONOPOLY_THRESHOLD = _data;\n  }\n\n  function $set_ORACLE_UPDATE_TIMESTAMP(uint256 _data) external {\n    _getStakeModuleStorage().ORACLE_UPDATE_TIMESTAMP = _data;\n  }\n\n  function $set_package(uint256 _type, uint256 package) external {\n    _getStakeModuleStorage().packages[_type] = package;\n  }\n\n  function $set_middleware(uint256 _type, uint256 middleware) external {\n    _getStakeModuleStorage().middlewares[_type][middleware] = true;\n  }\n\n  function $set_PricePerShare(uint256 price, uint256 poolId) external {\n    _getStakeModuleStorage().gETH.setPricePerShare(price, poolId);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL TO EXTERNAL **\n   */\n\n  function $_authenticate(\n    uint256 _id,\n    bool _expectCONTROLLER,\n    bool _expectMaintainer,\n    bool[2] memory _restrictionMap\n  ) external view {\n    StakeModuleLib._authenticate(\n      _getDataStoreModuleStorage(),\n      _id,\n      _expectCONTROLLER,\n      _expectMaintainer,\n      _restrictionMap\n    );\n  }\n\n  function $_setgETHMiddleware(uint256 id, address _middleware) external {\n    _getStakeModuleStorage()._setgETHMiddleware(_getDataStoreModuleStorage(), id, _middleware);\n  }\n\n  function $_deploygETHMiddleware(\n    uint256 _id,\n    uint256 _versionId,\n    bytes calldata _middleware_data\n  ) external {\n    _getStakeModuleStorage()._deploygETHMiddleware(\n      _getDataStoreModuleStorage(),\n      _id,\n      _versionId,\n      _middleware_data\n    );\n  }\n\n  function $_deployGeodePackage(\n    uint256 _type,\n    uint256 _poolId,\n    bytes memory _package_data\n  ) external returns (address packageInstance) {\n    return\n      _getStakeModuleStorage()._deployGeodePackage(\n        _getDataStoreModuleStorage(),\n        _type,\n        _poolId,\n        _package_data\n      );\n  }\n\n  function $_deployWithdrawalContract(uint256 _poolId) external {\n    _getStakeModuleStorage()._deployWithdrawalContract(_getDataStoreModuleStorage(), _poolId);\n  }\n\n  function $_setMaintainer(uint256 _id, address _newMaintainer) external {\n    StakeModuleLib._setMaintainer(_getDataStoreModuleStorage(), _id, _newMaintainer);\n  }\n\n  function $_setMaintenanceFee(uint256 _id, uint256 _newFee) external {\n    StakeModuleLib._setMaintenanceFee(_getDataStoreModuleStorage(), _id, _newFee);\n  }\n\n  function $_increaseWalletBalance(uint256 _id, uint256 _value) external {\n    StakeModuleLib._increaseWalletBalance(_getDataStoreModuleStorage(), _id, _value);\n  }\n\n  function $_decreaseWalletBalance(uint256 _id, uint256 _value) external {\n    StakeModuleLib._decreaseWalletBalance(_getDataStoreModuleStorage(), _id, _value);\n  }\n\n  function $_imprison(uint256 _operatorId, bytes calldata _proof) external {\n    OracleExtensionLib._imprison(_getDataStoreModuleStorage(), _operatorId, _proof);\n  }\n\n  function $_setValidatorPeriod(uint256 _operatorId, uint256 _newPeriod) external {\n    StakeModuleLib._setValidatorPeriod(_getDataStoreModuleStorage(), _operatorId, _newPeriod);\n  }\n\n  function $_approveOperator(\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 allowance\n  ) external returns (uint256 oldAllowance) {\n    return\n      StakeModuleLib._approveOperator(_getDataStoreModuleStorage(), poolId, operatorId, allowance);\n  }\n\n  function $_mintgETH(uint256 _poolId, uint256 _ethAmount) external returns (uint256 mintedgETH) {\n    return _getStakeModuleStorage()._mintgETH(_getDataStoreModuleStorage(), _poolId, _ethAmount);\n  }\n\n  function $_buyback(\n    uint256 _poolId,\n    uint256 _maxEthToSell,\n    uint256 _deadline\n  ) external payable returns (uint256 remETH, uint256 boughtgETH) {\n    (remETH, boughtgETH) = StakeModuleLib._buyback(\n      _getDataStoreModuleStorage(),\n      _poolId,\n      _maxEthToSell,\n      _deadline\n    );\n    emit return$_buyback(remETH, boughtgETH);\n  }\n\n  function $_canStake(\n    bytes calldata _pubkey,\n    uint256 _verificationIndex\n  ) external view returns (bool) {\n    return _getStakeModuleStorage()._canStake(_pubkey, _verificationIndex);\n  }\n\n  /**\n   * @custom:section                           ** FOR RETURN STATEMENTS **\n   */\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable virtual override whenNotPaused returns (uint256 poolId) {\n    poolId = _getStakeModuleStorage().initiatePool(\n      _getDataStoreModuleStorage(),\n      fee,\n      middlewareVersion,\n      maintainer,\n      NAME,\n      middleware_data,\n      config\n    );\n    emit return$initiatePool(poolId);\n  }\n\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  )\n    external\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 boughtgETH, uint256 mintedgETH)\n  {\n    (boughtgETH, mintedgETH) = _getStakeModuleStorage().deposit(\n      _getDataStoreModuleStorage(),\n      poolId,\n      mingETH,\n      deadline,\n      receiver\n    );\n    emit return$deposit(boughtgETH, mintedgETH);\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/helpers/test/mocks/WithdrawalContractV2_0_Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// import {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// // structs\n// import {WithdrawalModuleStorage} from \"../../../modules/WithdrawalModule/structs/storage.sol\";\n// // globals\n// import {ID_TYPE} from \"../../../globals/id_type.sol\";\n// import {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// // interfaces\n// import {IPortal} from \"../../../interfaces/IPortal.sol\";\n// import {IGeodeModule} from \"../../../interfaces/modules/IGeodeModule.sol\";\n// import {IWithdrawalContractV2_0_Mock} from \"./interfaces/IWithdrawalContractV2_0_Mock.sol\";\n// import {IWithdrawalModule} from \"../../../interfaces/modules/IWithdrawalModule.sol\";\n// // libraries\n// import {WithdrawalModuleLib as WML} from \"../../../modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\n// // contracts\n// import {GeodeModule} from \"../../../modules/GeodeModule/GeodeModule.sol\";\n// import {WithdrawalModule} from \"../../../modules/WithdrawalModule/WithdrawalModule.sol\";\n\n// contract WithdrawalContractV2_0_Mock is\n//   IWithdrawalContractV2_0_Mock,\n//   GeodeModule,\n//   WithdrawalModule\n// {\n//   using WML for WithdrawalModuleStorage;\n//   /**\n//    * @custom:section                           ** VARIABLES **\n//    * Following immutable parameters are set when the referance library implementation is deployed.\n//    * Making necessary data for initialization reachable for all instances of LP package.\n//    */\n//   /// @notice gETH position\n//   address internal immutable gETHPos;\n//   /// @notice Portal position\n//   address internal immutable portalPos;\n\n//   uint256 freshSlot;\n\n//   /**\n//    * @custom:section                           ** MODIFIERS **\n//    */\n\n//   modifier onlyOwner() {\n//     require(msg.sender == GEODE.SENATE, \"WCP:sender not owner\");\n//     _;\n//   }\n\n//   /**\n//    * @custom:section                           ** INITIALIZING **\n//    */\n//   /**\n//    * @custom:oz-upgrades-unsafe-allow constructor\n//    *\n//    * @dev we don't want to provide these package-specific not-changing parameters\n//    * accross all instances of the packages.\n//    * So we will store them in the ref implementation contract of the package,\n//    * and fetch when needed on initialization.\n//    */\n//   constructor(address _gETHPos, address _portalPos) {\n//     require(_gETHPos != address(0), \"WCP:_gETHPos cannot be zero\");\n//     require(_portalPos != address(0), \"WCP:_portalPos cannot be zero\");\n\n//     gETHPos = _gETHPos;\n//     portalPos = _portalPos;\n\n//     _disableInitializers();\n//   }\n\n//   /**\n//    * @dev While 'data' parameter is not currently used it is a standarized approach on all\n//    * * GeodePackages have the same function signature on 'initialize'.\n//    */\n//   function initialize(\n//     uint256 poolId,\n//     address poolOwner,\n//     bytes calldata versionName,\n//     bytes calldata data\n//   ) public virtual override initializer {\n//     __WithdrawalContract_init(poolId, poolOwner, versionName);\n//   }\n\n//   function initializeV2_0_Mock(uint256 _freshSlot) public virtual override reinitializer(2) {\n//     setFreshSlot(_freshSlot);\n//   }\n\n//   function __WithdrawalContract_init(\n//     uint256 poolId,\n//     address poolOwner,\n//     bytes calldata versionName\n//   ) internal onlyInitializing {\n//     __GeodeModule_init(\n//       portalPos,\n//       poolOwner,\n//       type(uint256).max,\n//       ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\n//       versionName\n//     );\n//     __WithdrawalModule_init(gETHPos, portalPos, poolId);\n//     __WithdrawalContract_init_unchained();\n//   }\n\n//   function __WithdrawalContract_init_unchained() internal onlyInitializing {}\n\n//   function setFreshSlot(uint256 value) public virtual override {\n//     freshSlot = value;\n//   }\n\n//   function getFreshSlot() external view virtual override returns (uint256) {\n//     return freshSlot;\n//   }\n\n//   function getPoolId() public view override returns (uint256) {\n//     return WITHDRAWAL.POOL_ID;\n//   }\n\n//   /**\n//    * @notice get Portal as a contract\n//    */\n//   function getPortal() public view override returns (IPortal) {\n//     return IPortal(GEODE.GOVERNANCE);\n//   }\n\n//   /**\n//    * @dev GeodeModule override\n//    */\n//   function getProposedVersion() public view virtual override returns (uint256) {\n//     return getPortal().getPackageVersion(GEODE.PACKAGE_TYPE);\n//   }\n\n//   /**\n//    * @dev GeodeModule override\n//    */\n//   function isolationMode()\n//     external\n//     view\n//     virtual\n//     override(GeodeModule, IGeodeModule)\n//     returns (bool)\n//   {\n//     if (paused()) {\n//       return true;\n//     }\n\n//     if (getContractVersion() != getProposedVersion()) {\n//       return true;\n//     }\n\n//     if (GEODE.APPROVED_UPGRADE != ERC1967Utils.getImplementation()) {\n//       return true;\n//     }\n\n//     if (getPortal().readAddress(getPoolId(), rks.CONTROLLER) != GEODE.SENATE) {\n//       return true;\n//     }\n\n//     return false;\n//   }\n\n//   /**\n//    * @custom:section                           ** ADMIN FUNCTIONS **\n//    *\n//    * @custom:visibility -> external\n//    */\n\n//   /**\n//    * @custom:subsection                           ** UPGRADABILITY FUNCTIONS **\n//    */\n\n//   /**\n//    * @dev IGeodePackage override\n//    */\n//   function pullUpgrade() external virtual override onlyOwner {\n//     require(!(getPortal().isolationMode()), \"WCP:Portal is isolated\");\n//     require(getProposedVersion() != getContractVersion(), \"WCP:no upgrades\");\n\n//     uint256 id = getPortal().pushUpgrade(GEODE.PACKAGE_TYPE);\n//     approveProposal(id);\n//   }\n\n//   /**\n//    * @custom:subsection                           ** PAUSABILITY FUNCTIONS **\n//    */\n\n//   /**\n//    * @notice pausing the contract activates the isolationMode\n//    */\n//   function pause() external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n//     _pause();\n//   }\n\n//   /**\n//    * @notice unpausing the contract deactivates the isolationMode\n//    */\n//   function unpause() external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n//     _unpause();\n//   }\n\n//   /**\n//    * @custom:subsection                           ** WITHDRAWAL QUEUE **\n//    *\n//    * @dev WM override\n//    */\n//   function setExitThreshold(\n//     uint256 newThreshold\n//   ) external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n//     WITHDRAWAL.setExitThreshold(newThreshold);\n//   }\n\n//   /**\n//    * @notice keep the total number of variables at 50\n//    */\n//   uint256[49] private __gap;\n// }\n"
    },
    "contracts/helpers/test/mocks/WithdrawalModuleLibMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {IPortal} from \"../../../interfaces/IPortal.sol\";\nimport {WithdrawalModuleStorage} from \"../../../modules/WithdrawalModule/structs/storage.sol\";\nimport {StakeModule} from \"../../../modules/StakeModule/StakeModule.sol\";\nimport {StakeModuleLib} from \"../../../modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {WithdrawalModule} from \"../../../modules/WithdrawalModule/WithdrawalModule.sol\";\nimport {WithdrawalModuleLib} from \"../../../modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\nimport {InitiatorExtensionLib} from \"../../../modules/StakeModule/libs/InitiatorExtensionLib.sol\";\nimport {OracleExtensionLib} from \"../../../modules/StakeModule/libs/OracleExtensionLib.sol\";\nimport {DataStoreModuleLib} from \"../../../modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\n\ncontract WithdrawalModuleLibMock is WithdrawalModule {\n  using WithdrawalModuleLib for WithdrawalModuleStorage;\n\n  function initialize(\n    address _gETH_position,\n    address _portal_position,\n    uint256 _poolId\n  ) external initializer {\n    __WithdrawalModule_init(_gETH_position, _portal_position, _poolId);\n  }\n\n  function pause() external virtual override(WithdrawalModule) {\n    _pause();\n  }\n\n  function unpause() external virtual override(WithdrawalModule) {\n    _unpause();\n  }\n\n  function claimInfrastructureFees(\n    address receiver\n  ) external virtual override(WithdrawalModule) returns (bool success) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    (address governance, , , , ) = IPortal($.PORTAL).GeodeParams();\n    require(msg.sender == governance);\n\n    uint256 claimable = $.gatheredInfrastructureFees;\n\n    (success, ) = payable(receiver).call{value: claimable}(\"\");\n    require(success, \"SML:Failed to send ETH\");\n  }\n\n  function setExitThreshold(uint256 newThreshold) external virtual override(WithdrawalModule) {\n    _getWithdrawalModuleStorage().setExitThreshold(newThreshold);\n  }\n\n  function $getWithdrawalParams()\n    external\n    view\n    returns (\n      address gETH,\n      address PORTAL,\n      uint256 POOL_ID,\n      uint256 EXIT_THRESHOLD,\n      uint256 gatheredInfrastructureFees\n    )\n  {\n    gETH = address(_getWithdrawalModuleStorage().gETH);\n    PORTAL = _getWithdrawalModuleStorage().PORTAL;\n    POOL_ID = _getWithdrawalModuleStorage().POOL_ID;\n    EXIT_THRESHOLD = _getWithdrawalModuleStorage().EXIT_THRESHOLD;\n    gatheredInfrastructureFees = _getWithdrawalModuleStorage().gatheredInfrastructureFees;\n  }\n\n  function $getValidatorData(\n    bytes memory pubkey\n  ) external view returns (uint256 beaconBalance, uint256 withdrawnBalance, uint256 poll) {\n    beaconBalance = _getWithdrawalModuleStorage().validators[pubkey].beaconBalance;\n    withdrawnBalance = _getWithdrawalModuleStorage().validators[pubkey].withdrawnBalance;\n    poll = _getWithdrawalModuleStorage().validators[pubkey].poll;\n  }\n\n  function $getQueueData()\n    external\n    view\n    returns (\n      uint256 requested,\n      uint256 realized,\n      uint256 realizedEtherBalance,\n      uint256 realizedPrice,\n      uint256 fulfilled,\n      uint256 fulfilledEtherBalance,\n      uint256 commonPoll\n    )\n  {\n    requested = _getWithdrawalModuleStorage().queue.requested;\n    realized = _getWithdrawalModuleStorage().queue.realized;\n    realizedEtherBalance = _getWithdrawalModuleStorage().queue.realizedEtherBalance;\n    realizedPrice = _getWithdrawalModuleStorage().queue.realizedPrice;\n    fulfilled = _getWithdrawalModuleStorage().queue.fulfilled;\n    fulfilledEtherBalance = _getWithdrawalModuleStorage().queue.fulfilledEtherBalance;\n    commonPoll = _getWithdrawalModuleStorage().queue.commonPoll;\n  }\n\n  function $getRequestFromLastIndex(\n    uint256 index\n  )\n    external\n    view\n    returns (\n      uint256 realIndex,\n      address owner,\n      uint256 trigger,\n      uint256 size,\n      uint256 fulfilled,\n      uint256 claimableEther\n    )\n  {\n    require(index < _getWithdrawalModuleStorage().requests.length, \"WMLM: index exceeds length\");\n    realIndex = _getWithdrawalModuleStorage().requests.length - 1 - index;\n    owner = _getWithdrawalModuleStorage().requests[realIndex].owner;\n    trigger = _getWithdrawalModuleStorage().requests[realIndex].trigger;\n    size = _getWithdrawalModuleStorage().requests[realIndex].size;\n    fulfilled = _getWithdrawalModuleStorage().requests[realIndex].fulfilled;\n    claimableEther = _getWithdrawalModuleStorage().requests[realIndex].claimableEther;\n  }\n\n  function $getValidatorThreshold(\n    bytes memory pubkey\n  ) external view returns (uint256 threshold, uint256 beaconBalancePriced) {\n    (threshold, beaconBalancePriced) = _getWithdrawalModuleStorage().getValidatorThreshold(pubkey);\n  }\n\n  function $setMockValidatorData(\n    bytes memory pubkey,\n    uint256 beaconBalance,\n    uint256 withdrawnBalance,\n    uint256 poll\n  ) external {\n    _getWithdrawalModuleStorage().validators[pubkey].beaconBalance = beaconBalance;\n    _getWithdrawalModuleStorage().validators[pubkey].withdrawnBalance = withdrawnBalance;\n    _getWithdrawalModuleStorage().validators[pubkey].poll = poll;\n  }\n\n  function $setMockQueueData(\n    uint256 requested,\n    uint256 realized,\n    uint256 fulfilled,\n    uint256 realizedEtherBalance,\n    uint256 realizedPrice,\n    uint256 commonPoll\n  ) external {\n    _getWithdrawalModuleStorage().queue.requested = requested;\n    _getWithdrawalModuleStorage().queue.realized = realized;\n    _getWithdrawalModuleStorage().queue.fulfilled = fulfilled;\n    _getWithdrawalModuleStorage().queue.realizedEtherBalance = realizedEtherBalance;\n    _getWithdrawalModuleStorage().queue.realizedPrice = realizedPrice;\n    _getWithdrawalModuleStorage().queue.commonPoll = commonPoll;\n  }\n\n  function $canFinalizeExit(bytes memory pubkey) external view returns (bool) {\n    return _getWithdrawalModuleStorage().canFinalizeExit(pubkey);\n  }\n\n  function $checkAndRequestExit(\n    bytes calldata pubkey,\n    uint256 commonPoll\n  ) external returns (uint256) {\n    return _getWithdrawalModuleStorage()._checkAndRequestExit(pubkey, commonPoll);\n  }\n\n  function $_vote(uint256 index, bytes calldata pubkey, uint256 size) external {\n    _getWithdrawalModuleStorage()._vote(index, pubkey, size);\n  }\n\n  function $_enqueue(uint256 trigger, uint256 size, address owner) external {\n    _getWithdrawalModuleStorage()._enqueue(trigger, size, owner);\n  }\n\n  function $enqueueBatch(\n    uint256[] calldata sizes,\n    bytes[] calldata pubkeys,\n    address owner\n  ) external {\n    _getWithdrawalModuleStorage().enqueueBatch(sizes, pubkeys, owner);\n  }\n\n  function $enqueue(uint256 size, bytes calldata pubkey, address owner) external {\n    _getWithdrawalModuleStorage().enqueue(size, pubkey, owner);\n  }\n\n  function $transferRequest(uint256 index, address newOwner) external {\n    _getWithdrawalModuleStorage().transferRequest(index, newOwner);\n  }\n\n  function $fulfillable(\n    uint256 index,\n    uint256 Qrealized,\n    uint256 Qfulfilled\n  ) external view returns (uint256) {\n    return _getWithdrawalModuleStorage().fulfillable(index, Qrealized, Qfulfilled);\n  }\n\n  function $fulfill(uint256 index) external {\n    _getWithdrawalModuleStorage().fulfill(index);\n  }\n\n  function $fulfillBatch(uint256[] calldata indexes) external {\n    _getWithdrawalModuleStorage().fulfillBatch(indexes);\n  }\n\n  function $_dequeue(uint256 index) external returns (uint256 claimableETH) {\n    return _getWithdrawalModuleStorage()._dequeue(index);\n  }\n\n  function $dequeue(uint256 index, address receiver) external {\n    _getWithdrawalModuleStorage().dequeue(index, receiver);\n  }\n\n  function $dequeueBatch(uint256[] calldata indexes, address receiver) external {\n    _getWithdrawalModuleStorage().dequeueBatch(indexes, receiver);\n  }\n\n  function $_realizeProcessedEther(uint256 processedBalance) external {\n    _getWithdrawalModuleStorage()._realizeProcessedEther(processedBalance);\n  }\n\n  function $_distributeFees(\n    bytes memory pubkey,\n    uint256 reportedWithdrawn,\n    uint256 processedWithdrawn\n  ) external returns (uint256 extra) {\n    extra = _getWithdrawalModuleStorage()._distributeFees(\n      _getWithdrawalModuleStorage()._getPortal().getValidator(pubkey),\n      reportedWithdrawn,\n      processedWithdrawn\n    );\n  }\n\n  function $processValidators(\n    bytes[] calldata pubkeys,\n    uint256[] calldata beaconBalances,\n    uint256[] calldata withdrawnBalances,\n    bytes32[][] calldata balanceProofs\n  ) external {\n    _getWithdrawalModuleStorage().processValidators(\n      pubkeys,\n      beaconBalances,\n      withdrawnBalances,\n      balanceProofs\n    );\n  }\n\n  /**\n   * @notice fallback functions\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/helpers/test/nonERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../../interfaces/IgETH.sol\";\n\ncontract nonERC1155Receiver is Context {\n  uint256 private immutable _id;\n  IgETH private immutable _ERC1155;\n\n  constructor(uint256 id_, address gETH_) {\n    _id = id_;\n    _ERC1155 = IgETH(gETH_);\n  }\n\n  function transfer(address recipient, uint256 amount) public virtual {\n    _transfer(_msgSender(), recipient, amount);\n  }\n\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    unchecked {\n      _ERC1155.burn(account, _id, amount);\n    }\n  }\n\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    unchecked {\n      _ERC1155.safeTransferFrom(sender, recipient, _id, amount, \"\");\n    }\n  }\n}\n"
    },
    "contracts/interfaces/helpers/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/** This interface is designed to be compatible with the Vyper version.\n * @notice This is the Ethereum 2.0 deposit contract interface.\n * For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\n */\ninterface IDepositContract {\n  /**\n   * @notice Submit a Phase 0 DepositData object.\n   * @param pubkey A BLS12-381 public key.\n   * @param withdrawal_credentials Commitment to a public key for withdrawals.\n   * @param signature A BLS12-381 signature.\n   * @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n   *Used as a protection against malformed input.\n   */\n  function deposit(\n    bytes calldata pubkey,\n    bytes calldata withdrawal_credentials,\n    bytes calldata signature,\n    bytes32 deposit_data_root\n  ) external payable;\n}\n"
    },
    "contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @dev IERC1155 inherits IERC165\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\ninterface IERC1155Burnable is IERC1155, IERC1155MetadataURI, IERC1155Errors {\n  function burn(address account, uint256 id, uint256 value) external;\n\n  function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\n}\n\ninterface IERC1155Supply is IERC1155, IERC1155MetadataURI, IERC1155Errors {\n  function totalSupply(uint256 id) external view returns (uint256);\n\n  function exists(uint256 id) external view returns (bool);\n}\n\ninterface IERC1155PausableBurnableSupply is IERC1155Burnable, IERC1155Supply {\n  function setURI(string memory newuri) external;\n\n  function pause() external;\n\n  function unpause() external;\n\n  function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\n\n  function mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) external;\n}\n"
    },
    "contracts/interfaces/helpers/ILPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.20;\n\ninterface ILPToken {\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address account, uint256 amount) external;\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function initialize(string memory name, string memory symbol) external;\n\n  function mint(address recipient, uint256 amount) external;\n\n  function name() external view returns (string memory);\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n  function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/helpers/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\ninterface IWhitelist {\n  function isAllowed(address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IgETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IERC1155PausableBurnableSupply} from \"./helpers/IERC1155PausableBurnableSupply.sol\";\n\ninterface IgETH is IERC1155PausableBurnableSupply {\n  function denominator() external view returns (uint256);\n\n  function isMiddleware(address middleware, uint256 id) external view returns (bool);\n\n  function setMiddleware(address middleware, uint256 id, bool isSet) external;\n\n  function isAvoider(address account, uint256 id) external view returns (bool);\n\n  function avoidMiddlewares(uint256 id, bool isAvoid) external;\n\n  function pricePerShare(uint256 id) external view returns (uint256);\n\n  function priceUpdateTimestamp(uint256 id) external view returns (uint256);\n\n  function setPricePerShare(uint256 price, uint256 id) external;\n\n  function transferUriSetterRole(address newUriSetter) external;\n\n  function transferPauserRole(address newPauser) external;\n\n  function transferMinterRole(address newMinter) external;\n\n  function transferOracleRole(address newOracle) external;\n\n  function transferMiddlewareManagerRole(address newMiddlewareManager) external;\n}\n"
    },
    "contracts/interfaces/IPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IGeodeModule} from \"./modules/IGeodeModule.sol\";\nimport {IStakeModule} from \"./modules/IStakeModule.sol\";\n\ninterface IPortal is IGeodeModule, IStakeModule {\n  function pausegETH() external;\n\n  function unpausegETH() external;\n\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\n\n  function releasePrisoned(uint256 operatorId) external;\n}\n"
    },
    "contracts/interfaces/middlewares/IgETHMiddleware.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\ninterface IgETHMiddleware {\n  function initialize(uint256 id_, address erc1155_, bytes memory data) external;\n\n  function ERC1155() external view returns (address);\n\n  function ERC1155_ID() external view returns (uint256);\n\n  function pricePerShare() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/modules/IDataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\ninterface IDataStoreModule {\n  function generateId(string calldata _name, uint256 _type) external pure returns (uint256 id);\n\n  function getKey(uint256 _id, bytes32 _param) external pure returns (bytes32 key);\n\n  function allIdsByType(uint256 _type, uint256 _index) external view returns (uint256);\n\n  function allIdsByTypeLength(uint256 _type) external view returns (uint256);\n\n  function readUint(uint256 id, bytes32 key) external view returns (uint256 data);\n\n  function readAddress(uint256 id, bytes32 key) external view returns (address data);\n\n  function readBytes(uint256 id, bytes32 key) external view returns (bytes memory data);\n\n  function readUintArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (uint256 data);\n\n  function readBytesArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (bytes memory data);\n\n  function readAddressArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view returns (address data);\n}\n"
    },
    "contracts/interfaces/modules/IGeodeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IDataStoreModule} from \"./IDataStoreModule.sol\";\nimport {Proposal} from \"../../modules/GeodeModule/structs/utils.sol\";\n\ninterface IGeodeModule is IDataStoreModule {\n  function isolationMode() external view returns (bool);\n\n  function GeodeParams()\n    external\n    view\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType\n    );\n\n  function getGovernance() external view returns (address);\n\n  function getContractVersion() external view returns (uint256);\n\n  function getProposal(uint256 id) external view returns (Proposal memory proposal);\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external returns (uint256 id);\n\n  function rescueSenate(address _newSenate) external;\n\n  function approveProposal(\n    uint256 id\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\n\n  function changeSenate(address _newSenate) external;\n\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\n}\n"
    },
    "contracts/interfaces/modules/ILiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\ninterface ILiquidityModule {\n  function pause() external;\n\n  function unpause() external;\n\n  function LiquidityParams()\n    external\n    view\n    returns (\n      address gETH,\n      address lpToken,\n      uint256 pooledTokenId,\n      uint256 initialA,\n      uint256 futureA,\n      uint256 initialATime,\n      uint256 futureATime,\n      uint256 swapFee,\n      uint256 adminFee\n    );\n\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getBalance(uint8 index) external view returns (uint256);\n\n  function getDebt() external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function getAdminBalance(uint256 index) external view returns (uint256);\n\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateTokenAmount(\n    uint256[2] calldata amounts,\n    bool deposit\n  ) external view returns (uint256);\n\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory);\n\n  function calculateRemoveLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount);\n\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function addLiquidity(\n    uint256[2] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[2] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[2] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[2] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function withdrawAdminFees(address receiver) external;\n\n  function setAdminFee(uint256 newAdminFee) external;\n\n  function setSwapFee(uint256 newSwapFee) external;\n\n  function rampA(uint256 futureA, uint256 futureTime) external;\n\n  function stopRampA() external;\n}\n"
    },
    "contracts/interfaces/modules/IStakeModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IDataStoreModule} from \"./IDataStoreModule.sol\";\nimport {Validator} from \"../../modules/StakeModule/structs/utils.sol\";\n\ninterface IStakeModule is IDataStoreModule {\n  function pause() external;\n\n  function unpause() external;\n\n  function setInfrastructureFee(uint256 _type, uint256 fee) external;\n\n  function setBeaconDelays(uint256 entry, uint256 exit) external;\n\n  function setInitiationDeposit(uint256 newInitiationDeposit) external;\n\n  function StakeParams()\n    external\n    view\n    returns (\n      address gETH,\n      address oraclePosition,\n      uint256 validatorsIndex,\n      uint256 verificationIndex,\n      uint256 monopolyThreshold,\n      uint256 beaconDelayEntry,\n      uint256 beaconDelayExit,\n      uint256 initiationDeposit,\n      uint256 oracleUpdateTimestamp,\n      uint256 dailyPriceIncreaseLimit,\n      uint256 dailyPriceDecreaseLimit\n    );\n\n  function getValidator(bytes calldata pubkey) external view returns (Validator memory);\n\n  function getPackageVersion(uint256 _type) external view returns (uint256);\n\n  function getPriceMerkleRoot() external view returns (bytes32);\n\n  function getBalancesMerkleRoot() external view returns (bytes32);\n\n  function isMiddleware(uint256 _type, uint256 _version) external view returns (bool);\n\n  function getInfrastructureFee(uint256 _type) external view returns (uint256);\n\n  function initiateOperator(\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external payable;\n\n  function deployLiquidityPool(uint256 poolId) external;\n\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable returns (uint256 poolId);\n\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external;\n\n  function setWhitelist(uint256 poolId, address whitelist) external;\n\n  function setYieldReceiver(uint256 poolId, address yieldReceiver) external;\n\n  function changeMaintainer(uint256 id, address newMaintainer) external;\n\n  function getMaintenanceFee(uint256 id) external view returns (uint256);\n\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\n\n  function increaseWalletBalance(uint256 id) external payable returns (bool);\n\n  function decreaseWalletBalance(uint256 id, uint256 value) external returns (bool);\n\n  function isPrisoned(uint256 operatorId) external view returns (bool);\n\n  function blameExit(\n    bytes calldata pk,\n    uint256 beaconBalance,\n    uint256 withdrawnBalance,\n    bytes32[] calldata balanceProof\n  ) external;\n\n  function blameProposal(bytes calldata pk) external;\n\n  function getValidatorPeriod(uint256 id) external view returns (uint256);\n\n  function switchValidatorPeriod(uint256 operatorId, uint256 newPeriod) external;\n\n  function setFallbackOperator(\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 fallbackThreshold\n  ) external;\n\n  function operatorAllowance(uint256 poolId, uint256 operatorId) external view returns (uint256);\n\n  function delegate(\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances\n  ) external;\n\n  function isWhitelisted(uint256 poolId, address staker) external view returns (bool);\n\n  function isPrivatePool(uint256 poolId) external view returns (bool);\n\n  function isPriceValid(uint256 poolId) external view returns (bool);\n\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\n\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  ) external payable returns (uint256 boughtgETH, uint256 mintedgETH);\n\n  function canStake(bytes calldata pubkey) external view returns (bool);\n\n  function proposeStake(\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external;\n\n  function stake(uint256 operatorId, bytes[] calldata pubkeys) external;\n\n  function requestExit(uint256 poolId, bytes memory pk) external returns (bool);\n\n  function finalizeExit(uint256 poolId, bytes memory pk) external;\n\n  function updateVerificationIndex(\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external;\n\n  function regulateOperators(uint256[] calldata feeThefts, bytes[] calldata proofs) external;\n\n  function reportBeacon(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external;\n\n  function priceSync(uint256 poolId, uint256 price, bytes32[] calldata priceProof) external;\n\n  function priceSyncBatch(\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external;\n}\n"
    },
    "contracts/interfaces/modules/IWithdrawalModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\ninterface IWithdrawalModule {\n  function pause() external;\n\n  function unpause() external;\n\n  function setExitThreshold(uint256 newThreshold) external;\n\n  function claimInfrastructureFees(address receiver) external returns (bool success);\n\n  function WithdrawalParams()\n    external\n    view\n    returns (\n      address gETH,\n      address portal,\n      uint256 poolId,\n      uint256 exitThreshold,\n      uint256 gatheredInfrastructureFees\n    );\n\n  function QueueParams()\n    external\n    view\n    returns (\n      uint256 requested,\n      uint256 realized,\n      uint256 realizedEtherBalance,\n      uint256 realizedPrice,\n      uint256 fulfilled,\n      uint256 fulfilledEtherBalance,\n      uint256 commonPoll\n    );\n\n  function getRequest(\n    uint256 index\n  )\n    external\n    view\n    returns (\n      address owner,\n      uint256 trigger,\n      uint256 size,\n      uint256 fulfilled,\n      uint256 claimableEther\n    );\n\n  function getValidatorData(\n    bytes calldata pubkey\n  ) external view returns (uint256 beaconBalance, uint256 withdrawnBalance, uint256 poll);\n\n  function canFinalizeExit(bytes memory pubkey) external view returns (bool);\n\n  function validatorThreshold(bytes memory pubkey) external view returns (uint256 threshold);\n\n  function enqueue(\n    uint256 size,\n    bytes calldata pubkey,\n    address owner\n  ) external returns (uint256 index);\n\n  function enqueueBatch(\n    uint256[] calldata sizes,\n    bytes[] calldata pubkeys,\n    address owner\n  ) external returns (uint256[] memory indexes);\n\n  function transferRequest(uint256 index, address newOwner) external;\n\n  function fulfillable(uint256 index) external view returns (uint256);\n\n  function fulfill(uint256 index) external;\n\n  function fulfillBatch(uint256[] calldata indexes) external;\n\n  function dequeue(uint256 index, address receiver) external;\n\n  function dequeueBatch(uint256[] calldata indexes, address receiver) external;\n\n  function processValidators(\n    bytes[] calldata pubkeys,\n    uint256[] calldata beaconBalances,\n    uint256[] calldata withdrawnBalances,\n    bytes32[][] calldata balanceProofs,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external;\n\n  function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n}\n"
    },
    "contracts/interfaces/packages/IGeodePackage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IGeodeModule} from \"../modules/IGeodeModule.sol\";\nimport {IPortal} from \"../IPortal.sol\";\n\ninterface IGeodePackage is IGeodeModule {\n  function initialize(\n    uint256 poolId,\n    address owner,\n    bytes calldata versionName,\n    bytes memory data\n  ) external;\n\n  function getPoolId() external view returns (uint256);\n\n  function getProposedVersion() external view returns (uint256);\n\n  function pullUpgrade() external;\n}\n"
    },
    "contracts/interfaces/packages/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {ILiquidityModule} from \"../modules/ILiquidityModule.sol\";\nimport {IGeodePackage} from \"./IGeodePackage.sol\";\n\ninterface ILiquidityPool is IGeodePackage, ILiquidityModule {}\n"
    },
    "contracts/interfaces/packages/IWithdrawalContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IWithdrawalModule} from \"../modules/IWithdrawalModule.sol\";\nimport {IGeodePackage} from \"./IGeodePackage.sol\";\n\ninterface IWithdrawalContract is IGeodePackage, IWithdrawalModule {}\n"
    },
    "contracts/middlewares/ERC20RebaseMiddleware.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\n// external - interfaces\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n// external - contracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n// internal - globals\nimport {gETH_DENOMINATOR} from \"../globals/macros.sol\";\n// internal - interfaces\nimport {IgETH} from \"../interfaces/IgETH.sol\";\nimport {IgETHMiddleware} from \"../interfaces/middlewares/IgETHMiddleware.sol\";\n// internal - libraries\nimport {BytesLib} from \"../helpers/BytesLib.sol\";\n\n/**\n * @notice Same as ERC20Middleware, but balances represent underlying balances, instead of ERC1155 balances.\n * which means it represents the staked ether amount, instead of gETH amount.\n *\n * @dev This contract should only be used for user interaction when ERC1155 is not an option.\n * @dev As a known bug, not all Transfer events are logged here. Please listen the underlying ERC1155 for the correct data.\n *\n * @dev differences between ERC20RebaseMiddleware and ERC20Middleware can be seen observed at:\n * -> totalSupply, balanceOf, _update.\n *\n * diffchecker: https://www.diffchecker.com/VQPmW62g/\n *\n * @dev decimals is 18 onlyif erc1155.denominator = 1e18\n */\ncontract ERC20RebaseMiddleware is\n  Initializable,\n  ContextUpgradeable,\n  IgETHMiddleware,\n  IERC20,\n  IERC20Metadata,\n  IERC20Errors\n{\n  /// @custom:storage-location erc7201:geode.storage.ERC20RebaseMiddleware\n  struct ERC20RebaseMiddlewareStorage {\n    // mapping(address account => uint256) _balances; -> use ERC1155\n    mapping(address account => mapping(address spender => uint256)) _allowances;\n    // uint256 _totalSupply; -> use ERC1155\n    string _name;\n    string _symbol;\n    IgETH ERC1155;\n    uint256 ERC1155_ID;\n  }\n\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.ERC20RebaseMiddleware\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant ERC20RebaseMiddlewareStorageLocation =\n    0x033cdebea869703c4621de9e95304f18ae23301f1ffc0c9d2917741e54db2500;\n\n  function _getERC20RebaseMiddlewareStorage()\n    private\n    pure\n    returns (ERC20RebaseMiddlewareStorage storage $)\n  {\n    assembly {\n      $.slot := ERC20RebaseMiddlewareStorageLocation\n    }\n  }\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    uint256 id_,\n    address gETH_,\n    bytes calldata data\n  ) public virtual override initializer {\n    uint256 nameLen = uint256(bytes32(BytesLib.slice(data, 0, 32)));\n    __ERC20RebaseMiddleware_init(\n      id_,\n      gETH_,\n      string(BytesLib.slice(data, 32, nameLen)),\n      string(BytesLib.slice(data, 32 + nameLen, data.length - (32 + nameLen)))\n    );\n  }\n\n  /**\n   * @dev Sets the values for {name} and {symbol} based on provided data:\n   * * First 32 bytes indicate the lenght of the name, one therefore can find out\n   * * which byte the name ends and symbol starts.\n   */\n  function __ERC20RebaseMiddleware_init(\n    uint256 id_,\n    address gETH_,\n    string memory name_,\n    string memory symbol_\n  ) internal onlyInitializing {\n    __ERC20RebaseMiddleware_init_unchained(id_, gETH_, name_, symbol_);\n  }\n\n  function __ERC20RebaseMiddleware_init_unchained(\n    uint256 id_,\n    address gETH_,\n    string memory name_,\n    string memory symbol_\n  ) internal onlyInitializing {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    $._name = name_;\n    $._symbol = symbol_;\n    $.ERC1155 = IgETH(gETH_);\n    $.ERC1155_ID = id_;\n  }\n\n  function name() public view virtual returns (string memory) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return $._name;\n  }\n\n  function symbol() public view virtual returns (string memory) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return $._symbol;\n  }\n\n  function ERC1155() public view virtual override returns (address) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return address($.ERC1155);\n  }\n\n  function ERC1155_ID() public view virtual override returns (uint256) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return $.ERC1155_ID;\n  }\n\n  function pricePerShare() public view virtual override returns (uint256) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return $.ERC1155.pricePerShare($.ERC1155_ID);\n  }\n\n  function decimals() public view virtual returns (uint8) {\n    return 18;\n  }\n\n  function totalSupply() public view virtual returns (uint256) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n\n    uint256 id = $.ERC1155_ID;\n    return ($.ERC1155.totalSupply(id) * $.ERC1155.pricePerShare(id)) / gETH_DENOMINATOR;\n  }\n\n  function balanceOf(address account) public view virtual returns (uint256) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n\n    uint256 id = $.ERC1155_ID;\n    return ($.ERC1155.balanceOf(account, id) * $.ERC1155.pricePerShare(id)) / gETH_DENOMINATOR;\n  }\n\n  function transfer(address to, uint256 value) public virtual returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, value);\n    return true;\n  }\n\n  function allowance(address owner, address spender) public view virtual returns (uint256) {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    return $._allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 value) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  function _transfer(address from, address to, uint256 value) internal {\n    if (from == address(0)) {\n      revert ERC20InvalidSender(address(0));\n    }\n    if (to == address(0)) {\n      revert ERC20InvalidReceiver(address(0));\n    }\n    _update(from, to, value);\n  }\n\n  function _update(address from, address to, uint256 value) internal virtual {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n\n    uint256 fromBalance = balanceOf(from);\n    if (fromBalance < value) {\n      revert ERC20InsufficientBalance(from, fromBalance, value);\n    }\n\n    uint256 id = $.ERC1155_ID;\n    uint256 transferAmount = (value * gETH_DENOMINATOR) / $.ERC1155.pricePerShare(id);\n    $.ERC1155.safeTransferFrom(from, to, id, transferAmount, \"\");\n\n    emit Transfer(from, to, value);\n  }\n\n  function _approve(address owner, address spender, uint256 value) internal {\n    _approve(owner, spender, value, true);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value,\n    bool emitEvent\n  ) internal virtual {\n    ERC20RebaseMiddlewareStorage storage $ = _getERC20RebaseMiddlewareStorage();\n    if (owner == address(0)) {\n      revert ERC20InvalidApprover(address(0));\n    }\n    if (spender == address(0)) {\n      revert ERC20InvalidSpender(address(0));\n    }\n    $._allowances[owner][spender] = value;\n    if (emitEvent) {\n      emit Approval(owner, spender, value);\n    }\n  }\n\n  function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      if (currentAllowance < value) {\n        revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n      }\n      unchecked {\n        _approve(owner, spender, currentAllowance - value, false);\n      }\n    }\n  }\n}\n"
    },
    "contracts/middlewares/ERC20RebasePermitMiddleware.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n// external - interfaces\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n// external - libraries\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n// external - contracts\nimport {EIP712Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol\";\n// internal - libraries\nimport {BytesLib} from \"../helpers/BytesLib.sol\";\n// internal - contracts\nimport {ERC20RebaseMiddleware} from \"./ERC20RebaseMiddleware.sol\";\n\n/**\n * @dev differences between ERC20RebasePermitMiddleware and Openzeppelin's implementation of ERC20PermitUpgradable is:\n * -> using ERC20Middleware instead of ERC20Upgradeable\n * -> added initialize\n *\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ncontract ERC20RebasePermitMiddleware is\n  ERC20RebaseMiddleware,\n  IERC20Permit,\n  EIP712Upgradeable,\n  NoncesUpgradeable\n{\n  bytes32 private constant PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  /**\n   * @dev Permit deadline has expired.\n   */\n  error ERC2612ExpiredSignature(uint256 deadline);\n\n  /**\n   * @dev Mismatched signature.\n   */\n  error ERC2612InvalidSigner(address signer, address owner);\n\n  ///@custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   */\n  function initialize(\n    uint256 id_,\n    address gETH_,\n    bytes calldata data\n  ) public virtual override initializer {\n    uint256 nameLen = uint256(bytes32(BytesLib.slice(data, 0, 32)));\n    __ERC20RebasePermitMiddleware_init(\n      id_,\n      gETH_,\n      string(BytesLib.slice(data, 32, nameLen)),\n      string(BytesLib.slice(data, 32 + nameLen, data.length - (32 + nameLen)))\n    );\n  }\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n   *\n   * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n   */\n  function __ERC20RebasePermitMiddleware_init(\n    uint256 id_,\n    address gETH_,\n    string memory name_,\n    string memory symbol_\n  ) internal onlyInitializing {\n    __EIP712_init_unchained(name_, \"1\");\n    __ERC20RebaseMiddleware_init_unchained(id_, gETH_, name_, symbol_);\n    __ERC20RebasePermitMiddleware_init_unchained();\n  }\n\n  function __ERC20RebasePermitMiddleware_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @inheritdoc IERC20Permit\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    if (block.timestamp > deadline) {\n      revert ERC2612ExpiredSignature(deadline);\n    }\n\n    bytes32 structHash = keccak256(\n      abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\n    );\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ECDSA.recover(hash, v, r, s);\n    if (signer != owner) {\n      revert ERC2612InvalidSigner(signer, owner);\n    }\n\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @inheritdoc IERC20Permit\n   */\n  function nonces(\n    address owner\n  ) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /**\n   * @inheritdoc IERC20Permit\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n}\n"
    },
    "contracts/modules/DataStoreModule/DataStoreModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - contracts\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n// internal - interfaces\nimport {IDataStoreModule} from \"../../interfaces/modules/IDataStoreModule.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"./structs/storage.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"./libs/DataStoreModuleLib.sol\";\n\n/**\n * @title DSM: DataStore Module\n *\n * @notice A storage management tool designed to create a safe and scalable storage layout\n * for upgradable contracts with various types of data classes (users, packages, definitions).\n *\n * @dev review: this module delegates its functionality to DSML (DataStoreModuleLib).\n * DSM or DSML has NO access control.\n *\n * @dev There are no additional functionalities implemented apart from the library.\n *\n * @dev NO function needs to be overriden when inherited.\n *\n * @dev __DataStoreModule_init (or _unchained) call is not necessary when inherited.\n *\n * @dev No storage-altering external/public functions are exposed here, only view/pure external functions.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract DataStoreModule is IDataStoreModule, Initializable {\n  using DSML for DataStoreModuleStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.DataStoreModule\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant DataStoreModuleStorageLocation =\n    0xa3ee0f890fa2a50cc11476f86783721ec49c3aba88b83a957fe08235f6485c00;\n\n  function _getDataStoreModuleStorage() internal pure returns (DataStoreModuleStorage storage $) {\n    assembly {\n      $.slot := DataStoreModuleStorageLocation\n    }\n  }\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  function __DataStoreModule_init() internal onlyInitializing {}\n\n  function __DataStoreModule_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @custom:section                           ** HELPER FUNCTIONS **\n   *\n   * @custom:visibility -> pure-external\n   */\n\n  /**\n   * @notice useful function for string inputs - returns same with the DSML.generateId\n   * @dev id is generated by keccak(name, type)\n   */\n  function generateId(\n    string calldata _name,\n    uint256 _type\n  ) external pure virtual override returns (uint256 id) {\n    id = uint256(keccak256(abi.encode(_name, _type)));\n  }\n\n  /**\n   * @notice useful view function for string inputs - returns same with the DSML.generateId\n   */\n  function getKey(\n    uint256 _id,\n    bytes32 _param\n  ) external pure virtual override returns (bytes32 key) {\n    return DSML.getKey(_id, _param);\n  }\n\n  /**\n   * @custom:section                           ** DATA GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @dev useful for outside reach, shouldn't be used within contracts as a referance\n   * @return allIdsByType is an array of IDs of the given TYPE from Datastore,\n   * returns a specific index\n   */\n  function allIdsByType(\n    uint256 _type,\n    uint256 _index\n  ) external view virtual override returns (uint256) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    return $.allIdsByType[_type][_index];\n  }\n\n  function allIdsByTypeLength(uint256 _type) external view virtual override returns (uint256) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    return $.allIdsByType[_type].length;\n  }\n\n  function readUint(uint256 id, bytes32 key) external view virtual override returns (uint256 data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readUint(id, key);\n  }\n\n  function readAddress(\n    uint256 id,\n    bytes32 key\n  ) external view virtual override returns (address data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readAddress(id, key);\n  }\n\n  function readBytes(\n    uint256 id,\n    bytes32 key\n  ) external view virtual override returns (bytes memory data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readBytes(id, key);\n  }\n\n  /**\n   * @custom:section                           ** ARRAY GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function readUintArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (uint256 data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readUintArray(id, key, index);\n  }\n\n  function readBytesArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (bytes memory data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readBytesArray(id, key, index);\n  }\n\n  function readAddressArray(\n    uint256 id,\n    bytes32 key,\n    uint256 index\n  ) external view virtual override returns (address data) {\n    DataStoreModuleStorage storage $ = _getDataStoreModuleStorage();\n    data = $.readAddressArray(id, key, index);\n  }\n}\n"
    },
    "contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.20;\n\n// external - interfaces\n// external - libraries\n// external - contracts\n// internal - globals\n// internal - interfaces\nimport {DataStoreModuleStorage} from \"../structs/storage.sol\";\n\n// internal - structs\n// internal - libraries\n\n/**\n * @title DSML: DataStore Module Library\n *\n * @notice A Storage Management Library created for the contracts and modules that inherits DataStoreModule (DSM).\n * Enables Dynamic Structs with unlimited key space.\n * Provides an Isolated Storage Layout with IDs and KEYs.\n * Focusing on upgradable contracts with various data types to create a\n * * sustainable development environment.\n * In summary, extra gas cost that would be saved with Storage packing are\n * * ignored to create dynamic structs.\n *\n * @dev Distinct id and key pairs SHOULD return different storage slots. No collisions!\n * @dev IDs are the representation of an entity with any given key as properties.\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\n * @dev review: For a safer development process, NEVER use the DataStoreModuleStorage with strings. Refer to globals/reserved_key_space.sol\n *\n * @dev While it is a good practice for keeping a record;\n * * TYPE for ID is not mandatory, an ID might not have an explicit type.\n * * e.g., When a relational data is added with getKey, like allowance, it has a unique ID but no TYPE.\n * * Thus there are no checks for types or keys.\n *\n * @dev readUint(id, arrayName) returns the lenght of array.\n *\n * @dev Contracts relying on this library must use DataStoreModuleLib.DataStoreModuleStorage\n * @dev This is an internal library, requires NO deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary DataStoreModuleLib {\n  /**\n   * @custom:section                           ** HELPERS **\n   *\n   * @custom:visibility -> pure-internal\n   */\n\n  /**\n   * @notice generalized method of generating an ID\n   *\n   * @dev Some TYPEs may require permissionless creation, allowing anyone to claim any ID;\n   * meaning malicious actors can claim names to mislead people. To prevent this\n   * TYPEs will be considered during ID generation.\n   */\n  function generateId(bytes memory _name, uint256 _type) internal pure returns (uint256 id) {\n    id = uint256(keccak256(abi.encode(_name, _type)));\n  }\n\n  /**\n   * @notice hash of given ID and a KEY defines the key for the DataStoreModuleStorage\n   * @return key bytes32, hash.\n   **/\n  function getKey(uint256 id, bytes32 param) internal pure returns (bytes32 key) {\n    key = keccak256(abi.encode(id, param));\n  }\n\n  /**\n   * @custom:section                           ** DATA GETTERS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  function readUint(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (uint256 data) {\n    data = self.uintData[getKey(_id, _key)];\n  }\n\n  function readBytes(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (bytes memory data) {\n    data = self.bytesData[getKey(_id, _key)];\n  }\n\n  function readAddress(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key\n  ) internal view returns (address data) {\n    data = self.addressData[getKey(_id, _key)];\n  }\n\n  /**\n   * @custom:section                           ** ARRAY GETTERS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  function readUintArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (uint256 data) {\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\n  }\n\n  function readBytesArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (bytes memory data) {\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\n  }\n\n  function readAddressArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _index\n  ) internal view returns (address data) {\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\n  }\n\n  /**\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @custom:subsection                        ** DATA SETTERS **\n   */\n\n  function writeUint(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _data\n  ) internal {\n    self.uintData[getKey(_id, _key)] = _data;\n  }\n\n  function addUint(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _addend\n  ) internal {\n    self.uintData[getKey(_id, _key)] += _addend;\n  }\n\n  function subUint(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _minuend\n  ) internal {\n    self.uintData[getKey(_id, _key)] -= _minuend;\n  }\n\n  function writeBytes(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes memory _data\n  ) internal {\n    self.bytesData[getKey(_id, _key)] = _data;\n  }\n\n  function writeAddress(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address _data\n  ) internal {\n    self.addressData[getKey(_id, _key)] = _data;\n  }\n\n  /**\n   * @custom:subsection                        ** ARRAY SETTERS **\n   */\n\n  function appendUintArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256 _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  function appendBytesArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  function appendAddressArray(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\n  }\n\n  /**\n   * @custom:subsection                        ** BATCH ARRAY SETTERS **\n   */\n\n  function appendUintArrayBatch(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    uint256[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    uint256 _dataLen = _data.length;\n    for (uint256 i; i < _dataLen; ) {\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n\n  function appendBytesArrayBatch(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    bytes[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    uint256 _dataLen = _data.length;\n    for (uint256 i; i < _dataLen; ) {\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n\n  function appendAddressArrayBatch(\n    DataStoreModuleStorage storage self,\n    uint256 _id,\n    bytes32 _key,\n    address[] memory _data\n  ) internal {\n    bytes32 arrayKey = getKey(_id, _key);\n    uint256 arrayLen = self.uintData[arrayKey];\n\n    uint256 _dataLen = _data.length;\n    for (uint256 i; i < _dataLen; ) {\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.uintData[arrayKey] = arrayLen;\n  }\n}\n"
    },
    "contracts/modules/DataStoreModule/structs/storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice Storage Struct for reading/writing operations for given (id, key) pairs.\n *\n * @param allIdsByType type => id[], optional categorization for IDs, can be directly accessed.\n * @param uintData keccak(id, key) =>  returns uint256\n * @param bytesData keccak(id, key) => returns bytes\n * @param addressData keccak(id, key) =>  returns address\n *\n * @dev any other storage type can be expressed as uint or bytes. E.g., bools are 0/1 as uints.\n *\n * @dev normally we would put custom:storage-location erc7201:geode.storage.DataStoreModule\n * but compiler throws an error... So np for now, just effects dev ex.\n */\nstruct DataStoreModuleStorage {\n  mapping(uint256 => uint256[]) allIdsByType;\n  mapping(bytes32 => uint256) uintData;\n  mapping(bytes32 => bytes) bytesData;\n  mapping(bytes32 => address) addressData;\n}\n"
    },
    "contracts/modules/GeodeModule/GeodeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - library\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// external - contracts\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n// internal - globals\nimport {ID_TYPE} from \"../../globals/id_type.sol\";\n// internal - interfaces\nimport {IGeodeModule} from \"../../interfaces/modules/IGeodeModule.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../DataStoreModule/structs/storage.sol\";\nimport {GeodeModuleStorage} from \"./structs/storage.sol\";\nimport {Proposal} from \"./structs/utils.sol\";\n// internal - libraries\nimport {GeodeModuleLib as GML} from \"./libs/GeodeModuleLib.sol\";\nimport {DataStoreModuleLib as DSML} from \"../DataStoreModule/libs/DataStoreModuleLib.sol\";\n// internal - contracts\nimport {DataStoreModule} from \"../DataStoreModule/DataStoreModule.sol\";\n\n/**\n * @title GM: Geode Module\n *\n * @notice Base logic for Upgradable Packages:\n * * Dual Governance with Senate+Governance: Governance proposes, Senate approves.\n * * Limited Upgradability built on top of UUPS via Dual Governance.\n *\n * @dev review: this module delegates its functionality to GML (GeodeModuleLib):\n * GML has onlyGovernance, onlySenate, onlyController modifiers for access control.\n *\n * @dev There is 1 additional functionality implemented apart from the library:\n * Mutating UUPS pattern to fit Limited Upgradability:\n * 1. New implementation contract is proposed with its own package type within the limits, refer to globals/id_type.sol.\n * 2. Proposal is approved by the contract owner, Senate.\n * 3. approveProposal calls _handleUpgrade which mimics UUPS.upgradeTo:\n * 3.1. Checks the implementation address with _authorizeUpgrade, also preventing any UUPS upgrades.\n * 3.2. Upgrades the contract with no function to call afterwards.\n * 3.3. Sets contract version. Note that it does not increase linearly like one might expect.\n *\n * @dev 1 function needs to be overriden when inherited: isolationMode. (also refer to approveProposal)\n *\n * @dev __GeodeModule_init (or _unchained) call is NECESSARY when inherited.\n * However, deployer MUST call initializer after upgradeTo call,\n * should not call initializer on upgradeToAndCall or new ERC1967Proxy calls.\n *\n * @dev This module inherits DataStoreModule.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract GeodeModule is IGeodeModule, UUPSUpgradeable, DataStoreModule {\n  using GML for GeodeModuleStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.GeodeModuleStorage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant GeodeModuleStorageLocation =\n    0x121584cf2b7b1dee51ceaabc76cdefc72f829ce42dd8cc5282d8e9f009b04200;\n\n  function _getGeodeModuleStorage() internal pure returns (GeodeModuleStorage storage $) {\n    assembly {\n      $.slot := GeodeModuleStorageLocation\n    }\n  }\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event ContractVersionSet(uint256 version);\n\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n  event Approved(uint256 ID);\n  event NewSenate(address senate, uint256 expiry);\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   */\n  function isolationMode() external view virtual override returns (bool);\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  function __GeodeModule_init(\n    address governance,\n    address senate,\n    uint256 senateExpiry,\n    uint256 packageType,\n    bytes calldata initVersionName\n  ) internal onlyInitializing {\n    __UUPSUpgradeable_init();\n    __DataStoreModule_init();\n    __GeodeModule_init_unchained(governance, senate, senateExpiry, packageType, initVersionName);\n  }\n\n  /**\n   * @dev This function uses _getImplementation(), clearly deployer should not call initializer on\n   * upgradeToAndCall or new ERC1967Proxy calls. _getImplementation() returns 0 then.\n   * @dev GOVERNANCE and SENATE set to msg.sender at beginning, cannot propose+approve otherwise.\n   * @dev native approveProposal(public) is not used here. Because it has an _handleUpgrade,\n   * however initialization does not require UUPS.upgradeTo.\n   */\n  function __GeodeModule_init_unchained(\n    address governance,\n    address senate,\n    uint256 senateExpiry,\n    uint256 packageType,\n    bytes calldata initVersionName\n  ) internal onlyInitializing {\n    require(governance != address(0), \"GM:governance cannot be zero\");\n    require(senate != address(0), \"GM:senate cannot be zero\");\n    require(senateExpiry > block.timestamp, \"GM:low senateExpiry\");\n    require(packageType != 0, \"GM:packageType cannot be zero\");\n    require(initVersionName.length != 0, \"GM:initVersionName cannot be empty\");\n\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    $.GOVERNANCE = msg.sender;\n    $.SENATE = msg.sender;\n\n    $.SENATE_EXPIRY = senateExpiry;\n    $.PACKAGE_TYPE = packageType;\n\n    DataStoreModuleStorage storage DSMStorage = _getDataStoreModuleStorage();\n\n    uint256 initVersion = $.propose(\n      DSMStorage,\n      ERC1967Utils.getImplementation(),\n      packageType,\n      initVersionName,\n      1 days\n    );\n\n    $.approveProposal(DSMStorage, initVersion);\n\n    _setContractVersion(DSML.generateId(initVersionName, $.PACKAGE_TYPE));\n\n    $.GOVERNANCE = governance;\n    $.SENATE = senate;\n  }\n\n  /**\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @dev required by the OZ UUPS module, improved by the Geode Module.\n   */\n  function _authorizeUpgrade(address proposed_implementation) internal virtual override {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    require(\n      $.isUpgradeAllowed(proposed_implementation, ERC1967Utils.getImplementation()),\n      \"GM:not allowed to upgrade\"\n    );\n  }\n\n  function _setContractVersion(uint256 id) internal virtual {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    $.CONTRACT_VERSION = id;\n    emit ContractVersionSet(id);\n  }\n\n  /**\n   * @dev Would use the public upgradeTo() call, which does _authorizeUpgrade and _upgradeToAndCallUUPS,\n   * but it is external, OZ have not made it public yet.\n   */\n  function _handleUpgrade(address proposed_implementation, uint256 id) internal virtual {\n    UUPSUpgradeable.upgradeToAndCall(proposed_implementation, \"\");\n    _setContractVersion(id);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function GeodeParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address governance,\n      address senate,\n      address approvedUpgrade,\n      uint256 senateExpiry,\n      uint256 packageType\n    )\n  {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n\n    governance = $.GOVERNANCE;\n    senate = $.SENATE;\n    approvedUpgrade = $.APPROVED_UPGRADE;\n    senateExpiry = $.SENATE_EXPIRY;\n    packageType = $.PACKAGE_TYPE;\n  }\n\n  function getGovernance() external view virtual override returns (address) {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    return $.GOVERNANCE;\n  }\n\n  function getContractVersion() public view virtual override returns (uint256) {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    return $.CONTRACT_VERSION;\n  }\n\n  function getProposal(\n    uint256 id\n  ) external view virtual override returns (Proposal memory proposal) {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    proposal = $.getProposal(id);\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   *\n   * @custom:visibility -> public/external\n   */\n\n  /**\n   * @custom:subsection                        ** ONLY GOVERNANCE **\n   *\n   */\n\n  function propose(\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) public virtual override returns (uint256 id) {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    id = $.propose(_getDataStoreModuleStorage(), _CONTROLLER, _TYPE, _NAME, duration);\n  }\n\n  function rescueSenate(address _newSenate) external virtual override {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    $.rescueSenate(_newSenate);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY SENATE **\n   */\n\n  /**\n   * @dev handles PACKAGE_TYPE proposals by upgrading the contract immediately.\n   * @dev onlySenate is checked inside GML.approveProposal\n   */\n  function approveProposal(\n    uint256 id\n  ) public virtual override returns (address _controller, uint256 _type, bytes memory _name) {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    (_controller, _type, _name) = $.approveProposal(_getDataStoreModuleStorage(), id);\n\n    if (_type == $.PACKAGE_TYPE) {\n      _handleUpgrade(_controller, id);\n    }\n  }\n\n  function changeSenate(address _newSenate) external virtual override {\n    GeodeModuleStorage storage $ = _getGeodeModuleStorage();\n    $.changeSenate(_newSenate);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY CONTROLLER **\n   */\n\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external virtual override {\n    GML.changeIdCONTROLLER(_getDataStoreModuleStorage(), id, newCONTROLLER);\n  }\n}\n"
    },
    "contracts/modules/GeodeModule/libs/GeodeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - globals\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../../DataStoreModule/structs/storage.sol\";\nimport {GeodeModuleStorage} from \"../structs/storage.sol\";\nimport {Proposal} from \"../structs/utils.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\n\n/**\n * @title GML: Geode Module Library\n *\n * @notice Dual Governance & Limited Upgradability:\n * Administration of the Isolated Storage with a Dual Governance consisting a Governance and a Senate.\n * Administration of a UUPS contract with Limited Upgradability for Packages like Portal, LiquidityPool.\n *\n * @dev review: DataStoreModule for the id based isolated storage logic.\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\n *\n * @dev SENATE_EXPIRY is not mandatory to utilize. Simply set it to MAX_UINT256 if rescueSenate is not needed.\n *\n * @dev There are 3 ways to set a new Senate:\n * 1. With a proposal TYPE 1. Proposal's controller becomes the new Senate, refreshes the expiry.\n * 2. Current Senate can call changeSenate, which doesn't change the expiry\n * 3. As a circuit breaker: If senate is expired, then rescue senate can be called by governance.\n * @dev Currently, there are no way to set a new Governance.\n *\n *\n * @dev Contracts relying on this library must use GeodeModuleLib.GeodeModuleStorage\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary GeodeModuleLib {\n  using DSML for DataStoreModuleStorage;\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice a proposal can have a duration between 1 days to 4 weeks (inclusive)\n  uint32 internal constant MIN_PROPOSAL_DURATION = 1 days;\n  uint32 internal constant MAX_PROPOSAL_DURATION = 4 weeks;\n\n  /// @notice if expiry is utilized, a senate can be active for a year.\n  /// @dev \"MAX\" underlines a new senate can be set without expecting an expiry\n  uint32 internal constant MAX_SENATE_PERIOD = 365 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Proposed(uint256 indexed TYPE, uint256 ID, address CONTROLLER, uint256 deadline);\n  event Approved(uint256 ID);\n  event NewSenate(address senate, uint256 expiry);\n  event ControllerChanged(uint256 indexed ID, address CONTROLLER);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyGovernance(GeodeModuleStorage storage self) {\n    require(msg.sender == self.GOVERNANCE, \"GML:GOVERNANCE role needed\");\n    _;\n  }\n\n  modifier onlySenate(GeodeModuleStorage storage self) {\n    require(msg.sender == self.SENATE, \"GML:SENATE role needed\");\n    require(block.timestamp < self.SENATE_EXPIRY, \"GML:SENATE expired\");\n    _;\n  }\n\n  modifier onlyController(DataStoreModuleStorage storage DATASTORE, uint256 id) {\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"GML:CONTROLLER role needed\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** LIMITED UUPS VERSION CONTROL **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @notice Check if it is allowed to change the package version to given proposedImplementation.\n   * @dev provided for _authorizeUpgrade\n   * @dev currentImplementation should always be UUPS._getImplementation()\n   * @dev currentImplementation or zero as proposedImplementation will return false\n   **/\n  function isUpgradeAllowed(\n    GeodeModuleStorage storage self,\n    address proposedImplementation,\n    address currentImplementation\n  ) external view returns (bool) {\n    return\n      (self.APPROVED_UPGRADE != address(0)) &&\n      (proposedImplementation != currentImplementation) &&\n      (self.APPROVED_UPGRADE == proposedImplementation);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function getProposal(\n    GeodeModuleStorage storage self,\n    uint256 id\n  ) external view returns (Proposal memory) {\n    return self.proposals[id];\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   */\n\n  /**\n   * @custom:subsection                        ** INTERNAL **\n   *\n   * @custom:visibility -> internal\n   */\n  function _setSenate(\n    GeodeModuleStorage storage self,\n    address _newSenate,\n    uint256 _expiry\n  ) internal {\n    require(_newSenate != address(0), \"GML:Senate cannot be zero address\");\n    self.SENATE = _newSenate;\n    self.SENATE_EXPIRY = _expiry;\n\n    emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY GOVERNANCE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice generates a new ID with given TYPE and NAME, proposes it to be owned by a CONTROLLER.\n   * @dev DATASTORE[id] will not be updated until the proposal is approved\n   * @dev Proposals can NEVER be overriden\n   */\n  function propose(\n    GeodeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    address _CONTROLLER,\n    uint256 _TYPE,\n    bytes calldata _NAME,\n    uint256 duration\n  ) external onlyGovernance(self) returns (uint256 id) {\n    id = DSML.generateId(_NAME, _TYPE);\n\n    require(self.proposals[id].deadline == 0, \"GML:already proposed\");\n    require((DATASTORE.readBytes(id, rks.NAME)).length == 0, \"GML:ID already exist\");\n    require(_CONTROLLER != address(0), \"GML:CONTROLLER cannot be ZERO\");\n    require((_TYPE != ID_TYPE.NONE) && (_TYPE != ID_TYPE.POOL), \"GML:TYPE is NONE or POOL\");\n    require(\n      (duration >= MIN_PROPOSAL_DURATION) && (duration <= MAX_PROPOSAL_DURATION),\n      \"GML:invalid proposal duration\"\n    );\n\n    uint256 _deadline = block.timestamp + duration;\n\n    self.proposals[id] = Proposal({\n      CONTROLLER: _CONTROLLER,\n      TYPE: _TYPE,\n      NAME: _NAME,\n      deadline: _deadline\n    });\n\n    emit Proposed(_TYPE, id, _CONTROLLER, _deadline);\n  }\n\n  /**\n   * @notice changes Senate in a scenerio where the current Senate acts maliciously!\n   * * We are sure this will not be the case, but creating a method for possible recovery is a must.\n   * @notice Normally, Governance creates Senate Proposals frequently to signal it does not have\n   * * any intent of malicious overtake.\n   * note: If Governance does not send a Senate Proposal \"a while\" before the SENATE_EXPIRY,\n   * * we recommend users to take their money out.\n   * @dev Obviously, Governance needs to wait for SENATE_EXPIRY.\n   * @dev Refreshes the expiry\n   */\n  function rescueSenate(\n    GeodeModuleStorage storage self,\n    address _newSenate\n  ) external onlyGovernance(self) {\n    require(block.timestamp > self.SENATE_EXPIRY, \"GML:cannot rescue yet\");\n\n    _setSenate(self, _newSenate, block.timestamp + MAX_SENATE_PERIOD);\n  }\n\n  /**\n   * @custom:subsection                        ** ONLY SENATE **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice approves a proposal and records given data to DataStore\n   * @notice specific changes for the reserved types (1, 2, 3) are implemented here,\n   * any other addition should take place in Portal, as not related.\n   * Note that GM has additional logic for package type approvals.\n   * @param id given ID proposal that has will be approved by Senate\n   * @dev Senate is not able to approve approved proposals\n   * @dev Senate is not able to approve expired proposals\n   */\n  function approveProposal(\n    GeodeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id\n  ) external onlySenate(self) returns (address _controller, uint256 _type, bytes memory _name) {\n    require(self.proposals[id].deadline > block.timestamp, \"GML:not an active proposal\");\n\n    _controller = self.proposals[id].CONTROLLER;\n    _type = self.proposals[id].TYPE;\n    _name = self.proposals[id].NAME;\n\n    DATASTORE.writeUint(id, rks.TYPE, _type);\n    DATASTORE.writeAddress(id, rks.CONTROLLER, _controller);\n    DATASTORE.writeBytes(id, rks.NAME, _name);\n    DATASTORE.allIdsByType[_type].push(id);\n\n    if (_type == ID_TYPE.SENATE) {\n      _setSenate(self, _controller, block.timestamp + MAX_SENATE_PERIOD);\n    } else if (_type == self.PACKAGE_TYPE) {\n      self.APPROVED_UPGRADE = _controller;\n    }\n\n    // important\n    self.proposals[id].deadline = block.timestamp;\n\n    emit Approved(id);\n  }\n\n  /**\n   * @notice It is useful to be able to change the Senate's address without changing the expiry.\n   * @dev Does not change the expiry\n   */\n  function changeSenate(\n    GeodeModuleStorage storage self,\n    address _newSenate\n  ) external onlySenate(self) {\n    _setSenate(self, _newSenate, self.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:section                           ** ONLY CONTROLLER **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice change the CONTROLLER of an ID\n   * @dev this operation cannot be reverted by the old CONTROLLER!!!\n   * @dev cannot provide address(0), try 0x000000000000000000000000000000000000dEaD\n   */\n  function changeIdCONTROLLER(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    address newCONTROLLER\n  ) external onlyController(DATASTORE, id) {\n    require(newCONTROLLER != address(0), \"GML:CONTROLLER cannot be zero\");\n\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\n    require(\n      typeOfId > ID_TYPE.LIMIT_MIN_USER && typeOfId < ID_TYPE.LIMIT_MAX_USER,\n      \"GML:ID TYPE is not user\"\n    );\n\n    DATASTORE.writeAddress(id, rks.CONTROLLER, newCONTROLLER);\n\n    emit ControllerChanged(id, newCONTROLLER);\n  }\n}\n"
    },
    "contracts/modules/GeodeModule/structs/storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - structs\nimport {Proposal} from \"./utils.sol\";\n\n/**\n * @notice Storage struct for the Dual Governance logic\n * @dev Dual Governance allows 2 parties to manage a package with proposals and approvals.\n * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\n * Suggests updates, such as new operators, contract/package upgrades, a new Senate (without any permission to force them)\n * @param SENATE An address that protects the users by controlling the state of governance, contract updates and other crucial changes\n * @param APPROVED_UPGRADE only 1 implementation contract SHOULD be \"approved\" at any given time.\n * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Might not be utilized. Limited by MAX_SENATE_PERIOD\n * @param PACKAGE_TYPE every package has a specific TYPE. Defined in globals/id_type.sol\n * @param CONTRACT_VERSION always refers to the upgrade proposal ID. Does not increase uniformly like one might expect.\n * @param proposals till approved, proposals are kept separated from the Isolated Storage\n *\n * @dev normally we would put custom:storage-location erc7201:geode.storage.GeodeModule\n * but compiler throws an error... So np for now, just effects dev ex.\n **/\nstruct GeodeModuleStorage {\n  address GOVERNANCE;\n  address SENATE;\n  address APPROVED_UPGRADE;\n  uint256 SENATE_EXPIRY;\n  uint256 PACKAGE_TYPE;\n  uint256 CONTRACT_VERSION;\n  mapping(uint256 => Proposal) proposals;\n}\n"
    },
    "contracts/modules/GeodeModule/structs/utils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice Giving the control of a specific ID to proposed CONTROLLER.\n *\n * @param TYPE: refer to globals/id_type.sol\n * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\n * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\n * @param NAME: DataStore generates ID by keccak(name, type)\n * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\n * * Expired proposals cannot be approved by Senate\n * * Expired proposals cannot be overriden by new proposals\n **/\nstruct Proposal {\n  address CONTROLLER;\n  uint256 TYPE;\n  bytes NAME;\n  uint256 deadline;\n}\n"
    },
    "contracts/modules/LiquidityModule/libs/AmplificationLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - structs\nimport {LiquidityModuleStorage} from \"../structs/storage.sol\";\n// internal - libraries\nimport {LiquidityModuleLib as LML} from \"./LiquidityModuleLib.sol\";\n\n/**\n * @title AL: Amplification Library\n *\n * @notice A helper library for Liquidity Module Library (LML) to calculate and ramp the A parameter of a given `LiquidityModuleLib.LiquidityModuleStorage` struct.\n *\n * @dev review: Liquidity Module for the StableSwap logic.\n * @dev This library assumes the Swap struct is fully validated.\n *\n * @dev This is an internal library, requires NO deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary AmplificationLib {\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n  uint256 internal constant A_PRECISION = 100;\n  uint256 internal constant MAX_A = 1e6;\n  uint256 internal constant MAX_A_CHANGE = 2;\n  uint256 internal constant MIN_RAMP_TIME = 14 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n  event StopRampA(uint256 currentA, uint256 time);\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter\n   */\n  function getA(LiquidityModuleStorage storage self) internal view returns (uint256) {\n    return _getAPrecise(self) / (A_PRECISION);\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter in its raw precision form\n   */\n  function getAPrecise(LiquidityModuleStorage storage self) internal view returns (uint256) {\n    return _getAPrecise(self);\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter in its raw precision form\n   */\n  function _getAPrecise(LiquidityModuleStorage storage self) internal view returns (uint256) {\n    uint256 t1 = self.futureATime; // time when ramp is finished\n    uint256 a1 = self.futureA; // final A value when ramp is finished\n\n    if (block.timestamp < t1) {\n      uint256 t0 = self.initialATime; // time when ramp is started\n      uint256 a0 = self.initialA; // initial A value when ramp is started\n      if (a1 > a0) {\n        // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n        return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\n      } else {\n        // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n        return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\n      }\n    } else {\n      return a1;\n    }\n  }\n\n  /**\n   * @custom:section                           ** SETTER FUNCTIONS **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param self Swap struct to update\n   * @param futureA_ the new A to ramp towards\n   * @param futureTime_ timestamp when the new A should be reached\n   */\n  function rampA(\n    LiquidityModuleStorage storage self,\n    uint256 futureA_,\n    uint256 futureTime_\n  ) internal {\n    require(block.timestamp >= self.initialATime + 1 days, \"AL:Wait 1 day before starting ramp\");\n    require(futureTime_ >= block.timestamp + MIN_RAMP_TIME, \"AL:Insufficient ramp time\");\n    require(futureA_ > 0 && futureA_ < MAX_A, \"AL:futureA_ must be > 0 and < MAX_A\");\n\n    uint256 initialAPrecise = _getAPrecise(self);\n    uint256 futureAPrecise = futureA_ * A_PRECISION;\n\n    if (futureAPrecise < initialAPrecise) {\n      require(futureAPrecise * MAX_A_CHANGE >= initialAPrecise, \"AL:futureA_ is too small\");\n    } else {\n      require(futureAPrecise <= initialAPrecise * MAX_A_CHANGE, \"AL:futureA_ is too large\");\n    }\n\n    self.initialA = initialAPrecise;\n    self.futureA = futureAPrecise;\n    self.initialATime = block.timestamp;\n    self.futureATime = futureTime_;\n\n    emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\n  }\n\n  /**\n   * @notice Stops ramping A immediately. Once this function is called, rampA()\n   * cannot be called for another 24 hours\n   * @param self Swap struct to update\n   */\n  function stopRampA(LiquidityModuleStorage storage self) internal {\n    require(self.futureATime > block.timestamp, \"AL:Ramp is already stopped\");\n\n    uint256 currentA = _getAPrecise(self);\n    self.initialA = currentA;\n    self.futureA = currentA;\n    self.initialATime = block.timestamp;\n    self.futureATime = block.timestamp;\n\n    emit StopRampA(currentA, block.timestamp);\n  }\n}\n"
    },
    "contracts/modules/LiquidityModule/libs/LiquidityModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - globals\nimport {gETH_DENOMINATOR, PERCENTAGE_DENOMINATOR} from \"../../../globals/macros.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\nimport {ILPToken} from \"../../../interfaces/helpers/ILPToken.sol\";\n// internal - structs\nimport {LiquidityModuleStorage} from \"../structs/storage.sol\";\nimport {CalculateWithdrawOneTokenDYInfo, ManageLiquidityInfo} from \"../structs/helpers.sol\";\n// internal - libraries\nimport {AmplificationLib as AL} from \"./AmplificationLib.sol\";\n\n/**\n * @title LiquidityModule Library - LML\n *\n * @notice A library to be used within LiquidityModule\n * * Contains functions responsible for custody and AMM functionalities with some changes.\n * * The main functionality of Liquidity Pools is allowing the depositors to have instant access to liquidity\n * * relying on the Oracle Price, with the help of Liquidity Providers.\n *\n * @dev focus point (1-1) of the pricing algorithm is manipulated with PriceIn and PriceOut functions.\n * Because the underlying price of the staked assets are expected to raise in time.\n * One can see this similar to accomplishing a \"rebasing\" logic, with the help of a trusted price source.\n * Whenever \"Effective Balance\" is mentioned it refers to the balance projected with the underlying price.\n *\n * @dev Contracts relying on this library must initialize LiquidityModuleLib.Swap struct\n * * Note that this library contains both functions called by users and admins.\n * * Admin functions should be protected within contracts using this library.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary LiquidityModuleLib {\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice Max swap fee is 1% or 100bps of each swap\n  uint256 internal constant MAX_SWAP_FEE = 1e8; // PERCENTAGE_DENOMINATOR / 100;\n\n  /// @notice Max adminFee is 50% of the swapFee\n  /// adminFee does not add additional fee on top of swapFee\n  /// instead it takes a certain percentage of the swapFee.\n  /// Therefore it has no impact on users but only on the earnings of LPs\n  uint256 internal constant MAX_ADMIN_FEE = 5e9; // (50 * PERCENTAGE_DENOMINATOR) / 100;\n\n  /// @notice Constant value used as max loop limit\n  uint256 internal constant MAX_LOOP_LIMIT = 256;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n\n  event TokenSwap(\n    address indexed buyer,\n    uint256 tokensSold,\n    uint256 tokensBought,\n    uint128 soldId,\n    uint128 boughtId\n  );\n  event AddLiquidity(\n    address indexed provider,\n    uint256[2] tokenAmounts,\n    uint256[2] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[2] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[2] tokenAmounts,\n    uint256[2] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n\n  /**\n   * @custom:section                           ** HELPERS **\n   *\n   * @custom:visibility -> pure-internal\n   */\n\n  /**\n   * @custom:subsection Math helpers\n   */\n\n  /**\n   * @notice Compares a and b and returns true if the difference between a and b is 1 or 0.\n   * @param a uint256 to compare with\n   * @param b uint256 to compare with\n   * @return True if the difference between a and b is less than 1 or equal.\n   */\n  function within1(uint256 a, uint256 b) internal pure returns (bool) {\n    return (difference(a, b) <= 1);\n  }\n\n  /**\n   * @notice Calculates absolute difference between a and b\n   * @param a uint256 to compare with\n   * @param b uint256 to compare with\n   * @return Difference between a and b\n   */\n  function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a > b) {\n      return a - b;\n    }\n    return b - a;\n  }\n\n  /**\n   * @custom:subsection StableSwap invariants: D,Y,YD\n   */\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   *  balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a  set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[2] memory xp,\n    uint256 d\n  ) internal pure returns (uint256) {\n    uint256 numTokens = 2;\n    require(tokenIndex < numTokens, \"LML:Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < numTokens; ) {\n      if (i != tokenIndex) {\n        s = s + xp[i];\n        c = (c * d) / (xp[i] * (numTokens));\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    c = (c * d * AL.A_PRECISION) / (nA * numTokens);\n\n    uint256 b = s + ((d * AL.A_PRECISION) / nA);\n    uint256 yPrev;\n    uint256 y = d;\n\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / (2 * y + b - d);\n      if (within1(y, yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a  set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[2] memory xp, uint256 a) internal pure returns (uint256) {\n    uint256 numTokens = 2;\n    uint256 s = xp[0] + xp[1];\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\n      uint256 dP = (d ** (numTokens + 1)) / (numTokens ** numTokens * xp[0] * xp[1]);\n      prevD = d;\n      d =\n        ((((nA * s) / AL.A_PRECISION) + dP * numTokens) * (d)) /\n        (((nA - AL.A_PRECISION) * (d)) / (AL.A_PRECISION) + ((numTokens + 1) * dP));\n\n      if (within1(d, prevD)) {\n        return d;\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[2] memory xp\n  ) internal pure returns (uint256) {\n    uint256 numTokens = 2;\n    require(tokenIndexFrom != tokenIndexTo, \"LML:Cannot compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"LML:Tokens must be in pool\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s = x;\n    uint256 nA = numTokens * (preciseA);\n\n    c = (c * d) / (x * numTokens);\n    c = (c * d * (AL.A_PRECISION)) / (nA * numTokens);\n    uint256 b = s + ((d * AL.A_PRECISION) / nA);\n\n    uint256 yPrev;\n    uint256 y = d;\n\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / (2 * y + b - d);\n      if (within1(y, yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @custom:subsection                           ** REBASING FUNCTIONS **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  /**\n   * @notice This function MULTIPLIES the Staking Derivative (gETH) balance with underlying relative price (pricePerShare),\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\n   * @param balance balance that will be taken into calculation\n   * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\n   */\n  function _pricedIn(\n    LiquidityModuleStorage storage self,\n    uint256 balance,\n    uint256 i\n  ) internal view returns (uint256) {\n    return\n      i == 1 ? (balance * self.gETH.pricePerShare(self.pooledTokenId)) / gETH_DENOMINATOR : balance;\n  }\n\n  /**\n   * @notice This function DIVIDES the Staking Derivative (gETH) balance with underlying relative price (pricePerShare),\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\n   * @param balance balance that will be taken into calculation\n   * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\n   */\n  function _pricedOut(\n    LiquidityModuleStorage storage self,\n    uint256 balance,\n    uint256 i\n  ) internal view returns (uint256) {\n    return\n      i == 1 ? (balance * gETH_DENOMINATOR) / self.gETH.pricePerShare(self.pooledTokenId) : balance;\n  }\n\n  /**\n   * @notice This function MULTIPLIES the Staking Derivative (gETH) balance with underlying relative price (pricePerShare),\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\n   * @param balances ARRAY of balances that will be taken into calculation\n   */\n  function _pricedInBatch(\n    LiquidityModuleStorage storage self,\n    uint256[2] memory balances\n  ) internal view returns (uint256[2] memory _p) {\n    _p[0] = balances[0];\n    _p[1] = (balances[1] * self.gETH.pricePerShare(self.pooledTokenId)) / gETH_DENOMINATOR;\n    return _p;\n  }\n\n  /**\n   * @notice This function DIVIDES the Staking Derivative (gETH) balance with underlying relative price (pricePerShare),\n   * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\n   * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\n   * @param balances ARRAY of balances that will be taken into calculation\n   */\n  function _pricedOutBatch(\n    LiquidityModuleStorage storage self,\n    uint256[2] memory balances\n  ) internal view returns (uint256[2] memory _p) {\n    _p[0] = balances[0];\n    _p[1] = (balances[1] * gETH_DENOMINATOR) / self.gETH.pricePerShare(self.pooledTokenId);\n    return _p;\n  }\n\n  /**\n   * @custom:subsection                           ** DEBT FUNCTIONS **\n   *\n   * @custom:visibility -> view\n   *\n   * @dev debt refers to the amount of ETH needed to stabilize the pool\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice Get Debt, The amount of buyback for stable pricing.\n   * @param xp a  set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\n   */\n  function _getDebt(\n    LiquidityModuleStorage storage self,\n    uint256[2] memory xp,\n    uint256 a\n  ) internal view returns (uint256 debt) {\n    uint256 halfD = getD(xp, a) >> 1;\n    if (xp[0] >= halfD) {\n      debt = 0;\n    } else {\n      uint256 dy = xp[1] - halfD;\n      uint256 feeHalf = ((dy * self.swapFee) / PERCENTAGE_DENOMINATOR) >> 1;\n      debt = halfD - xp[0] + feeHalf;\n    }\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\n   * @dev might change when price is in.\n   */\n  function getDebt(LiquidityModuleStorage storage self) external view returns (uint256) {\n    return _getDebt(self, _pricedInBatch(self, self.balances), AL._getAPrecise(self));\n  }\n\n  /**\n   * @custom:section                           ** SWAP HELPER FUNCTIONS **\n   */\n\n  /**\n   * @custom:visibility -> pure-internal\n   */\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return amounts of tokens user will receive as an array [ETH, gETH]\n   */\n  function _calculateRemoveLiquidity(\n    uint256[2] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[2] memory amounts) {\n    require(amount <= totalSupply, \"LML:Cannot exceed total supply\");\n\n    amounts[0] = (balances[0] * amount) / totalSupply;\n    amounts[1] = (balances[1] * amount) / totalSupply;\n\n    return amounts;\n  }\n\n  /**\n   * @custom:visibility -> view-internal\n   */\n\n  function _calculateWithdrawOneToken(\n    LiquidityModuleStorage storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) internal view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    uint256 dySwapFee = currentY - newY - dy;\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   * @return dyFee the associated fee\n   */\n  function _calculateSwap(\n    LiquidityModuleStorage storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[2] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    require(tokenIndexFrom < 2 && tokenIndexTo < 2, \"LML:Token index out of range\");\n\n    uint256 x = _pricedIn(self, dx + balances[tokenIndexFrom], tokenIndexFrom);\n    uint256[2] memory pricedBalances = _pricedInBatch(self, balances);\n    uint256 y = _pricedOut(\n      self,\n      getY(AL._getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, pricedBalances),\n      tokenIndexTo // => not id, index !!!\n    );\n    dy = balances[tokenIndexTo] - y - 1;\n    dyFee = (dy * self.swapFee) / (PERCENTAGE_DENOMINATOR);\n    dy = dy - dyFee;\n  }\n\n  /**\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    LiquidityModuleStorage storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    LiquidityModuleStorage storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  ) internal view returns (uint256, uint256, uint256) {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n\n    require(tokenIndex < 2, \"LML:Token index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = AL._getAPrecise(self);\n    v.d0 = getD(_pricedInBatch(self, self.balances), v.preciseA);\n    v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n    require(tokenAmount <= self.balances[tokenIndex], \"LML:Withdraw exceeds available\");\n\n    v.newY = _pricedOut(\n      self,\n      getYD(v.preciseA, tokenIndex, _pricedInBatch(self, self.balances), v.d1),\n      tokenIndex\n    );\n\n    uint256[2] memory xpReduced;\n\n    v.feePerToken = self.swapFee >> 1;\n    for (uint256 i; i < 2; ) {\n      uint256 xpi = self.balances[i];\n      xpReduced[i] =\n        xpi -\n        ((((i == tokenIndex) ? (xpi * v.d1) / v.d0 - v.newY : xpi - ((xpi * v.d1) / (v.d0))) *\n          (v.feePerToken)) / (PERCENTAGE_DENOMINATOR));\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    uint256 dy = xpReduced[tokenIndex] -\n      _pricedOut(\n        self,\n        (getYD(v.preciseA, tokenIndex, _pricedInBatch(self, xpReduced), v.d1)),\n        tokenIndex\n      );\n    dy = dy - 1;\n\n    return (dy, v.newY, self.balances[tokenIndex]);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price\n   */\n  function getVirtualPrice(LiquidityModuleStorage storage self) external view returns (uint256) {\n    uint256 d = getD(_pricedInBatch(self, self.balances), AL._getAPrecise(self));\n    ILPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply > 0) {\n      return (d * 1e18) / supply;\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    LiquidityModuleStorage storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Uses _calculateRemoveLiquidity with Effective Balances,\n   * then projects the prices to the token amounts\n   * to get Real Balances, before removing them from pool.\n   */\n  function calculateRemoveLiquidity(\n    LiquidityModuleStorage storage self,\n    uint256 amount\n  ) external view returns (uint256[2] memory) {\n    return\n      _pricedOutBatch(\n        self,\n        _calculateRemoveLiquidity(\n          _pricedInBatch(self, self.balances),\n          amount,\n          self.lpToken.totalSupply()\n        )\n      );\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    LiquidityModuleStorage storage self,\n    uint256[2] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    uint256 a = AL._getAPrecise(self);\n    uint256[2] memory balances = self.balances;\n\n    uint256 d0 = getD(_pricedInBatch(self, balances), a);\n    for (uint256 i; i < 2; ) {\n      if (deposit) {\n        balances[i] = balances[i] + amounts[i];\n      } else {\n        require(amounts[i] <= balances[i], \"LML:Cannot withdraw > available\");\n        balances[i] = balances[i] - amounts[i];\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    uint256 d1 = getD(_pricedInBatch(self, balances), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return ((d1 - d0) * totalSupply) / d0;\n    } else {\n      return ((d0 - d1) * totalSupply) / d0;\n    }\n  }\n\n  /**\n   * @custom:section                           ** ADMIN HELPER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(\n    LiquidityModuleStorage storage self,\n    uint256 index\n  ) external view returns (uint256) {\n    require(index < 2, \"LML:Token index out of range\");\n    if (index == 0) {\n      return address(this).balance - (self.balances[index]);\n    } else if (index == 1) {\n      return self.gETH.balanceOf(address(this), self.pooledTokenId) - (self.balances[index]);\n    } else {\n      revert(\"LML:invalid index\");\n    }\n  }\n\n  /**\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    LiquidityModuleStorage storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) external returns (uint256) {\n    IgETH gETHRef = self.gETH;\n    if (tokenIndexFrom == 0) {\n      // Means user is selling some ETH to the pool to get some gETH.\n      // In which case, we need to send exactly that amount of ETH.\n      require(dx == msg.value, \"LML:Cannot swap != eth sent\");\n    }\n    if (tokenIndexFrom == 1) {\n      // Means user is selling some gETH to the pool to get some ETH.\n\n      require(dx <= gETHRef.balanceOf(msg.sender, self.pooledTokenId), \"LML:Cannot swap > you own\");\n\n      // Transfer tokens first\n      uint256 beforeBalance = gETHRef.balanceOf(address(this), self.pooledTokenId);\n      gETHRef.safeTransferFrom(msg.sender, address(this), self.pooledTokenId, dx, \"\");\n\n      // Use the actual transferred amount for AMM math\n      dx = gETHRef.balanceOf(address(this), self.pooledTokenId) - beforeBalance;\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    // Meaning the real balances *without* any effect of underlying price\n    // However, when we call _calculateSwap, it uses pricedIn function before calculation,\n    // and pricedOut function after the calculation. So, we don't need to use priceOut here.\n    uint256[2] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n\n    require(dy >= minDy, \"LML:Swap didnot result in min tokens\");\n    uint256 dyAdminFee = (dyFee * self.adminFee) / PERCENTAGE_DENOMINATOR;\n\n    // To prevent any Reentrancy, balances are updated before transfering the tokens.\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n\n    if (tokenIndexTo == 0) {\n      // Means contract is going to send Idle Ether (ETH)\n      (bool sent, ) = payable(msg.sender).call{value: dy}(\"\");\n      require(sent, \"LML:Failed to send Ether\");\n    }\n    if (tokenIndexTo == 1) {\n      // Means contract is going to send staked ETH (gETH)\n      gETHRef.safeTransferFrom(address(this), msg.sender, self.pooledTokenId, dy, \"\");\n    }\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    LiquidityModuleStorage storage self,\n    uint256[2] memory amounts,\n    uint256 minToMint\n  ) external returns (uint256) {\n    require(amounts[0] == msg.value, \"LML:received less or more ETH than expected\");\n    IgETH gETHRef = self.gETH;\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      self.lpToken,\n      0,\n      0,\n      0,\n      AL._getAPrecise(self),\n      0,\n      self.balances\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\n    }\n\n    uint256[2] memory newBalances;\n    newBalances[0] = v.balances[0] + msg.value;\n\n    for (uint256 i; i < 2; ) {\n      require(v.totalSupply != 0 || amounts[i] > 0, \"LML:Must supply all tokens in pool\");\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    {\n      // Transfer tokens first\n      uint256 beforeBalance = gETHRef.balanceOf(address(this), self.pooledTokenId);\n      gETHRef.safeTransferFrom(msg.sender, address(this), self.pooledTokenId, amounts[1], \"\");\n\n      // Update the amounts[] with actual transfer amount\n      amounts[1] = gETHRef.balanceOf(address(this), self.pooledTokenId) - beforeBalance;\n\n      newBalances[1] = v.balances[1] + amounts[1];\n    }\n\n    // invariant after change\n    v.d1 = getD(_pricedInBatch(self, newBalances), v.preciseA);\n    require(v.d1 > v.d0, \"LML:D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[2] memory fees;\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = self.swapFee >> 1;\n\n      for (uint256 i; i < 2; ) {\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n\n        fees[i] =\n          (feePerToken * (difference(idealBalance, newBalances[i]))) /\n          (PERCENTAGE_DENOMINATOR);\n        self.balances[i] =\n          newBalances[i] -\n          ((fees[i] * (self.adminFee)) / (PERCENTAGE_DENOMINATOR));\n        newBalances[i] = newBalances[i] - (fees[i]);\n\n        unchecked {\n          i += 1;\n        }\n      }\n\n      v.d2 = getD(_pricedInBatch(self, newBalances), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n    }\n\n    require(toMint >= minToMint, \"LML:Could not mint min requested\");\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    LiquidityModuleStorage storage self,\n    uint256 amount,\n    uint256[2] calldata minAmounts\n  ) external returns (uint256[2] memory) {\n    ILPToken lpToken = self.lpToken;\n    IgETH gETHRef = self.gETH;\n    require(amount <= lpToken.balanceOf(msg.sender), \"LML:>LP.balanceOf\");\n\n    uint256[2] memory balances = self.balances;\n    uint256 totalSupply = lpToken.totalSupply();\n\n    uint256[2] memory amounts = _pricedOutBatch(\n      self,\n      _calculateRemoveLiquidity(_pricedInBatch(self, balances), amount, totalSupply)\n    );\n\n    for (uint256 i; i < amounts.length; ) {\n      require(amounts[i] >= minAmounts[i], \"LML:amounts[i] < minAmounts[i]\");\n      self.balances[i] = balances[i] - amounts[i];\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\n    lpToken.burnFrom(msg.sender, amount);\n\n    (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\"\");\n    require(sent, \"LML:Failed to send Ether\");\n\n    gETHRef.safeTransferFrom(address(this), msg.sender, self.pooledTokenId, amounts[1], \"\");\n\n    emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\n    return amounts;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param self Swap struct to read from and write to\n   * @param tokenAmount the amount of the lp tokens to burn\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @return amount chosen token that user received\n   */\n  function removeLiquidityOneToken(\n    LiquidityModuleStorage storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) external returns (uint256) {\n    ILPToken lpToken = self.lpToken;\n    IgETH gETHRef = self.gETH;\n\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \"LML:>LP.balanceOf\");\n    require(tokenIndex < 2, \"LML:Token not found\");\n\n    uint256 totalSupply = lpToken.totalSupply();\n\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      totalSupply\n    );\n\n    require(dy >= minAmount, \"LML:dy < minAmount\");\n\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\n    self.balances[tokenIndex] =\n      self.balances[tokenIndex] -\n      (dy + ((dyFee * (self.adminFee)) / (PERCENTAGE_DENOMINATOR)));\n    lpToken.burnFrom(msg.sender, tokenAmount);\n\n    if (tokenIndex == 0) {\n      (bool sent, ) = payable(msg.sender).call{value: dy}(\"\");\n      require(sent, \"LML:Failed to send Ether\");\n    }\n    if (tokenIndex == 1) {\n      gETHRef.safeTransferFrom(address(this), msg.sender, self.pooledTokenId, dy, \"\");\n    }\n\n    emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\n\n    return dy;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   *\n   * @param self Swap struct to read from and write to\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @return actual amount of LP tokens burned in the withdrawal\n   */\n  function removeLiquidityImbalance(\n    LiquidityModuleStorage storage self,\n    uint256[2] memory amounts,\n    uint256 maxBurnAmount\n  ) public returns (uint256) {\n    IgETH gETHRef = self.gETH;\n\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      self.lpToken,\n      0,\n      0,\n      0,\n      AL._getAPrecise(self),\n      0,\n      self.balances\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    require(\n      maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0,\n      \"LML:>LP.balanceOf\"\n    );\n\n    uint256 feePerToken = self.swapFee >> 1;\n    uint256[2] memory fees;\n\n    {\n      uint256[2] memory balances1;\n\n      v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\n      for (uint256 i; i < 2; ) {\n        require(amounts[i] <= v.balances[i], \"LML:Cannot withdraw > available\");\n        balances1[i] = v.balances[i] - amounts[i];\n\n        unchecked {\n          i += 1;\n        }\n      }\n      v.d1 = getD(_pricedInBatch(self, balances1), v.preciseA);\n\n      for (uint256 i; i < 2; ) {\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n        uint256 _diff = difference(idealBalance, balances1[i]);\n        fees[i] = (feePerToken * _diff) / PERCENTAGE_DENOMINATOR;\n        uint256 adminFee = self.adminFee;\n        {\n          self.balances[i] = balances1[i] - ((fees[i] * adminFee) / PERCENTAGE_DENOMINATOR);\n        }\n        balances1[i] = balances1[i] - fees[i];\n\n        unchecked {\n          i += 1;\n        }\n      }\n\n      v.d2 = getD(_pricedInBatch(self, balances1), v.preciseA);\n    }\n\n    uint256 tokenAmount = ((v.d0 - v.d2) * (v.totalSupply)) / v.d0;\n    require(tokenAmount != 0, \"LML:Burnt amount cannot be zero\");\n    tokenAmount = tokenAmount + 1;\n\n    require(tokenAmount <= maxBurnAmount, \"LML:tokenAmount > maxBurnAmount\");\n\n    // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n    (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\"\");\n    require(sent, \"LML:Failed to send Ether\");\n\n    gETHRef.safeTransferFrom(address(this), msg.sender, self.pooledTokenId, amounts[1], \"\");\n\n    emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, v.totalSupply - tokenAmount);\n\n    return tokenAmount;\n  }\n\n  /**\n   * @custom:subsection                           ** ADMIN FUNCTIONS **\n   */\n\n  /**\n   * @notice withdraw all admin fees to a given address\n   * @param self Swap struct to withdraw fees from\n   * @param receiver Address to send the fees to\n   */\n  function withdrawAdminFees(LiquidityModuleStorage storage self, address receiver) external {\n    IgETH gETHRef = self.gETH;\n    uint256 tokenBalance = gETHRef.balanceOf(address(this), self.pooledTokenId) - self.balances[1];\n    if (tokenBalance != 0) {\n      gETHRef.safeTransferFrom(address(this), receiver, self.pooledTokenId, tokenBalance, \"\");\n    }\n\n    uint256 etherBalance = address(this).balance - self.balances[0];\n    if (etherBalance != 0) {\n      (bool sent, ) = payable(receiver).call{value: etherBalance}(\"\");\n      require(sent, \"LML:Failed to send Ether\");\n    }\n  }\n\n  /**\n   * @notice Sets the admin fee\n   * @dev adminFee cannot be higher than 100% of the swap fee\n   * @param self Swap struct to update\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(LiquidityModuleStorage storage self, uint256 newAdminFee) external {\n    require(newAdminFee <= MAX_ADMIN_FEE, \"LML:Fee is too high\");\n    self.adminFee = newAdminFee;\n\n    emit NewAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice update the swap fee\n   * @dev fee cannot be higher than 1% of each swap\n   * @param self Swap struct to update\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(LiquidityModuleStorage storage self, uint256 newSwapFee) external {\n    require(newSwapFee <= MAX_SWAP_FEE, \"LML:Fee is too high\");\n    self.swapFee = newSwapFee;\n\n    emit NewSwapFee(newSwapFee);\n  }\n}\n"
    },
    "contracts/modules/LiquidityModule/LiquidityModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - contracts\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {ERC1155HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../interfaces/IgETH.sol\";\nimport {ILiquidityModule} from \"../../interfaces/modules/ILiquidityModule.sol\";\nimport {ILPToken} from \"../../interfaces/helpers/ILPToken.sol\";\n// internal - structs\nimport {LiquidityModuleStorage} from \"./structs/storage.sol\";\n// internal - libraries\nimport {LiquidityModuleLib as LML} from \"./libs/LiquidityModuleLib.sol\";\nimport {AmplificationLib as AL} from \"./libs/AmplificationLib.sol\";\n\n/**\n * @title LM: Liquidity Module\n *\n * @notice A StableSwap implementation for ERC1155 staking derivatives, gETH.\n * * Users become an LP (Liquidity Provider) by depositing their tokens\n * * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * * Users can burn pool tokens and withdraw their share of token(s).\n * * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * * distributed to the LPs.\n * * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * * stops the ratio of the tokens in the pool from changing.\n * * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev There are no additional functionalities implemented apart from the library.\n * * However, this module inherits and implements nonReentrant & whenNotPaused modifiers.\n * * LM has pausability and expects inheriting contract to provide the access control mechanism.\n *\n * @dev review: this module delegates its functionality to LML (LiquidityModuleLib).\n *\n * @dev 7 functions need to be overriden with access control when inherited:\n * * pause, unpause, setSwapFee, setAdminFee, withdrawAdminFees, rampA, stopRampA.\n *\n * @dev __LiquidityModule_init (or _unchained) call is NECESSARY when inherited.\n *\n * note This module utilizes modifiers but does not implement necessary admin checks; or pausability overrides.\n * * If a package inherits LM, should implement it's own logic around those.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract LiquidityModule is\n  ILiquidityModule,\n  ERC1155HolderUpgradeable,\n  ReentrancyGuardUpgradeable,\n  PausableUpgradeable\n{\n  using LML for LiquidityModuleStorage;\n  using AL for LiquidityModuleStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.LiquidityModule\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant LiquidityModuleStorageLocation =\n    0xbf570a7b0f42d13b79178a015638486db13c20a3e56dc93ef0739ba4e0119a00;\n\n  function _getLiquidityModuleStorage() internal pure returns (LiquidityModuleStorage storage $) {\n    assembly {\n      $.slot := LiquidityModuleStorageLocation\n    }\n  }\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event TokenSwap(\n    address indexed buyer,\n    uint256 tokensSold,\n    uint256 tokensBought,\n    uint128 soldId,\n    uint128 boughtId\n  );\n  event AddLiquidity(\n    address indexed provider,\n    uint256[2] tokenAmounts,\n    uint256[2] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[2] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[2] tokenAmounts,\n    uint256[2] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n  event NewWithdrawFee(uint256 newWithdrawFee);\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n  event StopRampA(uint256 currentA, uint256 time);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    require(block.timestamp <= deadline, \"LM:Deadline not met\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   *\n   * @dev these functions MUST be overriden for admin functionality.\n   */\n\n  /**\n   * @dev -> external\n   */\n  function pause() external virtual override;\n\n  function unpause() external virtual override;\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(uint256 newSwapFee) external virtual override;\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(uint256 newAdminFee) external virtual override;\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   */\n  function withdrawAdminFees(address receiver) external virtual override;\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(uint256 futureA, uint256 futureTime) external virtual override;\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   */\n  function stopRampA() external virtual override;\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  function __LiquidityModule_init(\n    address _gETH_position,\n    address _lpToken_referance,\n    uint256 _pooledTokenId,\n    uint256 _A,\n    uint256 _swapFee,\n    string memory _poolName\n  ) internal onlyInitializing {\n    __ReentrancyGuard_init();\n    __Pausable_init();\n    __ERC1155Holder_init();\n    __LiquidityModule_init_unchained(\n      _gETH_position,\n      _lpToken_referance,\n      _pooledTokenId,\n      _A,\n      _swapFee,\n      _poolName\n    );\n  }\n\n  function __LiquidityModule_init_unchained(\n    address _gETH_position,\n    address _lpToken_referance,\n    uint256 _pooledTokenId,\n    uint256 _A,\n    uint256 _swapFee,\n    string memory _poolName\n  ) internal onlyInitializing {\n    require(_gETH_position != address(0), \"LM:_gETH_position cannot be zero\");\n    require(_lpToken_referance != address(0), \"LM:_lpToken_referance cannot be zero\");\n    require(_pooledTokenId != 0, \"LM:_pooledTokenId cannot be zero\");\n    require(_A != 0, \"LM:_A cannot be zero\");\n    require(_A < AL.MAX_A, \"LM:_A exceeds maximum\");\n    require(_swapFee < LML.MAX_SWAP_FEE, \"LM:_swapFee exceeds maximum\");\n\n    // Clone and initialize a LPToken contract\n    ILPToken _lpToken = ILPToken(Clones.clone(_lpToken_referance));\n    string memory name_prefix = \"Geode LP Token: \";\n    string memory symbol_suffix = \"-LP\";\n    _lpToken.initialize(\n      string(abi.encodePacked(name_prefix, _poolName)),\n      string(abi.encodePacked(_poolName, symbol_suffix))\n    );\n\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    $.gETH = IgETH(_gETH_position);\n    $.lpToken = _lpToken;\n    $.pooledTokenId = _pooledTokenId;\n    $.initialA = _A * AL.A_PRECISION;\n    $.futureA = _A * AL.A_PRECISION;\n    $.swapFee = _swapFee;\n\n    // Do not trust middlewares. Protect LPs, gETH tokens from\n    // issues that can be surfaced with future middlewares.\n    $.gETH.avoidMiddlewares(_pooledTokenId, true);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function LiquidityParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address gETH,\n      address lpToken,\n      uint256 pooledTokenId,\n      uint256 initialA,\n      uint256 futureA,\n      uint256 initialATime,\n      uint256 futureATime,\n      uint256 swapFee,\n      uint256 adminFee\n    )\n  {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    gETH = address($.gETH);\n    lpToken = address($.lpToken);\n    pooledTokenId = $.pooledTokenId;\n    initialA = $.initialA;\n    futureA = $.futureA;\n    initialATime = $.initialATime;\n    futureATime = $.futureATime;\n    swapFee = $.swapFee;\n    adminFee = $.adminFee;\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n * (n - 1)\n   * @dev See the StableSwap paper for details\n   * @return A parameter\n   */\n  function getA() external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @return A parameter in its raw precision form\n   */\n  function getAPrecise() external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.getAPrecise();\n  }\n\n  /**\n   * @notice Debt, The amount of buyback for stable pricing (1=1).\n   * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\n   * @dev result might change when price is in.\n   */\n  function getDebt() external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.getDebt();\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getBalance(uint8 index) external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.balances[index];\n  }\n\n  /**\n   * @notice Get the virtual override price, to help calculate profit\n   * @return the virtual override price\n   */\n  function getVirtualPrice() external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.getVirtualPrice();\n  }\n\n  /**\n   * @notice Reads the accumulated amount of admin fees of the token with given index\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getAdminBalance(uint256 index) external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.getAdminBalance(index);\n  }\n\n  /**\n   * @custom:section                           ** HELPER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateTokenAmount(\n    uint256[2] calldata amounts,\n    bool deposit\n  ) external view virtual override returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveLiquidity(\n    uint256 amount\n  ) external view virtual override returns (uint256[2] memory) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view virtual override returns (uint256 availableTokenAmount) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  )\n    public\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    deadlineCheck(deadline)\n    returns (uint256)\n  {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addLiquidity(\n    uint256[2] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  )\n    public\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    deadlineCheck(deadline)\n    returns (uint256)\n  {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeLiquidity(\n    uint256 amount,\n    uint256[2] calldata minAmounts,\n    uint256 deadline\n  ) public virtual override nonReentrant deadlineCheck(deadline) returns (uint256[2] memory) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) public virtual override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeLiquidityImbalance(\n    uint256[2] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) public virtual override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    LiquidityModuleStorage storage $ = _getLiquidityModuleStorage();\n    return $.removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n}\n"
    },
    "contracts/modules/LiquidityModule/structs/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - interfaces\nimport {ILPToken} from \"../../../interfaces/helpers/ILPToken.sol\";\n\n/**\n * @notice Helper Struct storing variables used in calculations in the\n * calculateWithdrawOneTokenDY function to avoid stack too deep errors\n */\nstruct CalculateWithdrawOneTokenDYInfo {\n  uint256 d0;\n  uint256 d1;\n  uint256 newY;\n  uint256 feePerToken;\n  uint256 preciseA;\n}\n\n/**\n * @notice Helper Struct storing variables used in calculations in the\n * {add,remove} Liquidity functions to avoid stack too deep errors\n */\nstruct ManageLiquidityInfo {\n  ILPToken lpToken;\n  uint256 d0;\n  uint256 d1;\n  uint256 d2;\n  uint256 preciseA;\n  uint256 totalSupply;\n  uint256[2] balances;\n}\n"
    },
    "contracts/modules/LiquidityModule/structs/storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal -interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\nimport {ILPToken} from \"../../../interfaces/helpers/ILPToken.sol\";\n\n/**\n * @notice Storage struct for the liquidity pool logic, should be correctly initialized.\n *\n * @param gETH ERC1155 contract\n * @param lpToken address of the LP Token\n * @param pooledTokenId gETH ID of the pooled staking derivative\n * @param initialA the amplification coefficient * n * (n - 1)\n * @param futureA the amplification coef that will be effective after futureATime\n * @param initialATime variable around the ramp management of A\n * @param futureATime variable around the ramp management of A\n * @param swapFee fee as a percentage/PERCENTAGE_DENOMINATOR, will be deducted from resulting tokens of a swap\n * @param adminFee fee as a percentage/PERCENTAGE_DENOMINATOR, will be deducted from swapFee\n * @param balances the pool balance as [ETH, gETH]; the contract's actual token balance might differ\n *\n * @dev normally we would put custom:storage-location erc7201:geode.storage.LiquidityModule\n * but compiler throws an error... So np for now, just effects dev ex.\n */\nstruct LiquidityModuleStorage {\n  IgETH gETH;\n  ILPToken lpToken;\n  uint256 pooledTokenId;\n  uint256 initialA;\n  uint256 futureA;\n  uint256 initialATime;\n  uint256 futureATime;\n  uint256 swapFee;\n  uint256 adminFee;\n  uint256[2] balances;\n}\n"
    },
    "contracts/modules/StakeModule/libs/DepositContractLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n// internal - interfaces\nimport {IDepositContract} from \"../../../interfaces/helpers/IDepositContract.sol\";\n// internal - libraries\nimport {BytesLib} from \"../../../helpers/BytesLib.sol\";\n\n/**\n * @title DCL: Deposit Contract Library\n *\n * @notice Includes constants & functions that helps to the deposit process.\n *\n * @dev DEPOSIT_CONTRACT is chain specific and should be changed before deployments.\n *\n * @dev This is an internal library, requires NO deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary DepositContractLib {\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  IDepositContract internal constant DEPOSIT_CONTRACT =\n    IDepositContract(0x4242424242424242424242424242424242424242);\n  uint256 internal constant PUBKEY_LENGTH = 48;\n  uint256 internal constant SIGNATURE_LENGTH = 96;\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\n\n  /**\n   * @custom:section                           ** FUNCTIONS **\n   */\n\n  /**\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\n   * @param _b Memory array of size 32 .. 64\n   */\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\n    assert(_b.length >= 32 && _b.length <= 64);\n    if (64 == _b.length) return _b;\n\n    bytes memory zero32 = new bytes(32);\n    assembly {\n      mstore(add(zero32, 0x20), 0)\n    }\n\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\n    else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\n  }\n\n  /**\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\n   * @param _value Number less than `2**64` for compatibility reasons\n   */\n  function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n    result = 0;\n    uint256 temp_value = _value;\n    for (uint256 i; i < 8; ++i) {\n      result = (result << 8) | (temp_value & 0xFF);\n      temp_value >>= 8;\n    }\n\n    assert(0 == temp_value); // fully converted\n    result <<= (24 * 8);\n  }\n\n  function _getDepositDataRoot(\n    bytes memory _pubkey,\n    bytes memory _withdrawalCredentials,\n    bytes memory _signature,\n    uint256 _stakeAmount\n  ) internal pure returns (bytes32) {\n    require(_stakeAmount >= 1 ether, \"DepositContract: deposit value too low\");\n    require(_stakeAmount % 1 gwei == 0, \"DepositContract: deposit value not multiple of gwei\");\n\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\n    bytes32 signatureRoot = sha256(\n      abi.encodePacked(\n        sha256(BytesLib.slice(_signature, 0, 64)),\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n      )\n    );\n\n    bytes32 depositDataRoot = sha256(\n      abi.encodePacked(\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n        sha256(abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot))\n      )\n    );\n\n    return depositDataRoot;\n  }\n\n  /**\n   * @notice converts an address to withdrawal credential, used on validator creation\n   */\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\n    uint256 w = 1 << 248;\n\n    return abi.encodePacked(bytes32(w) | bytes32(uint256(uint160(address(wcAddress)))));\n  }\n\n  /**\n   * @notice deposit to DEPOSIT_CONTRACT and initiate a validator.\n   */\n  function depositValidator(\n    bytes calldata pubkey,\n    bytes memory withdrawalCredential,\n    bytes memory signature,\n    uint256 amount\n  ) internal {\n    DEPOSIT_CONTRACT.deposit{value: amount}(\n      pubkey,\n      withdrawalCredential,\n      signature,\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\n    );\n  }\n}\n"
    },
    "contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - contracts\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n// internal - globals\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// internal - interfaces\nimport {IgETHMiddleware} from \"../../../interfaces/middlewares/IgETHMiddleware.sol\";\nimport {IGeodePackage} from \"../../../interfaces/packages/IGeodePackage.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../../DataStoreModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"../structs/storage.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {DepositContractLib as DCL} from \"./DepositContractLib.sol\";\nimport {StakeModuleLib as SML} from \"./StakeModuleLib.sol\";\n\n/**\n * @title IEL: Initiator Extension Library\n *\n * @notice An extension to SML.\n * @notice This library is responsible from:\n * * 1. Node Operator Initiator for permissioned IDs\n * * 2. Configurable Staking Pools Initiator and its helpers.\n * * 3. Bound Liquidity Pool deployment after pool initiation.\n *\n * @dev review: DataStoreModule for the id based isolated storage logic.\n * @dev review: StakeModuleLib for base staking logic.\n *\n * @dev This library utilizes the '_authenticate' function on the external deployLiquidityPool,\n *  Compared to gETHMiddleware(optional) and WithdrawalContract(mandatory), LP be activated after\n * the pool initiation.\n *\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary InitiatorExtensionLib {\n  using DSML for DataStoreModuleStorage;\n  using SML for StakeModuleStorage;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event InitiationDepositSet(uint256 initiationDeposit);\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\n  event MiddlewareDeployed(uint256 poolId, uint256 version);\n  event PackageDeployed(uint256 poolId, uint256 packageType, address instance);\n\n  /**\n   * @custom:section                           ** GOVERNING **\n   *\n   * @custom:visibility -> external\n   * @dev IMPORTANT! These functions should be governed by a governance! Which is not done here!\n   */\n\n  /**\n   * @notice Set the required amount for a pool initiation.\n   * @dev note that, could have been used to prevent pool creation if there were no limits.\n   */\n  function setInitiationDeposit(\n    StakeModuleStorage storage self,\n    uint256 initiationDeposit\n  ) external {\n    require(initiationDeposit <= DCL.DEPOSIT_AMOUNT);\n\n    self.INITIATION_DEPOSIT = initiationDeposit;\n\n    emit InitiationDepositSet(initiationDeposit);\n  }\n\n  /**\n   * @custom:section                           ** OPERATOR INITIATOR **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice initiates ID as a Permissionned Node Operator\n   * @notice requires ID to be approved as a node operator with a specific CONTROLLER\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%\n   * @param validatorPeriod the expected maximum staking interval. This value should between\n   * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above.\n   * Operator can unstake at any given point before this period ends.\n   * If operator disobeys this rule, it can be prisoned with blameProposal()\n   * @param maintainer an address that automates daily operations, a script, a contract...\n   * @dev operators can fund their internal wallet on initiation by simply sending some ether.\n   */\n  function initiateOperator(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external {\n    require(DATASTORE.readUint(id, rks.initiated) == 0, \"SML:already initiated\");\n    require(DATASTORE.readUint(id, rks.TYPE) == ID_TYPE.OPERATOR, \"SML:TYPE not allowed\");\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"SML:sender not CONTROLLER\");\n\n    DATASTORE.writeUint(id, rks.initiated, block.timestamp);\n\n    SML._setMaintenanceFee(DATASTORE, id, fee);\n    SML._setValidatorPeriod(DATASTORE, id, validatorPeriod);\n    SML._setMaintainer(DATASTORE, id, maintainer);\n    SML._increaseWalletBalance(DATASTORE, id, msg.value);\n\n    emit IdInitiated(id, ID_TYPE.OPERATOR);\n  }\n\n  /**\n   * @custom:section                           ** STAKING POOL INITIATOR **\n   *\n   * @dev this section also contains the helper functions for packages and middlewares.\n   */\n\n  /**\n   * @notice Creates a Configurable Trustless Staking Pool!\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\n   * @param middlewareVersion Pool creators can choose any allowed version as their gETHMiddleware\n   * @param maintainer an address that automates daily operations, a script, a contract... not so critical.\n   * @param name is utilized while generating an ID for the Pool, similar to any other ID generation.\n   * @param middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\n   * @param config array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]\n   * @dev checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.\n   * @dev requires INITIATION_DEPOSIT worth of funds (currently 1 validator) to be deposited on initiation, prevent sybil attacks.\n   */\n  function initiatePool(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata name,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external returns (uint256 poolId) {\n    require(msg.value == self.INITIATION_DEPOSIT, \"SML:need 1 validator worth of funds\");\n\n    poolId = DSML.generateId(name, ID_TYPE.POOL);\n    require(DATASTORE.readUint(poolId, rks.initiated) == 0, \"SML:already initiated\");\n    require(poolId > 1e9, \"SML:Wow! Low poolId\");\n\n    DATASTORE.writeUint(poolId, rks.initiated, block.timestamp);\n\n    DATASTORE.writeUint(poolId, rks.TYPE, ID_TYPE.POOL);\n    DATASTORE.writeAddress(poolId, rks.CONTROLLER, msg.sender);\n    DATASTORE.writeBytes(poolId, rks.NAME, name);\n    DATASTORE.allIdsByType[ID_TYPE.POOL].push(poolId);\n\n    SML._setMaintainer(DATASTORE, poolId, maintainer);\n    SML._setMaintenanceFee(DATASTORE, poolId, fee);\n\n    // deploy a withdrawal Contract - mandatory\n    _deployWithdrawalContract(self, DATASTORE, poolId);\n\n    if (config[0]) {\n      // set pool to private\n      SML.setPoolVisibility(DATASTORE, poolId, true);\n    }\n    if (config[1]) {\n      // deploy a gETH middleware(erc20 etc.) - optional\n      _deploygETHMiddleware(self, DATASTORE, poolId, middlewareVersion, middleware_data);\n    }\n    if (config[2]) {\n      // deploy a bound liquidity pool - optional\n      _deployLiquidityPool(self, DATASTORE, poolId);\n    }\n\n    // initially 1 ETHER = 1 ETHER\n    self.gETH.setPricePerShare(1 ether, poolId);\n\n    // mint gETH and send back to the caller\n    uint256 mintedgETH = SML._mintgETH(self, DATASTORE, poolId, msg.value);\n    self.gETH.safeTransferFrom(address(this), msg.sender, poolId, mintedgETH, \"\");\n\n    emit IdInitiated(poolId, ID_TYPE.POOL);\n  }\n\n  /**\n   * @custom:section                           ** POOL INITIATOR HELPERS **\n   */\n\n  /**\n   * @custom:subsection                        ** gETH MIDDLEWARES **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set a gETHMiddleware\n   * @param _middleware address of the new gETHMiddleware for given ID\n   * @dev every middleware has a unique index within the middlewares dynamic array.\n   * @dev if ever unset, SHOULD replace the implementation with address(0) for obvious security reasons.\n   */\n  function _setgETHMiddleware(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    address _middleware\n  ) internal {\n    require(!self.gETH.isMiddleware(_middleware, id), \"SML:already middleware\");\n\n    DATASTORE.appendAddressArray(id, rks.middlewares, _middleware);\n\n    self.gETH.setMiddleware(_middleware, id, true);\n  }\n\n  /**\n   * @notice deploys a new gETHMiddleware by cloning (no upgradability)\n   * @param _id gETH id, also required for IgETHMiddleware.initialize\n   * @param _versionId provided version id, can use any as a middleware if allowed for TYPE = MIDDLEWARE_GETH\n   * @param _middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\n   * @dev currrently, cannot deploy a middleware after initiation, thus only used by the initiator.\n   * @dev currrently, cannot unset a middleware.\n   */\n  function _deploygETHMiddleware(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _versionId,\n    bytes calldata _middleware_data\n  ) internal {\n    require(_versionId > 0, \"SML:versionId cannot be 0\");\n    require(self.middlewares[ID_TYPE.MIDDLEWARE_GETH][_versionId], \"SML:not a middleware\");\n\n    address newgETHMiddleware = Clones.clone(DATASTORE.readAddress(_versionId, rks.CONTROLLER));\n\n    IgETHMiddleware(newgETHMiddleware).initialize(_id, address(self.gETH), _middleware_data);\n\n    _setgETHMiddleware(self, DATASTORE, _id, newgETHMiddleware);\n\n    // isolate the contract from middleware risk for ID\n    self.gETH.avoidMiddlewares(_id, true);\n\n    emit MiddlewareDeployed(_id, _versionId);\n  }\n\n  /**\n   * @notice deploys a new package for given id with given type from packages mapping.\n   * @param _type given package type\n   * @param _poolId pool id, required for IGeodePackage.initialize\n   * @param _package_data packages might require additional data on initialization\n   * @dev no cloning because GeodePackages has Limited Upgradability (based on UUPS)\n   */\n  function _deployGeodePackage(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _type,\n    bytes memory _package_data\n  ) internal returns (address packageInstance) {\n    uint256 versionId = self.packages[_type];\n    require(versionId > 0, \"SML:versionId cannot be 0\");\n\n    packageInstance = address(\n      new ERC1967Proxy(DATASTORE.readAddress(versionId, rks.CONTROLLER), \"\")\n    );\n    // we don't call on deployment because initialize uses _getImplementation() which is not available\n    IGeodePackage(packageInstance).initialize(\n      _poolId,\n      DATASTORE.readAddress(_poolId, rks.CONTROLLER),\n      DATASTORE.readBytes(versionId, rks.NAME),\n      _package_data\n    );\n\n    emit PackageDeployed(_poolId, _type, packageInstance);\n  }\n\n  /**\n   * @custom:subsection                        ** WITHDRAWAL CONTRACT **\n   *\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Deploys a Withdrawal Contract that will be used as a withdrawal credential on validator creation\n   * @dev every pool requires a Withdrawal Contract, thus this function is only used by the initiator\n   */\n  function _deployWithdrawalContract(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId\n  ) internal {\n    address wp = _deployGeodePackage(\n      self,\n      DATASTORE,\n      _poolId,\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\n      bytes(\"\")\n    );\n\n    DATASTORE.writeAddress(_poolId, rks.withdrawalContract, wp);\n    DATASTORE.writeBytes(_poolId, rks.withdrawalCredential, DCL.addressToWC(wp));\n  }\n\n  /**\n   * @custom:subsection                        ** BOUND LIQUIDITY POOL **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice deploys a bound liquidity pool for a staking pool.\n   * @dev gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)\n   * @dev unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well\n   * @dev _package_data of a liquidity pool is only the staking pool's name, used on LPToken.\n   */\n  function _deployLiquidityPool(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId\n  ) internal {\n    address lp = _deployGeodePackage(\n      self,\n      DATASTORE,\n      poolId,\n      ID_TYPE.PACKAGE_LIQUIDITY_POOL,\n      DATASTORE.readBytes(poolId, rks.NAME)\n    );\n\n    DATASTORE.writeAddress(poolId, rks.liquidityPool, lp);\n    // approve gETH so we can use it in buybacks\n    self.gETH.setApprovalForAll(lp, true);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @notice allows pools to deploy a Liquidity Pool after initiation, if it does not have one.\n   */\n  function deployLiquidityPool(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId\n  ) public {\n    SML._authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(DATASTORE.readAddress(poolId, rks.liquidityPool) == address(0), \"SML:already deployed\");\n\n    _deployLiquidityPool(self, DATASTORE, poolId);\n  }\n}\n"
    },
    "contracts/modules/StakeModule/libs/OracleExtensionLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - libraries\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n// internal - globals\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {VALIDATOR_STATE} from \"../../../globals/validator_state.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../../DataStoreModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"../structs/storage.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {DepositContractLib as DCL} from \"./DepositContractLib.sol\";\nimport {StakeModuleLib as SML} from \"./StakeModuleLib.sol\";\n\n/**\n * @title OEL: Oracle Extension Library\n *\n * @notice An extension to SML\n * @notice Oracle, named Telescope, handles some operations for The Staking Library,\n * * using the logic explained below.\n *\n * @dev review: DataStoreModule for the id based isolated storage logic.\n * @dev review: StakeModuleLib for base staking logic.\n *\n * @dev Telescope is currently responsible for 4 tasks:\n * * Updating the on-chain price of all pools with a MerkleRoot for minting operations\n * * Updating the on-chain balances info of all validators with a MerkleRoot for withdrawal operations\n * * Confirming validator proposals\n * * Regulating the Node Operators\n *\n * 1. updateVerificationIndex: Confirming validator proposals\n * * 2 step process is essential to prevent the frontrunning with a problematic withdrawalCredential: https://bit.ly/3Tkc6UC\n * * Simply, all proposed validator has an index bound to them,\n * * n representing the latest proposal: (0,n]\n * * Telescope verifies the validator data provided in proposeStake:\n * * especially sig1, sig31 and withdrawal credentials.\n * * Telescope confirms the latest index verified and states the faulty validator proposals (aliens)\n * * If a validator proposal is faulty then it's state is set to 69, refer to globals/validator_state.sol\n *\n * 2. regulateOperators: Regulating the Operators\n * * Operators can act faulty in many different ways. To prevent such actions,\n * * Telescope regulates them with well defined limitations.\n * * Currently only issue is the fee theft, meaning operators have not\n * * used the withdrawal contract for miner fees or MEV boost.\n * * There can be other restrictions in the future.\n *\n * 2. reportBeacon: Continous Data from Beacon chain: Price Merkle Root & Balances Merkle Root & # of active validators\n * * 1. Oracle Nodes calculate the price of its derivative, according to the validator data such as balance and fees.\n * * 2. If a pool doesn't have a validator, the price is kept the same.\n * * 3. A merkle tree is constructed with the order of allIdsByType array.\n * * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root.\n * * 5. Anyone can update the price of the derivative  by calling priceSync() functions with correct merkle proofs\n * * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update.\n * * 7. Updates the regulation around Monopolies and provides BALANCE_MERKLE_ROOT to be used within withdrawal process.\n *\n * @dev Most external functions have OracleOnly modifier. Except: priceSync, priceSyncBatch, blameExit and blameProposal.\n *\n * @dev This is an external library, requires deployment.\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary OracleExtensionLib {\n  using DSML for DataStoreModuleStorage;\n  using SML for StakeModuleStorage;\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n  /// @notice effective on MONOPOLY_THRESHOLD, limiting the active validators: Set to 1%\n  uint256 internal constant MONOPOLY_RATIO = 1e8; // PERCENTAGE_DENOMINATOR / 100;\n\n  /// @notice sensible value for the minimum beacon chain validators. No reasoning.\n  uint256 internal constant MIN_VALIDATOR_COUNT = 50000;\n\n  /// @notice limiting the access for Operators in case of bad/malicious/faulty behaviour\n  uint256 internal constant PRISON_SENTENCE = 14 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Alienated(bytes pubkey);\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\n  event FeeTheft(uint256 indexed id, bytes proofs);\n  event Prisoned(uint256 indexed operatorId, bytes proof, uint256 releaseTimestamp);\n  event YieldDistributed(uint256 indexed poolId, uint256 amount);\n  event OracleReported(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 monopolyThreshold\n  );\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyOracle(StakeModuleStorage storage self) {\n    require(msg.sender == self.ORACLE_POSITION, \"OEL:sender not ORACLE\");\n    _;\n  }\n\n  /**\n   * @custom:section                                       ** VERIFICATION INDEX **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   *\n   * @notice \"Alien\" is a validator that is created with a faulty withdrawal\n   * credential or signatures, this is a malicious act.\n   * @notice Alienation results in imprisonment for the operator of the faulty validator proposal.\n   * @dev While alienating a validator we should adjust the 'surplus' and 'secured'\n   * balances of the pool accordingly\n   * @dev We should adjust the 'proposedValidators' to fix allowances.\n   */\n  function _alienateValidator(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 verificationIndex,\n    bytes calldata _pk\n  ) internal {\n    require(self.validators[_pk].index <= verificationIndex, \"OEL:unexpected index\");\n    require(\n      self.validators[_pk].state == VALIDATOR_STATE.PROPOSED,\n      \"OEL:not all pubkeys are pending\"\n    );\n\n    uint256 operatorId = self.validators[_pk].operatorId;\n    _imprison(DATASTORE, operatorId, _pk);\n\n    uint256 poolId = self.validators[_pk].poolId;\n    DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT);\n    DATASTORE.addUint(poolId, rks.surplus, DCL.DEPOSIT_AMOUNT);\n\n    DATASTORE.subUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), 1);\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.alienValidators), 1);\n\n    self.validators[_pk].state = VALIDATOR_STATE.ALIENATED;\n\n    emit Alienated(_pk);\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice Updating VERIFICATION_INDEX, signaling that it is safe to activate\n   * the validator proposals with lower index than new VERIFICATION_INDEX\n   * @param validatorVerificationIndex (inclusive) index of the highest validator that is verified to be activated\n   * @param alienatedPubkeys faulty proposals within the range of new and old verification indexes.\n   */\n  function updateVerificationIndex(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external onlyOracle(self) {\n    require(self.VALIDATORS_INDEX >= validatorVerificationIndex, \"OEL:high VERIFICATION_INDEX\");\n    require(validatorVerificationIndex > self.VERIFICATION_INDEX, \"OEL:low VERIFICATION_INDEX\");\n\n    uint256 alienatedPubkeysLen = alienatedPubkeys.length;\n    for (uint256 i; i < alienatedPubkeysLen; ) {\n      _alienateValidator(self, DATASTORE, validatorVerificationIndex, alienatedPubkeys[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.VERIFICATION_INDEX = validatorVerificationIndex;\n    emit VerificationIndexUpdated(validatorVerificationIndex);\n  }\n\n  /**\n   * @dev                                       ** REGULATING OPERATORS **\n   */\n\n  /**\n   * @custom:section                           ** PRISON **\n   *\n   * When node operators act in a malicious way, which can also be interpreted as\n   * an honest mistake like using a faulty signature, Oracle imprisons the operator.\n   * These conditions are:\n   * * 1. Created a malicious validator(alien): faulty withdrawal credential, faulty signatures etc.\n   * * 2. Have not respect the validatorPeriod (or blamed for some other valid case)\n   * * 3. Stole block fees or MEV boost rewards from the pool\n   *\n   * @dev this section lacks a potential punishable act, for now early exits are not enforced:\n   * While state is EXIT_REQUESTED: validator requested exit, but it hasn't been executed.\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Put an operator in prison\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\n   */\n  function _imprison(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _operatorId,\n    bytes calldata _proof\n  ) internal {\n    SML._authenticate(DATASTORE, _operatorId, false, false, [true, false]);\n\n    DATASTORE.writeUint(_operatorId, rks.release, block.timestamp + PRISON_SENTENCE);\n\n    emit Prisoned(_operatorId, _proof, block.timestamp + PRISON_SENTENCE);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice imprisoning an Operator if the validator proposal is approved but have not been executed.\n   * @dev anyone can call this function while the state is PROPOSED\n   * @dev this check can be problematic in the case the beaconchain deposit delay is > BEACON_DELAY_ENTRY,\n   * * depending on the expected delay of telescope approvals. However, BEACON_DELAY_ENTRY can be adjusted by the Governance.\n   * @dev _canStake checks == VALIDATOR_STATE.PROPOSED.\n   */\n  function blameProposal(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    bytes calldata pk\n  ) external {\n    uint256 verificationIndex = self.VERIFICATION_INDEX;\n    require(self._canStake(pk, verificationIndex), \"OEL:cannot blame proposal\");\n    require(\n      block.timestamp > self.validators[pk].createdAt + self.BEACON_DELAY_ENTRY,\n      \"OEL:acceptable delay\"\n    );\n\n    _alienateValidator(self, DATASTORE, verificationIndex, pk);\n  }\n\n  /**\n   * @notice imprisoning an Operator if the validator have not been exited until expected exit\n   * @dev normally, oracle should verify the signed exit request on beacon chain for a (deterministic) epoch\n   * * before approval. This function enforces it further for the stakers.\n   * @dev anyone can call this function while the state is ACTIVE or EXIT_REQUESTED\n   * @dev if operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned\n   */\n  function blameExit(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    bytes calldata pk,\n    uint256 beaconBalance,\n    uint256 withdrawnBalance,\n    bytes32[] calldata balanceProof\n  ) external {\n    uint64 state = self.validators[pk].state;\n    require(\n      state == VALIDATOR_STATE.ACTIVE || state == VALIDATOR_STATE.EXIT_REQUESTED,\n      \"OEL:unexpected validator state\"\n    );\n    require(\n      block.timestamp >\n        self.validators[pk].createdAt + self.validators[pk].period + self.BEACON_DELAY_EXIT,\n      \"OEL:validator is active or acceptable delay\"\n    );\n\n    // verify balances\n    bytes32 leaf = keccak256(\n      bytes.concat(keccak256(abi.encode(pk, beaconBalance, withdrawnBalance)))\n    );\n    require(\n      MerkleProof.verify(balanceProof, self.BALANCE_MERKLE_ROOT, leaf),\n      \"OEL:proof not valid\"\n    );\n\n    require(beaconBalance != 0, \"OEL:already exited\");\n\n    _imprison(DATASTORE, self.validators[pk].operatorId, pk);\n  }\n\n  /**\n  \n   */\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice regulating operators, currently only regulation is towards fee theft, can add more stuff in the future.\n   * @param feeThefts Operator ids who have stolen MEV or block rewards detected\n   * @param proofs  BlockNumber, tx or any other referance as a proof\n   * @dev Stuff here result in imprisonment\n   */\n  function regulateOperators(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256[] calldata feeThefts,\n    bytes[] calldata proofs\n  ) external onlyOracle(self) {\n    require(feeThefts.length == proofs.length, \"OEL:invalid proofs\");\n\n    uint256 feeTheftsLen = feeThefts.length;\n    for (uint256 i; i < feeTheftsLen; ) {\n      _imprison(DATASTORE, feeThefts[i], proofs[i]);\n\n      emit FeeTheft(feeThefts[i], proofs[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n  }\n\n  /**\n   * @custom:section                           ** CONTINUOUS UPDATES **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT.\n   * Also reports all of the validator balances with a BALANCE_MERKLE_ROOT.\n   * Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD\n   *\n   * @param allValidatorsCount Number of all validators within BeaconChain, all of them.\n   * Prevents monopolies.\n   */\n  function reportBeacon(\n    StakeModuleStorage storage self,\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external onlyOracle(self) {\n    require(allValidatorsCount > MIN_VALIDATOR_COUNT, \"OEL:low validator count\");\n\n    self.PRICE_MERKLE_ROOT = priceMerkleRoot;\n    self.BALANCE_MERKLE_ROOT = balanceMerkleRoot;\n    self.ORACLE_UPDATE_TIMESTAMP = block.timestamp;\n\n    uint256 newThreshold = (allValidatorsCount * MONOPOLY_RATIO) / PERCENTAGE_DENOMINATOR;\n    self.MONOPOLY_THRESHOLD = newThreshold;\n\n    emit OracleReported(priceMerkleRoot, balanceMerkleRoot, newThreshold);\n  }\n\n  /**\n   * @custom:section                           **  PRICE UPDATE **\n   *\n   * @dev Permissionless.\n   */\n\n  /**\n   * @custom:visibility -> view-internal\n   *\n   * @dev in order to prevent faulty updates to the derivative prices there are boundaries to price updates.\n   * 1. Price should not be increased more than DAILY_PRICE_INCREASE_LIMIT\n   *  with the factor of how many days since priceUpdateTimestamp has past.\n   * 2. Price should not be decreased more than DAILY_PRICE_DECREASE_LIMIT\n   *  with the factor of how many days since priceUpdateTimestamp has past.\n   *\n   * @dev Worth noting, if price drops more than x%, UP TO (slashing percentage/x) days deposits/withdrawals are halted.\n   * Example:\n   * * A pool can have only one validator, it can get slashed.\n   * * Lets say max decrease is 5%, and 50% is slashed.\n   * * Then deposits/withdrawals are halted for 10 days.\n   * This is not a bug, but a safe circuit-breaker.\n   * This logic have effects the withdrawal contract logic.\n   */\n  function _sanityCheck(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _newPrice\n  ) internal view {\n    require(DATASTORE.readUint(_id, rks.TYPE) == ID_TYPE.POOL, \"OEL:not a pool?\");\n\n    uint256 lastUpdate = self.gETH.priceUpdateTimestamp(_id);\n    uint256 dayPercentSinceUpdate = ((block.timestamp - lastUpdate) * PERCENTAGE_DENOMINATOR) /\n      1 days;\n\n    uint256 curPrice = self.gETH.pricePerShare(_id);\n\n    uint256 maxPriceIncrease = ((curPrice *\n      self.DAILY_PRICE_INCREASE_LIMIT *\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\n\n    uint256 maxPriceDecrease = ((curPrice *\n      self.DAILY_PRICE_DECREASE_LIMIT *\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\n\n    require(\n      (_newPrice + maxPriceDecrease >= curPrice) && (_newPrice <= curPrice + maxPriceIncrease),\n      \"OEL:price is insane, price update is halted\"\n    );\n  }\n\n  /**\n   * @custom:visibility -> internal\n   *\n   * @notice syncing the price of g-derivatives after checking the merkle proofs and the sanity of the price.\n   * @param _price price of the derivative denominated in gETH.denominator()\n   * @param _priceProof merkle proofs\n   */\n  function _priceSync(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _price,\n    bytes32[] calldata _priceProof\n  ) internal {\n    require(\n      self.ORACLE_UPDATE_TIMESTAMP > self.gETH.priceUpdateTimestamp(_poolId),\n      \"OEL:no price change\"\n    );\n\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_poolId, _price))));\n    require(\n      MerkleProof.verify(_priceProof, self.PRICE_MERKLE_ROOT, leaf),\n      \"OEL:not all proofs are valid\"\n    );\n\n    _sanityCheck(self, DATASTORE, _poolId, _price);\n\n    address yieldReceiver = DATASTORE.readAddress(_poolId, rks.yieldReceiver);\n\n    if (yieldReceiver == address(0)) {\n      self.gETH.setPricePerShare(_price, _poolId);\n    } else {\n      uint256 currentPrice = self.gETH.pricePerShare(_poolId);\n      if (_price > currentPrice) {\n        uint256 supplyDiff = ((_price - currentPrice) * self.gETH.totalSupply(_poolId)) /\n          gETH_DENOMINATOR;\n        self.gETH.mint(address(this), _poolId, supplyDiff, \"\");\n        self.gETH.safeTransferFrom(address(this), yieldReceiver, _poolId, supplyDiff, \"\");\n        emit YieldDistributed(_poolId, supplyDiff);\n      } else {\n        self.gETH.setPricePerShare(_price, _poolId);\n      }\n    }\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice external function to set a derivative price on Portal\n   * @param price price of the derivative denominated in gETH.denominator()\n   * @param priceProof merkle proofs\n   */\n  function priceSync(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external {\n    _priceSync(self, DATASTORE, poolId, price, priceProof);\n  }\n\n  /**\n   * @custom:visibility -> external\n   *\n   * @notice external function to set a multiple derivatives price at once, saves gas.\n   * @param prices price of the derivative denominated in gETH.denominator()\n   * @param priceProofs merkle proofs\n   */\n  function priceSyncBatch(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external {\n    require(poolIds.length == prices.length, \"OEL:array lengths not equal\");\n    require(poolIds.length == priceProofs.length, \"OEL:array lengths not equal\");\n\n    uint256 poolIdsLen = poolIds.length;\n    for (uint256 i; i < poolIdsLen; ) {\n      _priceSync(self, DATASTORE, poolIds[i], prices[i], priceProofs[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n  }\n}\n"
    },
    "contracts/modules/StakeModule/libs/StakeModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - globals\nimport {ID_TYPE} from \"../../../globals/id_type.sol\";\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {VALIDATOR_STATE} from \"../../../globals/validator_state.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../../../globals/reserved_key_space.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\nimport {IGeodePackage} from \"../../../interfaces/packages/IGeodePackage.sol\";\nimport {ILiquidityPool} from \"../../../interfaces/packages/ILiquidityPool.sol\";\nimport {IWhitelist} from \"../../../interfaces/helpers/IWhitelist.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../../DataStoreModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"../structs/storage.sol\";\nimport {ConstantValidatorData} from \"../structs/helpers.sol\";\nimport {Validator} from \"../structs/utils.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"../../DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {DepositContractLib as DCL} from \"./DepositContractLib.sol\";\n\n/**\n * @title SML: Stake Module Library (The Staking Library)\n *\n * @notice Creating a global standard for Staking, allowing anyone to OWN a trustless staking pool,\n * improving the user experience for stakers and removing the \"need\" for centralized or decentralized intermediaries.\n * * Exclusively contains functions related to:\n * * 1. Pool and Operator management, after initiation (review IEL).\n * * 2. Validator Delegation.\n * * 3. Depositing.\n * * 4. Staking Operations.\n *\n * @dev review: DataStoreModule for the id based isolated storage logic.\n * @dev review: InitiatorExtensionLib for initiator functions.\n * @dev review: OracleExtensionLib for oracle logic.\n *\n * @dev Every pool is isolated and every validator is unique. We segregate all the risk.\n *\n * @dev CONTROLLER and Maintainer:\n * CONTROLLER is the owner of an ID, it manages the pool/operator. Its security is exteremely important.\n * maintainer is the worker, can be used to automate some daily tasks:\n * * distributing validators for Staking Pools or creating validators for Operators.\n * * not so crucial in terms of security.\n *\n * @dev Users:\n * Type 4 : Permissioned Operators\n * * Needs to be onboarded by the Dual Governance (Senate + Governance).\n * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\n * * Can participate in the Operator Marketplace after initiation.\n * * Can utilize maintainers for staking operations.\n *\n * Type 5 : Permissionless Configurable Staking Pools\n * * Permissionless to create.\n * * Can utilize powers of packages and middlewares such as Bound Liquidity Pools, gETHMiddlewares etc.\n * * Can be public or private, can use a whitelist if private.\n * * Can utilize maintainers for validator distribution on Operator Marketplace.\n * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\n * * accruing rewards and keeping Staked Ether safe and isolated.\n *\n * @dev Packages:\n * An ID can only point to one version of a Package at a time.\n * Built by utilizing the Modules!\n * Can be upgraded by a dual governance, via pullUpgrade.\n * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\n *\n * Type 10011 : Withdrawal Contract\n * * Mandatory.\n * * CONTROLLER is the implementation contract position (always)\n * * Version Release Requires the approval of Senate\n * * Upgrading to a new version is optional for pool owners.\n * * * Staking Pools are in \"Isolation Mode\" until their Withdrawal Contract is upgraded.\n * * * Meaning, no more Depositing or Validator Proposal can happen.\n * * Custodian of the validator funds after creation, including any type of rewards and fees.\n *\n * Type 10021 : Liquidity Pool implementation\n * * Optional.\n * * CONTROLLER is the implementation contract position (always)\n * * Version Release Requires the approval of Senate\n * * Upgrading to a new version is optional for pool owners.\n * * * Liquidity Pools are in \"Isolation Mode\" until upgraded.\n *\n * @dev Middlewares:\n * Can support many different versions that can be utilized by the Pool Owners.\n * No particular way to build one.\n * Cannot be upgraded.\n * Currently only gETHMiddlewares.\n *\n * Type 20011 : gETHMiddleware\n * * Optional.\n * * CONTROLLER is the implementation contract position (always)\n * * Requires the approval of Senate\n * * Currently should be utilized on initiation.\n *\n * @dev Contracts relying on this library must initialize StakeModuleLib.StakeModuleStorage\n *\n * @dev Functions are protected with authentication function\n *\n * @author Ice Bear & Crash Bandicoot\n */\n\nlibrary StakeModuleLib {\n  using DSML for DataStoreModuleStorage;\n\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n\n  /// @notice limiting the GOVERNANCE_FEE to 5%\n  uint256 internal constant MAX_POOL_INFRASTRUCTURE_FEE = 5e8; // (PERCENTAGE_DENOMINATOR * 5) / 100;\n\n  /// @notice limit the beacon delays on entry and exit since it can be adjusted by the governance.\n  uint256 internal constant MAX_BEACON_DELAY = 90 days; // = MIN_VALIDATOR_PERIOD\n\n  /// @notice limiting the pool and operator maintenance fee, 10%\n  uint256 internal constant MAX_MAINTENANCE_FEE = 1e9; // (PERCENTAGE_DENOMINATOR * 10) / 100;\n\n  /// @notice effective on allowance per operator, prevents overflow. Exclusive, save gas with +1.\n  uint256 internal constant MAX_ALLOWANCE = 1e6;\n\n  /// @notice price of gETH is only valid for 24H, minting is not allowed afterwards.\n  uint256 internal constant PRICE_EXPIRY = 24 hours;\n\n  /// @notice ignoring any buybacks if the Liquidity Pool has a low debt\n  uint256 internal constant IGNORABLE_DEBT = 1 ether;\n\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 2 years\n  uint256 internal constant MIN_VALIDATOR_PERIOD = 90 days; // 3 * 30 days\n  uint256 internal constant MAX_VALIDATOR_PERIOD = 730 days; // 2 * 365 days\n\n  /// @notice some parameter changes are effective after a delay\n  uint256 internal constant SWITCH_LATENCY = 3 days;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event InfrastructureFeeSet(uint256 _type, uint256 fee);\n  event BeaconDelaySet(uint256 entryDelay, uint256 exitDelay);\n  event VisibilitySet(uint256 id, bool isPrivate);\n  event YieldReceiverSet(uint256 indexed poolId, address yieldReceiver);\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId, uint256 threshold);\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\n  event Stake(bytes[] pubkeys);\n  event ExitRequest(bytes pubkey);\n  event Exit(bytes pubkey);\n\n  /**\n   * @custom:section                           ** GOVERNING **\n   *\n   * @custom:visibility -> external\n   * @dev IMPORTANT! These functions should be governed by a governance! Which is not done here!\n   */\n\n  /**\n   * @notice Set the maxiumum allowed beacon delay for blaming validators on creation and exit.\n   * @dev high beacon delays will affect the ux negatively, low delays can cause issues for operators.\n   */\n  function setBeaconDelays(StakeModuleStorage storage self, uint256 entry, uint256 exit) external {\n    require(entry < MAX_BEACON_DELAY, \"SML:> MAX\");\n    require(exit < MAX_BEACON_DELAY, \"SML:> MAX\");\n\n    self.BEACON_DELAY_ENTRY = entry;\n    self.BEACON_DELAY_EXIT = exit;\n\n    emit BeaconDelaySet(entry, exit);\n  }\n\n  /**\n   * @notice Set a fee (denominated in PERCENTAGE_DENOMINATOR) for any given TYPE.\n   * @dev Changing the Staking Pool fee, only applies to the newly created validators.\n   * @dev advise that there can be other fees within the package, thus we will never allow\n   * * governance to take more than x%, while x<80(at least). For now, 50% limit on all fees\n   * * makes sense to us. However, it can be adjusted to any value between 0-80 in the future.\n   */\n  function setInfrastructureFee(\n    StakeModuleStorage storage self,\n    uint256 _type,\n    uint256 fee\n  ) external {\n    if (_type == ID_TYPE.POOL) {\n      require(fee <= MAX_POOL_INFRASTRUCTURE_FEE, \"PORTAL:> MAX\");\n    } else {\n      require(fee < PERCENTAGE_DENOMINATOR / 2, \"SML:> 50%\");\n    }\n\n    self.infrastructureFees[_type] = fee;\n    emit InfrastructureFeeSet(_type, fee);\n  }\n\n  /**\n   * @custom:section                           ** AUTHENTICATION **\n   *\n   * @custom:visibility -> view-internal\n   */\n\n  /**\n   * @notice restricts the access to given function based on TYPE and msg.sender\n   * @param _expectCONTROLLER restricts the access to only CONTROLLER.\n   * @param _expectMaintainer restricts the access to only maintainer.\n   * @param _restrictionMap Restricts which TYPEs can pass the authentication.\n   * * [0: Operator = TYPE(4), 1: Pool = TYPE(5)]\n   * @dev can only be used after an ID is initiated\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators cannot access.\n   */\n  function _authenticate(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    bool _expectCONTROLLER,\n    bool _expectMaintainer,\n    bool[2] memory _restrictionMap\n  ) internal view {\n    require(DATASTORE.readUint(_id, rks.initiated) != 0, \"SML:not initiated\");\n\n    uint256 typeOfId = DATASTORE.readUint(_id, rks.TYPE);\n\n    if (typeOfId == ID_TYPE.OPERATOR) {\n      require(_restrictionMap[0], \"SML:TYPE not allowed\");\n      if (_expectCONTROLLER || _expectMaintainer) {\n        require(!isPrisoned(DATASTORE, _id), \"SML:prisoned, get in touch with governance\");\n      }\n    } else if (typeOfId == ID_TYPE.POOL) {\n      require(_restrictionMap[1], \"SML:TYPE not allowed\");\n    } else {\n      revert(\"SML:invalid TYPE\");\n    }\n\n    if (_expectMaintainer) {\n      require(\n        msg.sender == DATASTORE.readAddress(_id, rks.maintainer),\n        \"SML:sender not maintainer\"\n      );\n      return;\n    }\n\n    if (_expectCONTROLLER) {\n      require(\n        msg.sender == DATASTORE.readAddress(_id, rks.CONTROLLER),\n        \"SML:sender not CONTROLLER\"\n      );\n      return;\n    }\n  }\n\n  /**\n   * @custom:subsection                           ** POOL VISIBILITY **\n   */\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice changes the visibility of the pool\n   * @param makePrivate true if pool should be private, false for public pools\n   * @dev whitelist is cleared when pool is set to public, to prevent legacy bugs if ever made private again.\n   * Note private pools can whitelist addresses with the help of a third party contract.\n   */\n  function setPoolVisibility(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    bool makePrivate\n  ) public {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(makePrivate != isPrivatePool(DATASTORE, poolId), \"SML:already set\");\n\n    DATASTORE.writeUint(poolId, rks.privatePool, makePrivate ? 1 : 0);\n\n    if (!makePrivate) {\n      DATASTORE.writeAddress(poolId, rks.whitelist, address(0));\n    }\n\n    emit VisibilitySet(poolId, makePrivate);\n  }\n\n  /**\n   * @notice private pools can whitelist addresses with the help of a third party contract.\n   * @dev Whitelisting contracts should implement IWhitelist interface.\n   */\n  function setWhitelist(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    address whitelist\n  ) external {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n    require(isPrivatePool(DATASTORE, poolId), \"SML:must be private pool\");\n\n    DATASTORE.writeAddress(poolId, rks.whitelist, whitelist);\n  }\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice returns true if the pool is private\n   */\n  function isPrivatePool(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId\n  ) public view returns (bool) {\n    return (DATASTORE.readUint(poolId, rks.privatePool) == 1);\n  }\n\n  /**\n   * @notice checks if the Whitelist allows staker to use given private pool\n   * @dev Owner of the pool doesn't need whitelisting\n   * @dev Otherwise requires a whitelisting address to be set\n   */\n  function isWhitelisted(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    address staker\n  ) public view returns (bool) {\n    if (DATASTORE.readAddress(poolId, rks.CONTROLLER) == staker) {\n      return true;\n    }\n\n    address whitelist = DATASTORE.readAddress(poolId, rks.whitelist);\n    if (whitelist == address(0)) {\n      return false;\n    }\n\n    if (whitelist.code.length > 0) {\n      try IWhitelist(whitelist).isAllowed(staker) returns (bool _isAllowed) {\n        return _isAllowed;\n      } catch {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @custom:section                           ** ID MANAGEMENT **\n   *\n   */\n\n  /**\n   * @custom:subsection                           ** YIELD SEPARATION **\n   */\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Set the yield receiver address to activate or deactivete yield separation logic.\n   * * If set other than address(0) separation will be activated, if set back to address(0)\n   * * separation will be deactivated again.\n   * @param poolId the gETH id of the Pool\n   * @param yieldReceiver address of the yield receiver\n   * @dev Only CONTROLLER of pool can set yield receier.\n   */\n  function setYieldReceiver(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    address yieldReceiver\n  ) external {\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\n\n    DATASTORE.writeAddress(poolId, rks.yieldReceiver, yieldReceiver);\n    emit YieldReceiverSet(poolId, yieldReceiver);\n  }\n\n  /**\n   * @custom:subsection                           ** MAINTAINER **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Set the maintainer address on initiation or later\n   * @param _newMaintainer address of the new maintainer\n   */\n  function _setMaintainer(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    address _newMaintainer\n  ) internal {\n    require(_newMaintainer != address(0), \"SML:maintainer cannot be zero\");\n\n    DATASTORE.writeAddress(_id, rks.maintainer, _newMaintainer);\n    emit MaintainerChanged(_id, _newMaintainer);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\n   * @dev there can only be 1 maintainer per ID.\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\n   * @dev we don't use _authenticate here because malicious maintainers can imprison operators\n   * * and prevent them entering here, smh.\n   */\n  function changeMaintainer(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    address newMaintainer\n  ) external {\n    require(DATASTORE.readUint(id, rks.initiated) != 0, \"SML:ID is not initiated\");\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \"SML:sender not CONTROLLER\");\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\n    require(typeOfId == ID_TYPE.OPERATOR || typeOfId == ID_TYPE.POOL, \"SML:invalid TYPE\");\n\n    _setMaintainer(DATASTORE, id, newMaintainer);\n  }\n\n  /**\n   * @custom:subsection                           ** MAINTENANCE FEE **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\n   *\n   * @dev respecs to the switching delay.\n   *\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\n   */\n  function getMaintenanceFee(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id\n  ) public view returns (uint256 fee) {\n    if (DATASTORE.readUint(id, rks.feeSwitch) > block.timestamp) {\n      return DATASTORE.readUint(id, rks.priorFee);\n    }\n    return DATASTORE.readUint(id, rks.fee);\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set fee with NO DELAY\n   */\n  function _setMaintenanceFee(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _newFee\n  ) internal {\n    require(_newFee <= MAX_MAINTENANCE_FEE, \"SML:> MAX_MAINTENANCE_FEE\");\n    DATASTORE.writeUint(_id, rks.fee, _newFee);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\n   * @dev Cannot be called again while its currently switching.\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\n   */\n  function switchMaintenanceFee(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    uint256 newFee\n  ) external {\n    _authenticate(DATASTORE, id, true, false, [true, true]);\n\n    require(block.timestamp > DATASTORE.readUint(id, rks.feeSwitch), \"SML:currently switching\");\n\n    DATASTORE.writeUint(id, rks.priorFee, DATASTORE.readUint(id, rks.fee));\n    DATASTORE.writeUint(id, rks.feeSwitch, block.timestamp + SWITCH_LATENCY);\n\n    _setMaintenanceFee(DATASTORE, id, newFee);\n\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\n  }\n\n  /**\n   * @custom:subsection                           ** INTERNAL WALLET **\n   *\n   * @dev Internal wallet of an ID accrues fees over time.\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice Simply increases the balance of an IDs Maintainer wallet\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\n   */\n  function _increaseWalletBalance(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _value\n  ) internal {\n    DATASTORE.addUint(_id, rks.wallet, _value);\n  }\n\n  /**\n   * @notice To decrease the balance of an Operator's wallet internally\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\n   */\n  function _decreaseWalletBalance(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _id,\n    uint256 _value\n  ) internal {\n    require(DATASTORE.readUint(_id, rks.wallet) >= _value, \"SML:insufficient wallet balance\");\n    DATASTORE.subUint(_id, rks.wallet, _value);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice external function to increase the internal wallet balance\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\n   */\n  function increaseWalletBalance(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id\n  ) external returns (bool success) {\n    _authenticate(DATASTORE, id, false, false, [true, true]);\n    _increaseWalletBalance(DATASTORE, id, msg.value);\n    success = true;\n  }\n\n  /**\n   * @notice external function to decrease the internal wallet balance\n   * @dev only CONTROLLER can decrease the balance externally,\n   * @return success if the amount was sent and deducted\n   */\n  function decreaseWalletBalance(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id,\n    uint256 value\n  ) external returns (bool success) {\n    _authenticate(DATASTORE, id, true, false, [true, true]);\n\n    require(address(this).balance >= value, \"SML:insufficient contract balance\");\n\n    _decreaseWalletBalance(DATASTORE, id, value);\n    address controller = DATASTORE.readAddress(id, rks.CONTROLLER);\n\n    (success, ) = payable(controller).call{value: value}(\"\");\n    require(success, \"SML:Failed to send ETH\");\n  }\n\n  /**\n   * @custom:subsection                           ** OPERATORS PERIOD **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  function getValidatorPeriod(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 id\n  ) public view returns (uint256 period) {\n    if (DATASTORE.readUint(id, rks.periodSwitch) > block.timestamp) {\n      return DATASTORE.readUint(id, rks.priorPeriod);\n    }\n    return DATASTORE.readUint(id, rks.validatorPeriod);\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice internal function to set validator period with NO DELAY\n   */\n  function _setValidatorPeriod(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _operatorId,\n    uint256 _newPeriod\n  ) internal {\n    require(_newPeriod >= MIN_VALIDATOR_PERIOD, \"SML:< MIN_VALIDATOR_PERIOD\");\n    require(_newPeriod <= MAX_VALIDATOR_PERIOD, \"SML:> MAX_VALIDATOR_PERIOD\");\n\n    DATASTORE.writeUint(_operatorId, rks.validatorPeriod, _newPeriod);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\n   */\n  function switchValidatorPeriod(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 operatorId,\n    uint256 newPeriod\n  ) external {\n    _authenticate(DATASTORE, operatorId, true, false, [true, false]);\n\n    require(\n      block.timestamp > DATASTORE.readUint(operatorId, rks.periodSwitch),\n      \"SML:currently switching\"\n    );\n\n    DATASTORE.writeUint(\n      operatorId,\n      rks.priorPeriod,\n      DATASTORE.readUint(operatorId, rks.validatorPeriod)\n    );\n    DATASTORE.writeUint(operatorId, rks.periodSwitch, block.timestamp + SWITCH_LATENCY);\n\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\n\n    emit ValidatorPeriodSwitched(operatorId, newPeriod, block.timestamp + SWITCH_LATENCY);\n  }\n\n  /**\n   * @custom:section                           ** PRISON **\n   *\n   * @custom:visibility -> view-public\n   * @dev check OEL.blameProposal and OEL.blameExit for imprisonment details\n   */\n\n  /**\n   * @notice Checks if the given operator is Prisoned\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\n   */\n  function isPrisoned(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 operatorId\n  ) public view returns (bool) {\n    return (block.timestamp < DATASTORE.readUint(operatorId, rks.release));\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR DELEGATION **\n   */\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice maximum number of remaining operator allowance that the given Operator is allowed to create for given Pool\n   * @dev an operator cannot create new validators if:\n   * * 1. operator is a monopoly\n   * * 2. allowance is filled\n   * * * But if operator is set as a fallback, it can if set fallbackThreshold is reached on all allowances.\n   * @dev If operator withdraws a validator, then able to create a new one.\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\n   */\n  function operatorAllowance(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId\n  ) public view returns (uint256 remValidators) {\n    // monopoly check\n    {\n      // readUint for an array gives us length\n      uint256 numOperatorValidators = DATASTORE.readUint(operatorId, rks.validators);\n      uint256 monopoly_threshold = self.MONOPOLY_THRESHOLD;\n      if (numOperatorValidators >= monopoly_threshold) {\n        return 0;\n      } else {\n        remValidators = monopoly_threshold - numOperatorValidators;\n      }\n    }\n\n    // fallback check\n    {\n      if (operatorId == DATASTORE.readUint(poolId, rks.fallbackOperator)) {\n        // readUint for an array gives us length\n        uint256 numPoolValidators = DATASTORE.readUint(poolId, rks.validators);\n        uint256 totalAllowance = DATASTORE.readUint(poolId, rks.totalAllowance);\n\n        if (\n          totalAllowance == 0 ||\n          (((numPoolValidators * PERCENTAGE_DENOMINATOR) / totalAllowance) >=\n            DATASTORE.readUint(poolId, rks.fallbackThreshold))\n        ) {\n          return remValidators;\n        }\n      }\n    }\n\n    // approval check\n    {\n      uint256 allowance = DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.allowance));\n      uint256 pooledValidators = DATASTORE.readUint(\n        poolId,\n        DSML.getKey(operatorId, rks.proposedValidators)\n      ) + DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.activeValidators));\n      if (pooledValidators >= allowance) {\n        return 0;\n      } else {\n        uint256 remAllowance = allowance - pooledValidators;\n        if (remValidators > remAllowance) {\n          remValidators = remAllowance;\n        }\n      }\n    }\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice To give allowence to node operator for a pool. It re-sets the allowance with the given value.\n   * @dev The value that is returned is not the new allowance, but the old one since it is required\n   * * at the point where it is being returned.\n   * @return oldAllowance to be used later, nothing is done with it within this function.\n   */\n  function _approveOperator(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 allowance\n  ) internal returns (uint256 oldAllowance) {\n    bytes32 allowanceKey = DSML.getKey(operatorId, rks.allowance);\n\n    oldAllowance = DATASTORE.readUint(poolId, allowanceKey);\n    DATASTORE.writeUint(poolId, allowanceKey, allowance);\n\n    emit Delegation(poolId, operatorId, allowance);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\n   * * This number can be set again at any given point in the future.\n   * @param poolId the gETH id of the Pool\n   * @param operatorIds array of Operator IDs to allow them create validators\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\n   * @dev When decreased the approved validator count below current active+proposed validators,\n   * operator cannot create new validators.\n   */\n  function delegate(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances\n  ) external {\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\n    uint256 operatorIdsLen = operatorIds.length;\n    require(operatorIdsLen == allowances.length, \"SML:allowances should match\");\n\n    for (uint256 i; i < operatorIdsLen; ) {\n      require(\n        DATASTORE.readUint(operatorIds[i], rks.TYPE) == ID_TYPE.OPERATOR,\n        \"SML:id not operator\"\n      );\n      require(allowances[i] <= MAX_ALLOWANCE, \"SML:> MAX_ALLOWANCE, set fallback\");\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    uint256 newCumulativeSubset;\n    uint256 oldCumulativeSubset;\n    for (uint256 i; i < operatorIdsLen; ) {\n      newCumulativeSubset += allowances[i];\n      oldCumulativeSubset += _approveOperator(DATASTORE, poolId, operatorIds[i], allowances[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    if (newCumulativeSubset > oldCumulativeSubset) {\n      DATASTORE.addUint(poolId, rks.totalAllowance, newCumulativeSubset - oldCumulativeSubset);\n    } else if (newCumulativeSubset < oldCumulativeSubset) {\n      DATASTORE.subUint(poolId, rks.totalAllowance, oldCumulativeSubset - newCumulativeSubset);\n    }\n  }\n\n  /**\n   * @notice To allow a Node Operator run validators for your Pool without a limit\n   * * after pool reaches a given treshold as percentage.\n   * * fallback operator and percentage can be set again at any given point in the future.\n   * * cannot set an operator as a fallback operator while it is currently in prison.\n   * @param poolId the gETH id of the Pool\n   * @param operatorId Operator ID to allow create validators\n   * @param fallbackThreshold the percentage (with PERCENTAGE_DENOMINATOR) that fallback operator\n   * * is activated for given Pool. Should not be greater than 100.\n   */\n  function setFallbackOperator(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 fallbackThreshold\n  ) external {\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\n\n    if (operatorId == 0) {\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, 0);\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, 0);\n      emit FallbackOperator(poolId, 0, 0);\n    } else {\n      require(\n        DATASTORE.readUint(operatorId, rks.TYPE) == ID_TYPE.OPERATOR,\n        \"SML:fallback not operator\"\n      );\n\n      require(\n        fallbackThreshold <= PERCENTAGE_DENOMINATOR,\n        \"SML:threshold cannot be greater than 100\"\n      );\n\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, fallbackThreshold);\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, operatorId);\n\n      emit FallbackOperator(poolId, operatorId, fallbackThreshold);\n    }\n  }\n\n  /**\n   * @custom:section                           ** POOLING  **\n   */\n\n  /**\n   * @custom:subsection                           ** DEPOSIT HELPERS **\n   */\n\n  /**\n   * @custom:visibility -> view-internal\n   */\n\n  function _isGeodePackageIsolated(address _packageAddress) internal view returns (bool) {\n    return IGeodePackage(_packageAddress).isolationMode();\n  }\n\n  /**\n   * @notice returns wrapped bound liquidity pool. If deployed, if not in isolationMode.\n   * @dev returns address(0) if no pool or it is under isolation\n   */\n  function _getLiquidityPool(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId\n  ) internal view returns (ILiquidityPool) {\n    address liqPool = DATASTORE.readAddress(_poolId, rks.liquidityPool);\n    if (liqPool == address(0)) {\n      return ILiquidityPool(address(0));\n    } else if (_isGeodePackageIsolated(liqPool)) {\n      return ILiquidityPool(address(0));\n    } else {\n      return ILiquidityPool(liqPool);\n    }\n  }\n\n  /**\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice returns true if the price is valid:\n   * - last price syncinc happened less than 24h\n   * - there has been no oracle reports since the last update\n   *\n   * @dev known bug / feature: if there have been no oracle updates,\n   * * this function will return true.\n   *\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\n   *    : false\n   */\n  function isPriceValid(\n    StakeModuleStorage storage self,\n    uint256 poolId\n  ) public view returns (bool isValid) {\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\n    unchecked {\n      isValid =\n        lastupdate + PRICE_EXPIRY >= block.timestamp &&\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\n    }\n  }\n\n  /**\n   * @notice checks if staking is allowed in given staking pool\n   * @notice staking is not allowed if:\n   * 1. Price is not valid\n   * 2. WithdrawalContract is in Isolation Mode, can have many reasons\n   */\n  function isMintingAllowed(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId\n  ) public view returns (bool) {\n    return\n      (isPriceValid(self, poolId)) &&\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract)));\n  }\n\n  /**\n   * @custom:subsection                           ** DEPOSIT **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\n   * @dev fails if minting is not allowed: invalid price, or isolationMode.\n   */\n  function _mintgETH(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _ethAmount\n  ) internal returns (uint256 mintedgETH) {\n    require(isMintingAllowed(self, DATASTORE, _poolId), \"SML:minting is not allowed\");\n\n    uint256 price = self.gETH.pricePerShare(_poolId);\n    require(price > 0, \"SML:price is zero?\");\n\n    mintedgETH = (((_ethAmount * gETH_DENOMINATOR) / price));\n    self.gETH.mint(address(this), _poolId, mintedgETH, \"\");\n    DATASTORE.addUint(_poolId, rks.surplus, _ethAmount);\n  }\n\n  /**\n   * @notice conducts a buyback using the given liquidity pool\n   * @param _poolId id of the gETH that will be bought\n   * @param _maxEthToSell max ETH amount to sell in the liq pool\n   * @param _deadline TX is expected to revert by Swap.sol if not meet\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\n   * as index 0 is ETH and index 1 is gETH!\n   */\n  function _buyback(\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 _poolId,\n    uint256 _maxEthToSell,\n    uint256 _deadline\n  ) internal returns (uint256 remETH, uint256 boughtgETH) {\n    ILiquidityPool LP = _getLiquidityPool(DATASTORE, _poolId);\n    // skip if no liquidity pool is found\n    if (address(LP) != address(0)) {\n      uint256 debt = LP.getDebt();\n      // skip if debt is too low\n      if (debt > IGNORABLE_DEBT) {\n        if (_maxEthToSell > debt) {\n          // if debt is lower, then only sell debt\n          remETH = _maxEthToSell - debt;\n        } else {\n          // if eth is lower, then sell all eth, remETH already 0\n          debt = _maxEthToSell;\n        }\n        // SWAP in LP\n        boughtgETH = LP.swap{value: debt}(0, 1, debt, 0, _deadline);\n      } else {\n        remETH = _maxEthToSell;\n      }\n    } else {\n      remETH = _maxEthToSell;\n    }\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Allowing users to deposit into a staking pool.\n   * @notice If a pool is not public, only the controller and if there is a whitelist contract, the whitelisted addresses can deposit.\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\n   * @param mingETH liquidity pool parameter\n   * @param deadline liquidity pool parameter\n   * @dev an example for minting + buybacks\n   * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\n   * * debt  msgValue\n   * * 100   10  => buyback\n   * * 100   100 => buyback\n   * * 10    100 => buyback + mint\n   * * 1     x   => mint\n   * * 0.5   x   => mint\n   * * 0     x   => mint\n   */\n  function deposit(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\n    require(msg.value > 0, \"SML:msg.value cannot be zero\");\n    require(deadline > block.timestamp, \"SML:deadline not met\");\n    require(receiver != address(0), \"SML:receiver is zero address\");\n\n    if (isPrivatePool(DATASTORE, poolId)) {\n      require(isWhitelisted(DATASTORE, poolId, msg.sender), \"SML:sender not whitelisted\");\n    }\n\n    uint256 remEth = msg.value;\n    (remEth, boughtgETH) = _buyback(DATASTORE, poolId, remEth, deadline);\n\n    if (remEth > 0) {\n      mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\n    }\n\n    require(boughtgETH + mintedgETH >= mingETH, \"SML:less than minimum\");\n\n    // send back to user\n    self.gETH.safeTransferFrom(address(this), receiver, poolId, boughtgETH + mintedgETH, \"\");\n\n    emit Deposit(poolId, boughtgETH, mintedgETH);\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR CREATION **\n   *\n   * @dev Creation of a Validator takes 2 steps: propose and beacon stake.\n   * Before entering stake() function, _canStake verifies the eligibility of\n   * given pubKey that is proposed by an operator with proposeStake function.\n   * Eligibility is defined by an optimistic alienation, check OracleUtils._alienateValidator() for info.\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n\n  /**\n   * @notice internal function to check if a validator can use the pool funds\n   *\n   *  @param _pubkey BLS12-381 public key of the validator\n   *  @return true if:\n   *   - pubkey should be proposed\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\n   *   - the validator's index is already covered by VERIFICATION_INDEX. Updated by Telescope.\n   */\n  function _canStake(\n    StakeModuleStorage storage self,\n    bytes calldata _pubkey,\n    uint256 _verificationIndex\n  ) internal view returns (bool) {\n    return\n      (self.validators[_pubkey].state == VALIDATOR_STATE.PROPOSED) &&\n      (self.validators[_pubkey].index <= _verificationIndex);\n  }\n\n  /**\n   * @notice external function to check if a validator can use the pool funds\n   */\n  function canStake(\n    StakeModuleStorage storage self,\n    bytes calldata pubkey\n  ) external view returns (bool) {\n    return _canStake(self, pubkey, self.VERIFICATION_INDEX);\n  }\n\n  /**\n   * @dev -> external\n   */\n\n  /**\n   * @notice Validator Credentials Proposal function, first step of crating validators.\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\n   * * it is optimistically allowed to take funds from staking pools.\n   *\n   * @param poolId the id of the staking pool\n   * @param operatorId the id of the Operator whose maintainer calling this function\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\n   * maintainer balance\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on stake() function call\n   *\n   * @dev DCL.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCL.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\n   * 31 Ether will be staked after verification of oracles. 32 in total.\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\n   * @dev ProposeStake requires enough funds within Wallet.\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 50)\n   */\n  function proposeStake(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external {\n    // checks\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\n    require(\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract))),\n      \"SML:withdrawalContract is isolated\"\n    );\n\n    uint256 pkLen = pubkeys.length;\n\n    require((pkLen > 0) && (pkLen <= DCL.MAX_DEPOSITS_PER_CALL), \"SML:1 - 50 validators\");\n\n    require(\n      pkLen == signatures1.length && pkLen == signatures31.length,\n      \"SML:invalid input length\"\n    );\n\n    require(\n      operatorAllowance(self, DATASTORE, poolId, operatorId) >= pkLen,\n      \"SML:insufficient allowance\"\n    );\n\n    require(\n      DATASTORE.readUint(poolId, rks.surplus) >= DCL.DEPOSIT_AMOUNT * pkLen,\n      \"SML:not enough surplus\"\n    );\n\n    _decreaseWalletBalance(DATASTORE, operatorId, (pkLen * DCL.DEPOSIT_AMOUNT_PRESTAKE));\n\n    for (uint256 i; i < pkLen; ) {\n      require(pubkeys[i].length == DCL.PUBKEY_LENGTH, \"SML:PUBKEY_LENGTH ERROR\");\n      require(signatures1[i].length == DCL.SIGNATURE_LENGTH, \"SML:SIGNATURE_LENGTH ERROR\");\n      require(signatures31[i].length == DCL.SIGNATURE_LENGTH, \"SML:SIGNATURE_LENGTH ERROR\");\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    ConstantValidatorData memory valData = ConstantValidatorData({\n      index: uint64(self.VALIDATORS_INDEX + 1),\n      period: uint64(getValidatorPeriod(DATASTORE, operatorId)),\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\n      infrastructureFee: self.infrastructureFees[ID_TYPE.POOL],\n      withdrawalCredential: DATASTORE.readBytes(poolId, rks.withdrawalCredential)\n    });\n\n    for (uint256 i; i < pkLen; ) {\n      require(\n        self.validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\n        \"SML: used or alienated pk\"\n      );\n\n      self.validators[pubkeys[i]] = Validator(\n        VALIDATOR_STATE.PROPOSED,\n        valData.index + uint64(i),\n        uint64(block.timestamp),\n        valData.period,\n        poolId,\n        operatorId,\n        valData.poolFee,\n        valData.operatorFee,\n        valData.infrastructureFee,\n        signatures31[i]\n      );\n\n      DCL.depositValidator(\n        pubkeys[i],\n        valData.withdrawalCredential,\n        signatures1[i],\n        DCL.DEPOSIT_AMOUNT_PRESTAKE\n      );\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    DATASTORE.subUint(poolId, rks.surplus, (pkLen * DCL.DEPOSIT_AMOUNT));\n    DATASTORE.addUint(poolId, rks.secured, (pkLen * DCL.DEPOSIT_AMOUNT));\n\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), pkLen);\n    DATASTORE.appendBytesArrayBatch(poolId, rks.validators, pubkeys);\n    DATASTORE.appendBytesArrayBatch(operatorId, rks.validators, pubkeys);\n\n    self.VALIDATORS_INDEX += pkLen;\n\n    emit StakeProposal(poolId, operatorId, pubkeys);\n  }\n\n  /**\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\n   *\n   *  @param operatorId the id of the Operator whose maintainer calling this function\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\n   *\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\n   *  pk1, pk2, pk3 from pool1\n   *  pk4, pk5 from pool2\n   *  pk6 from pool3\n   *  separate them in similar groups as much as possible.\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 50)\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\n   */\n  function stake(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 operatorId,\n    bytes[] calldata pubkeys\n  ) external {\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\n\n    require(\n      (pubkeys.length > 0) && (pubkeys.length <= DCL.MAX_DEPOSITS_PER_CALL),\n      \"SML:1 - 50 validators\"\n    );\n\n    {\n      uint256 pubkeysLen = pubkeys.length;\n      uint256 _verificationIndex = self.VERIFICATION_INDEX;\n      for (uint256 j; j < pubkeysLen; ) {\n        require(\n          _canStake(self, pubkeys[j], _verificationIndex),\n          \"SML:not all pubkeys are stakeable\"\n        );\n\n        require(\n          self.validators[pubkeys[j]].operatorId == operatorId,\n          \"SML:not all pubkeys belong to operator\"\n        );\n\n        unchecked {\n          j += 1;\n        }\n      }\n    }\n\n    {\n      bytes32 activeValKey = DSML.getKey(operatorId, rks.activeValidators);\n      bytes32 proposedValKey = DSML.getKey(operatorId, rks.proposedValidators);\n      uint256 poolId = self.validators[pubkeys[0]].poolId;\n      bytes memory withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\n\n      uint256 lastIdChange = 0;\n      for (uint256 i; i < pubkeys.length; ) {\n        uint256 newPoolId = self.validators[pubkeys[i]].poolId;\n        if (poolId != newPoolId) {\n          uint256 sinceLastIdChange;\n\n          unchecked {\n            sinceLastIdChange = i - lastIdChange;\n          }\n\n          DATASTORE.subUint(poolId, rks.secured, (DCL.DEPOSIT_AMOUNT * (sinceLastIdChange)));\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\n\n          lastIdChange = i;\n          poolId = newPoolId;\n          withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\n        }\n\n        DCL.depositValidator(\n          pubkeys[i],\n          withdrawalCredential,\n          self.validators[pubkeys[i]].signature31,\n          (DCL.DEPOSIT_AMOUNT - DCL.DEPOSIT_AMOUNT_PRESTAKE)\n        );\n\n        self.validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\n\n        unchecked {\n          i += 1;\n        }\n      }\n      {\n        uint256 sinceLastIdChange;\n        unchecked {\n          sinceLastIdChange = pubkeys.length - lastIdChange;\n        }\n\n        DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT * (sinceLastIdChange));\n        DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\n        DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\n      }\n\n      _increaseWalletBalance(DATASTORE, operatorId, DCL.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length);\n\n      emit Stake(pubkeys);\n    }\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR EXITS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice Notifies the node operator with ExitRequest event\n   * @dev Prevents the request if validator is still within the MIN_VALIDATOR_PERIOD\n   * @dev Only the active validators can be called for an exit\n   * @dev Can only be called by the withdrawalContract of the pool given validator belongs to.\n   * @dev fails in case the tx is submitted without a secure medium, withdrawal contract of the correct pool\n   * @return true if operation is successful\n   */\n  function requestExit(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    bytes calldata pk\n  ) external returns (bool) {\n    if (self.validators[pk].createdAt + MIN_VALIDATOR_PERIOD > block.timestamp) {\n      return false;\n    }\n\n    require(\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\n      \"SML:sender is not withdrawal contract\"\n    );\n    require(self.validators[pk].poolId == poolId, \"SML:incorrect poolId\");\n    require(self.validators[pk].state == VALIDATOR_STATE.ACTIVE, \"SML:not an active validator\");\n\n    self.validators[pk].state = VALIDATOR_STATE.EXIT_REQUESTED;\n    emit ExitRequest(pk);\n    return true;\n  }\n\n  /**\n   * @notice Finalizes the exit process for a validator.\n   * @dev Strongly advised to be called right after the exiting process is over.\n   * @dev Operators can exit at any time they want.\n   * @dev Can only be called by the withdrawalContract of the pool given validator belongs to.\n   */\n  function finalizeExit(\n    StakeModuleStorage storage self,\n    DataStoreModuleStorage storage DATASTORE,\n    uint256 poolId,\n    bytes calldata pk\n  ) external {\n    require(\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\n      \"SML:sender is not withdrawal contract\"\n    );\n    require(self.validators[pk].poolId == poolId, \"SML:incorrect poolId\");\n\n    uint256 state = self.validators[pk].state;\n    require(\n      state == VALIDATOR_STATE.ACTIVE || state == VALIDATOR_STATE.EXIT_REQUESTED,\n      \"SML:not an active validator\"\n    );\n\n    self.validators[pk].state = VALIDATOR_STATE.EXITED;\n\n    emit Exit(pk);\n  }\n}\n"
    },
    "contracts/modules/StakeModule/StakeModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - contracts\nimport {ERC1155HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n// internal - globals\nimport {PERCENTAGE_DENOMINATOR} from \"../../globals/macros.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../interfaces/IgETH.sol\";\nimport {IStakeModule} from \"../../interfaces/modules/IStakeModule.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"../DataStoreModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"./structs/storage.sol\";\nimport {Validator} from \"./structs/utils.sol\";\n// internal - libraries\nimport {StakeModuleLib as SML} from \"./libs/StakeModuleLib.sol\";\nimport {InitiatorExtensionLib as IEL} from \"./libs/InitiatorExtensionLib.sol\";\nimport {OracleExtensionLib as OEL} from \"./libs/OracleExtensionLib.sol\";\n// internal - contracts\nimport {DataStoreModule} from \"../DataStoreModule/DataStoreModule.sol\";\n\n/**\n * @title SM: Stake Module\n *\n * @notice Liquid staking for everyone.\n * * pooling and staking for staking derivatives\n * * validator delegation and operator onboarding\n * * oracle operations such as pricing\n *\n * @dev review: this module delegates its functionality to SML (StakeModuleLib).\n * * SML has authenticate function for access control.\n * @dev review: OEL (OracleExtensionLib) is an extension for oracle operations.\n * @dev review: DCL (DepositContractLib) is an helper for validator creation.\n *\n * @dev There is 1 additional functionality implemented apart from the library:\n * * check price validity and accept proofs for updating the price (refer to deposit function).\n * * However, this module inherits and implements nonReentrant & whenNotPaused modifiers.\n * * SM has pausability and expects inheriting contract to provide the access control mechanism.\n *\n * @dev 4 functions need to be overriden when inherited: pause, unpause, setInfrastructureFee, setBeaconDelays.\n *\n * @dev __StakeModule_init (or _unchained) call is NECESSARY when inherited.\n *\n * @dev This module inherits DataStoreModule.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract StakeModule is\n  IStakeModule,\n  ERC1155HolderUpgradeable,\n  ReentrancyGuardUpgradeable,\n  PausableUpgradeable,\n  DataStoreModule\n{\n  using SML for StakeModuleStorage;\n  using IEL for StakeModuleStorage;\n  using OEL for StakeModuleStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.StakeModuleStorage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant StakeModuleStorageLocation =\n    0x642b1534be65022221e9e6919fcbcd097fefb6d9d9b7897cee77332e470da700;\n\n  function _getStakeModuleStorage() internal pure returns (StakeModuleStorage storage $) {\n    assembly {\n      $.slot := StakeModuleStorageLocation\n    }\n  }\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\n  event MiddlewareDeployed(uint256 poolId, uint256 version);\n  event PackageDeployed(uint256 poolId, uint256 packageType, address instance);\n  event InfrastructureFeeSet(uint256 _type, uint256 fee);\n  event BeaconDelaySet(uint256 entryDelay, uint256 exitDelay);\n  event InitiationDepositSet(uint256 initiationDeposit);\n  event VisibilitySet(uint256 id, bool isPrivate);\n  event YieldReceiverSet(uint256 indexed poolId, address yieldReceiver);\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId, uint256 threshold);\n  event Prisoned(uint256 indexed operatorId, bytes proof, uint256 releaseTimestamp);\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\n  event Stake(bytes[] pubkeys);\n\n  event Alienated(bytes pubkey);\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\n  event FeeTheft(uint256 indexed id, bytes proofs);\n  event YieldDistributed(uint256 indexed poolId, uint256 amount);\n  event OracleReported(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 monopolyThreshold\n  );\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   */\n  function pause() external virtual override;\n\n  function unpause() external virtual override;\n\n  function setInfrastructureFee(uint256 _type, uint256 fee) external virtual override;\n\n  function setBeaconDelays(uint256 _type, uint256 fee) external virtual override;\n\n  function setInitiationDeposit(uint256 newInitiationDeposit) external virtual override;\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n  function __StakeModule_init(address _gETH, address _oracle_position) internal onlyInitializing {\n    __ReentrancyGuard_init();\n    __Pausable_init();\n    __ERC1155Holder_init();\n    __DataStoreModule_init();\n    __StakeModule_init_unchained(_gETH, _oracle_position);\n  }\n\n  function __StakeModule_init_unchained(\n    address _gETH,\n    address _oracle_position\n  ) internal onlyInitializing {\n    require(_gETH != address(0), \"SM:gETH cannot be zero address\");\n    require(_oracle_position != address(0), \"SM:oracle cannot be zero address\");\n\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n\n    $.gETH = IgETH(_gETH);\n    $.ORACLE_POSITION = _oracle_position;\n\n    $.BEACON_DELAY_ENTRY = 14 days;\n    $.BEACON_DELAY_EXIT = 14 days;\n\n    $.INITIATION_DEPOSIT = 32 ether; // initially 32 eth\n\n    $.DAILY_PRICE_INCREASE_LIMIT = (7 * PERCENTAGE_DENOMINATOR) / 100;\n    $.DAILY_PRICE_DECREASE_LIMIT = (7 * PERCENTAGE_DENOMINATOR) / 100;\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function StakeParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address gETH,\n      address oraclePosition,\n      uint256 validatorsIndex,\n      uint256 verificationIndex,\n      uint256 monopolyThreshold,\n      uint256 beaconDelayEntry,\n      uint256 beaconDelayExit,\n      uint256 initiationDeposit,\n      uint256 oracleUpdateTimestamp,\n      uint256 dailyPriceIncreaseLimit,\n      uint256 dailyPriceDecreaseLimit\n    )\n  {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    gETH = address($.gETH);\n    oraclePosition = $.ORACLE_POSITION;\n    validatorsIndex = $.VALIDATORS_INDEX;\n    verificationIndex = $.VERIFICATION_INDEX;\n    monopolyThreshold = $.MONOPOLY_THRESHOLD;\n    beaconDelayEntry = $.BEACON_DELAY_ENTRY;\n    beaconDelayExit = $.BEACON_DELAY_EXIT;\n    initiationDeposit = $.INITIATION_DEPOSIT;\n    oracleUpdateTimestamp = $.ORACLE_UPDATE_TIMESTAMP;\n    dailyPriceIncreaseLimit = $.DAILY_PRICE_INCREASE_LIMIT;\n    dailyPriceDecreaseLimit = $.DAILY_PRICE_DECREASE_LIMIT;\n  }\n\n  function getValidator(\n    bytes calldata pubkey\n  ) external view virtual override returns (Validator memory) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.validators[pubkey];\n  }\n\n  function getBalancesMerkleRoot() external view virtual override returns (bytes32) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.BALANCE_MERKLE_ROOT;\n  }\n\n  function getPriceMerkleRoot() external view virtual override returns (bytes32) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.PRICE_MERKLE_ROOT;\n  }\n\n  function getPackageVersion(uint256 _type) external view virtual override returns (uint256) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.packages[_type];\n  }\n\n  function isMiddleware(\n    uint256 _type,\n    uint256 _version\n  ) external view virtual override returns (bool) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.middlewares[_type][_version];\n  }\n\n  function getInfrastructureFee(uint256 _type) external view virtual override returns (uint256) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.infrastructureFees[_type];\n  }\n\n  /**\n   * @custom:section                           ** OPERATOR INITIATOR **\n   *\n   * @custom:visibility -> external\n   */\n  function initiateOperator(\n    uint256 id,\n    uint256 fee,\n    uint256 validatorPeriod,\n    address maintainer\n  ) external payable virtual override nonReentrant whenNotPaused {\n    IEL.initiateOperator(_getDataStoreModuleStorage(), id, fee, validatorPeriod, maintainer);\n  }\n\n  /**\n   * @custom:section                           ** STAKING POOL INITIATOR **\n   *\n   * @custom:visibility -> external\n   */\n\n  function initiatePool(\n    uint256 fee,\n    uint256 middlewareVersion,\n    address maintainer,\n    bytes calldata NAME,\n    bytes calldata middleware_data,\n    bool[3] calldata config\n  ) external payable virtual override whenNotPaused returns (uint256 poolId) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    poolId = $.initiatePool(\n      _getDataStoreModuleStorage(),\n      fee,\n      middlewareVersion,\n      maintainer,\n      NAME,\n      middleware_data,\n      config\n    );\n  }\n\n  /**\n   * @custom:subsection                           ** POOL VISIBILITY **\n   */\n\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external virtual override {\n    SML.setPoolVisibility(_getDataStoreModuleStorage(), poolId, makePrivate);\n  }\n\n  function setWhitelist(uint256 poolId, address whitelist) external virtual override {\n    SML.setWhitelist(_getDataStoreModuleStorage(), poolId, whitelist);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function isPrivatePool(uint256 poolId) external view virtual override returns (bool) {\n    return SML.isPrivatePool(_getDataStoreModuleStorage(), poolId);\n  }\n\n  function isWhitelisted(\n    uint256 poolId,\n    address staker\n  ) external view virtual override returns (bool) {\n    return SML.isWhitelisted(_getDataStoreModuleStorage(), poolId, staker);\n  }\n\n  /**\n   * @custom:subsection                           ** BOUND LIQUIDITY POOL **\n   */\n\n  function deployLiquidityPool(uint256 poolId) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.deployLiquidityPool(_getDataStoreModuleStorage(), poolId);\n  }\n\n  /**\n   * @custom:subsection                           ** YIELD SEPARATION **\n   */\n\n  function setYieldReceiver(\n    uint256 poolId,\n    address yieldReceiver\n  ) external virtual override whenNotPaused {\n    SML.setYieldReceiver(_getDataStoreModuleStorage(), poolId, yieldReceiver);\n  }\n\n  /**\n   * @custom:section                           ** ID MANAGEMENT **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @custom:subsection                           ** MAINTAINER **\n   */\n\n  function changeMaintainer(\n    uint256 id,\n    address newMaintainer\n  ) external virtual override whenNotPaused {\n    SML.changeMaintainer(_getDataStoreModuleStorage(), id, newMaintainer);\n  }\n\n  /**\n   * @custom:subsection                           ** FEE **\n   */\n\n  function switchMaintenanceFee(\n    uint256 id,\n    uint256 newFee\n  ) external virtual override whenNotPaused {\n    SML.switchMaintenanceFee(_getDataStoreModuleStorage(), id, newFee);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function getMaintenanceFee(uint256 id) external view virtual override returns (uint256) {\n    return SML.getMaintenanceFee(_getDataStoreModuleStorage(), id);\n  }\n\n  /**\n   * @custom:section                           ** INTERNAL WALLET **\n   */\n\n  function increaseWalletBalance(\n    uint256 id\n  ) external payable virtual override nonReentrant whenNotPaused returns (bool) {\n    return SML.increaseWalletBalance(_getDataStoreModuleStorage(), id);\n  }\n\n  function decreaseWalletBalance(\n    uint256 id,\n    uint256 value\n  ) external virtual override nonReentrant returns (bool) {\n    return SML.decreaseWalletBalance(_getDataStoreModuleStorage(), id, value);\n  }\n\n  /**\n   * @custom:section                           ** OPERATORS PERIOD **\n   *\n   * @custom:visibility -> external\n   */\n\n  function switchValidatorPeriod(\n    uint256 operatorId,\n    uint256 newPeriod\n  ) external virtual override whenNotPaused {\n    SML.switchValidatorPeriod(_getDataStoreModuleStorage(), operatorId, newPeriod);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function getValidatorPeriod(uint256 id) external view virtual override returns (uint256) {\n    return SML.getValidatorPeriod(_getDataStoreModuleStorage(), id);\n  }\n\n  /**\n   * @custom:section                           ** PRISON **\n   *\n   * @custom:visibility -> external\n   */\n\n  function blameProposal(bytes calldata pk) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.blameProposal(_getDataStoreModuleStorage(), pk);\n  }\n\n  function blameExit(\n    bytes calldata pk,\n    uint256 beaconBalance,\n    uint256 withdrawnBalance,\n    bytes32[] calldata balanceProof\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.blameExit(_getDataStoreModuleStorage(), pk, beaconBalance, withdrawnBalance, balanceProof);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function isPrisoned(uint256 operatorId) external view virtual override returns (bool) {\n    return SML.isPrisoned(_getDataStoreModuleStorage(), operatorId);\n  }\n\n  /**\n   * @custom:section                           ** DELEGATION **\n   *\n   * @custom:visibility -> external\n   */\n\n  function delegate(\n    uint256 poolId,\n    uint256[] calldata operatorIds,\n    uint256[] calldata allowances\n  ) external virtual override whenNotPaused {\n    SML.delegate(_getDataStoreModuleStorage(), poolId, operatorIds, allowances);\n  }\n\n  function setFallbackOperator(\n    uint256 poolId,\n    uint256 operatorId,\n    uint256 fallbackThreshold\n  ) external virtual override whenNotPaused {\n    SML.setFallbackOperator(_getDataStoreModuleStorage(), poolId, operatorId, fallbackThreshold);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function operatorAllowance(\n    uint256 poolId,\n    uint256 operatorId\n  ) external view virtual override returns (uint256) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.operatorAllowance(_getDataStoreModuleStorage(), poolId, operatorId);\n  }\n\n  /**\n   * @custom:section                           ** DEPOSIT GETTERS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  function isPriceValid(uint256 poolId) external view virtual override returns (bool) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.isPriceValid(poolId);\n  }\n\n  function isMintingAllowed(uint256 poolId) external view virtual override returns (bool) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.isMintingAllowed(_getDataStoreModuleStorage(), poolId);\n  }\n\n  /**\n   * @custom:section                           ** POOLING OPERATIONS **\n   *\n   * @custom:visibility -> external\n   */\n  function deposit(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof,\n    uint256 mingETH,\n    uint256 deadline,\n    address receiver\n  )\n    external\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 boughtgETH, uint256 mintedgETH)\n  {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    DataStoreModuleStorage storage DSMStorage = _getDataStoreModuleStorage();\n    if (!$.isPriceValid(poolId)) {\n      $.priceSync(DSMStorage, poolId, price, priceProof);\n    }\n\n    (boughtgETH, mintedgETH) = $.deposit(\n      _getDataStoreModuleStorage(),\n      poolId,\n      mingETH,\n      deadline,\n      receiver\n    );\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR CREATION **\n   *\n   * @custom:visibility -> external\n   */\n  function proposeStake(\n    uint256 poolId,\n    uint256 operatorId,\n    bytes[] calldata pubkeys,\n    bytes[] calldata signatures1,\n    bytes[] calldata signatures31\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.proposeStake(\n      _getDataStoreModuleStorage(),\n      poolId,\n      operatorId,\n      pubkeys,\n      signatures1,\n      signatures31\n    );\n  }\n\n  function stake(\n    uint256 operatorId,\n    bytes[] calldata pubkeys\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.stake(_getDataStoreModuleStorage(), operatorId, pubkeys);\n  }\n\n  /**\n   * @custom:visibility -> view\n   */\n  function canStake(bytes calldata pubkey) external view virtual override returns (bool) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.canStake(pubkey);\n  }\n\n  /**\n   * @custom:section                           ** VALIDATOR EXITS **\n   *\n   * @custom:visibility -> external\n   */\n\n  function requestExit(\n    uint256 poolId,\n    bytes calldata pk\n  ) external virtual override nonReentrant whenNotPaused returns (bool) {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    return $.requestExit(_getDataStoreModuleStorage(), poolId, pk);\n  }\n\n  function finalizeExit(\n    uint256 poolId,\n    bytes calldata pk\n  ) external virtual override nonReentrant whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.finalizeExit(_getDataStoreModuleStorage(), poolId, pk);\n  }\n\n  /**\n   * @custom:section                           ** ORACLE OPERATIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  function updateVerificationIndex(\n    uint256 validatorVerificationIndex,\n    bytes[] calldata alienatedPubkeys\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.updateVerificationIndex(\n      _getDataStoreModuleStorage(),\n      validatorVerificationIndex,\n      alienatedPubkeys\n    );\n  }\n\n  function regulateOperators(\n    uint256[] calldata feeThefts,\n    bytes[] calldata proofs\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.regulateOperators(_getDataStoreModuleStorage(), feeThefts, proofs);\n  }\n\n  function reportBeacon(\n    bytes32 priceMerkleRoot,\n    bytes32 balanceMerkleRoot,\n    uint256 allValidatorsCount\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.reportBeacon(priceMerkleRoot, balanceMerkleRoot, allValidatorsCount);\n  }\n\n  function priceSync(\n    uint256 poolId,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.priceSync(_getDataStoreModuleStorage(), poolId, price, priceProof);\n  }\n\n  function priceSyncBatch(\n    uint256[] calldata poolIds,\n    uint256[] calldata prices,\n    bytes32[][] calldata priceProofs\n  ) external virtual override whenNotPaused {\n    StakeModuleStorage storage $ = _getStakeModuleStorage();\n    $.priceSyncBatch(_getDataStoreModuleStorage(), poolIds, prices, priceProofs);\n  }\n}\n"
    },
    "contracts/modules/StakeModule/structs/helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @notice Helper Struct to pack constant data that does not change per validator on batch proposals\n * * needed for that famous Solidity feature.\n */\nstruct ConstantValidatorData {\n  uint64 index;\n  uint64 period;\n  uint256 poolFee;\n  uint256 operatorFee;\n  uint256 infrastructureFee;\n  bytes withdrawalCredential;\n}\n"
    },
    "contracts/modules/StakeModule/structs/storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\n// internal - structs\nimport {Validator} from \"./utils.sol\";\n\n/**\n * @notice Storage struct for the Pooled Liquid Staking logic\n * @param gETH constant, ERC1155, all Geode Staking Derivatives.\n * @param ORACLE_POSITION constant, address of the Oracle https://github.com/Geodefi/Telescope-Eth\n * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\n * * Includes all validators: proposed, active, alienated, exited.\n * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\n * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\n * @param BEACON_DELAY_ENTRY allowed max delay between the creation of an (approved) proposal and stake() call, per the beaconchain entry queue.\n * @param BEACON_DELAY_EXIT allowed max delay between an exit request and its finalization with finalizeExit() call, per the beaconchain exit queue.\n * @param INITIATION_DEPOSIT the initial deposit amount that is required for a name to be reserved by the pool, prevents sybil attacks.\n * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\n * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval, per second.\n * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval, per second.\n * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, updated by the Holy Oracle.\n * @param GOVERNANCE_FEE **reserved** Although it is 0 right now, It can be updated in the future.\n * @param BALANCE_MERKLE_ROOT merkle root of the balances and other validator related data, useful on withdrawals, updated by the Holy Oracle.\n * @param validators pubkey => Validator, contains all the data about proposed, alienated, active, exit-called and fully exited validators.\n * @param packages TYPE => version id, pointing to the latest versions of the given package.\n * * Like default Withdrawal Contract version.\n * @param middlewares TYPE => version id => isAllowed, useful to check if given version of the middleware can be used.\n * * Like all the whitelisted gETHMiddlewares.\n * @param fees TYPE->PERCENTAGE, we can set a fee for any defined TYPE then use it in related operations.\n * * POOL type sets validator fees. Liqudity Pool Package type sets fee on swaps.\n *\n * @dev normally we would put custom:storage-location erc7201:geode.storage.StakeModule\n * but compiler throws an error... So np for now, just MAKE SURE.\n **/\nstruct StakeModuleStorage {\n  IgETH gETH;\n  address ORACLE_POSITION;\n  uint256 VALIDATORS_INDEX;\n  uint256 VERIFICATION_INDEX;\n  uint256 MONOPOLY_THRESHOLD;\n  uint256 BEACON_DELAY_ENTRY;\n  uint256 BEACON_DELAY_EXIT;\n  uint256 INITIATION_DEPOSIT;\n  uint256 ORACLE_UPDATE_TIMESTAMP;\n  uint256 DAILY_PRICE_INCREASE_LIMIT;\n  uint256 DAILY_PRICE_DECREASE_LIMIT;\n  bytes32 PRICE_MERKLE_ROOT;\n  bytes32 BALANCE_MERKLE_ROOT;\n  mapping(bytes => Validator) validators;\n  mapping(uint256 => uint256) packages;\n  mapping(uint256 => mapping(uint256 => bool)) middlewares;\n  mapping(uint256 => uint256) infrastructureFees;\n}\n"
    },
    "contracts/modules/StakeModule/structs/utils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @param state state of the validator, refer to globals.sol\n * @param index representing this validator's placement on the chronological order of the validators proposals\n * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\n * @param period the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\n * @param poolId needed for withdrawal_credential\n * @param operatorId needed for staking after allowance\n * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\n * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\n * @param infrastructureFee all fees are crucial for the price calculation by the oracle, even if its zero.\n * @param signature31 BLS12-381 signature for the validator, used when the remaining 31 ETH is sent on validator activation.\n **/\nstruct Validator {\n  uint64 state;\n  uint64 index;\n  uint64 createdAt;\n  uint64 period;\n  uint256 poolId;\n  uint256 operatorId;\n  uint256 poolFee;\n  uint256 operatorFee;\n  uint256 infrastructureFee;\n  bytes signature31;\n}\n"
    },
    "contracts/modules/WithdrawalModule/libs/WithdrawalModuleLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - libraries\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n// internal - globals\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \"../../../globals/macros.sol\";\nimport {VALIDATOR_STATE} from \"../../../globals/validator_state.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\nimport {IPortal} from \"../../../interfaces/IPortal.sol\";\n// internal - structs\nimport {Queue, Request, ValidatorData} from \"../structs/utils.sol\";\nimport {WithdrawalModuleStorage} from \"../structs/storage.sol\";\n// internal - libraries\nimport {DepositContractLib as DCL} from \"../../StakeModule/libs/DepositContractLib.sol\";\nimport {Validator} from \"../../StakeModule/structs/utils.sol\";\n\n/**\n * @title WML: Withdrawal Module Library\n *\n * @notice Improved validator withdrawals (and exits), while preserving the validator segregation.\n *\n * @notice Intended implementation scope:\n * 1. Processing the withdrawals (partial and exits).\n * * `processValidators` function handles any balance changes that is reflected from the Beacon Chain.\n * * If a validator's balance on the Beacon Chain is ZERO, it exited (forced or voluntary).\n *\n * 2. Distributing the fees.\n * * Pool and Operator fees are distributed whenever the validator is processed.\n * * Note that if the validator is slashed before being processed, fees can be lost along with the stakers' profit.\n *\n * 3. Queueing withdrawal requests.\n * * Users can request a withdrawal by forfeiting their gETH tokens.\n * * Requests would be put in a queue (First-In-First-Out).\n * * As the validators are processed, requests become claimable.\n * * Users can dequeue partially or fully.\n *\n * 4. Allowing (Instant Run-off) elections on which validators to exit.\n * * While getting into the queue, caller can vote on a validator, increasing it's 'poll'.\n * * If a validator is not specified, vote goes to 'commonPoll'. It can be used for any validator to top-up the EXIT_THRESHOLD\n * * If a validator is called for exit but there are remaining votes in it, it is transferred to the commonPoll.\n * * Note that, elections are basically just stating a preference:\n * * * Exit of the voted validator does not change the voter's priority in the queue.\n *\n * @dev The Queue\n * Lets say every '-' is representing 1 gETH.\n * Queue: --- -- ---------- -- --- --- - --- -- ---- ----- - ------- ---- -- -- - - -------- --\n * There are 20 requests in this queue, adding up to 65 gETH, this is 'requested'.\n * Every request has a 'size', first request' is 3 gETH , second' is 2 gETH.\n * Every request has a 'trigger', pointing it's kickoff point. Thus, 3rd request' is 5 gETH.\n * Let's say, there are 8 ETH processed in the contract, we burn 8 ETH worth of gETH.\n * Let's say 8 ETH is 4 gETH. Then the first request can exit fully, and second one can exit for 1 gETH.\n *\n * @dev This process creates a unique question:\n * Considering that profit processing, price updates and queue operations are ASYNC,\n * how can we make sure that we are paying the correct price?\n * We have determined 3 possible points that we can 'derisk' a Request:\n * Enqueue -> ProcessValidators -> Dequeue\n * 1. We derisk the Request when it is enqueued:\n * * This would cause 2 issues:\n * * a. Best case, we would prevent the queued Request from profiting while they are in the queue.\n * * b. Since there is a slashing risk, we cannot promise a fixed Ether amount without knowing what would be the future price.\n * 2. We derisk the Request when validators are processed, with the latest price for the derivative:\n * * This is the correct approach as we REALIZE the price at this exact point: by increasing the cumulative claimable gETH.\n * * However, we would need to insert an 'unbound for loop' through 'realized' Requests, when a 'processValidators' operation is finalized.\n * * We cannot, nor should, enforce an 'unbound for loop' on requests array.\n * 3. We derisk the Request when it is dequeued:\n * * Simply, price changes would have unpredictable effects on the Queue: A request can be claimable now, but might become unclaimable later.\n * * Derisked Requests that are waiting to be claimed, would hijack the real stakers' APR, while sitting on top of some allocated Ether.\n * * Unclaimed Requests can prevent the latter requests since there would be no way to keep track of the previous unclaimed requests without enforcing the order.\n * We do not want to promise vague returns, we do not want for loops over requests array or price checkpoints, we do not want APR hijacking.\n * Thus, none of these points can be implemented without utilizing a trusted third party, like an Oracle.\n * However, we want Withdrawal logic to have the minimum Third Party risk as Geode Developers.\n * As a result, we have came up with a logic that will allow stakers to maintain their profitability without disrupting the 'derisk' moment.\n * * a. We keep track of an internal price, stating the ratio of the claimable ETH and processed gETH: realizedPrice.\n * * b. We derisk the Queue on 'processValidators' by increasing the cumulative gETH that can be claimed.\n * * * We also adjust the realizedPrice considering the pricePerShare of the currently derisked asset amount.\n * * c. Requests can be fulfilled in respect to the internal price BY ANYONE at any point after they become claimable.\n * * d. Fulfilled requests, including partially fulfilled ones, can be claimed (ONLY) BY THE OWNER.\n * Why using an internal Price instead of 'enforcing the PricePerShare' makes sense:\n * * All Requests, without considering their index, are in the same pool until they are derisked through price processing.\n * * If all of the claimable requests are fulfilled periodically (via a script etc.), we would expect internal price to be equal to 'PricePerShare'.\n * * This way, a well maintained pool can prevent APR hijacking by fulfilling neglected Requests, while it is not enforced for all of the pools.\n * However, this is a gas-heavy process so it might not be needed after every 'processValidators' operation.\n * Similarly, 'processValidators' is expensive as well, we would advise calling it when there is a dequeue opportunity.\n * As a conclusion, if all requests are fulfilled immediately after the off-chain calculation signals them being claimable;\n * None of these approaches will be expensive, nor will disrupt the internal pricing for the latter requests.\n *\n * @dev while conducting the price calculations, a part of the balance within this contract should be taken into consideration.\n * This ETH amount can be calculated as: sum(lambda x: requests[x].withdrawnBalance) - [fulfilledEtherBalance] (todo for the telescope).\n * Note that, this is because: a price of the derivative is = total ETH / total Supply, and total ETH should include the balance within WC.\n *\n * @dev Contracts relying on this library must initialize WithdrawalModuleLib.WithdrawalModuleStorage\n *\n * @dev There are 'owner' checks on 'transferRequest', _dequeue (used by dequeue, dequeueBatch).\n * However, we preferred to not use a modifier for that.\n *\n * @dev all parameters related to balance are denominated in gETH; except realizedEtherBalance,fulfilledEtherBalance and claimableEther:\n * (requested, realized, fulfilled, commonPoll, trigger, size, fulfilled)\n * @author Ice Bear & Crash Bandicoot\n */\nlibrary WithdrawalModuleLib {\n  /**\n   * @custom:section                           ** CONSTANTS **\n   */\n  /// @notice EXIT_THRESHOLD should be at least 60% and at most 100%\n  uint256 internal constant MIN_EXIT_THRESHOLD = 6e9; // (6 * PERCENTAGE_DENOMINATOR) / 10;\n  // minimum withdrawal request is 0.05 ETH\n  uint256 internal constant MIN_REQUEST_SIZE = 5e16;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event NewExitThreshold(uint256 threshold);\n  event Enqueue(uint256 indexed index, address owner);\n  event Vote(uint256 indexed index, bytes indexed pubkey, uint256 size);\n  event RequestTransfer(uint256 indexed index, address oldOwner, address newOwner);\n  event Fulfill(uint256 indexed index, uint256 fulfillAmount, uint256 claimableETH);\n  event Dequeue(uint256 indexed index, uint256 claim);\n  event Processed();\n\n  /**\n   * @custom:section                           ** HELPER **\n   */\n\n  function _getPortal(WithdrawalModuleStorage storage self) internal view returns (IPortal) {\n    return IPortal(self.PORTAL);\n  }\n\n  /**\n   * @custom:section                           ** EARLY EXIT REQUESTS **\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n  /**\n   * @notice checks if given validator is exited, according to the information provided by Balances Merkle Root.\n   * @dev an external view function, just as an helper.\n   */\n  function canFinalizeExit(\n    WithdrawalModuleStorage storage self,\n    bytes calldata pubkey\n  ) external view returns (bool) {\n    if (self.validators[pubkey].beaconBalance != 0) {\n      return false;\n    }\n\n    Validator memory val = _getPortal(self).getValidator(pubkey);\n\n    // check pubkey belong to this pool\n    require(val.poolId == self.POOL_ID, \"WML:validator for an unknown pool\");\n\n    if (val.state != VALIDATOR_STATE.ACTIVE && val.state != VALIDATOR_STATE.EXIT_REQUESTED) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice notifies Portal to change validator state from ACTIVE to EXIT_REQUESTED\n   * @param pubkey public key of the given validator.\n   */\n  function _requestExit(\n    WithdrawalModuleStorage storage self,\n    bytes calldata pubkey\n  ) internal returns (bool) {\n    return _getPortal(self).requestExit(self.POOL_ID, pubkey);\n  }\n\n  /**\n   * @notice notifies Portal to change validator state from ACTIVE or EXIT_REQUESTED, to EXITED.\n   * @dev no additional checks are needed as processValidators and PORTAL.finalizeExit has propser checks.\n   * @param pubkey public key of the given validator.\n   */\n  function _finalizeExit(WithdrawalModuleStorage storage self, bytes calldata pubkey) internal {\n    _getPortal(self).finalizeExit(self.POOL_ID, pubkey);\n  }\n\n  /**\n   * @notice if the poll is above the threshold, calls Portal to request a voluntary exit.\n   * @param pubkey public key of the checked validator.\n   * @param commonPoll cached commonPoll\n   * @dev passing commonPoll around helps on gas on batch TXs.\n   */\n  function _checkAndRequestExit(\n    WithdrawalModuleStorage storage self,\n    bytes calldata pubkey,\n    uint256 commonPoll\n  ) internal returns (uint256) {\n    (uint256 threshold, uint256 beaconBalancePriced) = getValidatorThreshold(self, pubkey);\n    uint256 validatorPoll = self.validators[pubkey].poll;\n\n    if (commonPoll + validatorPoll > threshold) {\n      // meaning it can request withdrawal\n      if (_requestExit(self, pubkey)) {\n        if (threshold > validatorPoll) {\n          // If Poll is not enough spend votes from commonPoll.\n          commonPoll -= threshold - validatorPoll;\n        } else if (validatorPoll > beaconBalancePriced) {\n          // If Poll is bigger than needed, move the extra votes instead of spending.\n          commonPoll += validatorPoll - beaconBalancePriced;\n        }\n      }\n    }\n\n    return commonPoll;\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @notice allowing EXIT_THRESHOLD to be set by the contract owner.\n   * @param newThreshold as percentage, denominated in PERCENTAGE_DENOMINATOR.\n   * @dev caller should be governed on module contract.\n   */\n  function setExitThreshold(WithdrawalModuleStorage storage self, uint256 newThreshold) external {\n    require(newThreshold >= MIN_EXIT_THRESHOLD, \"WML:min threshold is 60%\");\n    require(newThreshold <= PERCENTAGE_DENOMINATOR, \"WML:max threshold is 100%\");\n\n    self.EXIT_THRESHOLD = newThreshold;\n    emit NewExitThreshold(newThreshold);\n  }\n\n  /**\n   * @custom:subsection                           ** VOTE **\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n  /**\n   * @notice figuring out the applied exit threshold, as in gETH, for a given validator.\n   * @param pubkey public key of the given validator.\n   */\n  function getValidatorThreshold(\n    WithdrawalModuleStorage storage self,\n    bytes calldata pubkey\n  ) public view returns (uint256 threshold, uint256 beaconBalancePriced) {\n    uint256 price = self.gETH.pricePerShare(self.POOL_ID);\n    beaconBalancePriced = ((self.validators[pubkey].beaconBalance * gETH_DENOMINATOR));\n    threshold = (beaconBalancePriced * self.EXIT_THRESHOLD) / PERCENTAGE_DENOMINATOR / price;\n    beaconBalancePriced = beaconBalancePriced / price;\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice a validator is chosen to be the next exit by enqueued Request\n   * @param pubkey public key of the voted validator.\n   * @param size specified gETH amount\n   */\n  function _vote(\n    WithdrawalModuleStorage storage self,\n    uint256 index,\n    bytes calldata pubkey,\n    uint256 size\n  ) internal {\n    Validator memory val = _getPortal(self).getValidator(pubkey);\n\n    require(val.poolId == self.POOL_ID, \"WML:vote for an unknown pool\");\n    require(val.state == VALIDATOR_STATE.ACTIVE, \"WML:voted for inactive validator\");\n\n    self.validators[pubkey].poll += size;\n    emit Vote(index, pubkey, size);\n  }\n\n  /**\n   * @custom:section                           ** REQUESTS QUEUE **\n   */\n\n  /**\n   * @custom:subsection                        ** ENQUEUE **\n   */\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice internal function to push a new Request into Queue\n   * @param trigger the kickoff point for the Request\n   * @param size specified gETH amount\n   */\n  function _enqueue(\n    WithdrawalModuleStorage storage self,\n    uint256 trigger,\n    uint256 size,\n    address owner\n  ) internal returns (uint256 index) {\n    require(size >= MIN_REQUEST_SIZE, \"WML:min 0.05 gETH\");\n    require(owner != address(0), \"WML:owner cannot be zero address\");\n\n    self.requests.push(\n      Request({owner: owner, trigger: trigger, size: size, fulfilled: 0, claimableEther: 0})\n    );\n\n    index = self.requests.length - 1;\n\n    emit Enqueue(index, owner);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice queues a Request into Queue, processes the vote, exits the validator in case of a run-off.\n   * @param pubkey voted validator, vote goes into commonPoll if bytes(0) is given.\n   * @param owner allows caller to directly transfer the Request on creation\n   */\n  function enqueue(\n    WithdrawalModuleStorage storage self,\n    uint256 size,\n    bytes calldata pubkey,\n    address owner\n  ) external returns (uint256 index) {\n    uint256 requestedgETH = self.queue.requested;\n    index = _enqueue(self, requestedgETH, size, owner);\n\n    if (pubkey.length == 0) {\n      self.queue.commonPoll += size;\n    } else {\n      _vote(self, index, pubkey, size);\n    }\n\n    self.queue.requested = requestedgETH + size;\n\n    self.gETH.safeTransferFrom(msg.sender, address(this), self.POOL_ID, size, \"\");\n  }\n\n  /**\n   * @notice enqueue() with batch optimizations\n   * @param sizes array of gETH amount that are sent to enqueue multiple Requests.\n   * @param pubkeys array of voted validators, vote goes into commonPoll if bytes(0) is given.\n   * @param owner the owner for all the Requests being created.\n   */\n  function enqueueBatch(\n    WithdrawalModuleStorage storage self,\n    uint256[] calldata sizes,\n    bytes[] calldata pubkeys,\n    address owner\n  ) external returns (uint256[] memory indexes) {\n    uint256 len = sizes.length;\n    require(len == pubkeys.length, \"WML:invalid input length\");\n\n    uint256 commonPoll = self.queue.commonPoll;\n    uint256 requestedgETH = self.queue.requested;\n    uint256 totalSize;\n\n    indexes = new uint256[](len);\n    for (uint256 i; i < len; ) {\n      indexes[i] = _enqueue(self, requestedgETH, sizes[i], owner);\n\n      if (pubkeys[i].length == 0) {\n        commonPoll += sizes[i];\n      } else {\n        _vote(self, indexes[i], pubkeys[i], sizes[i]);\n      }\n      requestedgETH = requestedgETH + sizes[i];\n      totalSize += sizes[i];\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.queue.commonPoll = commonPoll;\n    self.queue.requested = requestedgETH;\n\n    self.gETH.safeTransferFrom(msg.sender, address(this), self.POOL_ID, totalSize, \"\");\n  }\n\n  /**\n   * @notice transferring the ownership of a Request to a new address\n   * @param index placement of the Request within the requests array.\n   * @param newOwner new address that will be eligible to dequeue a Request.\n   * @dev only current Owner can change the owner\n   */\n  function transferRequest(\n    WithdrawalModuleStorage storage self,\n    uint256 index,\n    address newOwner\n  ) external {\n    address oldOwner = self.requests[index].owner;\n    require(msg.sender == oldOwner, \"WML:not owner\");\n    require(newOwner != address(0), \"WML:cannot transfer to zero address\");\n    require(\n      self.requests[index].fulfilled < self.requests[index].size,\n      \"WML:cannot transfer fulfilled\"\n    );\n\n    self.requests[index].owner = newOwner;\n\n    emit RequestTransfer(index, oldOwner, newOwner);\n  }\n\n  /**\n   * @custom:subsection                        ** FULFILL **\n   */\n  /**\n   * @custom:visibility -> view\n   */\n  /**\n   * @notice given a request, figure out the fulfillable gETH amount, limited up to its size.\n   * @param index placement of the Request within the requests array.\n   * @param qRealized self.queue.realized, might also be hot value for Batch optimizations\n   * @param qFulfilled self.queue.fulfilled, might also be a hot value for Batch optimizations\n   * @dev taking the previously fulfilled amount into consideration as it is the previously claimed part.\n   */\n  function fulfillable(\n    WithdrawalModuleStorage storage self,\n    uint256 index,\n    uint256 qRealized,\n    uint256 qFulfilled\n  ) public view returns (uint256) {\n    if (qRealized > qFulfilled) {\n      uint256 rTrigger = self.requests[index].trigger;\n      uint256 rSize = self.requests[index].size;\n      uint256 rFulfilled = self.requests[index].fulfilled;\n\n      uint256 rFloor = rTrigger + rFulfilled;\n      uint256 rCeil = rTrigger + rSize;\n\n      if (qRealized > rCeil) {\n        return rSize - rFulfilled;\n      } else if (qRealized > rFloor) {\n        return qRealized - rFloor;\n      } else {\n        return 0;\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice by using the realized part of the size, we fulfill a single request by making use of the internal pricing.\n   * @dev we burn the realized size of the Queue here because we do not want this process to mess with price\n   * * calculations of the oracle.\n   */\n  function _fulfill(WithdrawalModuleStorage storage self, uint256 index) internal {\n    uint256 toFulfill = fulfillable(self, index, self.queue.realized, self.queue.fulfilled);\n\n    if (toFulfill > 0) {\n      uint256 claimableETH = (toFulfill * self.queue.realizedPrice) / gETH_DENOMINATOR;\n      self.requests[index].claimableEther += claimableETH;\n      self.requests[index].fulfilled += toFulfill;\n      self.queue.fulfilled += toFulfill;\n      self.queue.fulfilledEtherBalance += claimableETH;\n\n      self.gETH.burn(address(this), self.POOL_ID, toFulfill);\n\n      emit Fulfill(index, toFulfill, claimableETH);\n    }\n  }\n\n  /**\n   * @notice _fulfill with Batch optimizations\n   * @param qRealized queue.realized, as a hot value.\n   * @param qFulfilled queue.fulfilled, as a hot value.\n   * @param qPrice queue.realizedPrice, as a hot value.\n   */\n  function _fulfillBatch(\n    WithdrawalModuleStorage storage self,\n    uint256[] calldata indexes,\n    uint256 qRealized,\n    uint256 qFulfilled,\n    uint256 qPrice\n  ) internal {\n    uint256 indexesLen = indexes.length;\n\n    uint256 oldFulfilled = qFulfilled;\n    uint256 qfulfilledEtherBalance;\n    for (uint256 i; i < indexesLen; ) {\n      uint256 toFulfill = fulfillable(self, indexes[i], qRealized, qFulfilled);\n      if (toFulfill > 0) {\n        uint256 claimableETH = (toFulfill * qPrice) / gETH_DENOMINATOR;\n        self.requests[indexes[i]].claimableEther += claimableETH;\n        self.requests[indexes[i]].fulfilled += toFulfill;\n        qFulfilled += toFulfill;\n        qfulfilledEtherBalance += claimableETH;\n\n        emit Fulfill(indexes[i], toFulfill, claimableETH);\n      }\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    self.queue.fulfilled = qFulfilled;\n    self.queue.fulfilledEtherBalance += qfulfilledEtherBalance;\n    self.gETH.burn(address(this), self.POOL_ID, qFulfilled - oldFulfilled);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  function fulfill(WithdrawalModuleStorage storage self, uint256 index) external {\n    _fulfill(self, index);\n  }\n\n  function fulfillBatch(WithdrawalModuleStorage storage self, uint256[] calldata indexes) external {\n    _fulfillBatch(\n      self,\n      indexes,\n      self.queue.realized,\n      self.queue.fulfilled,\n      self.queue.realizedPrice\n    );\n  }\n\n  /**\n   * @custom:subsection                        ** DEQUEUE **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n\n  /**\n   * @notice given a Request from the requests array, remove the part that is currently claimable.\n   * @param index placement of the Request within the requests array.\n   * @dev only owner can call this function\n   */\n  function _dequeue(\n    WithdrawalModuleStorage storage self,\n    uint256 index\n  ) internal returns (uint256 claimableETH) {\n    require(msg.sender == self.requests[index].owner, \"WML:not owner\");\n\n    claimableETH = self.requests[index].claimableEther;\n    require(claimableETH > 0, \"WML:not claimable\");\n\n    self.requests[index].claimableEther = 0;\n\n    emit Dequeue(index, claimableETH);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice given a Request from the requests array, claim the part that is currently claimable and forward the ether amount to the given receiver.\n   * @param index placement of the Request within the requests array.\n   * @dev only owner can call this function\n   */\n  function dequeue(WithdrawalModuleStorage storage self, uint256 index, address receiver) external {\n    require(receiver != address(0), \"WML:receiver cannot be zero address\");\n\n    _fulfill(self, index);\n    uint256 claimableETH = _dequeue(self, index);\n\n    // send ETH\n    (bool sent, ) = payable(receiver).call{value: claimableETH}(\"\");\n    require(sent, \"WML:Failed to send Ether\");\n  }\n\n  /**\n   * @notice dequeue() with batch optimizations\n   */\n  function dequeueBatch(\n    WithdrawalModuleStorage storage self,\n    uint256[] calldata indexes,\n    address receiver\n  ) external {\n    require(receiver != address(0), \"WML:receiver cannot be zero address\");\n\n    _fulfillBatch(\n      self,\n      indexes,\n      self.queue.realized,\n      self.queue.fulfilled,\n      self.queue.realizedPrice\n    );\n\n    uint256 claimableETH;\n    uint256 indexesLen = indexes.length;\n    for (uint256 i; i < indexesLen; ) {\n      claimableETH += _dequeue(self, indexes[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n\n    // send ETH\n    (bool sent, ) = payable(receiver).call{value: claimableETH}(\"\");\n    require(sent, \"WML:Failed to send Ether\");\n  }\n\n  /**\n   * @custom:section                           ** PROCESS BALANCES MERKLE UPDATE **\n   */\n\n  /**\n   * @custom:visibility -> internal\n   */\n  /**\n   * @notice\n   * @param pubkey public key of the given validator.\n   * @param reportedWithdrawn withdrawn Ether amount according to the fresh Merkle root.\n   * @param processedWithdrawn previously reported withdrawn amount.\n   * @dev cannot overflow since max fee is 10%, if we change fee structure ever, we need to reconsider the math there! \n   * * Note that if a validator is EXITED, we would assume 32 ETH that the pool put is also accounted for.\n   @return extra calculated profit since the last time validator was processed\n   */\n  function _distributeFees(\n    WithdrawalModuleStorage storage self,\n    Validator memory val,\n    uint256 reportedWithdrawn,\n    uint256 processedWithdrawn\n  ) internal returns (uint256 extra) {\n    // reportedWithdrawn > processedWithdrawn checks are done as it should be before calling this function\n    uint256 profit = reportedWithdrawn - processedWithdrawn;\n\n    uint256 poolProfit = (profit * val.poolFee) / PERCENTAGE_DENOMINATOR;\n    uint256 operatorProfit = (profit * val.operatorFee) / PERCENTAGE_DENOMINATOR;\n    uint256 infrastructureProfit = (profit * val.infrastructureFee) / PERCENTAGE_DENOMINATOR;\n\n    _getPortal(self).increaseWalletBalance{value: poolProfit}(val.poolId);\n    _getPortal(self).increaseWalletBalance{value: operatorProfit}(val.operatorId);\n    self.gatheredInfrastructureFees += infrastructureProfit;\n\n    extra = ((profit - poolProfit) - operatorProfit) - infrastructureProfit;\n  }\n\n  /**\n   * @notice acting like queue is one entity, we sell it some gETH in respect to Oracle price.\n   * * by using the Ether from the latest withdrawals.\n   */\n  function _realizeProcessedEther(\n    WithdrawalModuleStorage storage self,\n    uint256 processedBalance\n  ) internal {\n    uint256 pps = self.gETH.pricePerShare(self.POOL_ID);\n\n    uint256 processedgETH = ((processedBalance * gETH_DENOMINATOR) / pps);\n    uint256 newPrice = pps;\n\n    uint256 internalPrice = self.queue.realizedPrice;\n    if (internalPrice > 0) {\n      uint256 claimable = self.queue.realized - self.queue.fulfilled;\n      if (claimable > 0) {\n        newPrice =\n          ((claimable * internalPrice) + (processedBalance * gETH_DENOMINATOR)) /\n          (claimable + processedgETH);\n      }\n    }\n\n    self.queue.realized += processedgETH;\n    self.queue.realizedEtherBalance += processedBalance;\n    self.queue.realizedPrice = newPrice;\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  /**\n   * @notice main function of this library, processing given information about the provided validators.\n   * @dev not all validators need to be processed all the time, process them as you need.\n   * @dev We do not check if validators should be processed at all.\n   * Because its up to user if they want to pay extra for unnecessary operations.\n   * We should not be charging others extra to save their gas.\n   * @dev It is advised to sort the pks according to the time passed, or remaining, to ensure that\n   * the preferred validators are prioritized in a case\n   * when the subset of given validators are not called for an exit.\n   */\n  function processValidators(\n    WithdrawalModuleStorage storage self,\n    bytes[] calldata pubkeys,\n    uint256[] calldata beaconBalances,\n    uint256[] calldata withdrawnBalances,\n    bytes32[][] calldata balanceProofs\n  ) external {\n    uint256 pkLen = pubkeys.length;\n    require(\n      pkLen == beaconBalances.length &&\n        pkLen == withdrawnBalances.length &&\n        pkLen == balanceProofs.length,\n      \"WML:invalid lengths\"\n    );\n\n    Validator[] memory validators = new Validator[](pkLen);\n\n    {\n      bytes32 balanceMerkleRoot = _getPortal(self).getBalancesMerkleRoot();\n      for (uint256 i; i < pkLen; ) {\n        // fill the validators array while checking the pool id\n        validators[i] = _getPortal(self).getValidator(pubkeys[i]);\n\n        // check pubkey belong to this pool\n        require(validators[i].poolId == self.POOL_ID, \"WML:validator for an unknown pool\");\n\n        // verify balances\n        bytes32 leaf = keccak256(\n          bytes.concat(keccak256(abi.encode(pubkeys[i], beaconBalances[i], withdrawnBalances[i])))\n        );\n        require(\n          MerkleProof.verify(balanceProofs[i], balanceMerkleRoot, leaf),\n          \"WML:not all proofs are valid\"\n        );\n\n        unchecked {\n          i += 1;\n        }\n      }\n    }\n\n    uint256 commonPoll = self.queue.commonPoll;\n    uint256 processed;\n    for (uint256 j; j < pkLen; ) {\n      uint256 oldWitBal = self.validators[pubkeys[j]].withdrawnBalance;\n\n      self.validators[pubkeys[j]].beaconBalance = beaconBalances[j];\n      self.validators[pubkeys[j]].withdrawnBalance = withdrawnBalances[j];\n\n      if (beaconBalances[j] == 0) {\n        // exit\n        if (withdrawnBalances[j] > oldWitBal + DCL.DEPOSIT_AMOUNT) {\n          processed += _distributeFees(\n            self,\n            validators[j],\n            withdrawnBalances[j],\n            oldWitBal + DCL.DEPOSIT_AMOUNT\n          );\n          processed += DCL.DEPOSIT_AMOUNT;\n        } else if (withdrawnBalances[j] >= oldWitBal) {\n          processed += withdrawnBalances[j] - oldWitBal;\n        } else {\n          revert(\"WML:invalid withdrawn balance\");\n        }\n        _finalizeExit(self, pubkeys[j]);\n      } else {\n        // check if should request exit\n        if (withdrawnBalances[j] > oldWitBal) {\n          processed += _distributeFees(self, validators[j], withdrawnBalances[j], oldWitBal);\n        }\n        commonPoll = _checkAndRequestExit(self, pubkeys[j], commonPoll);\n      }\n\n      unchecked {\n        j += 1;\n      }\n    }\n    self.queue.commonPoll = commonPoll;\n\n    if (processed > 0) {\n      _realizeProcessedEther(self, processed);\n    }\n\n    emit Processed();\n  }\n}\n"
    },
    "contracts/modules/WithdrawalModule/structs/storage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// internal - interfaces\nimport {IgETH} from \"../../../interfaces/IgETH.sol\";\n// internal - structs\nimport {Queue, Request, ValidatorData} from \"./utils.sol\";\n\n/**\n * @notice Storage struct for the Withdrawal Contract enabling the Queued Withdrawal Requests with instant run-off validator exit elections\n * @param gETH constant, ERC1155, all Geode Staking Derivatives.\n * @param PORTAL constant, address of the PORTAL.\n * @param POOL_ID constant, ID of the pool, also the token ID of represented gETH.\n * @param EXIT_THRESHOLD variable, current exit threshold that is set by the owner.\n * @param queue main variables related to Enqueue-Dequeue operations.\n * @param requests an array of requests\n * @param validators as pubkey being the key, the related data for the validators of the given pool. Updated on processValidators.\n *\n * @dev normally we would put custom:storage-location erc7201:geode.storage.StakeModule\n * but compiler throws an error... So np for now, just effects dev ex.\n **/\nstruct WithdrawalModuleStorage {\n  IgETH gETH;\n  address PORTAL;\n  uint256 POOL_ID;\n  uint256 EXIT_THRESHOLD;\n  uint256 gatheredInfrastructureFees;\n  Queue queue;\n  Request[] requests;\n  mapping(bytes => ValidatorData) validators;\n}\n"
    },
    "contracts/modules/WithdrawalModule/structs/utils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n/**\n * @param beaconBalance  Beacon Chain balance of the validator (current).\n * @param withdrawnBalance  Representing any Ether sent from Beacon Chain to a withdrawal contract (cumulative).\n * @param poll size of the requests that specifically voted for given validator to exit. as in gETH.\n **/\nstruct ValidatorData {\n  uint256 beaconBalance;\n  uint256 withdrawnBalance;\n  uint256 poll;\n}\n\n/**\n * @param owner the address that can dequeue the request. Ownership can be transferred.\n * @param trigger cumulative sum of the previous requests, as in gETH.\n * @param size size of the withdrawal request, as in gETH.\n * @param fulfilled part of the 'size' that became available after being processed relative to the 'realizedPrice'. as in gETH.\n * @param claimableEther current ETH amount that can be claimed by the Owner, increased in respect to 'fulfilled' and 'realizedPrice', decreased with dequeue.\n **/\nstruct Request {\n  address owner;\n  uint256 trigger;\n  uint256 size;\n  uint256 fulfilled;\n  uint256 claimableEther;\n}\n\n/**\n * @param requested cumulative size of all requests, as in gETH.\n * ex: --- ------ ------ - - --- : 20 : there are 6 requests totaling up to 20 gETH.\n * @param realized cumulative size of gETH that is processed and can be used to fulfill Requests, as in gETH\n * ex: ----- -- -- - ----- --    : 17 : there are 17 gETH, processed as a response to the withdrawn funds.\n * @param fulfilled cumulative size of the fulfilled requests, claimed or claimable, as in gETH\n * ex: --- ----xx ------ x - ooo : 14 : there are 15 gETH being used to fulfill requests,including one that is partially filled. 3 gETH is still claimable.\n * @param realizedEtherBalance cumulative size of the withdrawn and realized balances. Note that, (realizedEtherBalance * realizedPrice != realized) as price changes constantly.\n * @param fulfilledEtherBalance cumulative size of the fulfilled requests.\n * @param realizedPrice current Price of the queue, used when fulfilling a Request, updated with processValidators.\n * @param commonPoll current size of requests that did not vote on any specific validator, as in gETH.\n **/\nstruct Queue {\n  uint256 requested;\n  uint256 realized;\n  uint256 realizedEtherBalance;\n  uint256 realizedPrice;\n  uint256 fulfilled;\n  uint256 fulfilledEtherBalance;\n  uint256 commonPoll;\n}\n"
    },
    "contracts/modules/WithdrawalModule/WithdrawalModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n// external - libraries\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n// external - contracts\nimport {ERC1155HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n// internal - interfaces\nimport {IgETH} from \"../../interfaces/IgETH.sol\";\nimport {IPortal} from \"../../interfaces/IPortal.sol\";\nimport {IWithdrawalModule} from \"../../interfaces/modules/IWithdrawalModule.sol\";\n// internal - structs\nimport {WithdrawalModuleStorage} from \"./structs/storage.sol\";\n// internal - libraries\nimport {WithdrawalModuleLib as WML} from \"./libs/WithdrawalModuleLib.sol\";\n\n/**\n * @title WM: Withdrawal Module\n *\n * @notice Withdrawal Queue and voluntary exit elections.\n * * Processing the withdrawals\n * * Distributing the fees\n * * Queueing withdrawal requests\n * * Allowing (Instant Run-off) elections on which validators to exit.\n * @dev all done while preserving the validator segregation.\n *\n * @dev There is 1 additional functionality implemented apart from the library:\n * * if the price is not valid, user must prove it before processing validators.\n *\n * @dev review: this module delegates its functionality to WML (WithdrawalModuleLib).\n *\n * @dev 4 functions need to be overriden with access control when inherited:\n * * pause, unpause, setExitThreshold, claimInfrastructureFees\n *\n * @dev __WithdrawalModule_init (or _unchained) call is NECESSARY when inherited.\n *\n * note This module does not implement necessary admin checks; or pausability overrides.\n * * If a package inherits WM, should implement it's own logic around those.\n *\n * @author Ice Bear & Crash Bandicoot\n */\nabstract contract WithdrawalModule is\n  IWithdrawalModule,\n  ERC1155HolderUpgradeable,\n  ReentrancyGuardUpgradeable,\n  PausableUpgradeable\n{\n  using WML for WithdrawalModuleStorage;\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Do not add any other variables here. Modules do not have a gap.\n   * Library's main struct has a gap, providing up to 16 storage slots for this module.\n   */\n  // keccak256(abi.encode(uint256(keccak256(\"geode.storage.WithdrawalModuleStorage\")) - 1)) & ~bytes32(uint256(0xff))\n  bytes32 private constant WithdrawalModuleStorageLocation =\n    0x50605cc6f5170f0cdbb610edd2214831ea96f61cd1eba92cf58939f65736af00;\n\n  function _getWithdrawalModuleStorage() internal pure returns (WithdrawalModuleStorage storage $) {\n    assembly {\n      $.slot := WithdrawalModuleStorageLocation\n    }\n  }\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event NewExitThreshold(uint256 threshold);\n  event Enqueue(uint256 indexed index, address owner);\n  event Vote(uint256 indexed index, bytes indexed pubkey, uint256 size);\n  event RequestTransfer(uint256 indexed index, address oldOwner, address newOwner);\n  event Fulfill(uint256 indexed index, uint256 fulfillAmount, uint256 claimableETH);\n  event Dequeue(uint256 indexed index, uint256 claim);\n  event Processed();\n\n  /**\n\n  /**\n   * @custom:section                           ** ABSTRACT FUNCTIONS **\n   *\n   * @dev these functions MUST be overriden for admin functionality.\n   */\n\n  function pause() external virtual override;\n\n  function unpause() external virtual override;\n\n  function setExitThreshold(uint256 newThreshold) external virtual override;\n\n  function claimInfrastructureFees(\n    address receiver\n  ) external virtual override returns (bool success);\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n  function __WithdrawalModule_init(\n    address _gETH_position,\n    address _portal_position,\n    uint256 _poolId\n  ) internal onlyInitializing {\n    __ReentrancyGuard_init();\n    __Pausable_init();\n    __ERC1155Holder_init();\n    __WithdrawalModule_init_unchained(_gETH_position, _portal_position, _poolId);\n  }\n\n  function __WithdrawalModule_init_unchained(\n    address _gETH_position,\n    address _portal_position,\n    uint256 _poolId\n  ) internal onlyInitializing {\n    require(_gETH_position != address(0), \"WM:gETH cannot be zero address\");\n    require(_portal_position != address(0), \"WM:portal cannot be zero address\");\n\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.gETH = IgETH(_gETH_position);\n    $.PORTAL = _portal_position;\n    $.POOL_ID = _poolId;\n    $.EXIT_THRESHOLD = WML.MIN_EXIT_THRESHOLD;\n\n    $.gETH.avoidMiddlewares(_poolId, true);\n  }\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n  function WithdrawalParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      address gETH,\n      address portal,\n      uint256 poolId,\n      uint256 exitThreshold,\n      uint256 gatheredInfrastructureFees\n    )\n  {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    gETH = address($.gETH);\n    portal = $.PORTAL;\n    poolId = $.POOL_ID;\n    exitThreshold = $.EXIT_THRESHOLD;\n    gatheredInfrastructureFees = $.gatheredInfrastructureFees;\n  }\n\n  function QueueParams()\n    external\n    view\n    virtual\n    override\n    returns (\n      uint256 requested,\n      uint256 realized,\n      uint256 realizedEtherBalance,\n      uint256 realizedPrice,\n      uint256 fulfilled,\n      uint256 fulfilledEtherBalance,\n      uint256 commonPoll\n    )\n  {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    requested = $.queue.requested;\n    realized = $.queue.realized;\n    realizedEtherBalance = $.queue.realizedEtherBalance;\n    realizedPrice = $.queue.realizedPrice;\n    fulfilled = $.queue.fulfilled;\n    fulfilledEtherBalance = $.queue.fulfilledEtherBalance;\n    commonPoll = $.queue.commonPoll;\n  }\n\n  function getRequest(\n    uint256 index\n  )\n    external\n    view\n    virtual\n    override\n    returns (\n      address owner,\n      uint256 trigger,\n      uint256 size,\n      uint256 fulfilled,\n      uint256 claimableEther\n    )\n  {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    owner = $.requests[index].owner;\n    trigger = $.requests[index].trigger;\n    size = $.requests[index].size;\n    fulfilled = $.requests[index].fulfilled;\n    claimableEther = $.requests[index].claimableEther;\n  }\n\n  function getValidatorData(\n    bytes calldata pubkey\n  )\n    external\n    view\n    virtual\n    override\n    returns (uint256 beaconBalance, uint256 withdrawnBalance, uint256 poll)\n  {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    beaconBalance = $.validators[pubkey].beaconBalance;\n    withdrawnBalance = $.validators[pubkey].withdrawnBalance;\n    poll = $.validators[pubkey].poll;\n  }\n\n  /**\n   * @custom:section                           ** EARLY EXIT **\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n  function canFinalizeExit(bytes calldata pubkey) external view virtual override returns (bool) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    return $.canFinalizeExit(pubkey);\n  }\n\n  function validatorThreshold(\n    bytes calldata pubkey\n  ) external view virtual override returns (uint256 threshold) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    (threshold, ) = $.getValidatorThreshold(pubkey);\n  }\n\n  /**\n   * @custom:section                           ** REQUESTS QUEUE **\n   */\n  /**\n   * @custom:subsection                        ** ENQUEUE **\n   *\n   * @custom:visibility -> external\n   */\n\n  function enqueue(\n    uint256 size,\n    bytes calldata pubkey,\n    address owner\n  ) external virtual override returns (uint256 index) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    index = $.enqueue(size, pubkey, owner);\n  }\n\n  function enqueueBatch(\n    uint256[] calldata sizes,\n    bytes[] calldata pubkeys,\n    address owner\n  ) external virtual override returns (uint256[] memory indexes) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    indexes = $.enqueueBatch(sizes, pubkeys, owner);\n  }\n\n  function transferRequest(uint256 index, address newOwner) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.transferRequest(index, newOwner);\n  }\n\n  /**\n   * @custom:subsection                        ** FULFILL **\n   */\n\n  /**\n   * @custom:visibility -> view\n   */\n\n  function fulfillable(uint256 index) external view virtual override returns (uint256) {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    return $.fulfillable(index, $.queue.realized, $.queue.fulfilled);\n  }\n\n  /**\n   * @custom:visibility -> external\n   */\n  function fulfill(uint256 index) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.fulfill(index);\n  }\n\n  function fulfillBatch(uint256[] calldata indexes) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.fulfillBatch(indexes);\n  }\n\n  /**\n   * @custom:subsection                        ** DEQUEUE **\n   */\n  /**\n   * @custom:visibility -> external\n   */\n  function dequeue(uint256 index, address receiver) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.dequeue(index, receiver);\n  }\n\n  function dequeueBatch(uint256[] calldata indexes, address receiver) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.dequeueBatch(indexes, receiver);\n  }\n\n  /**\n   * @custom:section                           ** PROCESS BALANCES MERKLE UPDATE **\n   */\n  function processValidators(\n    bytes[] calldata pubkeys,\n    uint256[] calldata beaconBalances,\n    uint256[] calldata withdrawnBalances,\n    bytes32[][] calldata balanceProofs,\n    uint256 price,\n    bytes32[] calldata priceProof\n  ) external virtual override {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    if (!IPortal($.PORTAL).isPriceValid($.POOL_ID)) {\n      IPortal($.PORTAL).priceSync($.POOL_ID, price, priceProof);\n    }\n    $.processValidators(pubkeys, beaconBalances, withdrawnBalances, balanceProofs);\n  }\n\n  /**\n   * @custom:section                           ** MULTICALL **\n   */\n\n  /**\n   * @dev Receives and executes a batch of function calls on this contract.\n   * @dev This is necessary for the multistep operations done in this contract:\n   * * Enqueue, Process, Fulfill, Dequeue.\n   * @dev Using 'functionDelegateCall' so it does not cause any issues when using msg.sender etc.\n   * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n   */\n  function multicall(\n    bytes[] calldata data\n  ) external virtual override returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i; i < data.length; ) {\n      results[i] = Address.functionDelegateCall(address(this), data[i]);\n\n      unchecked {\n        i += 1;\n      }\n    }\n    return results;\n  }\n}\n"
    },
    "contracts/packages/LiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// internal - globals\nimport {ID_TYPE} from \"../globals/id_type.sol\";\nimport {PERCENTAGE_DENOMINATOR} from \"../globals/macros.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../globals/reserved_key_space.sol\";\n// internal - interfaces\nimport {IGeodeModule} from \"../interfaces/modules/IGeodeModule.sol\";\nimport {ILiquidityModule} from \"../interfaces/modules/ILiquidityModule.sol\";\nimport {ILiquidityPool} from \"../interfaces/packages/ILiquidityPool.sol\";\nimport {IPortal} from \"../interfaces/IPortal.sol\";\n// internal - structs\nimport {GeodeModuleStorage} from \"../modules/GeodeModule/structs/storage.sol\";\nimport {LiquidityModuleStorage} from \"../modules/LiquidityModule/structs/storage.sol\";\n// internal - libraries\nimport {GeodeModuleLib as GML} from \"../modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport {AmplificationLib as AL} from \"../modules/LiquidityModule/libs/AmplificationLib.sol\";\nimport {LiquidityModuleLib as LML} from \"../modules/LiquidityModule/libs/LiquidityModuleLib.sol\";\n// internal - contracts\nimport {GeodeModule} from \"../modules/GeodeModule/GeodeModule.sol\";\nimport {LiquidityModule} from \"../modules/LiquidityModule/LiquidityModule.sol\";\n\n/**\n * @title LPP: Liquidity Pool Package: Geode Module + Liquidity Module\n *\n * @notice LPP is a package that provides a liquidity pool for a staking pool created through Portal.\n *\n * @dev TYPE: PACKAGE_LIQUIDITY_POOL\n * @dev Utilizing IGeodePackage interface, meaning initialize function takes 3 parameters:\n * * * poolOwner: will be assigned as the senate of the package\n * * * pooledTokenId: used internally on LM and LML.\n * * * data: referances 1 parameter: name. Used to generate lpTokenName and lpTokenSymbol for __LM_init.\n *\n * @dev review: LM for StableSwap implementation. Also note:\n * * initial and future A coefficients are set as 60 (LM)\n * * trade fee set to 4 bips (LM)\n * * owner fee is set to 0 (LM)\n * * senate expiry is not effective (GM)\n *\n * @dev review: GM for The Limited Upgradability through Dual Governance:\n * * Governance is the Portal, package version controller.\n * * Senate is the Staking Pool Owner.\n *\n * @author Ice Bear & Crash Bandicoot\n */\ncontract LiquidityPool is ILiquidityPool, GeodeModule, LiquidityModule {\n  using GML for GeodeModuleStorage;\n  using AL for LiquidityModuleStorage;\n  using LML for LiquidityModuleStorage;\n\n  /**\n   * @custom:section                           ** VARIABLES **\n   *\n   * @dev Following immutable parameters are set when the referance library implementation is deployed.\n   * It is not desired to provide these package-specific not-changing parameters\n   * accross all instances of the packages.\n   * So, we will store them in the ref implementation contract of the package,\n   * and fetch when needed on initialization of an instance.\n   */\n  /// @notice gETH position\n  address internal immutable gETHPos;\n  /// @notice Portal position\n  address internal immutable portalPos;\n  /// @notice LPToken implementation referance, needs to be cloned\n  address internal immutable LPTokenRef;\n  /// @notice LPP package type, useful for Limited Upgradability\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n\n  modifier onlyOwner() {\n    require(msg.sender == _getGeodeModuleStorage().SENATE, \"LPP:sender not owner\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  /**\n   * @custom:oz-upgrades-unsafe-allow constructor\n   */\n  constructor(address _gETHPos, address _portalPos, address _LPTokenRef) {\n    require(_gETHPos != address(0), \"LPP:_gETHPos cannot be zero\");\n    require(_portalPos != address(0), \"LPP:_portalPos cannot be zero\");\n    require(_LPTokenRef != address(0), \"LPP:_LPTokenRef cannot be zero\");\n\n    gETHPos = _gETHPos;\n    portalPos = _portalPos;\n    LPTokenRef = _LPTokenRef;\n\n    _disableInitializers();\n  }\n\n  /**\n   * @param data only poolName is required from Portal\n   */\n  function initialize(\n    uint256 pooledTokenId,\n    address poolOwner,\n    bytes calldata versionName,\n    bytes calldata data\n  ) public virtual override initializer {\n    __LiquidityPool_init(pooledTokenId, poolOwner, versionName, data);\n  }\n\n  function __LiquidityPool_init(\n    uint256 pooledTokenId,\n    address poolOwner,\n    bytes calldata versionName,\n    bytes calldata data\n  ) internal onlyInitializing {\n    __GeodeModule_init(\n      portalPos,\n      poolOwner,\n      type(uint256).max,\n      ID_TYPE.PACKAGE_LIQUIDITY_POOL,\n      versionName\n    );\n    __LiquidityModule_init(\n      gETHPos,\n      LPTokenRef,\n      pooledTokenId,\n      60,\n      (4 * PERCENTAGE_DENOMINATOR) / 10000,\n      string(data)\n    );\n    __LiquidityPool_init_unchained();\n  }\n\n  function __LiquidityPool_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-public\n   */\n\n  /**\n   * @notice get the gETH ID of the corresponding staking pool\n   */\n  function getPoolId() public view override returns (uint256) {\n    return _getLiquidityModuleStorage().pooledTokenId;\n  }\n\n  /**\n   * @dev GeodeModule override\n   */\n  function getProposedVersion() public view virtual override returns (uint256) {\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n    return IPortal(GMStorage.GOVERNANCE).getPackageVersion(GMStorage.PACKAGE_TYPE);\n  }\n\n  /**\n   * @dev GeodeModule override\n   *\n   * @custom:visibility -> view\n   */\n  function isolationMode()\n    external\n    view\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (bool)\n  {\n    if (paused()) {\n      return true;\n    }\n\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n\n    if (\n      GMStorage.CONTRACT_VERSION !=\n      IPortal(GMStorage.GOVERNANCE).getPackageVersion(GMStorage.PACKAGE_TYPE)\n    ) {\n      return true;\n    }\n\n    if (GMStorage.APPROVED_UPGRADE != ERC1967Utils.getImplementation()) {\n      return true;\n    }\n\n    if (\n      IPortal(GMStorage.GOVERNANCE).readAddress(getPoolId(), rks.CONTROLLER) != GMStorage.SENATE\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @custom:section                           ** ADMIN FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @custom:subsection                           ** UPGRADABILITY FUNCTIONS **\n   */\n\n  /**\n   * @dev IGeodePackage override\n   */\n  function pullUpgrade() external virtual override onlyOwner {\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n    IPortal Portal = IPortal(GMStorage.GOVERNANCE);\n\n    require(!Portal.isolationMode(), \"LPP:Portal is isolated\");\n    require(\n      GMStorage.CONTRACT_VERSION != Portal.getPackageVersion(GMStorage.PACKAGE_TYPE),\n      \"LPP:no upgrades\"\n    );\n\n    uint256 id = Portal.pushUpgrade(GMStorage.PACKAGE_TYPE);\n    approveProposal(id);\n  }\n\n  /**\n   * @custom:subsection                           ** PAUSABILITY FUNCTIONS **\n   */\n\n  /**\n   * @notice pausing the contract activates the isolationMode\n   */\n  function pause() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice unpausing the contract deactivates the isolationMode\n   */\n  function unpause() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @custom:subsection                           ** LIQUIDITY POOL **\n   *\n   * @dev LM override\n   */\n\n  function setSwapFee(\n    uint256 newSwapFee\n  ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _getLiquidityModuleStorage().setSwapFee(newSwapFee);\n  }\n\n  function setAdminFee(\n    uint256 newAdminFee\n  ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _getLiquidityModuleStorage().setAdminFee(newAdminFee);\n  }\n\n  function withdrawAdminFees(\n    address receiver\n  ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _getLiquidityModuleStorage().withdrawAdminFees(receiver);\n  }\n\n  function rampA(\n    uint256 futureA,\n    uint256 futureTime\n  ) public virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _getLiquidityModuleStorage().rampA(futureA, futureTime);\n  }\n\n  function stopRampA() external virtual override(LiquidityModule, ILiquidityModule) onlyOwner {\n    _getLiquidityModuleStorage().stopRampA();\n  }\n\n  /**\n   * @notice fallback functions: receive\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/packages/WithdrawalContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// internal - globals\nimport {ID_TYPE} from \"../globals/id_type.sol\";\nimport {RESERVED_KEY_SPACE as rks} from \"../globals/reserved_key_space.sol\";\n// internal - interfaces\nimport {IGeodeModule} from \"../interfaces/modules/IGeodeModule.sol\";\nimport {IWithdrawalModule} from \"../interfaces/modules/IWithdrawalModule.sol\";\nimport {IWithdrawalContract} from \"../interfaces/packages/IWithdrawalContract.sol\";\nimport {IPortal} from \"../interfaces/IPortal.sol\";\n// internal - structs\nimport {GeodeModuleStorage} from \"../modules/GeodeModule/structs/storage.sol\";\nimport {WithdrawalModuleStorage} from \"../modules/WithdrawalModule/structs/storage.sol\";\n// internal - libraries\nimport {WithdrawalModuleLib as WML} from \"../modules/WithdrawalModule/libs/WithdrawalModuleLib.sol\";\n// internal - contracts\nimport {GeodeModule} from \"../modules/GeodeModule/GeodeModule.sol\";\nimport {WithdrawalModule} from \"../modules/WithdrawalModule/WithdrawalModule.sol\";\n\ncontract WithdrawalContract is IWithdrawalContract, GeodeModule, WithdrawalModule {\n  using WML for WithdrawalModuleStorage;\n  /**\n   * @custom:section                           ** VARIABLES **\n   * Following immutable parameters are set when the referance library implementation is deployed.\n   * Making necessary data for initialization reachable for all instances of LP package.\n   */\n  /// @notice gETH position\n  address internal immutable gETHPos;\n  /// @notice Portal position\n  address internal immutable portalPos;\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n\n  modifier onlyOwner() {\n    require(msg.sender == _getGeodeModuleStorage().SENATE, \"WCP:sender not owner\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n  /**\n   * @custom:oz-upgrades-unsafe-allow constructor\n   *\n   * @dev we don't want to provide these package-specific not-changing parameters\n   * accross all instances of the packages.\n   * So we will store them in the ref implementation contract of the package,\n   * and fetch when needed on initialization.\n   */\n  constructor(address _gETHPos, address _portalPos) {\n    require(_gETHPos != address(0), \"WCP:_gETHPos cannot be zero\");\n    require(_portalPos != address(0), \"WCP:_portalPos cannot be zero\");\n\n    gETHPos = _gETHPos;\n    portalPos = _portalPos;\n\n    _disableInitializers();\n  }\n\n  /**\n   * @dev While 'data' parameter is not currently used it is a standarized approach on all\n   * * GeodePackages have the same function signature on 'initialize'.\n   */\n  function initialize(\n    uint256 poolId,\n    address poolOwner,\n    bytes calldata versionName,\n    bytes calldata data\n  ) public virtual override initializer {\n    __WithdrawalContract_init(poolId, poolOwner, versionName);\n  }\n\n  function __WithdrawalContract_init(\n    uint256 poolId,\n    address poolOwner,\n    bytes calldata versionName\n  ) internal onlyInitializing {\n    __GeodeModule_init(\n      portalPos,\n      poolOwner,\n      type(uint256).max,\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\n      versionName\n    );\n    __WithdrawalModule_init(gETHPos, portalPos, poolId);\n    __WithdrawalContract_init_unchained();\n  }\n\n  function __WithdrawalContract_init_unchained() internal onlyInitializing {}\n\n  function getPoolId() public view override returns (uint256) {\n    return _getWithdrawalModuleStorage().POOL_ID;\n  }\n\n  /**\n   * @dev GeodeModule override\n   */\n  function getProposedVersion() public view virtual override returns (uint256) {\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n\n    return IPortal(GMStorage.GOVERNANCE).getPackageVersion(GMStorage.PACKAGE_TYPE);\n  }\n\n  /**\n   * @dev GeodeModule override\n   */\n  function isolationMode()\n    external\n    view\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (bool)\n  {\n    if (paused()) {\n      return true;\n    }\n\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n\n    if (\n      GMStorage.CONTRACT_VERSION !=\n      IPortal(GMStorage.GOVERNANCE).getPackageVersion(GMStorage.PACKAGE_TYPE)\n    ) {\n      return true;\n    }\n\n    if (GMStorage.APPROVED_UPGRADE != ERC1967Utils.getImplementation()) {\n      return true;\n    }\n\n    if (\n      IPortal(GMStorage.GOVERNANCE).readAddress(getPoolId(), rks.CONTROLLER) != GMStorage.SENATE\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @custom:section                           ** ADMIN FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @custom:subsection                           ** UPGRADABILITY FUNCTIONS **\n   */\n\n  /**\n   * @dev IGeodePackage override\n   */\n  function pullUpgrade() external virtual override onlyOwner {\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n    IPortal Portal = IPortal(GMStorage.GOVERNANCE);\n\n    require(!Portal.isolationMode(), \"WCP:Portal is isolated\");\n    require(\n      GMStorage.CONTRACT_VERSION != Portal.getPackageVersion(GMStorage.PACKAGE_TYPE),\n      \"WCP:no upgrades\"\n    );\n\n    uint256 id = Portal.pushUpgrade(GMStorage.PACKAGE_TYPE);\n    approveProposal(id);\n  }\n\n  /**\n   * @custom:subsection                           ** PAUSABILITY FUNCTIONS **\n   */\n\n  /**\n   * @notice pausing the contract activates the isolationMode\n   */\n  function pause() external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice unpausing the contract deactivates the isolationMode\n   */\n  function unpause() external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @custom:subsection                           ** WITHDRAWAL QUEUE **\n   *\n   * @dev WM override\n   */\n  function setExitThreshold(\n    uint256 newThreshold\n  ) external virtual override(WithdrawalModule, IWithdrawalModule) onlyOwner {\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    $.setExitThreshold(newThreshold);\n  }\n\n  /**\n   * @custom:subsection                           ** INFRASTRUCTURE FEE **\n   *\n   * @dev WM override\n   */\n  function claimInfrastructureFees(\n    address receiver\n  ) external virtual override(WithdrawalModule, IWithdrawalModule) returns (bool success) {\n    require(msg.sender == IPortal(_getGeodeModuleStorage().GOVERNANCE).getGovernance());\n\n    WithdrawalModuleStorage storage $ = _getWithdrawalModuleStorage();\n    uint256 claimable = $.gatheredInfrastructureFees;\n\n    (success, ) = payable(receiver).call{value: claimable}(\"\");\n    require(success, \"WCP:Failed to send ETH\");\n  }\n\n  /**\n   * @notice fallback functions: receive\n   */\n\n  receive() external payable {}\n}\n"
    },
    "contracts/Portal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\n//   ██████╗ ███████╗ ██████╗ ██████╗ ███████╗    ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗\n//  ██╔════╝ ██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║\n//  ██║  ███╗█████╗  ██║   ██║██║  ██║█████╗      ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║\n//  ██║   ██║██╔══╝  ██║   ██║██║  ██║██╔══╝      ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║\n//  ╚██████╔╝███████╗╚██████╔╝██████╔╝███████╗    ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║███████╗\n//   ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚══════╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚══════╝\n//\n\n// external - library\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\n// internal - globals\nimport {ID_TYPE} from \"./globals/id_type.sol\";\n// internal - interfaces\nimport {IGeodeModule} from \"./interfaces/modules/IGeodeModule.sol\";\nimport {IStakeModule} from \"./interfaces/modules/IStakeModule.sol\";\nimport {IPortal} from \"./interfaces/IPortal.sol\";\n// internal - structs\nimport {DataStoreModuleStorage} from \"./modules/DataStoreModule/structs/storage.sol\";\nimport {GeodeModuleStorage} from \"./modules/GeodeModule/structs/storage.sol\";\nimport {StakeModuleStorage} from \"./modules/StakeModule/structs/storage.sol\";\n// internal - libraries\nimport {DataStoreModuleLib as DSML} from \"./modules/DataStoreModule/libs/DataStoreModuleLib.sol\";\nimport {GeodeModuleLib as GML} from \"./modules/GeodeModule/libs/GeodeModuleLib.sol\";\nimport {StakeModuleLib as SML} from \"./modules/StakeModule/libs/StakeModuleLib.sol\";\nimport {InitiatorExtensionLib as IEL} from \"./modules/StakeModule/libs/InitiatorExtensionLib.sol\";\n// internal - contracts\nimport {GeodeModule} from \"./modules/GeodeModule/GeodeModule.sol\";\nimport {StakeModule} from \"./modules/StakeModule/StakeModule.sol\";\n\n/**\n * @title Geode Portal: Geode Module + Stake Module\n *\n * @notice Global standard for staking with on chain delegation and customizable staking pools.\n * Management of the state of the protocol governance through dual governance and proposals.\n * Version management and distribution of packages used by the staking pools.\n *\n * @dev TYPE: PACKAGE_PORTAL\n * @dev Portal is a special package that is deployed once. Does not utilize IGeodePackage interface.\n *\n * @dev review: GM for The Limited Upgradability through Dual Governance:\n * * Governance is a governance token.\n * * Senate is a multisig, planned to be a contract that allows pool CONTROLLERs to maintain power.\n * * Senate expiry is effective.\n *\n * @dev review: SM for Staking logic.\n *\n * @dev There are 2 functionalities that are implemented here:\n * * Special Governance functions for Portal:\n * * * Pausing gETH, pausing Portal, releasing prisoned operators,and seting a governance fee.\n * * Push end of the version management logic via pull->push.\n * * * approveProposal changes the package version or allows specified middleware.\n * * * pushUpgrade creates a package type proposal on the package to upgrade the contract, and requires package owner to approve it.\n *\n * @dev authentication:\n * * GeodeModule has OnlyGovernance, OnlySenate and OnlyController checks with modifiers.\n * * StakeModuleLib has \"authenticate()\" function which checks for Maintainers, Controllers, and TYPE.\n * * OracleModuleLib has OnlyOracle checks with a modifier.\n * * Portal has OnlyGovernance checks on : pause, unpause, pausegETH, unpausegETH, setInfrastructureFee, setBeaconDelays, setInitiationDeposit, releasePrisoned.\n *\n * @author Ice Bear & Crash Bandicoot\n */\ncontract Portal is IPortal, GeodeModule, StakeModule {\n  using DSML for DataStoreModuleStorage;\n  using GML for GeodeModuleStorage;\n  using SML for StakeModuleStorage;\n  using IEL for StakeModuleStorage;\n\n  /**\n   * @custom:section                           ** EVENTS **\n   */\n  event Released(uint256 operatorId);\n\n  /**\n   * @custom:section                           ** MODIFIERS **\n   */\n  modifier onlyGovernance() {\n    require(msg.sender == _getGeodeModuleStorage().GOVERNANCE, \"PORTAL:sender not governance\");\n    _;\n  }\n\n  /**\n   * @custom:section                           ** INITIALIZING **\n   */\n\n  ///@custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address _governance,\n    address _senate,\n    address _gETH,\n    address _oracle_position,\n    bytes calldata versionName\n  ) public virtual initializer {\n    __Portal_init(_governance, _senate, _gETH, _oracle_position, versionName);\n  }\n\n  function __Portal_init(\n    address _governance,\n    address _senate,\n    address _gETH,\n    address _oracle_position,\n    bytes calldata versionName\n  ) internal onlyInitializing {\n    __GeodeModule_init(\n      _governance,\n      _senate,\n      block.timestamp + GML.MAX_SENATE_PERIOD,\n      ID_TYPE.PACKAGE_PORTAL,\n      versionName\n    );\n    __StakeModule_init(_gETH, _oracle_position);\n    __Portal_init_unchained();\n  }\n\n  function __Portal_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @custom:section                           ** GETTER FUNCTIONS **\n   *\n   * @custom:visibility -> view-external\n   */\n\n  /**\n   * @dev GeodeModule override\n   *\n   * @notice Isolation Mode is an external view function signaling other contracts\n   * * to isolate themselves from Portal. For example, withdrawalContract will not fetch upgrades.\n   * @return isRecovering true if isolationMode is active:\n   * * 1. Portal is paused\n   * * 2. Portal needs to be upgraded\n   * * 3. Senate expired\n   */\n  function isolationMode()\n    external\n    view\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (bool)\n  {\n    GeodeModuleStorage storage GMStorage = _getGeodeModuleStorage();\n    return (paused() ||\n      GMStorage.APPROVED_UPGRADE != ERC1967Utils.getImplementation() ||\n      block.timestamp > GMStorage.SENATE_EXPIRY);\n  }\n\n  /**\n   * @custom:section                           ** GOVERNANCE FUNCTIONS **\n   *\n   * @custom:visibility -> external\n   */\n\n  function pausegETH() external virtual override onlyGovernance {\n    _getStakeModuleStorage().gETH.pause();\n  }\n\n  function unpausegETH() external virtual override onlyGovernance {\n    _getStakeModuleStorage().gETH.unpause();\n  }\n\n  function pause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _pause();\n  }\n\n  function unpause() external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _unpause();\n  }\n\n  function setInfrastructureFee(\n    uint256 _type,\n    uint256 fee\n  ) external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _getStakeModuleStorage().setInfrastructureFee(_type, fee);\n  }\n\n  function setBeaconDelays(\n    uint256 entry,\n    uint256 exit\n  ) external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _getStakeModuleStorage().setBeaconDelays(entry, exit);\n  }\n\n  function setInitiationDeposit(\n    uint256 newInitiationDeposit\n  ) external virtual override(StakeModule, IStakeModule) onlyGovernance {\n    _getStakeModuleStorage().setInitiationDeposit(newInitiationDeposit);\n  }\n\n  /**\n   * @notice releases an imprisoned operator immediately\n   * @dev in different situations such as a faulty imprisonment or coordinated testing periods\n   * * Governance can release the prisoners\n   * @dev onlyGovernance SHOULD be checked in Portal\n   */\n  function releasePrisoned(uint256 operatorId) external virtual override onlyGovernance {\n    _getDataStoreModuleStorage().writeUint(operatorId, \"release\", block.timestamp);\n\n    emit Released(operatorId);\n  }\n\n  /**\n   * @custom:section                           ** PACKAGE VERSION MANAGEMENT **\n   *\n   * @custom:visibility -> external\n   */\n\n  /**\n   * @notice approves a specific proposal\n   * @dev OnlySenate is checked inside the GeodeModule\n   */\n  function approveProposal(\n    uint256 id\n  )\n    public\n    virtual\n    override(GeodeModule, IGeodeModule)\n    returns (address _controller, uint256 _type, bytes memory _name)\n  {\n    (_controller, _type, _name) = super.approveProposal(id);\n\n    if (_type > ID_TYPE.LIMIT_MIN_PACKAGE && _type < ID_TYPE.LIMIT_MAX_PACKAGE) {\n      _getStakeModuleStorage().packages[_type] = id;\n    } else if (_type > ID_TYPE.LIMIT_MIN_MIDDLEWARE && _type < ID_TYPE.LIMIT_MAX_MIDDLEWARE) {\n      _getStakeModuleStorage().middlewares[_type][id] = true;\n    }\n  }\n\n  function pushUpgrade(\n    uint256 packageType\n  ) external virtual override nonReentrant whenNotPaused returns (uint256 id) {\n    require(\n      packageType > ID_TYPE.LIMIT_MIN_PACKAGE && packageType < ID_TYPE.LIMIT_MAX_PACKAGE,\n      \"PORTAL:invalid package type\"\n    );\n\n    uint256 currentPackageVersion = _getStakeModuleStorage().packages[packageType];\n\n    DataStoreModuleStorage storage DSMStorage = _getDataStoreModuleStorage();\n\n    id = IGeodeModule(msg.sender).propose(\n      DSMStorage.readAddress(currentPackageVersion, \"CONTROLLER\"),\n      packageType,\n      DSMStorage.readBytes(currentPackageVersion, \"NAME\"),\n      GML.MAX_PROPOSAL_DURATION\n    );\n\n    require(id > 0, \"PORTAL:cannot push upgrade\");\n  }\n\n  /**\n   * @notice fallback functions: receive\n   */\n\n  receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}