{
  "address": "0xf27a6033F70B94b8255De091aac850e2E519E09F",
  "abi": [
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "TYPE",
          "type": "uint256"
        }
      ],
      "name": "IdInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newMaintainer",
          "type": "address"
        }
      ],
      "name": "MaintainerChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "poolId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "MiddlewareDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "poolId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "packageType",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "PackageDeployed",
      "type": "event"
    }
  ],
  "transactionHash": "0x05ebd116b2181095fc7a3c69c8c60c344761b45befcc9258482ffc95bbd8f26d",
  "receipt": {
    "to": null,
    "from": "0x2C95BC18Fd9382a07776D416EeF6c2FEb3AD2A8C",
    "contractAddress": "0xf27a6033F70B94b8255De091aac850e2E519E09F",
    "transactionIndex": 0,
    "gasUsed": "1976732",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa4642846d25593c74ee0972e51bad5a6f648230e6b1bdd4bbe0204207a92e92f",
    "transactionHash": "0x05ebd116b2181095fc7a3c69c8c60c344761b45befcc9258482ffc95bbd8f26d",
    "logs": [],
    "blockNumber": 500525,
    "cumulativeGasUsed": "1976732",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "61510320e155ddc5271d2656d1a4fd97",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"TYPE\",\"type\":\"uint256\"}],\"name\":\"IdInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMaintainer\",\"type\":\"address\"}],\"name\":\"MaintainerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"MiddlewareDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"PackageDeployed\",\"type\":\"event\"}],\"devdoc\":{\"author\":\"Ice Bear & Crash Bandicoot\",\"details\":\"review: DataStoreModule for the id based isolated storage logic.review: StakeModuleLib for base staking logic.This library utilizes the '_authenticate' function on the external deployLiquidityPool,  Compared to gETHMiddleware(optional) and WithdrawalContract(mandatory), LP be activated after the pool initiation.This is an external library, requires deployment.\",\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}]},\"events\":{\"IdInitiated(uint256,uint256)\":{\"custom:section\":\"** EVENTS **\"}},\"kind\":\"dev\",\"methods\":{\"_deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)\":{\"details\":\"gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well_package_data of a liquidity pool is only the staking pool's name, used on LPToken.\"},\"initiateOperator(DataStoreModuleStorage storage,uint256,uint256,uint256,address)\":{\"details\":\"operators can fund their internal wallet on initiation by simply sending some ether.\",\"params\":{\"fee\":\"as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%\",\"maintainer\":\"an address that automates daily operations, a script, a contract...\",\"validatorPeriod\":\"the expected maximum staking interval. This value should between * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above. Operator can unstake at any given point before this period ends. If operator disobeys this rule, it can be prisoned with blameProposal()\"}},\"initiatePool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,address,bytes,bytes,bool[3])\":{\"details\":\"checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.requires exactly 1 validator worth of funds to be deposited on initiation, prevent sybil attacks.\",\"params\":{\"config\":\"array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]\",\"fee\":\"as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\",\"maintainer\":\"an address that automates daily operations, a script, a contract... not so critical.\",\"middlewareVersion\":\"Pool creators can choose any allowed version as their gETHMiddleware\",\"middleware_data\":\"middlewares might require additional data on initialization; like name, symbol, etc.\",\"name\":\"is utilized while generating an ID for the Pool, similar to any other ID generation.\"}}},\"title\":\"IEL: Initiator Extension Library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)\":{\"notice\":\"deploys a bound liquidity pool for a staking pool.\"},\"deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)\":{\"notice\":\"allows pools to deploy a Liquidity Pool after initiation, if it does not have one.\"},\"initiateOperator(DataStoreModuleStorage storage,uint256,uint256,uint256,address)\":{\"notice\":\"initiates ID as a Permissionned Node Operatorrequires ID to be approved as a node operator with a specific CONTROLLER\"},\"initiatePool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,address,bytes,bytes,bool[3])\":{\"notice\":\"Creates a Configurable Trustless Staking Pool!\"}},\"notice\":\"An extension to SML.This library is responsible from: * 1. Node Operator Initiator for permissioned IDs * 2. Configurable Staking Pools Initiator and its helpers. * 3. Bound Liquidity Pool deployment after pool initiation.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\":\"InitiatorExtensionLib\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x60c65f701957fdd6faea1acb0bb45825791d473693ed9ecb34726fdfaa849dd7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Proxy} from \\\"../Proxy.sol\\\";\\nimport {ERC1967Utils} from \\\"./ERC1967Utils.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    constructor(address implementation, bytes memory _data) payable {\\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Utils.getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xbfb6695731de677140fbf76c772ab08c4233a122fb51ac28ac120fc49bbbc4ec\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06a78f9b3ee3e6d0eb4e4cd635ba49960bea34cac1db8c0a27c75f2319f1fd65\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\",\"keccak256\":\"0xc3f2ec76a3de8ed7a7007c46166f5550c72c7709e3fc7e8bb3111a7191cdedbd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe64b3445a3f638890af7ad92464cd18f1f202a2f5a7ed42dabf74317bae43303\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xe92b5e199b963d108ad6e06feeede151ba23849e0d064956535489ff967ffe68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/globals/id_type.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice ID_TYPE is an internal library that acts like an ENUM.\\n *\\n * @dev Used within the limited upgradability pattern:\\n *\\n * NONE & GAP: should not be used.\\n *\\n * Dual Governance:\\n * * SENATE: points to a proposal that will update the current SENATE address of a package(or Portal).\\n * * CONTRACT UPGRADE: proposal to change the given contract's implementation. TYPE should be package's TYPE.\\n *\\n * Users:\\n * * OPERATOR: permissionned Node Operators (hosted on Portal).\\n * * POOL: permissionless staking pools (hosted on Portal).\\n *\\n * Packages: (hosted on StakeModuleLib)\\n * * An ID can only point to 1(one) Package version' implementation address at a given point.\\n * * Can be upgraded by a dual governance, via pullUpgrade.\\n * * * Portal's dual governance consists of a Governance Token(governance) and a Senate(senate).\\n * * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n * * Built by utilizing the Modules.\\n * * LiquidityPool and WithdrawalContract are some examples.\\n *\\n * Middlewares: (hosted on StakeModuleLib)\\n * * An ID can point to multiple Middleware version' implementation address at the same time.\\n * * Can not be upgraded.\\n * * Do not have any guides to build really.\\n * * Currently only gETHMiddlewares\\n *\\n *  Limits:\\n *  * We simply set limits to separate a group of types from others. Like Packages and Middlewares.\\n *\\n * @dev all LIMIT parameters are exclusive, prevents double usage.\\n */\\nlibrary ID_TYPE {\\n  /// @notice TYPE 0: *invalid*\\n  uint256 internal constant NONE = 0;\\n\\n  /// @notice TYPE 1: Senate\\n  uint256 internal constant SENATE = 1;\\n\\n  /// --\\n\\n  /// @notice TYPE 3: Limit: exclusive, minimum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MIN_USER = 3;\\n\\n  /// @notice TYPE 4: USER: Permissionned Node Operator\\n  uint256 internal constant OPERATOR = 4;\\n\\n  /// @notice TYPE 5: USER: Staking Pool\\n  uint256 internal constant POOL = 5;\\n\\n  /// @notice TYPE 9999: Limit: exclusive, maximum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MAX_USER = 9999;\\n\\n  /// --\\n\\n  /// @notice TYPE 10000: Limit: exclusive, minimum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MIN_PACKAGE = 10000;\\n\\n  /// @notice TYPE 10001: Package: Portal is also a package\\n  uint256 internal constant PACKAGE_PORTAL = 10001;\\n\\n  /// @notice TYPE 10011: Package: The Withdrawal Credential Contract\\n  uint256 internal constant PACKAGE_WITHDRAWAL_CONTRACT = 10011;\\n\\n  /// @notice TYPE 10021: Package: A Liquidity Pool\\n  uint256 internal constant PACKAGE_LIQUIDITY_POOL = 10021;\\n\\n  /// @notice TYPE 19999: Limit: exclusive, maximum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MAX_PACKAGE = 19999;\\n\\n  /// --\\n\\n  /// @notice TYPE 20000: Limit: exclusive, minimum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MIN_MIDDLEWARE = 20000;\\n\\n  /// @notice TYPE 20011: Middleware: A new gETH interface\\n  uint256 internal constant MIDDLEWARE_GETH = 20011;\\n\\n  /// @notice TYPE 29999: Limit: exclusive, maximum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MAX_MIDDLEWARE = 29999;\\n}\\n\",\"keccak256\":\"0x57f7402676daf6b6e67c986886a6bcda45e22bef084fda946fd191fd3ff9f63d\",\"license\":\"MIT\"},\"contracts/globals/macros.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// no floats in solidity. If needed, PERCENTAGE_DENOMINATOR always represents \\\"1\\\" (100%)\\nuint256 constant PERCENTAGE_DENOMINATOR = 1e10;\\n\\nuint256 constant gETH_DENOMINATOR = 1e18;\\n\",\"keccak256\":\"0x9d699aeaf6da35d188a5495eec188b28a990e09bd04fa7701d28c4ff9afba801\",\"license\":\"MIT\"},\"contracts/globals/reserved_key_space.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Reserved Key Space for DataStoreModule\\n * * helps preventing potential dev mistakes.\\n * * helps keeping track of them.\\n * * limits keys to bytes32.\\n *\\n * @dev utilize a key with rks.key\\n * @dev keep this list in alphabetical order, per module.\\n * @dev NEVER name your variables something else other than *its string value*.\\n * @dev ! array keys with readUint returns the lenght of the array !\\n */\\nlibrary RESERVED_KEY_SPACE {\\n  /**\\n   * @dev reserved on GeodeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition representing body of an id\\n   */\\n  bytes32 internal constant CONTROLLER = \\\"CONTROLLER\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition base of an id\\n   */\\n  bytes32 internal constant NAME = \\\"NAME\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition identifier for an id, based on ID_TYPEs\\n   */\\n  bytes32 internal constant TYPE = \\\"TYPE\\\";\\n\\n  /**\\n   * @dev reserved on StakeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of active validators run by an operator for a pool\\n   */\\n  bytes32 internal constant activeValidators = \\\"activeValidators\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition max amount of validators for an operator to run, for a specific pool.\\n   */\\n  bytes32 internal constant allowance = \\\"allowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition special operator that has max allowance, if threshold is hit for the pool\\n   */\\n  bytes32 internal constant fallbackOperator = \\\"fallbackOperator\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition treshold calculated with given percentage value for fallback operator to be activated\\n   */\\n  bytes32 internal constant fallbackThreshold = \\\"fallbackThreshold\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee of the pool or operator, will be shadowed by priorFee if switching\\n   */\\n  bytes32 internal constant fee = \\\"fee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed fee change\\n   */\\n  bytes32 internal constant feeSwitch = \\\"feeSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition the initiation timestamp of a \\\"user\\\" TYPE id\\n   */\\n  bytes32 internal constant initiated = \\\"initiated\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition bound liquidity pool of a pool\\n   */\\n  bytes32 internal constant liquidityPool = \\\"liquidityPool\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition receiver address for yield seperation functionality\\n   * * will receive minted gETH to given receiver instead of increasing pricePerShare\\n   */\\n  bytes32 internal constant yieldReceiver = \\\"yieldReceiver\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition hot wallet for pool and operators, automatooor\\n   */\\n  bytes32 internal constant maintainer = \\\"maintainer\\\";\\n\\n  /**\\n   * @custom:type address array, direct call returns length\\n   * @custom:definition contracts with more than one versions, ex: gETHMiddlewares of a pool\\n   */\\n  bytes32 internal constant middlewares = \\\"middlewares\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed validator period change\\n   */\\n  bytes32 internal constant periodSwitch = \\\"periodSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee that will be effective if fee is currently switching\\n   */\\n  bytes32 internal constant priorFee = \\\"priorFee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition period that will be effective if validatorPeriod is currently switching\\n   */\\n  bytes32 internal constant priorPeriod = \\\"priorPeriod\\\";\\n\\n  /**\\n   * @custom:type uint, bool\\n   * @custom:definition 1(true) if id is a private pool\\n   */\\n  bytes32 internal constant privatePool = \\\"privatePool\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition proposed validator count for pool-operator pair.\\n   */\\n  bytes32 internal constant proposedValidators = \\\"proposedValidators\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition timestamp of the date of the latest imprisonment for an operator\\n   */\\n  bytes32 internal constant release = \\\"release\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition 32 eth is secured, per proposed-but-not-yet-activated validator\\n   */\\n  bytes32 internal constant secured = \\\"secured\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition collateral waiting to be staked, in wei\\n   */\\n  bytes32 internal constant surplus = \\\"surplus\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition sum of all allowances for a pool\\n   */\\n\\n  bytes32 internal constant totalAllowance = \\\"totalAllowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition seconds, time that passes before the expected exit is reached for a validator\\n   */\\n  bytes32 internal constant validatorPeriod = \\\"validatorPeriod\\\";\\n\\n  /**\\n   * @custom:type bytes array, direct call returns length\\n   * @custom:definition lists all (any state) validators' pubkeys for a pool, or an operator\\n   */\\n  bytes32 internal constant validators = \\\"validators\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition custodian of validator funds for a pool\\n   */\\n  bytes32 internal constant withdrawalContract = \\\"withdrawalContract\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition derived from withdrawalContract\\n   */\\n  bytes32 internal constant withdrawalCredential = \\\"withdrawalCredential\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition size of the internal wallet, which accrues fees etc. in wei\\n   */\\n  bytes32 internal constant wallet = \\\"wallet\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition whitelist contract for the pool\\n   */\\n  bytes32 internal constant whitelist = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev reserved on OracleExtensionLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of alienated validators run by an operator for a pool\\n   */\\n  bytes32 internal constant alienValidators = \\\"alienValidators\\\";\\n}\\n\",\"keccak256\":\"0x62ab3086774ad8721fa9e571e663e6444bebe30020075898406ec92ab55146bb\",\"license\":\"MIT\"},\"contracts/globals/validator_state.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice VALIDATOR_STATE: keeping track of validators within The Staking Library.\\n */\\nlibrary VALIDATOR_STATE {\\n  /// @notice STATE 0: *invalid*\\n  uint8 internal constant NONE = 0;\\n\\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract.\\n  uint8 internal constant PROPOSED = 1;\\n\\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator.\\n  uint8 internal constant ACTIVE = 2;\\n\\n  /// @notice STATE 3: validator is called to be exited.\\n  uint8 internal constant EXIT_REQUESTED = 3;\\n\\n  /// @notice STATE 4: validator is fully exited.\\n  uint8 internal constant EXITED = 4;\\n\\n  /// @notice STATE 69: proposal was malicious(alien). Maybe faulty signatures or probably frontrunning (https://bit.ly/3Tkc6UC)\\n  uint8 internal constant ALIENATED = 69;\\n}\\n\",\"keccak256\":\"0xe3b6be931c93e3855d7dc1775870378652699745f7273f601dea102a7ce87546\",\"license\":\"MIT\"},\"contracts/helpers/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity =0.8.20;\\n\\nlibrary BytesLib {\\n  function concat(\\n    bytes memory _preBytes,\\n    bytes memory _postBytes\\n  ) internal pure returns (bytes memory) {\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      // Get a location of some free memory and store it in tempBytes as\\n      // Solidity does for memory variables.\\n      tempBytes := mload(0x40)\\n\\n      // Store the length of the first bytes array at the beginning of\\n      // the memory for tempBytes.\\n      let length := mload(_preBytes)\\n      mstore(tempBytes, length)\\n\\n      // Maintain a memory counter for the current write location in the\\n      // temp bytes array by adding the 32 bytes for the array length to\\n      // the starting location.\\n      let mc := add(tempBytes, 0x20)\\n      // Stop copying when the memory counter reaches the length of the\\n      // first bytes array.\\n      let end := add(mc, length)\\n\\n      for {\\n        // Initialize a copy counter to the start of the _preBytes data,\\n        // 32 bytes into its memory.\\n        let cc := add(_preBytes, 0x20)\\n      } lt(mc, end) {\\n        // Increase both counters by 32 bytes each iteration.\\n        mc := add(mc, 0x20)\\n        cc := add(cc, 0x20)\\n      } {\\n        // Write the _preBytes data into the tempBytes memory 32 bytes\\n        // at a time.\\n        mstore(mc, mload(cc))\\n      }\\n\\n      // Add the length of _postBytes to the current length of tempBytes\\n      // and store it as the new length in the first 32 bytes of the\\n      // tempBytes memory.\\n      length := mload(_postBytes)\\n      mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n      // Move the memory counter back from a multiple of 0x20 to the\\n      // actual end of the _preBytes data.\\n      mc := end\\n      // Stop copying when the memory counter reaches the new combined\\n      // length of the arrays.\\n      end := add(mc, length)\\n\\n      for {\\n        let cc := add(_postBytes, 0x20)\\n      } lt(mc, end) {\\n        mc := add(mc, 0x20)\\n        cc := add(cc, 0x20)\\n      } {\\n        mstore(mc, mload(cc))\\n      }\\n\\n      // Update the free-memory pointer by padding our last write location\\n      // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n      // next 32 byte block, then round down to the nearest multiple of\\n      // 32. If the sum of the length of the two arrays is zero then add\\n      // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n      mstore(\\n        0x40,\\n        and(\\n          add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n          not(31) // Round down to the nearest 32 bytes.\\n        )\\n      )\\n    }\\n\\n    return tempBytes;\\n  }\\n\\n  function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n    assembly {\\n      // Read the first 32 bytes of _preBytes storage, which is the length\\n      // of the array. (We don't need to use the offset into the slot\\n      // because arrays use the entire slot.)\\n      let fslot := sload(_preBytes.slot)\\n      // Arrays of 31 bytes or less have an even value in their slot,\\n      // while longer arrays have an odd value. The actual length is\\n      // the slot divided by two for odd values, and the lowest order\\n      // byte divided by two for even values.\\n      // If the slot is even, bitwise and the slot with 255 and divide by\\n      // two to get the length. If the slot is odd, bitwise and the slot\\n      // with -1 and divide by two.\\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n      let mlength := mload(_postBytes)\\n      let newlength := add(slength, mlength)\\n      // slength can contain both the length and contents of the array\\n      // if length < 32 bytes so let's prepare for that\\n      // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n      switch add(lt(slength, 32), lt(newlength, 32))\\n      case 2 {\\n        // Since the new array still fits in the slot, we just need to\\n        // update the contents of the slot.\\n        // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n        sstore(\\n          _preBytes.slot,\\n          // all the modifications to the slot are inside this\\n          // next block\\n          add(\\n            // we can just add to the slot contents because the\\n            // bytes we want to change are the LSBs\\n            fslot,\\n            add(\\n              mul(\\n                div(\\n                  // load the bytes from memory\\n                  mload(add(_postBytes, 0x20)),\\n                  // zero all bytes to the right\\n                  exp(0x100, sub(32, mlength))\\n                ),\\n                // and now shift left the number of bytes to\\n                // leave space for the length in the slot\\n                exp(0x100, sub(32, newlength))\\n              ),\\n              // increase length by the double of the memory\\n              // bytes length\\n              mul(mlength, 2)\\n            )\\n          )\\n        )\\n      }\\n      case 1 {\\n        // The stored value fits in the slot, but the combined value\\n        // will exceed it.\\n        // get the keccak hash to get the contents of the array\\n        mstore(0x0, _preBytes.slot)\\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n        // save new length\\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n        // The contents of the _postBytes array start 32 bytes into\\n        // the structure. Our first read should obtain the `submod`\\n        // bytes that can fit into the unused space in the last word\\n        // of the stored array. To get this, we read 32 bytes starting\\n        // from `submod`, so the data we read overlaps with the array\\n        // contents by `submod` bytes. Masking the lowest-order\\n        // `submod` bytes allows us to add that value directly to the\\n        // stored value.\\n\\n        let submod := sub(32, slength)\\n        let mc := add(_postBytes, submod)\\n        let end := add(_postBytes, mlength)\\n        let mask := sub(exp(0x100, submod), 1)\\n\\n        sstore(\\n          sc,\\n          add(\\n            and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n            and(mload(mc), mask)\\n          )\\n        )\\n\\n        for {\\n          mc := add(mc, 0x20)\\n          sc := add(sc, 1)\\n        } lt(mc, end) {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } {\\n          sstore(sc, mload(mc))\\n        }\\n\\n        mask := exp(0x100, sub(mc, end))\\n\\n        sstore(sc, mul(div(mload(mc), mask), mask))\\n      }\\n      default {\\n        // get the keccak hash to get the contents of the array\\n        mstore(0x0, _preBytes.slot)\\n        // Start copying to the last used word of the stored array.\\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n        // save new length\\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n        // Copy over the first `submod` bytes of the new data as in\\n        // case 1 above.\\n        let slengthmod := mod(slength, 32)\\n        let mlengthmod := mod(mlength, 32)\\n        let submod := sub(32, slengthmod)\\n        let mc := add(_postBytes, submod)\\n        let end := add(_postBytes, mlength)\\n        let mask := sub(exp(0x100, submod), 1)\\n\\n        sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n        for {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } lt(mc, end) {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } {\\n          sstore(sc, mload(mc))\\n        }\\n\\n        mask := exp(0x100, sub(mc, end))\\n\\n        sstore(sc, mul(div(mload(mc), mask), mask))\\n      }\\n    }\\n  }\\n\\n  function slice(\\n    bytes memory _bytes,\\n    uint256 _start,\\n    uint256 _length\\n  ) internal pure returns (bytes memory) {\\n    require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n    require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      switch iszero(_length)\\n      case 0 {\\n        // Get a location of some free memory and store it in tempBytes as\\n        // Solidity does for memory variables.\\n        tempBytes := mload(0x40)\\n\\n        // The first word of the slice result is potentially a partial\\n        // word read from the original array. To read it, we calculate\\n        // the length of that partial word and start copying that many\\n        // bytes into the array. The first word we copy will start with\\n        // data we don't care about, but the last `lengthmod` bytes will\\n        // land at the beginning of the contents of the new array. When\\n        // we're done copying, we overwrite the full first word with\\n        // the actual length of the slice.\\n        let lengthmod := and(_length, 31)\\n\\n        // The multiplication in the next line is necessary\\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\\n        // the following copy loop was copying the origin's length\\n        // and then ending prematurely not copying everything it should.\\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n        let end := add(mc, _length)\\n\\n        for {\\n          // The multiplication in the next line has the same exact purpose\\n          // as the one above.\\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n        } lt(mc, end) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          mstore(mc, mload(cc))\\n        }\\n\\n        mstore(tempBytes, _length)\\n\\n        //update free-memory pointer\\n        //allocating the array padded to 32 bytes like the compiler does now\\n        mstore(0x40, and(add(mc, 31), not(31)))\\n      }\\n      //if we want a zero-length slice let's just return a zero-length array\\n      default {\\n        tempBytes := mload(0x40)\\n        //zero out the 32 bytes slice we are about to return\\n        //we need to do it because Solidity does not garbage collect\\n        mstore(tempBytes, 0)\\n\\n        mstore(0x40, add(tempBytes, 0x20))\\n      }\\n    }\\n\\n    return tempBytes;\\n  }\\n\\n  function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n    require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n    address tempAddress;\\n\\n    assembly {\\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n    }\\n\\n    return tempAddress;\\n  }\\n\\n  function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n    require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n    uint8 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x1), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n    require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n    uint16 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x2), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n    require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n    uint32 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x4), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n    require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n    uint64 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x8), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n    require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n    uint96 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0xc), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n    require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n    uint128 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x10), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n    require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n    uint256 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x20), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n    require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n    bytes32 tempBytes32;\\n\\n    assembly {\\n      tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n    }\\n\\n    return tempBytes32;\\n  }\\n\\n  function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n    bool success = true;\\n\\n    assembly {\\n      let length := mload(_preBytes)\\n\\n      // if lengths don't match the arrays are not equal\\n      switch eq(length, mload(_postBytes))\\n      case 1 {\\n        // cb is a circuit breaker in the for loop since there's\\n        //  no said feature for inline assembly loops\\n        // cb = 1 - don't breaker\\n        // cb = 0 - break\\n        let cb := 1\\n\\n        let mc := add(_preBytes, 0x20)\\n        let end := add(mc, length)\\n\\n        for {\\n          let cc := add(_postBytes, 0x20)\\n          // the next line is the loop condition:\\n          // while(uint256(mc < end) + cb == 2)\\n        } eq(add(lt(mc, end), cb), 2) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          // if any of these checks fails then arrays are not equal\\n          if iszero(eq(mload(mc), mload(cc))) {\\n            // unsuccess:\\n            success := 0\\n            cb := 0\\n          }\\n        }\\n      }\\n      default {\\n        // unsuccess:\\n        success := 0\\n      }\\n    }\\n\\n    return success;\\n  }\\n\\n  function equalStorage(\\n    bytes storage _preBytes,\\n    bytes memory _postBytes\\n  ) internal view returns (bool) {\\n    bool success = true;\\n\\n    assembly {\\n      // we know _preBytes_offset is 0\\n      let fslot := sload(_preBytes.slot)\\n      // Decode the length of the stored array like in concatStorage().\\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n      let mlength := mload(_postBytes)\\n\\n      // if lengths don't match the arrays are not equal\\n      switch eq(slength, mlength)\\n      case 1 {\\n        // slength can contain both the length and contents of the array\\n        // if length < 32 bytes so let's prepare for that\\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n        if iszero(iszero(slength)) {\\n          switch lt(slength, 32)\\n          case 1 {\\n            // blank the last byte which is the length\\n            fslot := mul(div(fslot, 0x100), 0x100)\\n\\n            if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n              // unsuccess:\\n              success := 0\\n            }\\n          }\\n          default {\\n            // cb is a circuit breaker in the for loop since there's\\n            //  no said feature for inline assembly loops\\n            // cb = 1 - don't breaker\\n            // cb = 0 - break\\n            let cb := 1\\n\\n            // get the keccak hash to get the contents of the array\\n            mstore(0x0, _preBytes.slot)\\n            let sc := keccak256(0x0, 0x20)\\n\\n            let mc := add(_postBytes, 0x20)\\n            let end := add(mc, mlength)\\n\\n            // the next line is the loop condition:\\n            // while(uint256(mc < end) + cb == 2)\\n            for {\\n\\n            } eq(add(lt(mc, end), cb), 2) {\\n              sc := add(sc, 1)\\n              mc := add(mc, 0x20)\\n            } {\\n              if iszero(eq(sload(sc), mload(mc))) {\\n                // unsuccess:\\n                success := 0\\n                cb := 0\\n              }\\n            }\\n          }\\n        }\\n      }\\n      default {\\n        // unsuccess:\\n        success := 0\\n      }\\n    }\\n\\n    return success;\\n  }\\n}\\n\",\"keccak256\":\"0x4ee3f6ef85baa41794fc1519522f7c135becd0e267980eadc68dd643e52b59c7\",\"license\":\"Unlicense\"},\"contracts/interfaces/IPortal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IGeodeModule} from \\\"./modules/IGeodeModule.sol\\\";\\nimport {IStakeModule} from \\\"./modules/IStakeModule.sol\\\";\\n\\ninterface IPortal is IGeodeModule, IStakeModule {\\n  function pausegETH() external;\\n\\n  function unpausegETH() external;\\n\\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\\n\\n  function releasePrisoned(uint256 operatorId) external;\\n}\\n\",\"keccak256\":\"0x012a8ed050ba68838eeb7463b75f32ba8fdf50c9e54e44dd37d4e87ca16ba78c\",\"license\":\"MIT\"},\"contracts/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IERC1155PausableBurnableSupply} from \\\"./helpers/IERC1155PausableBurnableSupply.sol\\\";\\n\\ninterface IgETH is IERC1155PausableBurnableSupply {\\n  function denominator() external view returns (uint256);\\n\\n  function isMiddleware(address middleware, uint256 id) external view returns (bool);\\n\\n  function setMiddleware(address middleware, uint256 id, bool isSet) external;\\n\\n  function isAvoider(address account, uint256 id) external view returns (bool);\\n\\n  function avoidMiddlewares(uint256 id, bool isAvoid) external;\\n\\n  function pricePerShare(uint256 id) external view returns (uint256);\\n\\n  function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\n\\n  function setPricePerShare(uint256 price, uint256 id) external;\\n\\n  function transferUriSetterRole(address newUriSetter) external;\\n\\n  function transferPauserRole(address newPauser) external;\\n\\n  function transferMinterRole(address newMinter) external;\\n\\n  function transferOracleRole(address newOracle) external;\\n\\n  function transferMiddlewareManagerRole(address newMiddlewareManager) external;\\n}\\n\",\"keccak256\":\"0xa093b769e8ba42091d3db8a9e4ddc1be066f4aa92f61ee552983c22a0e9f29d8\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/** This interface is designed to be compatible with the Vyper version.\\n * @notice This is the Ethereum 2.0 deposit contract interface.\\n * For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\n */\\ninterface IDepositContract {\\n  /**\\n   * @notice Submit a Phase 0 DepositData object.\\n   * @param pubkey A BLS12-381 public key.\\n   * @param withdrawal_credentials Commitment to a public key for withdrawals.\\n   * @param signature A BLS12-381 signature.\\n   * @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n   *Used as a protection against malformed input.\\n   */\\n  function deposit(\\n    bytes calldata pubkey,\\n    bytes calldata withdrawal_credentials,\\n    bytes calldata signature,\\n    bytes32 deposit_data_root\\n  ) external payable;\\n}\\n\",\"keccak256\":\"0x2db8802f8f888c62b147508e142e15c59775ff75906d09122e810483919bff27\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @dev IERC1155 inherits IERC165\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport {IERC1155Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\n\\ninterface IERC1155Burnable is IERC1155, IERC1155MetadataURI, IERC1155Errors {\\n  function burn(address account, uint256 id, uint256 value) external;\\n\\n  function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\\n}\\n\\ninterface IERC1155Supply is IERC1155, IERC1155MetadataURI, IERC1155Errors {\\n  function totalSupply(uint256 id) external view returns (uint256);\\n\\n  function exists(uint256 id) external view returns (bool);\\n}\\n\\ninterface IERC1155PausableBurnableSupply is IERC1155Burnable, IERC1155Supply {\\n  function setURI(string memory newuri) external;\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\\n\\n  function mintBatch(\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x8b0a02fdbc8d54c815d68e122f6869348217b5efd853c8b833c59d2053998ef0\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IWhitelist {\\n  function isAllowed(address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xd9a70c727b9cee59af99357d2ff7b04e8ef19372f6a72efd74a14091f836bdcb\",\"license\":\"MIT\"},\"contracts/interfaces/middlewares/IgETHMiddleware.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IgETHMiddleware {\\n  function initialize(uint256 id_, address erc1155_, bytes memory data) external;\\n\\n  function ERC1155() external view returns (address);\\n\\n  function ERC1155_ID() external view returns (uint256);\\n\\n  function pricePerShare() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5b94e7cf38487d607c720d311578fa0b777a75050113b3533b8e4e22fe6ab61c\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IDataStoreModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IDataStoreModule {\\n  function generateId(string calldata _name, uint256 _type) external pure returns (uint256 id);\\n\\n  function getKey(uint256 _id, bytes32 _param) external pure returns (bytes32 key);\\n\\n  function allIdsByType(uint256 _type, uint256 _index) external view returns (uint256);\\n\\n  function allIdsByTypeLength(uint256 _type) external view returns (uint256);\\n\\n  function readUint(uint256 id, bytes32 key) external view returns (uint256 data);\\n\\n  function readAddress(uint256 id, bytes32 key) external view returns (address data);\\n\\n  function readBytes(uint256 id, bytes32 key) external view returns (bytes memory data);\\n\\n  function readUintArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (uint256 data);\\n\\n  function readBytesArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (bytes memory data);\\n\\n  function readAddressArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (address data);\\n}\\n\",\"keccak256\":\"0x3ba6191b4a643bce171bb7dc9b39a55dd0c8c932934429902dec4eb7b6c3df9a\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IGeodeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {Proposal} from \\\"../../modules/GeodeModule/structs/utils.sol\\\";\\n\\ninterface IGeodeModule is IDataStoreModule {\\n  function isolationMode() external view returns (bool);\\n\\n  function GeodeParams()\\n    external\\n    view\\n    returns (\\n      address governance,\\n      address senate,\\n      address approvedUpgrade,\\n      uint256 senateExpiry,\\n      uint256 packageType\\n    );\\n\\n  function getGovernance() external view returns (address);\\n\\n  function getContractVersion() external view returns (uint256);\\n\\n  function getProposal(uint256 id) external view returns (Proposal memory proposal);\\n\\n  function propose(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external returns (uint256 id);\\n\\n  function rescueSenate(address _newSenate) external;\\n\\n  function approveProposal(\\n    uint256 id\\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\\n\\n  function changeSenate(address _newSenate) external;\\n\\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\\n}\\n\",\"keccak256\":\"0x2eb0e5472c00c7d91443f0544ce349129266665dd59f1e4b0598173df1a9d1c5\",\"license\":\"MIT\"},\"contracts/interfaces/modules/ILiquidityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface ILiquidityModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function LiquidityParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address lpToken,\\n      uint256 pooledTokenId,\\n      uint256 initialA,\\n      uint256 futureA,\\n      uint256 initialATime,\\n      uint256 futureATime,\\n      uint256 swapFee,\\n      uint256 adminFee\\n    );\\n\\n  function getA() external view returns (uint256);\\n\\n  function getAPrecise() external view returns (uint256);\\n\\n  function getBalance(uint8 index) external view returns (uint256);\\n\\n  function getDebt() external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  function getAdminBalance(uint256 index) external view returns (uint256);\\n\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory);\\n\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256 availableTokenAmount);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[2] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function withdrawAdminFees(address receiver) external;\\n\\n  function setAdminFee(uint256 newAdminFee) external;\\n\\n  function setSwapFee(uint256 newSwapFee) external;\\n\\n  function rampA(uint256 futureA, uint256 futureTime) external;\\n\\n  function stopRampA() external;\\n}\\n\",\"keccak256\":\"0xee470aafacf0ec10f63efa53a3f4f8deaf03cd9b0d0aae178949464960ff397a\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IStakeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {Validator} from \\\"../../modules/StakeModule/structs/utils.sol\\\";\\n\\ninterface IStakeModule is IDataStoreModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function setInfrastructureFee(uint256 _type, uint256 fee) external;\\n\\n  function StakeParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address oraclePosition,\\n      uint256 validatorsIndex,\\n      uint256 verificationIndex,\\n      uint256 monopolyThreshold,\\n      uint256 oracleUpdateTimestamp,\\n      uint256 dailyPriceIncreaseLimit,\\n      uint256 dailyPriceDecreaseLimit\\n    );\\n\\n  function getValidator(bytes calldata pubkey) external view returns (Validator memory);\\n\\n  function getPackageVersion(uint256 _type) external view returns (uint256);\\n\\n  function getPriceMerkleRoot() external view returns (bytes32);\\n\\n  function getBalancesMerkleRoot() external view returns (bytes32);\\n\\n  function isMiddleware(uint256 _type, uint256 _version) external view returns (bool);\\n\\n  function getInfrastructureFee(uint256 _type) external view returns (uint256);\\n\\n  function initiateOperator(\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external payable;\\n\\n  function deployLiquidityPool(uint256 poolId) external;\\n\\n  function initiatePool(\\n    uint256 fee,\\n    uint256 middlewareVersion,\\n    address maintainer,\\n    bytes calldata NAME,\\n    bytes calldata middleware_data,\\n    bool[3] calldata config\\n  ) external payable returns (uint256 poolId);\\n\\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external;\\n\\n  function setWhitelist(uint256 poolId, address whitelist) external;\\n\\n  function setYieldReceiver(uint256 poolId, address yieldReceiver) external;\\n\\n  function changeMaintainer(uint256 id, address newMaintainer) external;\\n\\n  function getMaintenanceFee(uint256 id) external view returns (uint256);\\n\\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\\n\\n  function increaseWalletBalance(uint256 id) external payable returns (bool);\\n\\n  function decreaseWalletBalance(uint256 id, uint256 value) external returns (bool);\\n\\n  function isPrisoned(uint256 operatorId) external view returns (bool);\\n\\n  function blameExit(bytes calldata pk) external;\\n\\n  function blameProposal(bytes calldata pk) external;\\n\\n  function getValidatorPeriod(uint256 id) external view returns (uint256);\\n\\n  function switchValidatorPeriod(uint256 operatorId, uint256 newPeriod) external;\\n\\n  function setFallbackOperator(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external;\\n\\n  function operatorAllowance(uint256 poolId, uint256 operatorId) external view returns (uint256);\\n\\n  function delegate(\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external;\\n\\n  function isWhitelisted(uint256 poolId, address staker) external view returns (bool);\\n\\n  function isPrivatePool(uint256 poolId) external view returns (bool);\\n\\n  function isPriceValid(uint256 poolId) external view returns (bool);\\n\\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\\n\\n  function deposit(\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProof,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external payable returns (uint256 boughtgETH, uint256 mintedgETH);\\n\\n  function canStake(bytes calldata pubkey) external view returns (bool);\\n\\n  function proposeStake(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external;\\n\\n  function stake(uint256 operatorId, bytes[] calldata pubkeys) external;\\n\\n  function requestExit(uint256 poolId, bytes memory pk) external;\\n\\n  function finalizeExit(uint256 poolId, bytes memory pk) external;\\n\\n  function updateVerificationIndex(\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external;\\n\\n  function regulateOperators(uint256[] calldata feeThefts, bytes[] calldata proofs) external;\\n\\n  function reportBeacon(\\n    bytes32 priceMerkleRoot,\\n    bytes32 balanceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external;\\n\\n  function priceSync(uint256 poolId, uint256 price, bytes32[] calldata priceProof) external;\\n\\n  function priceSyncBatch(\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external;\\n}\\n\",\"keccak256\":\"0x9aa14e9a735d7487740753aa1c0c8a9eb4fba868d2f3b9fa9ea6972874362f25\",\"license\":\"MIT\"},\"contracts/interfaces/packages/IGeodePackage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IGeodeModule} from \\\"../modules/IGeodeModule.sol\\\";\\nimport {IPortal} from \\\"../IPortal.sol\\\";\\n\\ninterface IGeodePackage is IGeodeModule {\\n  function initialize(\\n    uint256 poolId,\\n    address owner,\\n    bytes calldata versionName,\\n    bytes memory data\\n  ) external;\\n\\n  function getPoolId() external view returns (uint256);\\n\\n  function getProposedVersion() external view returns (uint256);\\n\\n  function pullUpgrade() external;\\n}\\n\",\"keccak256\":\"0x9c854fab873502a768e5903e7f66b6697313f77bea4d5ca200aad8d0c3190ed9\",\"license\":\"MIT\"},\"contracts/interfaces/packages/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {ILiquidityModule} from \\\"../modules/ILiquidityModule.sol\\\";\\nimport {IGeodePackage} from \\\"./IGeodePackage.sol\\\";\\n\\ninterface ILiquidityPool is IGeodePackage, ILiquidityModule {}\\n\",\"keccak256\":\"0x75fe3f103131761db0210141774365c7eb975812178b262564343c7d660f9cb4\",\"license\":\"MIT\"},\"contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.20;\\n\\n// external - interfaces\\n// external - libraries\\n// external - contracts\\n// internal - globals\\n// internal - interfaces\\nimport {DataStoreModuleStorage} from \\\"../structs/storage.sol\\\";\\n\\n// internal - structs\\n// internal - libraries\\n\\n/**\\n * @title DSML: DataStore Module Library\\n *\\n * @notice A Storage Management Library created for the contracts and modules that inherits DataStoreModule (DSM).\\n * Enables Dynamic Structs with unlimited key space.\\n * Provides an Isolated Storage Layout with IDs and KEYs.\\n * Focusing on upgradable contracts with various data types to create a\\n * * sustainable development environment.\\n * In summary, extra gas cost that would be saved with Storage packing are\\n * * ignored to create dynamic structs.\\n *\\n * @dev Distinct id and key pairs SHOULD return different storage slots. No collisions!\\n * @dev IDs are the representation of an entity with any given key as properties.\\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\\n * @dev review: For a safer development process, NEVER use the DataStoreModuleStorage with strings. Refer to globals/reserved_key_space.sol\\n *\\n * @dev While it is a good practice for keeping a record;\\n * * TYPE for ID is NOT mandatory, an ID might not have an explicit type.\\n * * e.g., When a relational data is added with getKey, like allowance, it has a unique ID but no TYPE.\\n * * Thus there are no checks for types or keys.\\n *\\n * @dev readUint(id, arrayName) returns the lenght of array.\\n *\\n * @dev Contracts relying on this library must use DataStoreModuleLib.DataStoreModuleStorage\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\nlibrary DataStoreModuleLib {\\n  /**\\n   * @custom:section                           ** HELPERS **\\n   *\\n   * @custom:visibility -> pure-internal\\n   */\\n\\n  /**\\n   * @notice generalized method of generating an ID\\n   *\\n   * @dev Some TYPEs may require permissionless creation, allowing anyone to claim any ID;\\n   * meaning malicious actors can claim names to mislead people. To prevent this\\n   * TYPEs will be considered during ID generation.\\n   */\\n  function generateId(bytes memory _name, uint256 _type) internal pure returns (uint256 id) {\\n    id = uint256(keccak256(abi.encode(_name, _type)));\\n  }\\n\\n  /**\\n   * @notice hash of given ID and a KEY defines the key for the DataStoreModuleStorage\\n   * @return key bytes32, hash.\\n   **/\\n  function getKey(uint256 id, bytes32 param) internal pure returns (bytes32 key) {\\n    key = keccak256(abi.encode(id, param));\\n  }\\n\\n  /**\\n   * @custom:section                           ** DATA GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_id, _key)];\\n  }\\n\\n  function readBytes(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_id, _key)];\\n  }\\n\\n  function readAddress(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_id, _key)];\\n  }\\n\\n  /**\\n   * @custom:section                           ** ARRAY GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUintArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readBytesArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readAddressArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  /**\\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** DATA SETTERS **\\n   */\\n\\n  function writeUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function addUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _addend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] += _addend;\\n  }\\n\\n  function subUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _minuend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] -= _minuend;\\n  }\\n\\n  function writeBytes(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    self.bytesData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function writeAddress(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    self.addressData[getKey(_id, _key)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ARRAY SETTERS **\\n   */\\n\\n  function appendUintArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendBytesArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendAddressArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** BATCH ARRAY SETTERS **\\n   */\\n\\n  function appendUintArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendBytesArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendAddressArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n}\\n\",\"keccak256\":\"0xfc96e97319466fe81944b00814d17aee972c91858eb64c7e5d8e1d0258a62c9b\",\"license\":\"MIT\"},\"contracts/modules/DataStoreModule/structs/storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Storage Struct for reading/writing operations for given (id, key) pairs.\\n *\\n * @param allIdsByType type => id[], optional categorization for IDs, can be directly accessed.\\n * @param uintData keccak(id, key) =>  returns uint256\\n * @param bytesData keccak(id, key) => returns bytes\\n * @param addressData keccak(id, key) =>  returns address\\n *\\n * @dev any other storage type can be expressed as uint or bytes. E.g., bools are 0/1 as uints.\\n *\\n * @dev normally we would put custom:storage-location erc7201:geode.storage.DataStoreModule\\n * but compiler throws an error... So np for now, just effects dev ex.\\n */\\nstruct DataStoreModuleStorage {\\n  mapping(uint256 => uint256[]) allIdsByType;\\n  mapping(bytes32 => uint256) uintData;\\n  mapping(bytes32 => bytes) bytesData;\\n  mapping(bytes32 => address) addressData;\\n}\\n\",\"keccak256\":\"0x10c4430d4d368abd4bd5488b4cf6c942c6e26e58ae52163926cd5daae3e0c77f\",\"license\":\"MIT\"},\"contracts/modules/GeodeModule/structs/utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Giving the control of a specific ID to proposed CONTROLLER.\\n *\\n * @param TYPE: refer to globals/id_type.sol\\n * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\\n * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\\n * @param NAME: DataStore generates ID by keccak(name, type)\\n * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\\n * * Expired proposals can not be approved by Senate\\n * * Expired proposals can not be overriden by new proposals\\n **/\\nstruct Proposal {\\n  address CONTROLLER;\\n  uint256 TYPE;\\n  bytes NAME;\\n  uint256 deadline;\\n}\\n\",\"keccak256\":\"0x7092bceb57c78a1a7332d78233e1b3563546102f8bccf62c85ec1c93d9a556c3\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/DepositContractLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - interfaces\\nimport {IDepositContract} from \\\"../../../interfaces/helpers/IDepositContract.sol\\\";\\n// internal - libraries\\nimport {BytesLib} from \\\"../../../helpers/BytesLib.sol\\\";\\n\\n/**\\n * @title DCL: Deposit Contract Library\\n *\\n * @notice Includes constants & functions that helps to the deposit process.\\n *\\n * @dev DEPOSIT_CONTRACT is chain specific and should be changed before deployments.\\n *\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary DepositContractLib {\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  IDepositContract internal constant DEPOSIT_CONTRACT =\\n    IDepositContract(0x4242424242424242424242424242424242424242);\\n  uint256 internal constant PUBKEY_LENGTH = 48;\\n  uint256 internal constant SIGNATURE_LENGTH = 96;\\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\\n\\n  /**\\n   * @custom:section                           ** FUNCTIONS **\\n   */\\n\\n  /**\\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\\n   * @param _b Memory array of size 32 .. 64\\n   */\\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\\n    assert(_b.length >= 32 && _b.length <= 64);\\n    if (64 == _b.length) return _b;\\n\\n    bytes memory zero32 = new bytes(32);\\n    assembly {\\n      mstore(add(zero32, 0x20), 0)\\n    }\\n\\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\\n    else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\\n  }\\n\\n  /**\\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\\n   * @param _value Number less than `2**64` for compatibility reasons\\n   */\\n  function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n    result = 0;\\n    uint256 temp_value = _value;\\n    for (uint256 i; i < 8; ++i) {\\n      result = (result << 8) | (temp_value & 0xFF);\\n      temp_value >>= 8;\\n    }\\n\\n    assert(0 == temp_value); // fully converted\\n    result <<= (24 * 8);\\n  }\\n\\n  function _getDepositDataRoot(\\n    bytes memory _pubkey,\\n    bytes memory _withdrawalCredentials,\\n    bytes memory _signature,\\n    uint256 _stakeAmount\\n  ) internal pure returns (bytes32) {\\n    require(_stakeAmount >= 1 ether, \\\"DepositContract: deposit value too low\\\");\\n    require(_stakeAmount % 1 gwei == 0, \\\"DepositContract: deposit value not multiple of gwei\\\");\\n\\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\\n    bytes32 signatureRoot = sha256(\\n      abi.encodePacked(\\n        sha256(BytesLib.slice(_signature, 0, 64)),\\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\\n      )\\n    );\\n\\n    bytes32 depositDataRoot = sha256(\\n      abi.encodePacked(\\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\\n        sha256(abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot))\\n      )\\n    );\\n\\n    return depositDataRoot;\\n  }\\n\\n  /**\\n   * @notice converts an address to withdrawal credential, used on validator creation\\n   */\\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\\n    uint256 w = 1 << 248;\\n\\n    return abi.encodePacked(bytes32(w) | bytes32(uint256(uint160(address(wcAddress)))));\\n  }\\n\\n  /**\\n   * @notice deposit to DEPOSIT_CONTRACT and initiate a validator.\\n   */\\n  function depositValidator(\\n    bytes calldata pubkey,\\n    bytes memory withdrawalCredential,\\n    bytes memory signature,\\n    uint256 amount\\n  ) internal {\\n    DEPOSIT_CONTRACT.deposit{value: amount}(\\n      pubkey,\\n      withdrawalCredential,\\n      signature,\\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0x71fa2b28cf5299abb9cfd8d7b8130c84f104b7a74d3ee2d6f5274e2fcc9a7ab2\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/InitiatorExtensionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// external - contracts\\nimport {Clones} from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {ERC1967Proxy} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n// internal - globals\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\n// internal - interfaces\\nimport {IgETHMiddleware} from \\\"../../../interfaces/middlewares/IgETHMiddleware.sol\\\";\\nimport {IGeodePackage} from \\\"../../../interfaces/packages/IGeodePackage.sol\\\";\\n// internal - structs\\nimport {DataStoreModuleStorage} from \\\"../../DataStoreModule/structs/storage.sol\\\";\\nimport {StakeModuleStorage} from \\\"../structs/storage.sol\\\";\\n// internal - libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {DepositContractLib as DCL} from \\\"./DepositContractLib.sol\\\";\\nimport {StakeModuleLib as SML} from \\\"./StakeModuleLib.sol\\\";\\n\\n/**\\n * @title IEL: Initiator Extension Library\\n *\\n * @notice An extension to SML.\\n * @notice This library is responsible from:\\n * * 1. Node Operator Initiator for permissioned IDs\\n * * 2. Configurable Staking Pools Initiator and its helpers.\\n * * 3. Bound Liquidity Pool deployment after pool initiation.\\n *\\n * @dev review: DataStoreModule for the id based isolated storage logic.\\n * @dev review: StakeModuleLib for base staking logic.\\n *\\n * @dev This library utilizes the '_authenticate' function on the external deployLiquidityPool,\\n *  Compared to gETHMiddleware(optional) and WithdrawalContract(mandatory), LP be activated after\\n * the pool initiation.\\n *\\n * @dev This is an external library, requires deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary InitiatorExtensionLib {\\n  using DSML for DataStoreModuleStorage;\\n  using SML for StakeModuleStorage;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event IdInitiated(uint256 id, uint256 indexed TYPE);\\n  event MiddlewareDeployed(uint256 poolId, uint256 version);\\n  event PackageDeployed(uint256 poolId, uint256 packageType, address instance);\\n\\n  /**\\n   * @custom:section                           ** OPERATOR INITIATOR **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice initiates ID as a Permissionned Node Operator\\n   * @notice requires ID to be approved as a node operator with a specific CONTROLLER\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%\\n   * @param validatorPeriod the expected maximum staking interval. This value should between\\n   * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above.\\n   * Operator can unstake at any given point before this period ends.\\n   * If operator disobeys this rule, it can be prisoned with blameProposal()\\n   * @param maintainer an address that automates daily operations, a script, a contract...\\n   * @dev operators can fund their internal wallet on initiation by simply sending some ether.\\n   */\\n  function initiateOperator(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external {\\n    require(DATASTORE.readUint(id, rks.initiated) == 0, \\\"SML:already initiated\\\");\\n    require(DATASTORE.readUint(id, rks.TYPE) == ID_TYPE.OPERATOR, \\\"SML:TYPE NOT allowed\\\");\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"SML:sender NOT CONTROLLER\\\");\\n\\n    DATASTORE.writeUint(id, rks.initiated, block.timestamp);\\n\\n    SML._setMaintenanceFee(DATASTORE, id, fee);\\n    SML._setValidatorPeriod(DATASTORE, id, validatorPeriod);\\n    SML._setMaintainer(DATASTORE, id, maintainer);\\n    SML._increaseWalletBalance(DATASTORE, id, msg.value);\\n\\n    emit IdInitiated(id, ID_TYPE.OPERATOR);\\n  }\\n\\n  /**\\n   * @custom:section                           ** STAKING POOL INITIATOR **\\n   *\\n   * @dev this section also contains the helper functions for packages and middlewares.\\n   */\\n\\n  /**\\n   * @notice Creates a Configurable Trustless Staking Pool!\\n   * @param fee as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%\\n   * @param middlewareVersion Pool creators can choose any allowed version as their gETHMiddleware\\n   * @param maintainer an address that automates daily operations, a script, a contract... not so critical.\\n   * @param name is utilized while generating an ID for the Pool, similar to any other ID generation.\\n   * @param middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\\n   * @param config array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]\\n   * @dev checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.\\n   * @dev requires exactly 1 validator worth of funds to be deposited on initiation, prevent sybil attacks.\\n   */\\n  function initiatePool(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 fee,\\n    uint256 middlewareVersion,\\n    address maintainer,\\n    bytes calldata name,\\n    bytes calldata middleware_data,\\n    bool[3] calldata config\\n  ) external returns (uint256 poolId) {\\n    require(msg.value == DCL.DEPOSIT_AMOUNT, \\\"SML:need 1 validator worth of funds\\\");\\n\\n    poolId = DSML.generateId(name, ID_TYPE.POOL);\\n    require(DATASTORE.readUint(poolId, rks.initiated) == 0, \\\"SML:already initiated\\\");\\n    require(poolId > 1e9, \\\"SML:Wow! Low pool id\\\");\\n\\n    DATASTORE.writeUint(poolId, rks.initiated, block.timestamp);\\n\\n    DATASTORE.writeUint(poolId, rks.TYPE, ID_TYPE.POOL);\\n    DATASTORE.writeAddress(poolId, rks.CONTROLLER, msg.sender);\\n    DATASTORE.writeBytes(poolId, rks.NAME, name);\\n    DATASTORE.allIdsByType[ID_TYPE.POOL].push(poolId);\\n\\n    SML._setMaintainer(DATASTORE, poolId, maintainer);\\n    SML._setMaintenanceFee(DATASTORE, poolId, fee);\\n\\n    // deploy a withdrawal Contract - mandatory\\n    _deployWithdrawalContract(self, DATASTORE, poolId);\\n\\n    if (config[0]) {\\n      // set pool to private\\n      SML.setPoolVisibility(DATASTORE, poolId, true);\\n    }\\n    if (config[1]) {\\n      // deploy a gETH middleware(erc20 etc.) - optional\\n      _deploygETHMiddleware(self, DATASTORE, poolId, middlewareVersion, middleware_data);\\n    }\\n    if (config[2]) {\\n      // deploy a bound liquidity pool - optional\\n      deployLiquidityPool(self, DATASTORE, poolId);\\n    }\\n\\n    // initially 1 ETHER = 1 ETHER\\n    self.gETH.setPricePerShare(1 ether, poolId);\\n\\n    // mint gETH and send back to the caller\\n    uint256 mintedgETH = SML._mintgETH(self, DATASTORE, poolId, msg.value);\\n    self.gETH.safeTransferFrom(address(this), msg.sender, poolId, mintedgETH, \\\"\\\");\\n\\n    emit IdInitiated(poolId, ID_TYPE.POOL);\\n  }\\n\\n  /**\\n   * @custom:section                           ** POOL INITIATOR HELPERS **\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** gETH MIDDLEWARES **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set a gETHMiddleware\\n   * @param _middleware address of the new gETHMiddleware for given ID\\n   * @dev every middleware has a unique index within the middlewares dynamic array.\\n   * @dev if ever unset, SHOULD replace the implementation with address(0) for obvious security reasons.\\n   */\\n  function _setgETHMiddleware(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    address _middleware\\n  ) internal {\\n    require(!self.gETH.isMiddleware(_middleware, id), \\\"SML:already middleware\\\");\\n\\n    DATASTORE.appendAddressArray(id, rks.middlewares, _middleware);\\n\\n    self.gETH.setMiddleware(_middleware, id, true);\\n  }\\n\\n  /**\\n   * @notice deploys a new gETHMiddleware by cloning (no upgradability)\\n   * @param _id gETH id, also required for IgETHMiddleware.initialize\\n   * @param _versionId provided version id, can use any as a middleware if allowed for TYPE = MIDDLEWARE_GETH\\n   * @param _middleware_data middlewares might require additional data on initialization; like name, symbol, etc.\\n   * @dev currrently, can NOT deploy a middleware after initiation, thus only used by the initiator.\\n   * @dev currrently, can NOT unset a middleware.\\n   */\\n  function _deploygETHMiddleware(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _versionId,\\n    bytes memory _middleware_data\\n  ) internal {\\n    require(_versionId > 0, \\\"SML:versionId cannot be 0\\\");\\n    require(self.middlewares[ID_TYPE.MIDDLEWARE_GETH][_versionId], \\\"SML:not a middleware\\\");\\n\\n    address newgETHMiddleware = Clones.clone(DATASTORE.readAddress(_versionId, rks.CONTROLLER));\\n\\n    IgETHMiddleware(newgETHMiddleware).initialize(_id, address(self.gETH), _middleware_data);\\n\\n    _setgETHMiddleware(self, DATASTORE, _id, newgETHMiddleware);\\n\\n    // isolate the contract from middleware risk for ID\\n    self.gETH.avoidMiddlewares(_id, true);\\n\\n    emit MiddlewareDeployed(_id, _versionId);\\n  }\\n\\n  /**\\n   * @notice deploys a new package for given id with given type from packages mapping.\\n   * @param _type given package type\\n   * @param _poolId pool id, required for IGeodePackage.initialize\\n   * @param _package_data packages might require additional data on initialization\\n   * @dev no cloning because GeodePackages has Limited Upgradability (based on UUPS)\\n   */\\n  function _deployGeodePackage(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _type,\\n    bytes memory _package_data\\n  ) internal returns (address packageInstance) {\\n    uint256 versionId = self.packages[_type];\\n    require(versionId > 0, \\\"SML:versionId cannot be 0\\\");\\n\\n    packageInstance = address(\\n      new ERC1967Proxy(DATASTORE.readAddress(versionId, rks.CONTROLLER), \\\"\\\")\\n    );\\n    // we don't call on deployment because initialize uses _getImplementation() which is not available\\n    IGeodePackage(packageInstance).initialize(\\n      _poolId,\\n      DATASTORE.readAddress(_poolId, rks.CONTROLLER),\\n      DATASTORE.readBytes(versionId, rks.NAME),\\n      _package_data\\n    );\\n\\n    emit PackageDeployed(_poolId, _type, packageInstance);\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** WITHDRAWAL CONTRACT **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Deploys a Withdrawal Contract that will be used as a withdrawal credential on validator creation\\n   * @dev every pool requires a Withdrawal Contract, thus this function is only used by the initiator\\n   */\\n  function _deployWithdrawalContract(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) internal {\\n    address wp = _deployGeodePackage(\\n      self,\\n      DATASTORE,\\n      _poolId,\\n      ID_TYPE.PACKAGE_WITHDRAWAL_CONTRACT,\\n      bytes(\\\"\\\")\\n    );\\n\\n    DATASTORE.writeAddress(_poolId, rks.withdrawalContract, wp);\\n    DATASTORE.writeBytes(_poolId, rks.withdrawalCredential, DCL.addressToWC(wp));\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** BOUND LIQUIDITY POOL **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n  /**\\n   * @notice deploys a bound liquidity pool for a staking pool.\\n   * @dev gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)\\n   * @dev unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well\\n   * @dev _package_data of a liquidity pool is only the staking pool's name, used on LPToken.\\n   */\\n  function _deployLiquidityPool(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public {\\n    address lp = _deployGeodePackage(\\n      self,\\n      DATASTORE,\\n      poolId,\\n      ID_TYPE.PACKAGE_LIQUIDITY_POOL,\\n      DATASTORE.readBytes(poolId, rks.NAME)\\n    );\\n\\n    DATASTORE.writeAddress(poolId, rks.liquidityPool, lp);\\n    // approve gETH so we can use it in buybacks\\n    self.gETH.setApprovalForAll(lp, true);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n  /**\\n   * @notice allows pools to deploy a Liquidity Pool after initiation, if it does not have one.\\n   */\\n  function deployLiquidityPool(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public {\\n    SML._authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(DATASTORE.readAddress(poolId, rks.liquidityPool) == address(0), \\\"SML:already deployed\\\");\\n\\n    _deployLiquidityPool(self, DATASTORE, poolId);\\n  }\\n}\\n\",\"keccak256\":\"0xac19f5fa2b4d3aec2933410383ae8a44b51cc56a178ce2614e47eaed4158112f\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/StakeModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - globals\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \\\"../../../globals/macros.sol\\\";\\nimport {VALIDATOR_STATE} from \\\"../../../globals/validator_state.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\n// internal - interfaces\\nimport {IgETH} from \\\"../../../interfaces/IgETH.sol\\\";\\nimport {IGeodePackage} from \\\"../../../interfaces/packages/IGeodePackage.sol\\\";\\nimport {ILiquidityPool} from \\\"../../../interfaces/packages/ILiquidityPool.sol\\\";\\nimport {IWhitelist} from \\\"../../../interfaces/helpers/IWhitelist.sol\\\";\\n// internal - structs\\nimport {DataStoreModuleStorage} from \\\"../../DataStoreModule/structs/storage.sol\\\";\\nimport {StakeModuleStorage} from \\\"../structs/storage.sol\\\";\\nimport {ConstantValidatorData} from \\\"../structs/helpers.sol\\\";\\nimport {Validator} from \\\"../structs/utils.sol\\\";\\n// internal - libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {DepositContractLib as DCL} from \\\"./DepositContractLib.sol\\\";\\n\\n/**\\n * @title SML: Stake Module Library (The Staking Library)\\n *\\n * @notice Creating a global standard for Staking, allowing anyone to OWN a trustless staking pool,\\n * improving the user experience for stakers and removing the \\\"need\\\" for centralized or decentralized intermediaries.\\n * * Exclusively contains functions related to:\\n * * 1. Pool and Operator management, after initiation (review IEL).\\n * * 2. Validator Delegation.\\n * * 3. Depositing.\\n * * 4. Staking Operations.\\n *\\n * @dev review: DataStoreModule for the id based isolated storage logic.\\n * @dev review: InitiatorExtensionLib for initiator functions.\\n * @dev review: OracleExtensionLib for oracle logic.\\n *\\n * @dev Every pool is isolated and every validator is unique. We segregate all the risk.\\n *\\n * @dev CONTROLLER and Maintainer:\\n * CONTROLLER is the owner of an ID, it manages the pool/operator. Its security is exteremely important.\\n * maintainer is the worker, can be used to automate some daily tasks:\\n * * distributing validators for Staking Pools or creating validators for Operators.\\n * * not so crucial in terms of security.\\n *\\n * @dev Users:\\n * Type 4 : Permissioned Operators\\n * * Needs to be onboarded by the Dual Governance (Senate + Governance).\\n * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\\n * * Can participate in the Operator Marketplace after initiation.\\n * * Can utilize maintainers for staking operations.\\n *\\n * Type 5 : Permissionless Configurable Staking Pools\\n * * Permissionless to create.\\n * * Can utilize powers of packages and middlewares such as Bound Liquidity Pools, gETHMiddlewares etc.\\n * * Can be public or private, can use a whitelist if private.\\n * * Can utilize maintainers for validator distribution on Operator Marketplace.\\n * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\\n * * accruing rewards and keeping Staked Ether safe and isolated.\\n *\\n * @dev Packages:\\n * An ID can only point to one version of a Package at a time.\\n * Built by utilizing the Modules!\\n * Can be upgraded by a dual governance, via pullUpgrade.\\n * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n *\\n * Type 10011 : Withdrawal Contract\\n * * Mandatory.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Staking Pools are in \\\"Isolation Mode\\\" until their Withdrawal Contract is upgraded.\\n * * * Meaning, no more Depositing or Validator Proposal can happen.\\n * * Custodian of the validator funds after creation, including any type of rewards and fees.\\n *\\n * Type 10021 : Liquidity Pool implementation\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Liquidity Pools are in \\\"Isolation Mode\\\" until upgraded.\\n *\\n * @dev Middlewares:\\n * Can support many different versions that can be utilized by the Pool Owners.\\n * No particular way to build one.\\n * Can not be upgraded.\\n * Currently only gETHMiddlewares.\\n *\\n * Type 20011 : gETHMiddleware\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Requires the approval of Senate\\n * * Currently should be utilized on initiation.\\n *\\n * @dev Contracts relying on this library must initialize StakeModuleLib.StakeModuleStorage\\n *\\n * @dev Functions are protected with authentication function\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary StakeModuleLib {\\n  using DSML for DataStoreModuleStorage;\\n\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  /// @notice limiting the GOVERNANCE_FEE to 5%\\n  uint256 internal constant MAX_POOL_INFRASTRUCTURE_FEE = (PERCENTAGE_DENOMINATOR * 5) / 100;\\n\\n  /// @notice starting time of the GOVERNANCE_FEE\\n  uint256 internal constant GOVERNANCE_FEE_COMMENCEMENT = 1714514461;\\n\\n  /// @notice limiting the pool and operator maintenance fee, 10%\\n  uint256 internal constant MAX_MAINTENANCE_FEE = (PERCENTAGE_DENOMINATOR * 10) / 100;\\n\\n  /// @notice effective on allowance per operator, prevents overflow. Exclusive, save gas with +1.\\n  uint256 internal constant MAX_ALLOWANCE = 1e6;\\n\\n  /// @notice price of gETH is only valid for 24H, minting is not allowed afterwards.\\n  uint256 internal constant PRICE_EXPIRY = 24 hours;\\n\\n  /// @notice ignoring any buybacks if the Liquidity Pool has a low debt\\n  uint256 internal constant IGNORABLE_DEBT = 1 ether;\\n\\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 2 years\\n  uint256 internal constant MIN_VALIDATOR_PERIOD = 3 * 30 days;\\n  uint256 internal constant MAX_VALIDATOR_PERIOD = 2 * 365 days;\\n\\n  /// @notice some parameter changes are effective after a delay\\n  uint256 internal constant SWITCH_LATENCY = 3 days;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event VisibilitySet(uint256 id, bool isPrivate);\\n  event YieldReceiverSet(uint256 indexed poolId, address yieldReceiver);\\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId, uint256 threshold);\\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\\n  event Stake(bytes[] pubkeys);\\n  event ExitRequest(bytes pubkey);\\n  event Exit(bytes pubkey);\\n\\n  /**\\n   * @custom:section                           ** AUTHENTICATION **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  /**\\n   * @notice restricts the access to given function based on TYPE and msg.sender\\n   * @param _expectCONTROLLER restricts the access to only CONTROLLER.\\n   * @param _expectMaintainer restricts the access to only maintainer.\\n   * @param _restrictionMap Restricts which TYPEs can pass the authentication.\\n   * * [0: Operator = TYPE(4), 1: Pool = TYPE(5)]\\n   * @dev can only be used after an ID is initiated\\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators can not access.\\n   */\\n  function _authenticate(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    bool _expectCONTROLLER,\\n    bool _expectMaintainer,\\n    bool[2] memory _restrictionMap\\n  ) internal view {\\n    require(DATASTORE.readUint(_id, rks.initiated) != 0, \\\"SML:not initiated\\\");\\n\\n    uint256 typeOfId = DATASTORE.readUint(_id, rks.TYPE);\\n\\n    if (typeOfId == ID_TYPE.OPERATOR) {\\n      require(_restrictionMap[0], \\\"SML:TYPE NOT allowed\\\");\\n      if (_expectCONTROLLER || _expectMaintainer) {\\n        require(!isPrisoned(DATASTORE, _id), \\\"SML:prisoned, get in touch with governance\\\");\\n      }\\n    } else if (typeOfId == ID_TYPE.POOL) {\\n      require(_restrictionMap[1], \\\"SML:TYPE NOT allowed\\\");\\n    } else {\\n      revert(\\\"SML:invalid TYPE\\\");\\n    }\\n\\n    if (_expectMaintainer) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.maintainer),\\n        \\\"SML:sender NOT maintainer\\\"\\n      );\\n      return;\\n    }\\n\\n    if (_expectCONTROLLER) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.CONTROLLER),\\n        \\\"SML:sender NOT CONTROLLER\\\"\\n      );\\n      return;\\n    }\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** POOL VISIBILITY **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice changes the visibility of the pool\\n   * @param makePrivate true if pool should be private, false for public pools\\n   * @dev whitelist is cleared when pool is set to public, to prevent legacy bugs if ever made private again.\\n   * Note private pools can whitelist addresses with the help of a third party contract.\\n   */\\n  function setPoolVisibility(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bool makePrivate\\n  ) public {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(makePrivate != isPrivatePool(DATASTORE, poolId), \\\"SML:already set\\\");\\n\\n    DATASTORE.writeUint(poolId, rks.privatePool, makePrivate ? 1 : 0);\\n\\n    if (!makePrivate) {\\n      DATASTORE.writeAddress(poolId, rks.whitelist, address(0));\\n    }\\n\\n    emit VisibilitySet(poolId, makePrivate);\\n  }\\n\\n  /**\\n   * @notice private pools can whitelist addresses with the help of a third party contract.\\n   * @dev Whitelisting contracts should implement IWhitelist interface.\\n   */\\n  function setWhitelist(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address whitelist\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(isPrivatePool(DATASTORE, poolId), \\\"SML:must be private pool\\\");\\n\\n    DATASTORE.writeAddress(poolId, rks.whitelist, whitelist);\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the pool is private\\n   */\\n  function isPrivatePool(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return (DATASTORE.readUint(poolId, rks.privatePool) == 1);\\n  }\\n\\n  /**\\n   * @notice checks if the Whitelist allows staker to use given private pool\\n   * @dev Owner of the pool doesn't need whitelisting\\n   * @dev Otherwise requires a whitelisting address to be set\\n   */\\n  function isWhitelisted(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address staker\\n  ) public view returns (bool) {\\n    if (DATASTORE.readAddress(poolId, rks.CONTROLLER) == staker) {\\n      return true;\\n    }\\n\\n    address whitelist = DATASTORE.readAddress(poolId, rks.whitelist);\\n    if (whitelist == address(0)) {\\n      return false;\\n    }\\n\\n    if (whitelist.code.length > 0) {\\n      try IWhitelist(whitelist).isAllowed(staker) returns (bool _isAllowed) {\\n        return _isAllowed;\\n      } catch {\\n        return false;\\n      }\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** ID MANAGEMENT **\\n   *\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** YIELD SEPARATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Set the yield receiver address to activate or deactivete yield separation logic.\\n   * * If set other than address(0) separation will be activated, if set back to address(0)\\n   * * separation will be deactivated again.\\n   * @param poolId the gETH id of the Pool\\n   * @param yieldReceiver address of the yield receiver\\n   * @dev Only CONTROLLER of pool can set yield receier.\\n   */\\n  function setYieldReceiver(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address yieldReceiver\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n\\n    DATASTORE.writeAddress(poolId, rks.yieldReceiver, yieldReceiver);\\n    emit YieldReceiverSet(poolId, yieldReceiver);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** MAINTAINER **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Set the maintainer address on initiation or later\\n   * @param _newMaintainer address of the new maintainer\\n   */\\n  function _setMaintainer(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    address _newMaintainer\\n  ) internal {\\n    require(_newMaintainer != address(0), \\\"SML:maintainer can NOT be zero\\\");\\n\\n    DATASTORE.writeAddress(_id, rks.maintainer, _newMaintainer);\\n    emit MaintainerChanged(_id, _newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\\n   * @dev there can only be 1 maintainer per ID.\\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\\n   * @dev we don't use _authenticate here because malicious maintainers can imprison operators\\n   * * and prevent them entering here, smh.\\n   */\\n  function changeMaintainer(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    address newMaintainer\\n  ) external {\\n    require(DATASTORE.readUint(id, rks.initiated) != 0, \\\"SML:ID is not initiated\\\");\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"SML:sender NOT CONTROLLER\\\");\\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\\n    require(typeOfId == ID_TYPE.OPERATOR || typeOfId == ID_TYPE.POOL, \\\"SML:invalid TYPE\\\");\\n\\n    _setMaintainer(DATASTORE, id, newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** FEE **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\\n   *\\n   * @dev respecs to the switching delay.\\n   *\\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\\n   */\\n  function getMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 fee) {\\n    if (DATASTORE.readUint(id, rks.feeSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorFee);\\n    }\\n    return DATASTORE.readUint(id, rks.fee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Set a fee (denominated in PERCENTAGE_DENOMINATOR) for any given TYPE.\\n   * @dev Changing the Staking Pool fee, only applies to the newly created validators.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   * @dev IMPORTANT! This function should be governed by a mechanism! It is not here!\\n   */\\n  function setInfrastructureFee(\\n    StakeModuleStorage storage self,\\n    uint256 _type,\\n    uint256 _fee\\n  ) external {\\n    require(_fee < PERCENTAGE_DENOMINATOR / 2, \\\"SML:> 50%\\\");\\n\\n    self.infrastructureFees[_type] = _fee;\\n  }\\n\\n  /**\\n   * @notice internal function to set fee with NO DELAY\\n   */\\n  function _setMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _newFee\\n  ) internal {\\n    require(_newFee <= MAX_MAINTENANCE_FEE, \\\"SML:> MAX_MAINTENANCE_FEE\\\");\\n    DATASTORE.writeUint(_id, rks.fee, _newFee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\\n   * @dev Can NOT be called again while its currently switching.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   */\\n  function switchMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 newFee\\n  ) external {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(block.timestamp > DATASTORE.readUint(id, rks.feeSwitch), \\\"SML:currently switching\\\");\\n\\n    DATASTORE.writeUint(id, rks.priorFee, DATASTORE.readUint(id, rks.fee));\\n    DATASTORE.writeUint(id, rks.feeSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setMaintenanceFee(DATASTORE, id, newFee);\\n\\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** INTERNAL WALLET **\\n   *\\n   * @dev Internal wallet of an ID accrues fees over time.\\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Simply increases the balance of an IDs Maintainer wallet\\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\\n   */\\n  function _increaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    DATASTORE.addUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @notice To decrease the balance of an Operator's wallet internally\\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\\n   */\\n  function _decreaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    require(DATASTORE.readUint(_id, rks.wallet) >= _value, \\\"SML:insufficient wallet balance\\\");\\n    DATASTORE.subUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice external function to increase the internal wallet balance\\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\\n   */\\n  function increaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, false, false, [true, true]);\\n    _increaseWalletBalance(DATASTORE, id, msg.value);\\n    success = true;\\n  }\\n\\n  /**\\n   * @notice external function to decrease the internal wallet balance\\n   * @dev only CONTROLLER can decrease the balance externally,\\n   * @return success if the amount was sent and deducted\\n   */\\n  function decreaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 value\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(address(this).balance >= value, \\\"SML:insufficient contract balance\\\");\\n\\n    _decreaseWalletBalance(DATASTORE, id, value);\\n    address controller = DATASTORE.readAddress(id, rks.CONTROLLER);\\n\\n    (success, ) = payable(controller).call{value: value}(\\\"\\\");\\n    require(success, \\\"SML:Failed to send ETH\\\");\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** OPERATORS PERIOD **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  function getValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 period) {\\n    if (DATASTORE.readUint(id, rks.periodSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorPeriod);\\n    }\\n    return DATASTORE.readUint(id, rks.validatorPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set validator period with NO DELAY\\n   */\\n  function _setValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    uint256 _newPeriod\\n  ) internal {\\n    require(_newPeriod >= MIN_VALIDATOR_PERIOD, \\\"SML:< MIN_VALIDATOR_PERIOD\\\");\\n    require(_newPeriod <= MAX_VALIDATOR_PERIOD, \\\"SML:> MAX_VALIDATOR_PERIOD\\\");\\n\\n    DATASTORE.writeUint(_operatorId, rks.validatorPeriod, _newPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\\n   */\\n  function switchValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId,\\n    uint256 newPeriod\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, true, false, [true, false]);\\n\\n    require(\\n      block.timestamp > DATASTORE.readUint(operatorId, rks.periodSwitch),\\n      \\\"SML:currently switching\\\"\\n    );\\n\\n    DATASTORE.writeUint(\\n      operatorId,\\n      rks.priorPeriod,\\n      DATASTORE.readUint(operatorId, rks.validatorPeriod)\\n    );\\n    DATASTORE.writeUint(operatorId, rks.periodSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\\n\\n    emit ValidatorPeriodSwitched(operatorId, newPeriod, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:section                           ** PRISON **\\n   *\\n   * @custom:visibility -> view-public\\n   * @dev check OEL.blameProposal and OEL.blameExit for imprisonment details\\n   */\\n\\n  /**\\n   * @notice Checks if the given operator is Prisoned\\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function isPrisoned(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId\\n  ) public view returns (bool) {\\n    return (block.timestamp < DATASTORE.readUint(operatorId, rks.release));\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR DELEGATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice maximum number of remaining operator allowance that the given Operator is allowed to create for given Pool\\n   * @dev an operator can not create new validators if:\\n   * * 1. operator is a monopoly\\n   * * 2. allowance is filled\\n   * * * But if operator is set as a fallback, it can if set fallbackThreshold is reached on all allowances.\\n   * @dev If operator withdraws a validator, then able to create a new one.\\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\\n   */\\n  function operatorAllowance(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId\\n  ) public view returns (uint256 remValidators) {\\n    // monopoly check\\n    {\\n      // readUint for an array gives us length\\n      uint256 numOperatorValidators = DATASTORE.readUint(operatorId, rks.validators);\\n      uint256 monopoly_threshold = self.MONOPOLY_THRESHOLD;\\n      if (numOperatorValidators >= monopoly_threshold) {\\n        return 0;\\n      } else {\\n        remValidators = monopoly_threshold - numOperatorValidators;\\n      }\\n    }\\n\\n    // fallback check\\n    {\\n      if (operatorId == DATASTORE.readUint(poolId, rks.fallbackOperator)) {\\n        // readUint for an array gives us length\\n        uint256 numPoolValidators = DATASTORE.readUint(poolId, rks.validators);\\n        uint256 totalAllowance = DATASTORE.readUint(poolId, rks.totalAllowance);\\n\\n        if (\\n          totalAllowance == 0 ||\\n          (((numPoolValidators * PERCENTAGE_DENOMINATOR) / totalAllowance) >=\\n            DATASTORE.readUint(poolId, rks.fallbackThreshold))\\n        ) {\\n          return remValidators;\\n        }\\n      }\\n    }\\n\\n    // approval check\\n    {\\n      uint256 allowance = DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.allowance));\\n      uint256 pooledValidators = DATASTORE.readUint(\\n        poolId,\\n        DSML.getKey(operatorId, rks.proposedValidators)\\n      ) + DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.activeValidators));\\n      if (pooledValidators >= allowance) {\\n        return 0;\\n      } else {\\n        uint256 remAllowance = allowance - pooledValidators;\\n        if (remValidators > remAllowance) {\\n          remValidators = remAllowance;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice To give allowence to node operator for a pool. It re-sets the allowance with the given value.\\n   * @dev The value that is returned is not the new allowance, but the old one since it is required\\n   * * at the point where it is being returned.\\n   * @return oldAllowance to be used later, nothing is done with it within this function.\\n   */\\n  function _approveOperator(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 allowance\\n  ) internal returns (uint256 oldAllowance) {\\n    bytes32 allowanceKey = DSML.getKey(operatorId, rks.allowance);\\n\\n    oldAllowance = DATASTORE.readUint(poolId, allowanceKey);\\n    DATASTORE.writeUint(poolId, allowanceKey, allowance);\\n\\n    emit Delegation(poolId, operatorId, allowance);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\\n   * * This number can be set again at any given point in the future.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorIds array of Operator IDs to allow them create validators\\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\\n   * @dev When decreased the approved validator count below current active+proposed validators,\\n   * operator can NOT create new validators.\\n   */\\n  function delegate(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n    uint256 operatorIdsLen = operatorIds.length;\\n    require(operatorIdsLen == allowances.length, \\\"SML:allowances should match\\\");\\n\\n    for (uint256 i; i < operatorIdsLen; ) {\\n      require(\\n        DATASTORE.readUint(operatorIds[i], rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:id not operator\\\"\\n      );\\n      require(allowances[i] <= MAX_ALLOWANCE, \\\"SML:> MAX_ALLOWANCE, set fallback\\\");\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    uint256 newCumulativeSubset;\\n    uint256 oldCumulativeSubset;\\n    for (uint256 i; i < operatorIdsLen; ) {\\n      newCumulativeSubset += allowances[i];\\n      oldCumulativeSubset += _approveOperator(DATASTORE, poolId, operatorIds[i], allowances[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    if (newCumulativeSubset > oldCumulativeSubset) {\\n      DATASTORE.addUint(poolId, rks.totalAllowance, newCumulativeSubset - oldCumulativeSubset);\\n    } else if (newCumulativeSubset < oldCumulativeSubset) {\\n      DATASTORE.subUint(poolId, rks.totalAllowance, oldCumulativeSubset - newCumulativeSubset);\\n    }\\n  }\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool without a limit\\n   * * after pool reaches a given treshold as percentage.\\n   * * fallback operator and percentage can be set again at any given point in the future.\\n   * * cannot set an operator as a fallback operator while it is currently in prison.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorId Operator ID to allow create validators\\n   * @param fallbackThreshold the percentage (with PERCENTAGE_DENOMINATOR) that fallback operator\\n   * * is activated for given Pool. Should not be greater than 100.\\n   */\\n  function setFallbackOperator(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n\\n    if (operatorId == 0) {\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, 0);\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, 0);\\n      emit FallbackOperator(poolId, 0, 0);\\n    } else {\\n      require(\\n        DATASTORE.readUint(operatorId, rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:fallback not operator\\\"\\n      );\\n\\n      require(\\n        fallbackThreshold <= PERCENTAGE_DENOMINATOR,\\n        \\\"SML:threshold cannot be greater than 100\\\"\\n      );\\n\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, fallbackThreshold);\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, operatorId);\\n\\n      emit FallbackOperator(poolId, operatorId, fallbackThreshold);\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** POOLING  **\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT HELPERS **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function _isGeodePackageIsolated(address _packageAddress) internal view returns (bool) {\\n    return IGeodePackage(_packageAddress).isolationMode();\\n  }\\n\\n  /**\\n   * @notice returns wrapped bound liquidity pool. If deployed, if not in isolationMode.\\n   * @dev returns address(0) if no pool or it is under isolation\\n   */\\n  function _getLiquidityPool(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) internal view returns (ILiquidityPool) {\\n    address liqPool = DATASTORE.readAddress(_poolId, rks.liquidityPool);\\n    if (liqPool == address(0)) {\\n      return ILiquidityPool(address(0));\\n    } else if (_isGeodePackageIsolated(liqPool)) {\\n      return ILiquidityPool(address(0));\\n    } else {\\n      return ILiquidityPool(liqPool);\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the price is valid:\\n   * - last price syncinc happened less than 24h\\n   * - there has been no oracle reports since the last update\\n   *\\n   * @dev known bug / feature: if there have been no oracle updates,\\n   * * this function will return true.\\n   *\\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\\n   *    : false\\n   */\\n  function isPriceValid(\\n    StakeModuleStorage storage self,\\n    uint256 poolId\\n  ) public view returns (bool isValid) {\\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\\n    unchecked {\\n      isValid =\\n        lastupdate + PRICE_EXPIRY >= block.timestamp &&\\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\\n    }\\n  }\\n\\n  /**\\n   * @notice checks if staking is allowed in given staking pool\\n   * @notice staking is not allowed if:\\n   * 1. Price is not valid\\n   * 2. WithdrawalContract is in Isolation Mode, can have many reasons\\n   */\\n  function isMintingAllowed(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return\\n      (isPriceValid(self, poolId)) &&\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract)));\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\\n   * @dev fails if minting is not allowed: invalid price, or isolationMode.\\n   */\\n  function _mintgETH(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _ethAmount\\n  ) internal returns (uint256 mintedgETH) {\\n    require(isMintingAllowed(self, DATASTORE, _poolId), \\\"SML:minting is not allowed\\\");\\n\\n    uint256 price = self.gETH.pricePerShare(_poolId);\\n    require(price > 0, \\\"SML:price is zero?\\\");\\n\\n    mintedgETH = (((_ethAmount * gETH_DENOMINATOR) / price));\\n    self.gETH.mint(address(this), _poolId, mintedgETH, \\\"\\\");\\n    DATASTORE.addUint(_poolId, rks.surplus, _ethAmount);\\n  }\\n\\n  /**\\n   * @notice conducts a buyback using the given liquidity pool\\n   * @param _poolId id of the gETH that will be bought\\n   * @param _maxEthToSell max ETH amount to sell in the liq pool\\n   * @param _deadline TX is expected to revert by Swap.sol if not meet\\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\\n   * as index 0 is ETH and index 1 is gETH!\\n   */\\n  function _buyback(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _maxEthToSell,\\n    uint256 _deadline\\n  ) internal returns (uint256 remETH, uint256 boughtgETH) {\\n    ILiquidityPool LP = _getLiquidityPool(DATASTORE, _poolId);\\n    // skip if no liquidity pool is found\\n    if (address(LP) != address(0)) {\\n      uint256 debt = LP.getDebt();\\n      // skip if debt is too low\\n      if (debt > IGNORABLE_DEBT) {\\n        if (_maxEthToSell > debt) {\\n          // if debt is lower, then only sell debt\\n          remETH = _maxEthToSell - debt;\\n        } else {\\n          // if eth is lower, then sell all eth, remETH already 0\\n          debt = _maxEthToSell;\\n        }\\n        // SWAP in LP\\n        boughtgETH = LP.swap{value: debt}(0, 1, debt, 0, _deadline);\\n      } else {\\n        remETH = _maxEthToSell;\\n      }\\n    } else {\\n      remETH = _maxEthToSell;\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Allowing users to deposit into a staking pool.\\n   * @notice If a pool is not public, only the controller and if there is a whitelist contract, the whitelisted addresses can deposit.\\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\\n   * @param mingETH liquidity pool parameter\\n   * @param deadline liquidity pool parameter\\n   * @dev an example for minting + buybacks\\n   * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\\n   * * debt  msgValue\\n   * * 100   10  => buyback\\n   * * 100   100 => buyback\\n   * * 10    100 => buyback + mint\\n   * * 1     x   => mint\\n   * * 0.5   x   => mint\\n   * * 0     x   => mint\\n   */\\n  function deposit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(msg.value > 0, \\\"SML:msg.value cannot be zero\\\");\\n    require(deadline > block.timestamp, \\\"SML:deadline not met\\\");\\n    require(receiver != address(0), \\\"SML:receiver is zero address\\\");\\n\\n    if (isPrivatePool(DATASTORE, poolId)) {\\n      require(isWhitelisted(DATASTORE, poolId, msg.sender), \\\"SML:sender NOT whitelisted\\\");\\n    }\\n\\n    uint256 remEth = msg.value;\\n    (remEth, boughtgETH) = _buyback(DATASTORE, poolId, remEth, deadline);\\n\\n    if (remEth > 0) {\\n      mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\\n    }\\n\\n    require(boughtgETH + mintedgETH >= mingETH, \\\"SML:less than minimum\\\");\\n\\n    // send back to user\\n    self.gETH.safeTransferFrom(address(this), receiver, poolId, boughtgETH + mintedgETH, \\\"\\\");\\n\\n    emit Deposit(poolId, boughtgETH, mintedgETH);\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR CREATION **\\n   *\\n   * @dev Creation of a Validator takes 2 steps: propose and beacon stake.\\n   * Before entering stake() function, _canStake verifies the eligibility of\\n   * given pubKey that is proposed by an operator with proposeStake function.\\n   * Eligibility is defined by an optimistic alienation, check OracleUtils._alienateValidator() for info.\\n   */\\n\\n  /**\\n   * @custom:visibility -> view\\n   */\\n\\n  /**\\n   * @notice internal function to check if a validator can use the pool funds\\n   *\\n   *  @param _pubkey BLS12-381 public key of the validator\\n   *  @return true if:\\n   *   - pubkey should be proposed\\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\\n   *   - the validator's index is already covered by VERIFICATION_INDEX. Updated by Telescope.\\n   */\\n  function _canStake(\\n    StakeModuleStorage storage self,\\n    bytes calldata _pubkey,\\n    uint256 _verificationIndex\\n  ) internal view returns (bool) {\\n    return\\n      (self.validators[_pubkey].state == VALIDATOR_STATE.PROPOSED) &&\\n      (self.validators[_pubkey].index <= _verificationIndex);\\n  }\\n\\n  /**\\n   * @notice external function to check if a validator can use the pool funds\\n   */\\n  function canStake(\\n    StakeModuleStorage storage self,\\n    bytes calldata pubkey\\n  ) external view returns (bool) {\\n    return _canStake(self, pubkey, self.VERIFICATION_INDEX);\\n  }\\n\\n  /**\\n   * @dev -> external\\n   */\\n\\n  /**\\n   * @notice Validator Credentials Proposal function, first step of crating validators.\\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\\n   * * it is optimistically allowed to take funds from staking pools.\\n   *\\n   * @param poolId the id of the staking pool\\n   * @param operatorId the id of the Operator whose maintainer calling this function\\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\\n   * maintainer balance\\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on stake() function call\\n   *\\n   * @dev DCL.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCL.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\\n   * 31 Ether will be staked after verification of oracles. 32 in total.\\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\\n   * @dev ProposeStake requires enough funds within Wallet.\\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 50)\\n   */\\n  function proposeStake(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external {\\n    // checks\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract))),\\n      \\\"SML:withdrawalContract is isolated\\\"\\n    );\\n\\n    uint256 pkLen = pubkeys.length;\\n\\n    require((pkLen > 0) && (pkLen <= DCL.MAX_DEPOSITS_PER_CALL), \\\"SML:1 - 50 validators\\\");\\n\\n    require(\\n      pkLen == signatures1.length && pkLen == signatures31.length,\\n      \\\"SML:invalid input length\\\"\\n    );\\n\\n    require(\\n      operatorAllowance(self, DATASTORE, poolId, operatorId) >= pkLen,\\n      \\\"SML:insufficient allowance\\\"\\n    );\\n\\n    require(\\n      DATASTORE.readUint(poolId, rks.surplus) >= DCL.DEPOSIT_AMOUNT * pkLen,\\n      \\\"SML:NOT enough surplus\\\"\\n    );\\n\\n    _decreaseWalletBalance(DATASTORE, operatorId, (pkLen * DCL.DEPOSIT_AMOUNT_PRESTAKE));\\n\\n    for (uint256 i; i < pkLen; ) {\\n      require(pubkeys[i].length == DCL.PUBKEY_LENGTH, \\\"SML:PUBKEY_LENGTH ERROR\\\");\\n      require(signatures1[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n      require(signatures31[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    ConstantValidatorData memory valData = ConstantValidatorData({\\n      index: uint64(self.VALIDATORS_INDEX + 1),\\n      period: uint64(getValidatorPeriod(DATASTORE, operatorId)),\\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\\n      infrastructureFee: self.infrastructureFees[ID_TYPE.POOL],\\n      withdrawalCredential: DATASTORE.readBytes(poolId, rks.withdrawalCredential)\\n    });\\n\\n    for (uint256 i; i < pkLen; ) {\\n      require(\\n        self.validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\\n        \\\"SML: used or alienated pk\\\"\\n      );\\n\\n      self.validators[pubkeys[i]] = Validator(\\n        VALIDATOR_STATE.PROPOSED,\\n        valData.index + uint64(i),\\n        uint64(block.timestamp),\\n        valData.period,\\n        poolId,\\n        operatorId,\\n        valData.poolFee,\\n        valData.operatorFee,\\n        valData.infrastructureFee,\\n        signatures31[i]\\n      );\\n\\n      DCL.depositValidator(\\n        pubkeys[i],\\n        valData.withdrawalCredential,\\n        signatures1[i],\\n        DCL.DEPOSIT_AMOUNT_PRESTAKE\\n      );\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    DATASTORE.subUint(poolId, rks.surplus, (pkLen * DCL.DEPOSIT_AMOUNT));\\n    DATASTORE.addUint(poolId, rks.secured, (pkLen * DCL.DEPOSIT_AMOUNT));\\n\\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), pkLen);\\n    DATASTORE.appendBytesArrayBatch(poolId, rks.validators, pubkeys);\\n    DATASTORE.appendBytesArrayBatch(operatorId, rks.validators, pubkeys);\\n\\n    self.VALIDATORS_INDEX += pkLen;\\n\\n    emit StakeProposal(poolId, operatorId, pubkeys);\\n  }\\n\\n  /**\\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\\n   *\\n   *  @param operatorId the id of the Operator whose maintainer calling this function\\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\\n   *\\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\\n   *  pk1, pk2, pk3 from pool1\\n   *  pk4, pk5 from pool2\\n   *  pk6 from pool3\\n   *  separate them in similar groups as much as possible.\\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 50)\\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\\n   */\\n  function stake(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n\\n    require(\\n      (pubkeys.length > 0) && (pubkeys.length <= DCL.MAX_DEPOSITS_PER_CALL),\\n      \\\"SML:1 - 50 validators\\\"\\n    );\\n\\n    {\\n      uint256 pubkeysLen = pubkeys.length;\\n      uint256 _verificationIndex = self.VERIFICATION_INDEX;\\n      for (uint256 j; j < pubkeysLen; ) {\\n        require(\\n          _canStake(self, pubkeys[j], _verificationIndex),\\n          \\\"SML:NOT all pubkeys are stakeable\\\"\\n        );\\n\\n        require(\\n          self.validators[pubkeys[j]].operatorId == operatorId,\\n          \\\"SML:NOT all pubkeys belong to operator\\\"\\n        );\\n\\n        unchecked {\\n          j += 1;\\n        }\\n      }\\n    }\\n\\n    {\\n      bytes32 activeValKey = DSML.getKey(operatorId, rks.activeValidators);\\n      bytes32 proposedValKey = DSML.getKey(operatorId, rks.proposedValidators);\\n      uint256 poolId = self.validators[pubkeys[0]].poolId;\\n      bytes memory withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n\\n      uint256 lastIdChange = 0;\\n      for (uint256 i; i < pubkeys.length; ) {\\n        uint256 newPoolId = self.validators[pubkeys[i]].poolId;\\n        if (poolId != newPoolId) {\\n          uint256 sinceLastIdChange;\\n\\n          unchecked {\\n            sinceLastIdChange = i - lastIdChange;\\n          }\\n\\n          DATASTORE.subUint(poolId, rks.secured, (DCL.DEPOSIT_AMOUNT * (sinceLastIdChange)));\\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n\\n          lastIdChange = i;\\n          poolId = newPoolId;\\n          withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n        }\\n\\n        DCL.depositValidator(\\n          pubkeys[i],\\n          withdrawalCredential,\\n          self.validators[pubkeys[i]].signature31,\\n          (DCL.DEPOSIT_AMOUNT - DCL.DEPOSIT_AMOUNT_PRESTAKE)\\n        );\\n\\n        self.validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\\n\\n        unchecked {\\n          i += 1;\\n        }\\n      }\\n      {\\n        uint256 sinceLastIdChange;\\n        unchecked {\\n          sinceLastIdChange = pubkeys.length - lastIdChange;\\n        }\\n\\n        DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT * (sinceLastIdChange));\\n        DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n        DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n      }\\n\\n      _increaseWalletBalance(DATASTORE, operatorId, DCL.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length);\\n\\n      emit Stake(pubkeys);\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR EXITS **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n    @notice todo\\n  */\\n  function requestExit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bytes calldata pk\\n  ) external {\\n    require(\\n      block.timestamp > self.validators[pk].createdAt + MIN_VALIDATOR_PERIOD,\\n      \\\"SML:early exit not allowed\\\"\\n    );\\n    require(\\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\\n      \\\"SML:sender is NOT withdrawal contract\\\"\\n    );\\n    require(self.validators[pk].poolId == poolId, \\\"SML:incorrect poolId\\\");\\n    require(self.validators[pk].state == VALIDATOR_STATE.ACTIVE, \\\"SML:not an active validator\\\");\\n\\n    self.validators[pk].state = VALIDATOR_STATE.EXIT_REQUESTED;\\n\\n    emit ExitRequest(pk);\\n  }\\n\\n  /**\\n    @notice todo\\n  */\\n  function finalizeExit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bytes calldata pk\\n  ) external {\\n    require(\\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\\n      \\\"SML:sender is NOT withdrawal contract\\\"\\n    );\\n    require(self.validators[pk].poolId == poolId, \\\"SML:incorrect poolId\\\");\\n\\n    uint256 state = self.validators[pk].state;\\n    require(\\n      state == VALIDATOR_STATE.ACTIVE || state == VALIDATOR_STATE.EXIT_REQUESTED,\\n      \\\"SML:not an active validator\\\"\\n    );\\n\\n    self.validators[pk].state = VALIDATOR_STATE.EXITED;\\n\\n    emit Exit(pk);\\n  }\\n}\\n\",\"keccak256\":\"0x61f6de29dd93f648ccf3129a761b5a87155647e9259a3c283c8bfa9ae82c16aa\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Helper Struct to pack constant data that does not change per validator on batch proposals\\n * * needed for that famous Solidity feature.\\n */\\nstruct ConstantValidatorData {\\n  uint64 index;\\n  uint64 period;\\n  uint256 poolFee;\\n  uint256 operatorFee;\\n  uint256 infrastructureFee;\\n  bytes withdrawalCredential;\\n}\\n\",\"keccak256\":\"0x8286f4ad690287eafbab5c63f0fc4716dd00faac4a378a449feda104d50a9f5c\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - interfaces\\nimport {IgETH} from \\\"../../../interfaces/IgETH.sol\\\";\\n// internal - structs\\nimport {Validator} from \\\"./utils.sol\\\";\\n\\n/**\\n * @notice Storage struct for the Pooled Liquid Staking logic\\n * @param gETH constant, ERC1155, all Geode Staking Derivatives.\\n * @param ORACLE_POSITION constant, address of the Oracle https://github.com/Geodefi/Telescope-Eth\\n * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\\n * * Includes all validators: proposed, active, alienated, exited.\\n * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\\n * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\\n * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\\n * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval, per second.\\n * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval, per second.\\n * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, updated by the Holy Oracle.\\n * @param GOVERNANCE_FEE **reserved** Although it is 0 right now, It can be updated in the future.\\n * @param BALANCE_MERKLE_ROOT merkle root of the balances and other validator related data, useful on withdrawals, updated by the Holy Oracle.\\n * @param validators pubkey => Validator, contains all the data about proposed, alienated, active, exit-called and fully exited validators.\\n * @param packages TYPE => version id, pointing to the latest versions of the given package.\\n * * Like default Withdrawal Contract version.\\n * @param middlewares TYPE => version id => isAllowed, useful to check if given version of the middleware can be used.\\n * * Like all the whitelisted gETHMiddlewares.\\n * @param fees TYPE->PERCENTAGE, we can set a fee for any defined TYPE then use it in related operations.\\n * * POOL type sets validator fees. Liqudity Pool Package type sets fee on swaps.\\n *\\n * @dev normally we would put custom:storage-location erc7201:geode.storage.StakeModule\\n * but compiler throws an error... So np for now, just MAKE SURE.\\n **/\\nstruct StakeModuleStorage {\\n  IgETH gETH;\\n  address ORACLE_POSITION;\\n  uint256 VALIDATORS_INDEX;\\n  uint256 VERIFICATION_INDEX;\\n  uint256 MONOPOLY_THRESHOLD;\\n  uint256 ORACLE_UPDATE_TIMESTAMP;\\n  uint256 DAILY_PRICE_INCREASE_LIMIT;\\n  uint256 DAILY_PRICE_DECREASE_LIMIT;\\n  bytes32 PRICE_MERKLE_ROOT;\\n  bytes32 BALANCE_MERKLE_ROOT;\\n  mapping(bytes => Validator) validators;\\n  mapping(uint256 => uint256) packages;\\n  mapping(uint256 => mapping(uint256 => bool)) middlewares;\\n  mapping(uint256 => uint256) infrastructureFees;\\n}\\n\",\"keccak256\":\"0x828f71aec64e4b6cec7de0ef7de7d5c4f89487dca524c50a9b03f771980520d2\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @param state state of the validator, refer to globals.sol\\n * @param index representing this validator's placement on the chronological order of the validators proposals\\n * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\\n * @param period the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\\n * @param poolId needed for withdrawal_credential\\n * @param operatorId needed for staking after allowance\\n * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\\n * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\\n * @param infrastructureFee all fees are crucial for the price calculation by the oracle, even if its zero.\\n * @param signature31 BLS12-381 signature for the validator, used when the remaining 31 ETH is sent on validator activation.\\n **/\\nstruct Validator {\\n  uint64 state;\\n  uint64 index;\\n  uint64 createdAt;\\n  uint64 period;\\n  uint256 poolId;\\n  uint256 operatorId;\\n  uint256 poolFee;\\n  uint256 operatorFee;\\n  uint256 infrastructureFee;\\n  bytes signature31;\\n}\\n\",\"keccak256\":\"0xbbd41f0da602f5bc6cfd7ff7d4feec259d3266f87c711a5c16070d529da441e6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6122de61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106200005b5760003560e01c806325d41ea514620000605780632e072813146200008757806361e5c12314620000ac578063fdccde5314620000d1575b600080fd5b8180156200006d57600080fd5b50620000856200007f36600462001994565b62000108565b005b8180156200009457600080fd5b5062000085620000a6366004620019e0565b620002ab565b818015620000b957600080fd5b5062000085620000cb366004620019e0565b62000353565b818015620000de57600080fd5b50620000f6620000f036600462001a59565b62000407565b60405190815260200160405180910390f35b620001218585681a5b9a5d1a585d195960ba1b620008ac565b156200016c5760405162461bcd60e51b815260206004820152601560248201527414d3530e985b1c9958591e481a5b9a5d1a585d1959605a1b60448201526064015b60405180910390fd5b6004620001828686635459504560e01b620008ac565b14620001a25760405162461bcd60e51b8152600401620001639062001b23565b620001bc85856921a7a72a2927a62622a960b11b620008d8565b6001600160a01b0316336001600160a01b0316146200021a5760405162461bcd60e51b815260206004820152601960248201527829a6a61d39b2b73232b9102727aa1021a7a72a2927a62622a960391b604482015260640162000163565b620002348585681a5b9a5d1a585d195960ba1b426200090e565b6200024185858562000938565b6200024e858584620009bd565b6200025b85858362000a88565b6200026885853462000b3e565b60047f7b7905d4bbb05d33c55d852740a9c6ad7023620601ab2abb79f1839fc8e0a5fb856040516200029c91815260200190565b60405180910390a25050505050565b604080518082019091526000808252600160208301819052620002d392859285929162000b55565b6000620002f283836c1b1a5c5d5a591a5d1e541bdbdb609a1b620008d8565b6001600160a01b031614620003415760405162461bcd60e51b815260206004820152601460248201527314d3530e985b1c9958591e4819195c1b1bde595960621b604482015260640162000163565b6200034e83838362000353565b505050565b600062000379848484612725620003738383634e414d4560e01b62000df4565b62000eb0565b90506200039983836c1b1a5c5d5a591a5d1e541bdbdb609a1b846200105a565b835460405163a22cb46560e01b81526001600160a01b038381166004830152600160248301529091169063a22cb465906044015b600060405180830381600087803b158015620003e857600080fd5b505af1158015620003fd573d6000803e3d6000fd5b5050505050505050565b60006801bc16d674ec80000034146200046f5760405162461bcd60e51b815260206004820152602360248201527f534d4c3a6e65656420312076616c696461746f7220776f727468206f662066756044820152626e647360e81b606482015260840162000163565b620004b386868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525060059250620010a5915050565b9050620004ce8a82681a5b9a5d1a585d195960ba1b620008ac565b15620005155760405162461bcd60e51b815260206004820152601560248201527414d3530e985b1c9958591e481a5b9a5d1a585d1959605a1b604482015260640162000163565b633b9aca008111620005615760405162461bcd60e51b815260206004820152601460248201527314d3530e95dbddc848131bddc81c1bdbdb081a5960621b604482015260640162000163565b6200057b8a82681a5b9a5d1a585d195960ba1b426200090e565b620005918a82635459504560e01b60056200090e565b620005ac8a826921a7a72a2927a62622a960b11b336200105a565b6200061081634e414d4560e01b88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508d620010db909392919063ffffffff16565b6005600090815260208b81526040822080546001810182559083529120018190556200063e8a828962000a88565b6200064b8a828b62000938565b620006588b8b836200110a565b62000667602083018362001b63565b15620006e157604051633d363e5960e01b8152600481018b9052602481018290526001604482015273485a3161a9Dbec8c7EeA0F4F3DF13b9385Ceff8390633d363e599060640160006040518083038186803b158015620006c757600080fd5b505af4158015620006dc573d6000803e3d6000fd5b505050505b620006f3604083016020840162001b63565b156200073e576200073e8b8b838b88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250620011b492505050565b62000750606083016040840162001b63565b156200076357620007638b8b83620002ab565b8a546040516322af599760e01b8152670de0b6b3a76400006004820152602481018390526001600160a01b03909116906322af599790604401600060405180830381600087803b158015620007b757600080fd5b505af1158015620007cc573d6000803e3d6000fd5b505050506000620007e08c8c8434620013b2565b8c54604051637921219560e11b8152306004820152336024820152604481018590526064810183905260a06084820152600060a48201529192506001600160a01b03169063f242432a9060c401600060405180830381600087803b1580156200084857600080fd5b505af11580156200085d573d6000803e3d6000fd5b5050505060057f7b7905d4bbb05d33c55d852740a9c6ad7023620601ab2abb79f1839fc8e0a5fb836040516200089591815260200190565b60405180910390a2509a9950505050505050505050565b6000836001016000620008c0858562001588565b81526020019081526020016000205490509392505050565b6000836003016000620008ec858562001588565b81526020810191909152604001600020546001600160a01b0316949350505050565b8084600101600062000921868662001588565b815260208101919091526040016000205550505050565b60646200094c6402540be400600a62001ba0565b62000958919062001bba565b811115620009a95760405162461bcd60e51b815260206004820152601960248201527f534d4c3a3e204d41585f4d41494e54454e414e43455f46454500000000000000604482015260640162000163565b6200034e83836266656560e81b846200090e565b6276a70081101562000a125760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a3c204d494e5f56414c494441544f525f504552494f44000000000000604482015260640162000163565b6303c2670081111562000a685760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a3e204d41585f56414c494441544f525f504552494f44000000000000604482015260640162000163565b6200034e83836e1d985b1a59185d1bdc94195c9a5bd9608a1b846200090e565b6001600160a01b03811662000ae05760405162461bcd60e51b815260206004820152601e60248201527f534d4c3a6d61696e7461696e65722063616e204e4f54206265207a65726f0000604482015260640162000163565b62000afb83836936b0b4b73a30b4b732b960b11b846200105a565b6040516001600160a01b038216815282907f72774bc96991002276ea2f17557bc24e67733a3dcf2e8b390d38921daab1ab319060200160405180910390a2505050565b6200034e8383651dd85b1b195d60d21b84620015b4565b62000b6e8585681a5b9a5d1a585d195960ba1b620008ac565b60000362000bb35760405162461bcd60e51b815260206004820152601160248201527014d3530e9b9bdd081a5b9a5d1a585d1959607a1b604482015260640162000163565b600062000bc98686635459504560e01b620008ac565b90506004810362000c7957815162000bf55760405162461bcd60e51b8152600401620001639062001b23565b838062000bff5750825b1562000c735762000c118686620015f1565b1562000c735760405162461bcd60e51b815260206004820152602a60248201527f534d4c3a707269736f6e65642c2067657420696e20746f756368207769746820604482015269676f7665726e616e636560b01b606482015260840162000163565b62000ce2565b6005810362000ca657602082015162000c735760405162461bcd60e51b8152600401620001639062001b23565b60405162461bcd60e51b815260206004820152601060248201526f534d4c3a696e76616c6964205459504560801b604482015260640162000163565b821562000d6c5762000d0386866936b0b4b73a30b4b732b960b11b620008d8565b6001600160a01b0316336001600160a01b03161462000d655760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572204e4f54206d61696e7461696e657200000000000000604482015260640162000163565b5062000ded565b831562000deb5762000d8d86866921a7a72a2927a62622a960b11b620008d8565b6001600160a01b0316336001600160a01b03161462000d655760405162461bcd60e51b815260206004820152601960248201527829a6a61d39b2b73232b9102727aa1021a7a72a2927a62622a960391b604482015260640162000163565b505b5050505050565b606083600201600062000e08858562001588565b8152602001908152602001600020805462000e239062001bdd565b80601f016020809104026020016040519081016040528092919081815260200182805462000e519062001bdd565b801562000ea25780601f1062000e765761010080835404028352916020019162000ea2565b820191906000526020600020905b81548152906001019060200180831162000e8457829003601f168201915b505050505090509392505050565b6000828152600b860160205260408120548062000f0c5760405162461bcd60e51b81526020600482015260196024820152780534d4c3a76657273696f6e49642063616e6e6f74206265203603c1b604482015260640162000163565b62000f2686826921a7a72a2927a62622a960b11b620008d8565b60405162000f34906200196e565b6001600160a01b039091168152604060208201819052600090820152606001604051809103906000f08015801562000f70573d6000803e3d6000fd5b5091506001600160a01b038216639934b2818662000f9d89826921a7a72a2927a62622a960b11b620008d8565b62000fb18a86634e414d4560e01b62000df4565b876040518563ffffffff1660e01b815260040162000fd3949392919062001c61565b600060405180830381600087803b15801562000fee57600080fd5b505af115801562001003573d6000803e3d6000fd5b505060408051888152602081018890526001600160a01b0386168183015290517f89288ba00d4e2e012af872098d4fee07191e810d8c739b7cf1e842e0370888729350908190036060019150a15095945050505050565b808460030160006200106d868662001588565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b0316021790555050505050565b60008282604051602001620010bc92919062001cac565b60408051601f1981840301815291905280516020909101209392505050565b80846002016000620010ee868662001588565b8152602001908152602001600020908162000ded919062001d30565b60006200112c84848461271b6040518060200160405280600081525062000eb0565b9050620011518383711dda5d1a191c985dd85b10dbdb9d1c9858dd60721b846200105a565b620011ae82731dda5d1a191c985dd85b10dc9959195b9d1a585b60621b620011a484604080516001600160a01b0392909216600160f81b1760208084019190915281518084039091018152918101905290565b86929190620010db565b50505050565b60008211620012025760405162461bcd60e51b81526020600482015260196024820152780534d4c3a76657273696f6e49642063616e6e6f74206265203603c1b604482015260640162000163565b614e2b6000908152600c86016020908152604080832085845290915290205460ff16620012695760405162461bcd60e51b8152602060048201526014602482015273534d4c3a6e6f742061206d6964646c657761726560601b604482015260640162000163565b60006200128f6200128986856921a7a72a2927a62622a960b11b620008d8565b62001615565b8654604051637104db2360e11b81529192506001600160a01b038084169263e209b64692620012c8928992911690879060040162001dfd565b600060405180830381600087803b158015620012e357600080fd5b505af1158015620012f8573d6000803e3d6000fd5b505050506200130a8686868462001688565b8554604051630492f6e160e01b815260048101869052600160248201526001600160a01b0390911690630492f6e190604401600060405180830381600087803b1580156200135757600080fd5b505af11580156200136c573d6000803e3d6000fd5b505060408051878152602081018790527f49e0747139b3dca64314df382ec23da37e088325f877ecf4539d72357349e5a6935001905060405180910390a1505050505050565b6000620013c1858585620017a3565b6200140f5760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a6d696e74696e67206973206e6f7420616c6c6f776564000000000000604482015260640162000163565b845460405163f759cc3b60e01b8152600481018590526000916001600160a01b03169063f759cc3b90602401602060405180830381865afa15801562001459573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200147f919062001e32565b905060008111620014c85760405162461bcd60e51b8152602060048201526012602482015271534d4c3a7072696365206973207a65726f3f60701b604482015260640162000163565b80620014dd670de0b6b3a76400008562001ba0565b620014e9919062001bba565b865460405163731133e960e01b8152306004820152602481018790526044810183905260806064820152600060848201529193506001600160a01b03169063731133e99060a401600060405180830381600087803b1580156200154b57600080fd5b505af115801562001560573d6000803e3d6000fd5b506200157f925087915086905066737572706c757360c81b86620015b4565b50949350505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b80846001016000620015c7868662001588565b81526020019081526020016000206000828254620015e6919062001e4c565b909155505050505050565b60006200160a83836672656c6561736560c81b620008ac565b421090505b92915050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b03811662001683576040516330be1a3d60e21b815260040160405180910390fd5b919050565b8354604051634d280a5560e01b81526001600160a01b0383811660048301526024820185905290911690634d280a5590604401602060405180830381865afa158015620016d9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620016ff919062001e62565b15620017475760405162461bcd60e51b8152602060048201526016602482015275534d4c3a616c7265616479206d6964646c657761726560501b604482015260640162000163565b6200176383836a6d6964646c65776172657360a81b84620017ef565b8354604051632895f3cb60e11b81526001600160a01b03838116600483015260248201859052600160448301529091169063512be79690606401620003cd565b6000620017b1848362001870565b8015620017e75750620017e5620017df8484711dda5d1a191c985dd85b10dbdb9d1c9858dd60721b620008d8565b62001907565b155b949350505050565b6000620017fd848462001588565b6000818152600187016020526040812080549293508492600389019291620018379190836200182c8362001e82565b919050558562001588565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055505050505050565b815460405163908d67ed60e01b81526004810183905260009182916001600160a01b039091169063908d67ed90602401602060405180830381865afa158015620018be573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620018e4919062001e32565b90504262015180820110158015620017e757508360050154811015949350505050565b6000816001600160a01b0316638650c0726040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001948573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200160f919062001e62565b61040a8062001e9f83390190565b80356001600160a01b03811681146200168357600080fd5b600080600080600060a08688031215620019ad57600080fd5b85359450602086013593506040860135925060608601359150620019d4608087016200197c565b90509295509295909350565b600080600060608486031215620019f657600080fd5b505081359360208301359350604090920135919050565b60008083601f84011262001a2057600080fd5b50813567ffffffffffffffff81111562001a3957600080fd5b60208301915083602082850101111562001a5257600080fd5b9250929050565b6000806000806000806000806000806101408b8d03121562001a7a57600080fd5b8a35995060208b0135985060408b0135975060608b0135965062001aa160808c016200197c565b955060a08b013567ffffffffffffffff8082111562001abf57600080fd5b62001acd8e838f0162001a0d565b909750955060c08d013591508082111562001ae757600080fd5b5062001af68d828e0162001a0d565b9094509250506101408b018c101562001b0e57600080fd5b60e08b0190509295989b9194979a5092959850565b60208082526014908201527314d3530e95165411481393d508185b1b1bddd95960621b604082015260600190565b801515811462001b6057600080fd5b50565b60006020828403121562001b7657600080fd5b813562001b838162001b51565b9392505050565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176200160f576200160f62001b8a565b60008262001bd857634e487b7160e01b600052601260045260246000fd5b500490565b600181811c9082168062001bf257607f821691505b60208210810362001c1357634e487b7160e01b600052602260045260246000fd5b50919050565b6000815180845260005b8181101562001c415760208185018101518683018201520162001c23565b506000602082860101526020601f19601f83011685010191505092915050565b8481526001600160a01b038416602082015260806040820181905260009062001c8d9083018562001c19565b828103606084015262001ca1818562001c19565b979650505050505050565b60408152600062001cc1604083018562001c19565b90508260208301529392505050565b634e487b7160e01b600052604160045260246000fd5b601f8211156200034e57600081815260208120601f850160051c8101602086101562001d0f5750805b601f850160051c820191505b8181101562000deb5782815560010162001d1b565b815167ffffffffffffffff81111562001d4d5762001d4d62001cd0565b62001d658162001d5e845462001bdd565b8462001ce6565b602080601f83116001811462001d9d576000841562001d845750858301515b600019600386901b1c1916600185901b17855562000deb565b600085815260208120601f198616915b8281101562001dce5788860151825594840194600190910190840162001dad565b508582101562001ded5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b8381526001600160a01b038316602082015260606040820181905260009062001e299083018462001c19565b95945050505050565b60006020828403121562001e4557600080fd5b5051919050565b808201808211156200160f576200160f62001b8a565b60006020828403121562001e7557600080fd5b815162001b838162001b51565b60006001820162001e975762001e9762001b8a565b506001019056fe608060405260405161040a38038061040a83398101604081905261002291610268565b61002c8282610033565b5050610352565b61003c82610092565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a280511561008657610081828261010e565b505050565b61008e610185565b5050565b806001600160a01b03163b6000036100cd57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060600080846001600160a01b03168460405161012b9190610336565b600060405180830381855af49150503d8060008114610166576040519150601f19603f3d011682016040523d82523d6000602084013e61016b565b606091505b50909250905061017c8583836101a6565b95945050505050565b34156101a45760405163b398979f60e01b815260040160405180910390fd5b565b6060826101bb576101b682610205565b6101fe565b81511580156101d257506001600160a01b0384163b155b156101fb57604051639996b31560e01b81526001600160a01b03851660048201526024016100c4565b50805b9392505050565b8051156102155780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025f578181015183820152602001610247565b50506000910152565b6000806040838503121561027b57600080fd5b82516001600160a01b038116811461029257600080fd5b60208401519092506001600160401b03808211156102af57600080fd5b818501915085601f8301126102c357600080fd5b8151818111156102d5576102d561022e565b604051601f8201601f19908116603f011681019083821181831017156102fd576102fd61022e565b8160405282815288602084870101111561031657600080fd5b610327836020830160208801610244565b80955050505050509250929050565b60008251610348818460208701610244565b9190910192915050565b60aa806103606000396000f3fe6080604052600a600c565b005b60186014601a565b6051565b565b6000604c7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e808015606f573d6000f35b3d6000fdfea2646970667358221220f038e5386f37d7c294910e36c8834558bc963a25cf018593b31ef79e0554f56964736f6c63430008140033a26469706673582212200fc2b2f5466a4d1d635a04efef2f9a864179b509ebb3c9dfb98bae67bd5b467a64736f6c63430008140033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106200005b5760003560e01c806325d41ea514620000605780632e072813146200008757806361e5c12314620000ac578063fdccde5314620000d1575b600080fd5b8180156200006d57600080fd5b50620000856200007f36600462001994565b62000108565b005b8180156200009457600080fd5b5062000085620000a6366004620019e0565b620002ab565b818015620000b957600080fd5b5062000085620000cb366004620019e0565b62000353565b818015620000de57600080fd5b50620000f6620000f036600462001a59565b62000407565b60405190815260200160405180910390f35b620001218585681a5b9a5d1a585d195960ba1b620008ac565b156200016c5760405162461bcd60e51b815260206004820152601560248201527414d3530e985b1c9958591e481a5b9a5d1a585d1959605a1b60448201526064015b60405180910390fd5b6004620001828686635459504560e01b620008ac565b14620001a25760405162461bcd60e51b8152600401620001639062001b23565b620001bc85856921a7a72a2927a62622a960b11b620008d8565b6001600160a01b0316336001600160a01b0316146200021a5760405162461bcd60e51b815260206004820152601960248201527829a6a61d39b2b73232b9102727aa1021a7a72a2927a62622a960391b604482015260640162000163565b620002348585681a5b9a5d1a585d195960ba1b426200090e565b6200024185858562000938565b6200024e858584620009bd565b6200025b85858362000a88565b6200026885853462000b3e565b60047f7b7905d4bbb05d33c55d852740a9c6ad7023620601ab2abb79f1839fc8e0a5fb856040516200029c91815260200190565b60405180910390a25050505050565b604080518082019091526000808252600160208301819052620002d392859285929162000b55565b6000620002f283836c1b1a5c5d5a591a5d1e541bdbdb609a1b620008d8565b6001600160a01b031614620003415760405162461bcd60e51b815260206004820152601460248201527314d3530e985b1c9958591e4819195c1b1bde595960621b604482015260640162000163565b6200034e83838362000353565b505050565b600062000379848484612725620003738383634e414d4560e01b62000df4565b62000eb0565b90506200039983836c1b1a5c5d5a591a5d1e541bdbdb609a1b846200105a565b835460405163a22cb46560e01b81526001600160a01b038381166004830152600160248301529091169063a22cb465906044015b600060405180830381600087803b158015620003e857600080fd5b505af1158015620003fd573d6000803e3d6000fd5b5050505050505050565b60006801bc16d674ec80000034146200046f5760405162461bcd60e51b815260206004820152602360248201527f534d4c3a6e65656420312076616c696461746f7220776f727468206f662066756044820152626e647360e81b606482015260840162000163565b620004b386868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525060059250620010a5915050565b9050620004ce8a82681a5b9a5d1a585d195960ba1b620008ac565b15620005155760405162461bcd60e51b815260206004820152601560248201527414d3530e985b1c9958591e481a5b9a5d1a585d1959605a1b604482015260640162000163565b633b9aca008111620005615760405162461bcd60e51b815260206004820152601460248201527314d3530e95dbddc848131bddc81c1bdbdb081a5960621b604482015260640162000163565b6200057b8a82681a5b9a5d1a585d195960ba1b426200090e565b620005918a82635459504560e01b60056200090e565b620005ac8a826921a7a72a2927a62622a960b11b336200105a565b6200061081634e414d4560e01b88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508d620010db909392919063ffffffff16565b6005600090815260208b81526040822080546001810182559083529120018190556200063e8a828962000a88565b6200064b8a828b62000938565b620006588b8b836200110a565b62000667602083018362001b63565b15620006e157604051633d363e5960e01b8152600481018b9052602481018290526001604482015273__$c6d91ac6527b4f29f5b2ff90afd2bb0508$__90633d363e599060640160006040518083038186803b158015620006c757600080fd5b505af4158015620006dc573d6000803e3d6000fd5b505050505b620006f3604083016020840162001b63565b156200073e576200073e8b8b838b88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250620011b492505050565b62000750606083016040840162001b63565b156200076357620007638b8b83620002ab565b8a546040516322af599760e01b8152670de0b6b3a76400006004820152602481018390526001600160a01b03909116906322af599790604401600060405180830381600087803b158015620007b757600080fd5b505af1158015620007cc573d6000803e3d6000fd5b505050506000620007e08c8c8434620013b2565b8c54604051637921219560e11b8152306004820152336024820152604481018590526064810183905260a06084820152600060a48201529192506001600160a01b03169063f242432a9060c401600060405180830381600087803b1580156200084857600080fd5b505af11580156200085d573d6000803e3d6000fd5b5050505060057f7b7905d4bbb05d33c55d852740a9c6ad7023620601ab2abb79f1839fc8e0a5fb836040516200089591815260200190565b60405180910390a2509a9950505050505050505050565b6000836001016000620008c0858562001588565b81526020019081526020016000205490509392505050565b6000836003016000620008ec858562001588565b81526020810191909152604001600020546001600160a01b0316949350505050565b8084600101600062000921868662001588565b815260208101919091526040016000205550505050565b60646200094c6402540be400600a62001ba0565b62000958919062001bba565b811115620009a95760405162461bcd60e51b815260206004820152601960248201527f534d4c3a3e204d41585f4d41494e54454e414e43455f46454500000000000000604482015260640162000163565b6200034e83836266656560e81b846200090e565b6276a70081101562000a125760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a3c204d494e5f56414c494441544f525f504552494f44000000000000604482015260640162000163565b6303c2670081111562000a685760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a3e204d41585f56414c494441544f525f504552494f44000000000000604482015260640162000163565b6200034e83836e1d985b1a59185d1bdc94195c9a5bd9608a1b846200090e565b6001600160a01b03811662000ae05760405162461bcd60e51b815260206004820152601e60248201527f534d4c3a6d61696e7461696e65722063616e204e4f54206265207a65726f0000604482015260640162000163565b62000afb83836936b0b4b73a30b4b732b960b11b846200105a565b6040516001600160a01b038216815282907f72774bc96991002276ea2f17557bc24e67733a3dcf2e8b390d38921daab1ab319060200160405180910390a2505050565b6200034e8383651dd85b1b195d60d21b84620015b4565b62000b6e8585681a5b9a5d1a585d195960ba1b620008ac565b60000362000bb35760405162461bcd60e51b815260206004820152601160248201527014d3530e9b9bdd081a5b9a5d1a585d1959607a1b604482015260640162000163565b600062000bc98686635459504560e01b620008ac565b90506004810362000c7957815162000bf55760405162461bcd60e51b8152600401620001639062001b23565b838062000bff5750825b1562000c735762000c118686620015f1565b1562000c735760405162461bcd60e51b815260206004820152602a60248201527f534d4c3a707269736f6e65642c2067657420696e20746f756368207769746820604482015269676f7665726e616e636560b01b606482015260840162000163565b62000ce2565b6005810362000ca657602082015162000c735760405162461bcd60e51b8152600401620001639062001b23565b60405162461bcd60e51b815260206004820152601060248201526f534d4c3a696e76616c6964205459504560801b604482015260640162000163565b821562000d6c5762000d0386866936b0b4b73a30b4b732b960b11b620008d8565b6001600160a01b0316336001600160a01b03161462000d655760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572204e4f54206d61696e7461696e657200000000000000604482015260640162000163565b5062000ded565b831562000deb5762000d8d86866921a7a72a2927a62622a960b11b620008d8565b6001600160a01b0316336001600160a01b03161462000d655760405162461bcd60e51b815260206004820152601960248201527829a6a61d39b2b73232b9102727aa1021a7a72a2927a62622a960391b604482015260640162000163565b505b5050505050565b606083600201600062000e08858562001588565b8152602001908152602001600020805462000e239062001bdd565b80601f016020809104026020016040519081016040528092919081815260200182805462000e519062001bdd565b801562000ea25780601f1062000e765761010080835404028352916020019162000ea2565b820191906000526020600020905b81548152906001019060200180831162000e8457829003601f168201915b505050505090509392505050565b6000828152600b860160205260408120548062000f0c5760405162461bcd60e51b81526020600482015260196024820152780534d4c3a76657273696f6e49642063616e6e6f74206265203603c1b604482015260640162000163565b62000f2686826921a7a72a2927a62622a960b11b620008d8565b60405162000f34906200196e565b6001600160a01b039091168152604060208201819052600090820152606001604051809103906000f08015801562000f70573d6000803e3d6000fd5b5091506001600160a01b038216639934b2818662000f9d89826921a7a72a2927a62622a960b11b620008d8565b62000fb18a86634e414d4560e01b62000df4565b876040518563ffffffff1660e01b815260040162000fd3949392919062001c61565b600060405180830381600087803b15801562000fee57600080fd5b505af115801562001003573d6000803e3d6000fd5b505060408051888152602081018890526001600160a01b0386168183015290517f89288ba00d4e2e012af872098d4fee07191e810d8c739b7cf1e842e0370888729350908190036060019150a15095945050505050565b808460030160006200106d868662001588565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b0316021790555050505050565b60008282604051602001620010bc92919062001cac565b60408051601f1981840301815291905280516020909101209392505050565b80846002016000620010ee868662001588565b8152602001908152602001600020908162000ded919062001d30565b60006200112c84848461271b6040518060200160405280600081525062000eb0565b9050620011518383711dda5d1a191c985dd85b10dbdb9d1c9858dd60721b846200105a565b620011ae82731dda5d1a191c985dd85b10dc9959195b9d1a585b60621b620011a484604080516001600160a01b0392909216600160f81b1760208084019190915281518084039091018152918101905290565b86929190620010db565b50505050565b60008211620012025760405162461bcd60e51b81526020600482015260196024820152780534d4c3a76657273696f6e49642063616e6e6f74206265203603c1b604482015260640162000163565b614e2b6000908152600c86016020908152604080832085845290915290205460ff16620012695760405162461bcd60e51b8152602060048201526014602482015273534d4c3a6e6f742061206d6964646c657761726560601b604482015260640162000163565b60006200128f6200128986856921a7a72a2927a62622a960b11b620008d8565b62001615565b8654604051637104db2360e11b81529192506001600160a01b038084169263e209b64692620012c8928992911690879060040162001dfd565b600060405180830381600087803b158015620012e357600080fd5b505af1158015620012f8573d6000803e3d6000fd5b505050506200130a8686868462001688565b8554604051630492f6e160e01b815260048101869052600160248201526001600160a01b0390911690630492f6e190604401600060405180830381600087803b1580156200135757600080fd5b505af11580156200136c573d6000803e3d6000fd5b505060408051878152602081018790527f49e0747139b3dca64314df382ec23da37e088325f877ecf4539d72357349e5a6935001905060405180910390a1505050505050565b6000620013c1858585620017a3565b6200140f5760405162461bcd60e51b815260206004820152601a60248201527f534d4c3a6d696e74696e67206973206e6f7420616c6c6f776564000000000000604482015260640162000163565b845460405163f759cc3b60e01b8152600481018590526000916001600160a01b03169063f759cc3b90602401602060405180830381865afa15801562001459573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200147f919062001e32565b905060008111620014c85760405162461bcd60e51b8152602060048201526012602482015271534d4c3a7072696365206973207a65726f3f60701b604482015260640162000163565b80620014dd670de0b6b3a76400008562001ba0565b620014e9919062001bba565b865460405163731133e960e01b8152306004820152602481018790526044810183905260806064820152600060848201529193506001600160a01b03169063731133e99060a401600060405180830381600087803b1580156200154b57600080fd5b505af115801562001560573d6000803e3d6000fd5b506200157f925087915086905066737572706c757360c81b86620015b4565b50949350505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b80846001016000620015c7868662001588565b81526020019081526020016000206000828254620015e6919062001e4c565b909155505050505050565b60006200160a83836672656c6561736560c81b620008ac565b421090505b92915050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b03811662001683576040516330be1a3d60e21b815260040160405180910390fd5b919050565b8354604051634d280a5560e01b81526001600160a01b0383811660048301526024820185905290911690634d280a5590604401602060405180830381865afa158015620016d9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620016ff919062001e62565b15620017475760405162461bcd60e51b8152602060048201526016602482015275534d4c3a616c7265616479206d6964646c657761726560501b604482015260640162000163565b6200176383836a6d6964646c65776172657360a81b84620017ef565b8354604051632895f3cb60e11b81526001600160a01b03838116600483015260248201859052600160448301529091169063512be79690606401620003cd565b6000620017b1848362001870565b8015620017e75750620017e5620017df8484711dda5d1a191c985dd85b10dbdb9d1c9858dd60721b620008d8565b62001907565b155b949350505050565b6000620017fd848462001588565b6000818152600187016020526040812080549293508492600389019291620018379190836200182c8362001e82565b919050558562001588565b815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055505050505050565b815460405163908d67ed60e01b81526004810183905260009182916001600160a01b039091169063908d67ed90602401602060405180830381865afa158015620018be573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620018e4919062001e32565b90504262015180820110158015620017e757508360050154811015949350505050565b6000816001600160a01b0316638650c0726040518163ffffffff1660e01b8152600401602060405180830381865afa15801562001948573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200160f919062001e62565b61040a8062001e9f83390190565b80356001600160a01b03811681146200168357600080fd5b600080600080600060a08688031215620019ad57600080fd5b85359450602086013593506040860135925060608601359150620019d4608087016200197c565b90509295509295909350565b600080600060608486031215620019f657600080fd5b505081359360208301359350604090920135919050565b60008083601f84011262001a2057600080fd5b50813567ffffffffffffffff81111562001a3957600080fd5b60208301915083602082850101111562001a5257600080fd5b9250929050565b6000806000806000806000806000806101408b8d03121562001a7a57600080fd5b8a35995060208b0135985060408b0135975060608b0135965062001aa160808c016200197c565b955060a08b013567ffffffffffffffff8082111562001abf57600080fd5b62001acd8e838f0162001a0d565b909750955060c08d013591508082111562001ae757600080fd5b5062001af68d828e0162001a0d565b9094509250506101408b018c101562001b0e57600080fd5b60e08b0190509295989b9194979a5092959850565b60208082526014908201527314d3530e95165411481393d508185b1b1bddd95960621b604082015260600190565b801515811462001b6057600080fd5b50565b60006020828403121562001b7657600080fd5b813562001b838162001b51565b9392505050565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176200160f576200160f62001b8a565b60008262001bd857634e487b7160e01b600052601260045260246000fd5b500490565b600181811c9082168062001bf257607f821691505b60208210810362001c1357634e487b7160e01b600052602260045260246000fd5b50919050565b6000815180845260005b8181101562001c415760208185018101518683018201520162001c23565b506000602082860101526020601f19601f83011685010191505092915050565b8481526001600160a01b038416602082015260806040820181905260009062001c8d9083018562001c19565b828103606084015262001ca1818562001c19565b979650505050505050565b60408152600062001cc1604083018562001c19565b90508260208301529392505050565b634e487b7160e01b600052604160045260246000fd5b601f8211156200034e57600081815260208120601f850160051c8101602086101562001d0f5750805b601f850160051c820191505b8181101562000deb5782815560010162001d1b565b815167ffffffffffffffff81111562001d4d5762001d4d62001cd0565b62001d658162001d5e845462001bdd565b8462001ce6565b602080601f83116001811462001d9d576000841562001d845750858301515b600019600386901b1c1916600185901b17855562000deb565b600085815260208120601f198616915b8281101562001dce5788860151825594840194600190910190840162001dad565b508582101562001ded5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b8381526001600160a01b038316602082015260606040820181905260009062001e299083018462001c19565b95945050505050565b60006020828403121562001e4557600080fd5b5051919050565b808201808211156200160f576200160f62001b8a565b60006020828403121562001e7557600080fd5b815162001b838162001b51565b60006001820162001e975762001e9762001b8a565b506001019056fe608060405260405161040a38038061040a83398101604081905261002291610268565b61002c8282610033565b5050610352565b61003c82610092565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a280511561008657610081828261010e565b505050565b61008e610185565b5050565b806001600160a01b03163b6000036100cd57604051634c9c8ce360e01b81526001600160a01b03821660048201526024015b60405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b0392909216919091179055565b6060600080846001600160a01b03168460405161012b9190610336565b600060405180830381855af49150503d8060008114610166576040519150601f19603f3d011682016040523d82523d6000602084013e61016b565b606091505b50909250905061017c8583836101a6565b95945050505050565b34156101a45760405163b398979f60e01b815260040160405180910390fd5b565b6060826101bb576101b682610205565b6101fe565b81511580156101d257506001600160a01b0384163b155b156101fb57604051639996b31560e01b81526001600160a01b03851660048201526024016100c4565b50805b9392505050565b8051156102155780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b634e487b7160e01b600052604160045260246000fd5b60005b8381101561025f578181015183820152602001610247565b50506000910152565b6000806040838503121561027b57600080fd5b82516001600160a01b038116811461029257600080fd5b60208401519092506001600160401b03808211156102af57600080fd5b818501915085601f8301126102c357600080fd5b8151818111156102d5576102d561022e565b604051601f8201601f19908116603f011681019083821181831017156102fd576102fd61022e565b8160405282815288602084870101111561031657600080fd5b610327836020830160208801610244565b80955050505050509250929050565b60008251610348818460208701610244565b9190910192915050565b60aa806103606000396000f3fe6080604052600a600c565b005b60186014601a565b6051565b565b6000604c7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e808015606f573d6000f35b3d6000fdfea2646970667358221220f038e5386f37d7c294910e36c8834558bc963a25cf018593b31ef79e0554f56964736f6c63430008140033a26469706673582212200fc2b2f5466a4d1d635a04efef2f9a864179b509ebb3c9dfb98bae67bd5b467a64736f6c63430008140033",
  "libraries": {
    "StakeModuleLib": "0x485a3161a9Dbec8c7EeA0F4F3DF13b9385Ceff83"
  },
  "devdoc": {
    "author": "Ice Bear & Crash Bandicoot",
    "details": "review: DataStoreModule for the id based isolated storage logic.review: StakeModuleLib for base staking logic.This library utilizes the '_authenticate' function on the external deployLiquidityPool,  Compared to gETHMiddleware(optional) and WithdrawalContract(mandatory), LP be activated after the pool initiation.This is an external library, requires deployment.",
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ]
    },
    "events": {
      "IdInitiated(uint256,uint256)": {
        "custom:section": "** EVENTS **"
      }
    },
    "kind": "dev",
    "methods": {
      "_deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)": {
        "details": "gives full allowance to the pool (should not be a problem as Portal only temporarily holds gETH)unlike withdrawal Contract, a controller can deploy a liquidity pool after initiation as well_package_data of a liquidity pool is only the staking pool's name, used on LPToken."
      },
      "initiateOperator(DataStoreModuleStorage storage,uint256,uint256,uint256,address)": {
        "details": "operators can fund their internal wallet on initiation by simply sending some ether.",
        "params": {
          "fee": "as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR represents 100%",
          "maintainer": "an address that automates daily operations, a script, a contract...",
          "validatorPeriod": "the expected maximum staking interval. This value should between * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above. Operator can unstake at any given point before this period ends. If operator disobeys this rule, it can be prisoned with blameProposal()"
        }
      },
      "initiatePool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,address,bytes,bytes,bool[3])": {
        "details": "checking only initiated is enough to validate that ID is not used. no need to check TYPE, CONTROLLER etc.requires exactly 1 validator worth of funds to be deposited on initiation, prevent sybil attacks.",
        "params": {
          "config": "array(3)= [private(true) or public(false), deploy a middleware(if true), deploy liquidity pool(if true)]",
          "fee": "as a percentage limited by MAX_MAINTENANCE_FEE, PERCENTAGE_DENOMINATOR is 100%",
          "maintainer": "an address that automates daily operations, a script, a contract... not so critical.",
          "middlewareVersion": "Pool creators can choose any allowed version as their gETHMiddleware",
          "middleware_data": "middlewares might require additional data on initialization; like name, symbol, etc.",
          "name": "is utilized while generating an ID for the Pool, similar to any other ID generation."
        }
      }
    },
    "title": "IEL: Initiator Extension Library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)": {
        "notice": "deploys a bound liquidity pool for a staking pool."
      },
      "deployLiquidityPool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256)": {
        "notice": "allows pools to deploy a Liquidity Pool after initiation, if it does not have one."
      },
      "initiateOperator(DataStoreModuleStorage storage,uint256,uint256,uint256,address)": {
        "notice": "initiates ID as a Permissionned Node Operatorrequires ID to be approved as a node operator with a specific CONTROLLER"
      },
      "initiatePool(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,address,bytes,bytes,bool[3])": {
        "notice": "Creates a Configurable Trustless Staking Pool!"
      }
    },
    "notice": "An extension to SML.This library is responsible from: * 1. Node Operator Initiator for permissioned IDs * 2. Configurable Staking Pools Initiator and its helpers. * 3. Bound Liquidity Pool deployment after pool initiation.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}