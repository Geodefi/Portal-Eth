{
  "address": "0x08334E524d1d274708d808d918E76DcEa46b3952",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "pubkey",
          "type": "bytes"
        }
      ],
      "name": "Alienated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "proofs",
          "type": "bytes"
        }
      ],
      "name": "FeeTheft",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "priceMerkleRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "balanceMerkleRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "monopolyThreshold",
          "type": "uint256"
        }
      ],
      "name": "OracleReported",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "operatorId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "releaseTimestamp",
          "type": "uint256"
        }
      ],
      "name": "Prisoned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "validatorVerificationIndex",
          "type": "uint256"
        }
      ],
      "name": "VerificationIndexUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "poolId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "YieldDistributed",
      "type": "event"
    }
  ],
  "transactionHash": "0x7741477831c5f7290062649df53ef4227951ab6180c2c16c538b82ab5d79e184",
  "receipt": {
    "to": null,
    "from": "0x7B6fA217a374826FCa50dccB87041AE0e34Ba1f5",
    "contractAddress": "0x08334E524d1d274708d808d918E76DcEa46b3952",
    "transactionIndex": 1,
    "gasUsed": "1783383",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x287e4f6ff2a12133941899a3039cf0b142bf7839f9c1e7b027a7bd1eb324486e",
    "transactionHash": "0x7741477831c5f7290062649df53ef4227951ab6180c2c16c538b82ab5d79e184",
    "logs": [],
    "blockNumber": 852073,
    "cumulativeGasUsed": "1804383",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "cfc92d910e56f99740a6d4737a3b72cb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"name\":\"Alienated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"proofs\",\"type\":\"bytes\"}],\"name\":\"FeeTheft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"priceMerkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"balanceMerkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"monopolyThreshold\",\"type\":\"uint256\"}],\"name\":\"OracleReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"operatorId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releaseTimestamp\",\"type\":\"uint256\"}],\"name\":\"Prisoned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorVerificationIndex\",\"type\":\"uint256\"}],\"name\":\"VerificationIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"YieldDistributed\",\"type\":\"event\"}],\"devdoc\":{\"author\":\"Ice Bear & Crash Bandicoot\",\"details\":\"review: DataStoreModule for the id based isolated storage logic.review: StakeModuleLib for base staking logic.Telescope is currently responsible for 4 tasks: * Updating the on-chain price of all pools with a MerkleRoot for minting operations * Updating the on-chain balances info of all validators with a MerkleRoot for withdrawal operations * Confirming validator proposals * Regulating the Node Operators 1. updateVerificationIndex: Confirming validator proposals * 2 step process is essential to prevent the frontrunning with a problematic withdrawalCredential: https://bit.ly/3Tkc6UC * Simply, all proposed validator has an index bound to them, * n representing the latest proposal: (0,n] * Telescope verifies the validator data provided in proposeStake: * especially sig1, sig31 and withdrawal credentials. * Telescope confirms the latest index verified and states the faulty validator proposals (aliens) * If a validator proposal is faulty then it's state is set to 69, refer to globals/validator_state.sol 2. regulateOperators: Regulating the Operators * Operators can act faulty in many different ways. To prevent such actions, * Telescope regulates them with well defined limitations. * Currently only issue is the fee theft, meaning operators have not * used the withdrawal contract for miner fees or MEV boost. * There can be other restrictions in the future. 2. reportBeacon: Continous Data from Beacon chain: Price Merkle Root & Balances Merkle Root & # of active validators * 1. Oracle Nodes calculate the price of its derivative, according to the validator data such as balance and fees. * 2. If a pool doesn't have a validator, the price is kept the same. * 3. A merkle tree is constructed with the order of allIdsByType array. * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root. * 5. Anyone can update the price of the derivative  by calling priceSync() functions with correct merkle proofs * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update. * 7. Updates the regulation around Monopolies and provides BALANCE_MERKLE_ROOT to be used within withdrawal process.Most external functions have OracleOnly modifier. Except: priceSync, priceSyncBatch, blameExit and blameProposal.This is an external library, requires deployment.\",\"events\":{\"Alienated(bytes)\":{\"custom:section\":\"** EVENTS **\"}},\"kind\":\"dev\",\"methods\":{\"blameExit(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes,uint256,uint256,bytes32[])\":{\"details\":\"normally, oracle should verify the signed exit request on beacon chain for a (deterministic) epoch * before approval. This function enforces it further for the stakers.anyone can call this function while the state is ACTIVE or EXIT_REQUESTEDif operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned\"},\"blameProposal(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes)\":{\"details\":\"anyone can call this function while the state is PROPOSEDthis check can be problematic in the case the beaconchain deposit delay is > BEACON_DELAY_ENTRY, * depending on the expected delay of telescope approvals. However, BEACON_DELAY_ENTRY can be adjusted by the Governance._canStake checks == VALIDATOR_STATE.PROPOSED.\"},\"priceSync(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,bytes32[])\":{\"custom:visibility\":\"-> external\",\"params\":{\"price\":\"price of the derivative denominated in gETH.denominator()\",\"priceProof\":\"merkle proofs\"}},\"priceSyncBatch(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],uint256[],bytes32[][])\":{\"custom:visibility\":\"-> external\",\"params\":{\"priceProofs\":\"merkle proofs\",\"prices\":\"price of the derivative denominated in gETH.denominator()\"}},\"regulateOperators(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],bytes[])\":{\"details\":\"Stuff here result in imprisonment\",\"params\":{\"feeThefts\":\"Operator ids who have stolen MEV or block rewards detected\",\"proofs\":\"BlockNumber, tx or any other referance as a proof\"}},\"reportBeacon(StakeModuleStorage storage,bytes32,bytes32,uint256)\":{\"params\":{\"allValidatorsCount\":\"Number of all validators within BeaconChain, all of them. Prevents monopolies.\"}},\"updateVerificationIndex(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,bytes[])\":{\"custom:visibility\":\"-> external\",\"params\":{\"alienatedPubkeys\":\"faulty proposals within the range of new and old verification indexes.\",\"validatorVerificationIndex\":\"(inclusive) index of the highest validator that is verified to be activated\"}}},\"title\":\"OEL: Oracle Extension Library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"blameExit(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes,uint256,uint256,bytes32[])\":{\"notice\":\"imprisoning an Operator if the validator have not been exited until expected exit\"},\"blameProposal(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes)\":{\"notice\":\"imprisoning an Operator if the validator proposal is approved but have not been executed.\"},\"priceSync(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,bytes32[])\":{\"notice\":\"external function to set a derivative price on Portal\"},\"priceSyncBatch(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],uint256[],bytes32[][])\":{\"notice\":\"external function to set a multiple derivatives price at once, saves gas.\"},\"regulateOperators(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],bytes[])\":{\"notice\":\"regulating operators, currently only regulation is towards fee theft, can add more stuff in the future.\"},\"reportBeacon(StakeModuleStorage storage,bytes32,bytes32,uint256)\":{\"notice\":\"Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT. Also reports all of the validator balances with a BALANCE_MERKLE_ROOT. Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD\"},\"updateVerificationIndex(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,bytes[])\":{\"notice\":\"Updating VERIFICATION_INDEX, signaling that it is safe to activate the validator proposals with lower index than new VERIFICATION_INDEX\"}},\"notice\":\"An extension to SMLOracle, named Telescope, handles some operations for The Staking Library, * using the logic explained below.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/StakeModule/libs/OracleExtensionLib.sol\":\"OracleExtensionLib\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x60c65f701957fdd6faea1acb0bb45825791d473693ed9ecb34726fdfaa849dd7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe64b3445a3f638890af7ad92464cd18f1f202a2f5a7ed42dabf74317bae43303\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xe92b5e199b963d108ad6e06feeede151ba23849e0d064956535489ff967ffe68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the Merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6400c4bee15052e043e5d10315135972529bd1c8012f43da494dc6b4f4661058\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/globals/id_type.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice ID_TYPE is an internal library that acts like an ENUM.\\n *\\n * @dev Used within the limited upgradability pattern:\\n *\\n * NONE & GAP: should not be used.\\n *\\n * Dual Governance:\\n * * SENATE: points to a proposal that will update the current SENATE address of a package(or Portal).\\n * * CONTRACT UPGRADE: proposal to change the given contract's implementation. TYPE should be package's TYPE.\\n *\\n * Users:\\n * * OPERATOR: permissionned Node Operators (hosted on Portal).\\n * * POOL: permissionless staking pools (hosted on Portal).\\n *\\n * Packages: (hosted on StakeModuleLib)\\n * * An ID can only point to 1(one) Package version' implementation address at a given point.\\n * * Can be upgraded by a dual governance, via pullUpgrade.\\n * * * Portal's dual governance consists of a Governance Token(governance) and a Senate(senate).\\n * * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n * * Built by utilizing the Modules.\\n * * LiquidityPool and WithdrawalContract are some examples.\\n *\\n * Middlewares: (hosted on StakeModuleLib)\\n * * An ID can point to multiple Middleware version' implementation address at the same time.\\n * * Cannot be upgraded.\\n * * Do not have any guides to build really.\\n * * Currently only gETHMiddlewares\\n *\\n *  Limits:\\n *  * We simply set limits to separate a group of types from others. Like Packages and Middlewares.\\n *\\n * @dev all LIMIT parameters are exclusive, prevents double usage.\\n */\\nlibrary ID_TYPE {\\n  /// @notice TYPE 0: *invalid*\\n  uint256 internal constant NONE = 0;\\n\\n  /// @notice TYPE 1: Senate\\n  uint256 internal constant SENATE = 1;\\n\\n  /// --\\n\\n  /// @notice TYPE 3: Limit: exclusive, minimum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MIN_USER = 3;\\n\\n  /// @notice TYPE 4: USER: Permissionned Node Operator\\n  uint256 internal constant OPERATOR = 4;\\n\\n  /// @notice TYPE 5: USER: Staking Pool\\n  uint256 internal constant POOL = 5;\\n\\n  /// @notice TYPE 9999: Limit: exclusive, maximum TYPE that will be percieved as a user\\n  uint256 internal constant LIMIT_MAX_USER = 9999;\\n\\n  /// --\\n\\n  /// @notice TYPE 10000: Limit: exclusive, minimum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MIN_PACKAGE = 10000;\\n\\n  /// @notice TYPE 10001: Package: Portal is also a package\\n  uint256 internal constant PACKAGE_PORTAL = 10001;\\n\\n  /// @notice TYPE 10011: Package: The Withdrawal Credential Contract\\n  uint256 internal constant PACKAGE_WITHDRAWAL_CONTRACT = 10011;\\n\\n  /// @notice TYPE 10021: Package: A Liquidity Pool\\n  uint256 internal constant PACKAGE_LIQUIDITY_POOL = 10021;\\n\\n  /// @notice TYPE 19999: Limit: exclusive, maximum TYPE that will be percieved as a package\\n  uint256 internal constant LIMIT_MAX_PACKAGE = 19999;\\n\\n  /// --\\n\\n  /// @notice TYPE 20000: Limit: exclusive, minimum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MIN_MIDDLEWARE = 20000;\\n\\n  /// @notice TYPE 20011: Middleware: A new gETH interface\\n  uint256 internal constant MIDDLEWARE_GETH = 20011;\\n\\n  /// @notice TYPE 29999: Limit: exclusive, maximum TYPE that will be percieved as a middleware\\n  uint256 internal constant LIMIT_MAX_MIDDLEWARE = 29999;\\n}\\n\",\"keccak256\":\"0x703e579cedf1a96736702958c414562d80fca21ed9f2eac7fe1957905a493493\",\"license\":\"MIT\"},\"contracts/globals/macros.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// no floats in solidity. If needed, PERCENTAGE_DENOMINATOR always represents \\\"1\\\" (100%)\\nuint256 constant PERCENTAGE_DENOMINATOR = 1e10;\\n\\nuint256 constant gETH_DENOMINATOR = 1e18;\\n\",\"keccak256\":\"0x9d699aeaf6da35d188a5495eec188b28a990e09bd04fa7701d28c4ff9afba801\",\"license\":\"MIT\"},\"contracts/globals/reserved_key_space.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Reserved Key Space for DataStoreModule\\n * * helps preventing potential dev mistakes.\\n * * helps keeping track of them.\\n * * limits keys to bytes32.\\n *\\n * @dev utilize a key with rks.key\\n * @dev keep this list in alphabetical order, per module.\\n * @dev NEVER name your variables something else other than *its string value*.\\n * @dev ! array keys with readUint returns the lenght of the array !\\n */\\nlibrary RESERVED_KEY_SPACE {\\n  /**\\n   * @dev reserved on GeodeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition representing body of an id\\n   */\\n  bytes32 internal constant CONTROLLER = \\\"CONTROLLER\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition base of an id\\n   */\\n  bytes32 internal constant NAME = \\\"NAME\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition identifier for an id, based on ID_TYPEs\\n   */\\n  bytes32 internal constant TYPE = \\\"TYPE\\\";\\n\\n  /**\\n   * @dev reserved on StakeModuleLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of active validators run by an operator for a pool\\n   */\\n  bytes32 internal constant activeValidators = \\\"activeValidators\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition max amount of validators for an operator to run, for a specific pool.\\n   */\\n  bytes32 internal constant allowance = \\\"allowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition special operator that has max allowance, if threshold is hit for the pool\\n   */\\n  bytes32 internal constant fallbackOperator = \\\"fallbackOperator\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition treshold calculated with given percentage value for fallback operator to be activated\\n   */\\n  bytes32 internal constant fallbackThreshold = \\\"fallbackThreshold\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee of the pool or operator, will be shadowed by priorFee if switching\\n   */\\n  bytes32 internal constant fee = \\\"fee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed fee change\\n   */\\n  bytes32 internal constant feeSwitch = \\\"feeSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition the initiation timestamp of a \\\"user\\\" TYPE id\\n   */\\n  bytes32 internal constant initiated = \\\"initiated\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition bound liquidity pool of a pool\\n   */\\n  bytes32 internal constant liquidityPool = \\\"liquidityPool\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition receiver address for yield seperation functionality\\n   * * will receive minted gETH to given receiver instead of increasing pricePerShare\\n   */\\n  bytes32 internal constant yieldReceiver = \\\"yieldReceiver\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition hot wallet for pool and operators, automatooor\\n   */\\n  bytes32 internal constant maintainer = \\\"maintainer\\\";\\n\\n  /**\\n   * @custom:type address array, direct call returns length\\n   * @custom:definition contracts with more than one versions, ex: gETHMiddlewares of a pool\\n   */\\n  bytes32 internal constant middlewares = \\\"middlewares\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition effective timestamp pointing to the latest delayed validator period change\\n   */\\n  bytes32 internal constant periodSwitch = \\\"periodSwitch\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition fee that will be effective if fee is currently switching\\n   */\\n  bytes32 internal constant priorFee = \\\"priorFee\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition period that will be effective if validatorPeriod is currently switching\\n   */\\n  bytes32 internal constant priorPeriod = \\\"priorPeriod\\\";\\n\\n  /**\\n   * @custom:type uint, bool\\n   * @custom:definition 1(true) if id is a private pool\\n   */\\n  bytes32 internal constant privatePool = \\\"privatePool\\\";\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition proposed validator count for pool-operator pair.\\n   */\\n  bytes32 internal constant proposedValidators = \\\"proposedValidators\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition timestamp of the date of the latest imprisonment for an operator\\n   */\\n  bytes32 internal constant release = \\\"release\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition 32 eth is secured, per proposed-but-not-yet-activated validator\\n   */\\n  bytes32 internal constant secured = \\\"secured\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition collateral waiting to be staked, in wei\\n   */\\n  bytes32 internal constant surplus = \\\"surplus\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition sum of all allowances for a pool\\n   */\\n\\n  bytes32 internal constant totalAllowance = \\\"totalAllowance\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition seconds, time that passes before the expected exit is reached for a validator\\n   */\\n  bytes32 internal constant validatorPeriod = \\\"validatorPeriod\\\";\\n\\n  /**\\n   * @custom:type bytes array, direct call returns length\\n   * @custom:definition lists all (any state) validators' pubkeys for a pool, or an operator\\n   */\\n  bytes32 internal constant validators = \\\"validators\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition custodian of validator funds for a pool\\n   */\\n  bytes32 internal constant withdrawalContract = \\\"withdrawalContract\\\";\\n\\n  /**\\n   * @custom:type bytes\\n   * @custom:definition derived from withdrawalContract\\n   */\\n  bytes32 internal constant withdrawalCredential = \\\"withdrawalCredential\\\";\\n\\n  /**\\n   * @custom:type uint\\n   * @custom:definition size of the internal wallet, which accrues fees etc. in wei\\n   */\\n  bytes32 internal constant wallet = \\\"wallet\\\";\\n\\n  /**\\n   * @custom:type address\\n   * @custom:definition whitelist contract for the pool\\n   */\\n  bytes32 internal constant whitelist = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev reserved on OracleExtensionLib\\n   */\\n\\n  /**\\n   * @custom:type uint, relational, pool[operator]\\n   * @custom:definition number of alienated validators run by an operator for a pool\\n   */\\n  bytes32 internal constant alienValidators = \\\"alienValidators\\\";\\n}\\n\",\"keccak256\":\"0x62ab3086774ad8721fa9e571e663e6444bebe30020075898406ec92ab55146bb\",\"license\":\"MIT\"},\"contracts/globals/validator_state.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice VALIDATOR_STATE: keeping track of validators within The Staking Library.\\n */\\nlibrary VALIDATOR_STATE {\\n  /// @notice STATE 0: *invalid*\\n  uint8 internal constant NONE = 0;\\n\\n  /// @notice STATE 1: validator is proposed, 1 ETH is sent from Operator to Deposit Contract.\\n  uint8 internal constant PROPOSED = 1;\\n\\n  /// @notice STATE 2: proposal was approved, operator used pooled funds, 1 ETH is released back to Operator.\\n  uint8 internal constant ACTIVE = 2;\\n\\n  /// @notice STATE 3: validator is called to be exited.\\n  uint8 internal constant EXIT_REQUESTED = 3;\\n\\n  /// @notice STATE 4: validator is fully exited.\\n  uint8 internal constant EXITED = 4;\\n\\n  /// @notice STATE 69: proposal was malicious(alien). Maybe faulty signatures or probably frontrunning (https://bit.ly/3Tkc6UC)\\n  uint8 internal constant ALIENATED = 69;\\n}\\n\",\"keccak256\":\"0xe3b6be931c93e3855d7dc1775870378652699745f7273f601dea102a7ce87546\",\"license\":\"MIT\"},\"contracts/helpers/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity =0.8.20;\\n\\nlibrary BytesLib {\\n  function concat(\\n    bytes memory _preBytes,\\n    bytes memory _postBytes\\n  ) internal pure returns (bytes memory) {\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      // Get a location of some free memory and store it in tempBytes as\\n      // Solidity does for memory variables.\\n      tempBytes := mload(0x40)\\n\\n      // Store the length of the first bytes array at the beginning of\\n      // the memory for tempBytes.\\n      let length := mload(_preBytes)\\n      mstore(tempBytes, length)\\n\\n      // Maintain a memory counter for the current write location in the\\n      // temp bytes array by adding the 32 bytes for the array length to\\n      // the starting location.\\n      let mc := add(tempBytes, 0x20)\\n      // Stop copying when the memory counter reaches the length of the\\n      // first bytes array.\\n      let end := add(mc, length)\\n\\n      for {\\n        // Initialize a copy counter to the start of the _preBytes data,\\n        // 32 bytes into its memory.\\n        let cc := add(_preBytes, 0x20)\\n      } lt(mc, end) {\\n        // Increase both counters by 32 bytes each iteration.\\n        mc := add(mc, 0x20)\\n        cc := add(cc, 0x20)\\n      } {\\n        // Write the _preBytes data into the tempBytes memory 32 bytes\\n        // at a time.\\n        mstore(mc, mload(cc))\\n      }\\n\\n      // Add the length of _postBytes to the current length of tempBytes\\n      // and store it as the new length in the first 32 bytes of the\\n      // tempBytes memory.\\n      length := mload(_postBytes)\\n      mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n      // Move the memory counter back from a multiple of 0x20 to the\\n      // actual end of the _preBytes data.\\n      mc := end\\n      // Stop copying when the memory counter reaches the new combined\\n      // length of the arrays.\\n      end := add(mc, length)\\n\\n      for {\\n        let cc := add(_postBytes, 0x20)\\n      } lt(mc, end) {\\n        mc := add(mc, 0x20)\\n        cc := add(cc, 0x20)\\n      } {\\n        mstore(mc, mload(cc))\\n      }\\n\\n      // Update the free-memory pointer by padding our last write location\\n      // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n      // next 32 byte block, then round down to the nearest multiple of\\n      // 32. If the sum of the length of the two arrays is zero then add\\n      // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n      mstore(\\n        0x40,\\n        and(\\n          add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n          not(31) // Round down to the nearest 32 bytes.\\n        )\\n      )\\n    }\\n\\n    return tempBytes;\\n  }\\n\\n  function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n    assembly {\\n      // Read the first 32 bytes of _preBytes storage, which is the length\\n      // of the array. (We don't need to use the offset into the slot\\n      // because arrays use the entire slot.)\\n      let fslot := sload(_preBytes.slot)\\n      // Arrays of 31 bytes or less have an even value in their slot,\\n      // while longer arrays have an odd value. The actual length is\\n      // the slot divided by two for odd values, and the lowest order\\n      // byte divided by two for even values.\\n      // If the slot is even, bitwise and the slot with 255 and divide by\\n      // two to get the length. If the slot is odd, bitwise and the slot\\n      // with -1 and divide by two.\\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n      let mlength := mload(_postBytes)\\n      let newlength := add(slength, mlength)\\n      // slength can contain both the length and contents of the array\\n      // if length < 32 bytes so let's prepare for that\\n      // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n      switch add(lt(slength, 32), lt(newlength, 32))\\n      case 2 {\\n        // Since the new array still fits in the slot, we just need to\\n        // update the contents of the slot.\\n        // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n        sstore(\\n          _preBytes.slot,\\n          // all the modifications to the slot are inside this\\n          // next block\\n          add(\\n            // we can just add to the slot contents because the\\n            // bytes we want to change are the LSBs\\n            fslot,\\n            add(\\n              mul(\\n                div(\\n                  // load the bytes from memory\\n                  mload(add(_postBytes, 0x20)),\\n                  // zero all bytes to the right\\n                  exp(0x100, sub(32, mlength))\\n                ),\\n                // and now shift left the number of bytes to\\n                // leave space for the length in the slot\\n                exp(0x100, sub(32, newlength))\\n              ),\\n              // increase length by the double of the memory\\n              // bytes length\\n              mul(mlength, 2)\\n            )\\n          )\\n        )\\n      }\\n      case 1 {\\n        // The stored value fits in the slot, but the combined value\\n        // will exceed it.\\n        // get the keccak hash to get the contents of the array\\n        mstore(0x0, _preBytes.slot)\\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n        // save new length\\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n        // The contents of the _postBytes array start 32 bytes into\\n        // the structure. Our first read should obtain the `submod`\\n        // bytes that can fit into the unused space in the last word\\n        // of the stored array. To get this, we read 32 bytes starting\\n        // from `submod`, so the data we read overlaps with the array\\n        // contents by `submod` bytes. Masking the lowest-order\\n        // `submod` bytes allows us to add that value directly to the\\n        // stored value.\\n\\n        let submod := sub(32, slength)\\n        let mc := add(_postBytes, submod)\\n        let end := add(_postBytes, mlength)\\n        let mask := sub(exp(0x100, submod), 1)\\n\\n        sstore(\\n          sc,\\n          add(\\n            and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\n            and(mload(mc), mask)\\n          )\\n        )\\n\\n        for {\\n          mc := add(mc, 0x20)\\n          sc := add(sc, 1)\\n        } lt(mc, end) {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } {\\n          sstore(sc, mload(mc))\\n        }\\n\\n        mask := exp(0x100, sub(mc, end))\\n\\n        sstore(sc, mul(div(mload(mc), mask), mask))\\n      }\\n      default {\\n        // get the keccak hash to get the contents of the array\\n        mstore(0x0, _preBytes.slot)\\n        // Start copying to the last used word of the stored array.\\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n        // save new length\\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n        // Copy over the first `submod` bytes of the new data as in\\n        // case 1 above.\\n        let slengthmod := mod(slength, 32)\\n        let mlengthmod := mod(mlength, 32)\\n        let submod := sub(32, slengthmod)\\n        let mc := add(_postBytes, submod)\\n        let end := add(_postBytes, mlength)\\n        let mask := sub(exp(0x100, submod), 1)\\n\\n        sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n        for {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } lt(mc, end) {\\n          sc := add(sc, 1)\\n          mc := add(mc, 0x20)\\n        } {\\n          sstore(sc, mload(mc))\\n        }\\n\\n        mask := exp(0x100, sub(mc, end))\\n\\n        sstore(sc, mul(div(mload(mc), mask), mask))\\n      }\\n    }\\n  }\\n\\n  function slice(\\n    bytes memory _bytes,\\n    uint256 _start,\\n    uint256 _length\\n  ) internal pure returns (bytes memory) {\\n    require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n    require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      switch iszero(_length)\\n      case 0 {\\n        // Get a location of some free memory and store it in tempBytes as\\n        // Solidity does for memory variables.\\n        tempBytes := mload(0x40)\\n\\n        // The first word of the slice result is potentially a partial\\n        // word read from the original array. To read it, we calculate\\n        // the length of that partial word and start copying that many\\n        // bytes into the array. The first word we copy will start with\\n        // data we don't care about, but the last `lengthmod` bytes will\\n        // land at the beginning of the contents of the new array. When\\n        // we're done copying, we overwrite the full first word with\\n        // the actual length of the slice.\\n        let lengthmod := and(_length, 31)\\n\\n        // The multiplication in the next line is necessary\\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\\n        // the following copy loop was copying the origin's length\\n        // and then ending prematurely not copying everything it should.\\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n        let end := add(mc, _length)\\n\\n        for {\\n          // The multiplication in the next line has the same exact purpose\\n          // as the one above.\\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n        } lt(mc, end) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          mstore(mc, mload(cc))\\n        }\\n\\n        mstore(tempBytes, _length)\\n\\n        //update free-memory pointer\\n        //allocating the array padded to 32 bytes like the compiler does now\\n        mstore(0x40, and(add(mc, 31), not(31)))\\n      }\\n      //if we want a zero-length slice let's just return a zero-length array\\n      default {\\n        tempBytes := mload(0x40)\\n        //zero out the 32 bytes slice we are about to return\\n        //we need to do it because Solidity does not garbage collect\\n        mstore(tempBytes, 0)\\n\\n        mstore(0x40, add(tempBytes, 0x20))\\n      }\\n    }\\n\\n    return tempBytes;\\n  }\\n\\n  function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n    require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n    address tempAddress;\\n\\n    assembly {\\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n    }\\n\\n    return tempAddress;\\n  }\\n\\n  function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n    require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n    uint8 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x1), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n    require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n    uint16 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x2), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n    require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n    uint32 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x4), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n    require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n    uint64 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x8), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n    require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n    uint96 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0xc), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n    require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n    uint128 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x10), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n    require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n    uint256 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x20), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n    require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n    bytes32 tempBytes32;\\n\\n    assembly {\\n      tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n    }\\n\\n    return tempBytes32;\\n  }\\n\\n  function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n    bool success = true;\\n\\n    assembly {\\n      let length := mload(_preBytes)\\n\\n      // if lengths don't match the arrays are not equal\\n      switch eq(length, mload(_postBytes))\\n      case 1 {\\n        // cb is a circuit breaker in the for loop since there's\\n        //  no said feature for inline assembly loops\\n        // cb = 1 - don't breaker\\n        // cb = 0 - break\\n        let cb := 1\\n\\n        let mc := add(_preBytes, 0x20)\\n        let end := add(mc, length)\\n\\n        for {\\n          let cc := add(_postBytes, 0x20)\\n          // the next line is the loop condition:\\n          // while(uint256(mc < end) + cb == 2)\\n        } eq(add(lt(mc, end), cb), 2) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          // if any of these checks fails then arrays are not equal\\n          if iszero(eq(mload(mc), mload(cc))) {\\n            // unsuccess:\\n            success := 0\\n            cb := 0\\n          }\\n        }\\n      }\\n      default {\\n        // unsuccess:\\n        success := 0\\n      }\\n    }\\n\\n    return success;\\n  }\\n\\n  function equalStorage(\\n    bytes storage _preBytes,\\n    bytes memory _postBytes\\n  ) internal view returns (bool) {\\n    bool success = true;\\n\\n    assembly {\\n      // we know _preBytes_offset is 0\\n      let fslot := sload(_preBytes.slot)\\n      // Decode the length of the stored array like in concatStorage().\\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n      let mlength := mload(_postBytes)\\n\\n      // if lengths don't match the arrays are not equal\\n      switch eq(slength, mlength)\\n      case 1 {\\n        // slength can contain both the length and contents of the array\\n        // if length < 32 bytes so let's prepare for that\\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n        if iszero(iszero(slength)) {\\n          switch lt(slength, 32)\\n          case 1 {\\n            // blank the last byte which is the length\\n            fslot := mul(div(fslot, 0x100), 0x100)\\n\\n            if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n              // unsuccess:\\n              success := 0\\n            }\\n          }\\n          default {\\n            // cb is a circuit breaker in the for loop since there's\\n            //  no said feature for inline assembly loops\\n            // cb = 1 - don't breaker\\n            // cb = 0 - break\\n            let cb := 1\\n\\n            // get the keccak hash to get the contents of the array\\n            mstore(0x0, _preBytes.slot)\\n            let sc := keccak256(0x0, 0x20)\\n\\n            let mc := add(_postBytes, 0x20)\\n            let end := add(mc, mlength)\\n\\n            // the next line is the loop condition:\\n            // while(uint256(mc < end) + cb == 2)\\n            for {\\n\\n            } eq(add(lt(mc, end), cb), 2) {\\n              sc := add(sc, 1)\\n              mc := add(mc, 0x20)\\n            } {\\n              if iszero(eq(sload(sc), mload(mc))) {\\n                // unsuccess:\\n                success := 0\\n                cb := 0\\n              }\\n            }\\n          }\\n        }\\n      }\\n      default {\\n        // unsuccess:\\n        success := 0\\n      }\\n    }\\n\\n    return success;\\n  }\\n}\\n\",\"keccak256\":\"0x4ee3f6ef85baa41794fc1519522f7c135becd0e267980eadc68dd643e52b59c7\",\"license\":\"Unlicense\"},\"contracts/interfaces/IPortal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IGeodeModule} from \\\"./modules/IGeodeModule.sol\\\";\\nimport {IStakeModule} from \\\"./modules/IStakeModule.sol\\\";\\n\\ninterface IPortal is IGeodeModule, IStakeModule {\\n  function pausegETH() external;\\n\\n  function unpausegETH() external;\\n\\n  function pushUpgrade(uint256 packageType) external returns (uint256 id);\\n\\n  function releasePrisoned(uint256 operatorId) external;\\n}\\n\",\"keccak256\":\"0x012a8ed050ba68838eeb7463b75f32ba8fdf50c9e54e44dd37d4e87ca16ba78c\",\"license\":\"MIT\"},\"contracts/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IERC1155PausableBurnableSupply} from \\\"./helpers/IERC1155PausableBurnableSupply.sol\\\";\\n\\ninterface IgETH is IERC1155PausableBurnableSupply {\\n  function denominator() external view returns (uint256);\\n\\n  function isMiddleware(address middleware, uint256 id) external view returns (bool);\\n\\n  function setMiddleware(address middleware, uint256 id, bool isSet) external;\\n\\n  function isAvoider(address account, uint256 id) external view returns (bool);\\n\\n  function avoidMiddlewares(uint256 id, bool isAvoid) external;\\n\\n  function pricePerShare(uint256 id) external view returns (uint256);\\n\\n  function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\n\\n  function setPricePerShare(uint256 price, uint256 id) external;\\n\\n  function transferUriSetterRole(address newUriSetter) external;\\n\\n  function transferPauserRole(address newPauser) external;\\n\\n  function transferMinterRole(address newMinter) external;\\n\\n  function transferOracleRole(address newOracle) external;\\n\\n  function transferMiddlewareManagerRole(address newMiddlewareManager) external;\\n}\\n\",\"keccak256\":\"0xa093b769e8ba42091d3db8a9e4ddc1be066f4aa92f61ee552983c22a0e9f29d8\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IDepositContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/** This interface is designed to be compatible with the Vyper version.\\n * @notice This is the Ethereum 2.0 deposit contract interface.\\n * For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\n */\\ninterface IDepositContract {\\n  /**\\n   * @notice Submit a Phase 0 DepositData object.\\n   * @param pubkey A BLS12-381 public key.\\n   * @param withdrawal_credentials Commitment to a public key for withdrawals.\\n   * @param signature A BLS12-381 signature.\\n   * @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n   *Used as a protection against malformed input.\\n   */\\n  function deposit(\\n    bytes calldata pubkey,\\n    bytes calldata withdrawal_credentials,\\n    bytes calldata signature,\\n    bytes32 deposit_data_root\\n  ) external payable;\\n}\\n\",\"keccak256\":\"0x2db8802f8f888c62b147508e142e15c59775ff75906d09122e810483919bff27\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IERC1155PausableBurnableSupply.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @dev IERC1155 inherits IERC165\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport {IERC1155Errors} from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\n\\ninterface IERC1155Burnable is IERC1155, IERC1155MetadataURI, IERC1155Errors {\\n  function burn(address account, uint256 id, uint256 value) external;\\n\\n  function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;\\n}\\n\\ninterface IERC1155Supply is IERC1155, IERC1155MetadataURI, IERC1155Errors {\\n  function totalSupply(uint256 id) external view returns (uint256);\\n\\n  function exists(uint256 id) external view returns (bool);\\n}\\n\\ninterface IERC1155PausableBurnableSupply is IERC1155Burnable, IERC1155Supply {\\n  function setURI(string memory newuri) external;\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\\n\\n  function mintBatch(\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x8b0a02fdbc8d54c815d68e122f6869348217b5efd853c8b833c59d2053998ef0\",\"license\":\"MIT\"},\"contracts/interfaces/helpers/IWhitelist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IWhitelist {\\n  function isAllowed(address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xd9a70c727b9cee59af99357d2ff7b04e8ef19372f6a72efd74a14091f836bdcb\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IDataStoreModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface IDataStoreModule {\\n  function generateId(string calldata _name, uint256 _type) external pure returns (uint256 id);\\n\\n  function getKey(uint256 _id, bytes32 _param) external pure returns (bytes32 key);\\n\\n  function allIdsByType(uint256 _type, uint256 _index) external view returns (uint256);\\n\\n  function allIdsByTypeLength(uint256 _type) external view returns (uint256);\\n\\n  function readUint(uint256 id, bytes32 key) external view returns (uint256 data);\\n\\n  function readAddress(uint256 id, bytes32 key) external view returns (address data);\\n\\n  function readBytes(uint256 id, bytes32 key) external view returns (bytes memory data);\\n\\n  function readUintArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (uint256 data);\\n\\n  function readBytesArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (bytes memory data);\\n\\n  function readAddressArray(\\n    uint256 id,\\n    bytes32 key,\\n    uint256 index\\n  ) external view returns (address data);\\n}\\n\",\"keccak256\":\"0x3ba6191b4a643bce171bb7dc9b39a55dd0c8c932934429902dec4eb7b6c3df9a\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IGeodeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {Proposal} from \\\"../../modules/GeodeModule/structs/utils.sol\\\";\\n\\ninterface IGeodeModule is IDataStoreModule {\\n  function isolationMode() external view returns (bool);\\n\\n  function GeodeParams()\\n    external\\n    view\\n    returns (\\n      address governance,\\n      address senate,\\n      address approvedUpgrade,\\n      uint256 senateExpiry,\\n      uint256 packageType\\n    );\\n\\n  function getGovernance() external view returns (address);\\n\\n  function getContractVersion() external view returns (uint256);\\n\\n  function getProposal(uint256 id) external view returns (Proposal memory proposal);\\n\\n  function propose(\\n    address _CONTROLLER,\\n    uint256 _TYPE,\\n    bytes calldata _NAME,\\n    uint256 duration\\n  ) external returns (uint256 id);\\n\\n  function rescueSenate(address _newSenate) external;\\n\\n  function approveProposal(\\n    uint256 id\\n  ) external returns (address _controller, uint256 _type, bytes memory _name);\\n\\n  function changeSenate(address _newSenate) external;\\n\\n  function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\\n}\\n\",\"keccak256\":\"0x2eb0e5472c00c7d91443f0544ce349129266665dd59f1e4b0598173df1a9d1c5\",\"license\":\"MIT\"},\"contracts/interfaces/modules/ILiquidityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface ILiquidityModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function LiquidityParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address lpToken,\\n      uint256 pooledTokenId,\\n      uint256 initialA,\\n      uint256 futureA,\\n      uint256 initialATime,\\n      uint256 futureATime,\\n      uint256 swapFee,\\n      uint256 adminFee\\n    );\\n\\n  function getA() external view returns (uint256);\\n\\n  function getAPrecise() external view returns (uint256);\\n\\n  function getBalance(uint8 index) external view returns (uint256);\\n\\n  function getDebt() external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  function getAdminBalance(uint256 index) external view returns (uint256);\\n\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(\\n    uint256[2] calldata amounts,\\n    bool deposit\\n  ) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory);\\n\\n  function calculateRemoveLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) external view returns (uint256 availableTokenAmount);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function addLiquidity(\\n    uint256[2] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[2] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[2] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[2] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function withdrawAdminFees(address receiver) external;\\n\\n  function setAdminFee(uint256 newAdminFee) external;\\n\\n  function setSwapFee(uint256 newSwapFee) external;\\n\\n  function rampA(uint256 futureA, uint256 futureTime) external;\\n\\n  function stopRampA() external;\\n}\\n\",\"keccak256\":\"0xee470aafacf0ec10f63efa53a3f4f8deaf03cd9b0d0aae178949464960ff397a\",\"license\":\"MIT\"},\"contracts/interfaces/modules/IStakeModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IDataStoreModule} from \\\"./IDataStoreModule.sol\\\";\\nimport {Validator} from \\\"../../modules/StakeModule/structs/utils.sol\\\";\\n\\ninterface IStakeModule is IDataStoreModule {\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function setInfrastructureFee(uint256 _type, uint256 fee) external;\\n\\n  function setBeaconDelays(uint256 entry, uint256 exit) external;\\n\\n  function setInitiationDeposit(uint256 newInitiationDeposit) external;\\n\\n  function StakeParams()\\n    external\\n    view\\n    returns (\\n      address gETH,\\n      address oraclePosition,\\n      uint256 validatorsIndex,\\n      uint256 verificationIndex,\\n      uint256 monopolyThreshold,\\n      uint256 beaconDelayEntry,\\n      uint256 beaconDelayExit,\\n      uint256 initiationDeposit,\\n      uint256 oracleUpdateTimestamp,\\n      uint256 dailyPriceIncreaseLimit,\\n      uint256 dailyPriceDecreaseLimit\\n    );\\n\\n  function getValidator(bytes calldata pubkey) external view returns (Validator memory);\\n\\n  function getPackageVersion(uint256 _type) external view returns (uint256);\\n\\n  function getPriceMerkleRoot() external view returns (bytes32);\\n\\n  function getBalancesMerkleRoot() external view returns (bytes32);\\n\\n  function isMiddleware(uint256 _type, uint256 _version) external view returns (bool);\\n\\n  function getInfrastructureFee(uint256 _type) external view returns (uint256);\\n\\n  function initiateOperator(\\n    uint256 id,\\n    uint256 fee,\\n    uint256 validatorPeriod,\\n    address maintainer\\n  ) external payable;\\n\\n  function deployLiquidityPool(uint256 poolId) external;\\n\\n  function initiatePool(\\n    uint256 fee,\\n    uint256 middlewareVersion,\\n    address maintainer,\\n    bytes calldata NAME,\\n    bytes calldata middleware_data,\\n    bool[3] calldata config\\n  ) external payable returns (uint256 poolId);\\n\\n  function setPoolVisibility(uint256 poolId, bool makePrivate) external;\\n\\n  function setWhitelist(uint256 poolId, address whitelist) external;\\n\\n  function setYieldReceiver(uint256 poolId, address yieldReceiver) external;\\n\\n  function changeMaintainer(uint256 id, address newMaintainer) external;\\n\\n  function getMaintenanceFee(uint256 id) external view returns (uint256);\\n\\n  function switchMaintenanceFee(uint256 id, uint256 newFee) external;\\n\\n  function increaseWalletBalance(uint256 id) external payable returns (bool);\\n\\n  function decreaseWalletBalance(uint256 id, uint256 value) external returns (bool);\\n\\n  function isPrisoned(uint256 operatorId) external view returns (bool);\\n\\n  function blameExit(\\n    bytes calldata pk,\\n    uint256 beaconBalance,\\n    uint256 withdrawnBalance,\\n    bytes32[] calldata balanceProof\\n  ) external;\\n\\n  function blameProposal(bytes calldata pk) external;\\n\\n  function getValidatorPeriod(uint256 id) external view returns (uint256);\\n\\n  function switchValidatorPeriod(uint256 operatorId, uint256 newPeriod) external;\\n\\n  function setFallbackOperator(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external;\\n\\n  function operatorAllowance(uint256 poolId, uint256 operatorId) external view returns (uint256);\\n\\n  function delegate(\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external;\\n\\n  function isWhitelisted(uint256 poolId, address staker) external view returns (bool);\\n\\n  function isPrivatePool(uint256 poolId) external view returns (bool);\\n\\n  function isPriceValid(uint256 poolId) external view returns (bool);\\n\\n  function isMintingAllowed(uint256 poolId) external view returns (bool);\\n\\n  function deposit(\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProof,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external payable returns (uint256 boughtgETH, uint256 mintedgETH);\\n\\n  function canStake(bytes calldata pubkey) external view returns (bool);\\n\\n  function proposeStake(\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external;\\n\\n  function stake(uint256 operatorId, bytes[] calldata pubkeys) external;\\n\\n  function requestExit(uint256 poolId, bytes memory pk) external;\\n\\n  function finalizeExit(uint256 poolId, bytes memory pk) external;\\n\\n  function updateVerificationIndex(\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external;\\n\\n  function regulateOperators(uint256[] calldata feeThefts, bytes[] calldata proofs) external;\\n\\n  function reportBeacon(\\n    bytes32 priceMerkleRoot,\\n    bytes32 balanceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external;\\n\\n  function priceSync(uint256 poolId, uint256 price, bytes32[] calldata priceProof) external;\\n\\n  function priceSyncBatch(\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external;\\n}\\n\",\"keccak256\":\"0xc40b5a52176334fe7d2edd7fbd28fc529cf261d8ce3ffa138e0930899d545a03\",\"license\":\"MIT\"},\"contracts/interfaces/packages/IGeodePackage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {IGeodeModule} from \\\"../modules/IGeodeModule.sol\\\";\\nimport {IPortal} from \\\"../IPortal.sol\\\";\\n\\ninterface IGeodePackage is IGeodeModule {\\n  function initialize(\\n    uint256 poolId,\\n    address owner,\\n    bytes calldata versionName,\\n    bytes memory data\\n  ) external;\\n\\n  function getPoolId() external view returns (uint256);\\n\\n  function getProposedVersion() external view returns (uint256);\\n\\n  function pullUpgrade() external;\\n}\\n\",\"keccak256\":\"0x9c854fab873502a768e5903e7f66b6697313f77bea4d5ca200aad8d0c3190ed9\",\"license\":\"MIT\"},\"contracts/interfaces/packages/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {ILiquidityModule} from \\\"../modules/ILiquidityModule.sol\\\";\\nimport {IGeodePackage} from \\\"./IGeodePackage.sol\\\";\\n\\ninterface ILiquidityPool is IGeodePackage, ILiquidityModule {}\\n\",\"keccak256\":\"0x75fe3f103131761db0210141774365c7eb975812178b262564343c7d660f9cb4\",\"license\":\"MIT\"},\"contracts/modules/DataStoreModule/libs/DataStoreModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.20;\\n\\n// external - interfaces\\n// external - libraries\\n// external - contracts\\n// internal - globals\\n// internal - interfaces\\nimport {DataStoreModuleStorage} from \\\"../structs/storage.sol\\\";\\n\\n// internal - structs\\n// internal - libraries\\n\\n/**\\n * @title DSML: DataStore Module Library\\n *\\n * @notice A Storage Management Library created for the contracts and modules that inherits DataStoreModule (DSM).\\n * Enables Dynamic Structs with unlimited key space.\\n * Provides an Isolated Storage Layout with IDs and KEYs.\\n * Focusing on upgradable contracts with various data types to create a\\n * * sustainable development environment.\\n * In summary, extra gas cost that would be saved with Storage packing are\\n * * ignored to create dynamic structs.\\n *\\n * @dev Distinct id and key pairs SHOULD return different storage slots. No collisions!\\n * @dev IDs are the representation of an entity with any given key as properties.\\n * @dev review: Reserved TYPEs are defined within globals/id_type.sol\\n * @dev review: For a safer development process, NEVER use the DataStoreModuleStorage with strings. Refer to globals/reserved_key_space.sol\\n *\\n * @dev While it is a good practice for keeping a record;\\n * * TYPE for ID is not mandatory, an ID might not have an explicit type.\\n * * e.g., When a relational data is added with getKey, like allowance, it has a unique ID but no TYPE.\\n * * Thus there are no checks for types or keys.\\n *\\n * @dev readUint(id, arrayName) returns the lenght of array.\\n *\\n * @dev Contracts relying on this library must use DataStoreModuleLib.DataStoreModuleStorage\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\nlibrary DataStoreModuleLib {\\n  /**\\n   * @custom:section                           ** HELPERS **\\n   *\\n   * @custom:visibility -> pure-internal\\n   */\\n\\n  /**\\n   * @notice generalized method of generating an ID\\n   *\\n   * @dev Some TYPEs may require permissionless creation, allowing anyone to claim any ID;\\n   * meaning malicious actors can claim names to mislead people. To prevent this\\n   * TYPEs will be considered during ID generation.\\n   */\\n  function generateId(bytes memory _name, uint256 _type) internal pure returns (uint256 id) {\\n    id = uint256(keccak256(abi.encode(_name, _type)));\\n  }\\n\\n  /**\\n   * @notice hash of given ID and a KEY defines the key for the DataStoreModuleStorage\\n   * @return key bytes32, hash.\\n   **/\\n  function getKey(uint256 id, bytes32 param) internal pure returns (bytes32 key) {\\n    key = keccak256(abi.encode(id, param));\\n  }\\n\\n  /**\\n   * @custom:section                           ** DATA GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_id, _key)];\\n  }\\n\\n  function readBytes(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_id, _key)];\\n  }\\n\\n  function readAddress(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_id, _key)];\\n  }\\n\\n  /**\\n   * @custom:section                           ** ARRAY GETTERS **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function readUintArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (uint256 data) {\\n    data = self.uintData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readBytesArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (bytes memory data) {\\n    data = self.bytesData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  function readAddressArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _index\\n  ) internal view returns (address data) {\\n    data = self.addressData[getKey(_index, getKey(_id, _key))];\\n  }\\n\\n  /**\\n   * @custom:section                           ** STATE MODIFYING FUNCTIONS **\\n   *\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @custom:subsection                        ** DATA SETTERS **\\n   */\\n\\n  function writeUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function addUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _addend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] += _addend;\\n  }\\n\\n  function subUint(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _minuend\\n  ) internal {\\n    self.uintData[getKey(_id, _key)] -= _minuend;\\n  }\\n\\n  function writeBytes(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    self.bytesData[getKey(_id, _key)] = _data;\\n  }\\n\\n  function writeAddress(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    self.addressData[getKey(_id, _key)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** ARRAY SETTERS **\\n   */\\n\\n  function appendUintArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256 _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.uintData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendBytesArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.bytesData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  function appendAddressArray(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    self.addressData[getKey(self.uintData[arrayKey]++, arrayKey)] = _data;\\n  }\\n\\n  /**\\n   * @custom:subsection                        ** BATCH ARRAY SETTERS **\\n   */\\n\\n  function appendUintArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    uint256[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.uintData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendBytesArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    bytes[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.bytesData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n\\n  function appendAddressArrayBatch(\\n    DataStoreModuleStorage storage self,\\n    uint256 _id,\\n    bytes32 _key,\\n    address[] memory _data\\n  ) internal {\\n    bytes32 arrayKey = getKey(_id, _key);\\n    uint256 arrayLen = self.uintData[arrayKey];\\n\\n    uint256 _dataLen = _data.length;\\n    for (uint256 i; i < _dataLen; ) {\\n      self.addressData[getKey(arrayLen++, arrayKey)] = _data[i];\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.uintData[arrayKey] = arrayLen;\\n  }\\n}\\n\",\"keccak256\":\"0x5a3b3ca22504164ac53369e1fe1d7d7febb603c672fce147ce1a86b4875fd219\",\"license\":\"MIT\"},\"contracts/modules/DataStoreModule/structs/storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Storage Struct for reading/writing operations for given (id, key) pairs.\\n *\\n * @param allIdsByType type => id[], optional categorization for IDs, can be directly accessed.\\n * @param uintData keccak(id, key) =>  returns uint256\\n * @param bytesData keccak(id, key) => returns bytes\\n * @param addressData keccak(id, key) =>  returns address\\n *\\n * @dev any other storage type can be expressed as uint or bytes. E.g., bools are 0/1 as uints.\\n *\\n * @dev normally we would put custom:storage-location erc7201:geode.storage.DataStoreModule\\n * but compiler throws an error... So np for now, just effects dev ex.\\n */\\nstruct DataStoreModuleStorage {\\n  mapping(uint256 => uint256[]) allIdsByType;\\n  mapping(bytes32 => uint256) uintData;\\n  mapping(bytes32 => bytes) bytesData;\\n  mapping(bytes32 => address) addressData;\\n}\\n\",\"keccak256\":\"0x10c4430d4d368abd4bd5488b4cf6c942c6e26e58ae52163926cd5daae3e0c77f\",\"license\":\"MIT\"},\"contracts/modules/GeodeModule/structs/utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Giving the control of a specific ID to proposed CONTROLLER.\\n *\\n * @param TYPE: refer to globals/id_type.sol\\n * @param CONTROLLER: the address that refers to the change that is proposed by given proposal.\\n * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\\n * @param NAME: DataStore generates ID by keccak(name, type)\\n * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\\n * * Expired proposals cannot be approved by Senate\\n * * Expired proposals cannot be overriden by new proposals\\n **/\\nstruct Proposal {\\n  address CONTROLLER;\\n  uint256 TYPE;\\n  bytes NAME;\\n  uint256 deadline;\\n}\\n\",\"keccak256\":\"0xe3ec6ceacdbd2f960316b9c8b0bf930364c3f096fe9bf56849d9b4814c320643\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/DepositContractLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - interfaces\\nimport {IDepositContract} from \\\"../../../interfaces/helpers/IDepositContract.sol\\\";\\n// internal - libraries\\nimport {BytesLib} from \\\"../../../helpers/BytesLib.sol\\\";\\n\\n/**\\n * @title DCL: Deposit Contract Library\\n *\\n * @notice Includes constants & functions that helps to the deposit process.\\n *\\n * @dev DEPOSIT_CONTRACT is chain specific and should be changed before deployments.\\n *\\n * @dev This is an internal library, requires NO deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary DepositContractLib {\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  IDepositContract internal constant DEPOSIT_CONTRACT =\\n    IDepositContract(0x4242424242424242424242424242424242424242);\\n  uint256 internal constant PUBKEY_LENGTH = 48;\\n  uint256 internal constant SIGNATURE_LENGTH = 96;\\n  uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\\n  uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\\n  uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\\n  uint256 internal constant MAX_DEPOSITS_PER_CALL = 50;\\n\\n  /**\\n   * @custom:section                           ** FUNCTIONS **\\n   */\\n\\n  /**\\n   * @dev Padding memory array with zeroes up to 64 bytes on the right\\n   * @param _b Memory array of size 32 .. 64\\n   */\\n  function _pad64(bytes memory _b) internal pure returns (bytes memory) {\\n    assert(_b.length >= 32 && _b.length <= 64);\\n    if (64 == _b.length) return _b;\\n\\n    bytes memory zero32 = new bytes(32);\\n    assembly {\\n      mstore(add(zero32, 0x20), 0)\\n    }\\n\\n    if (32 == _b.length) return BytesLib.concat(_b, zero32);\\n    else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64 - _b.length)));\\n  }\\n\\n  /**\\n   * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\\n   * @param _value Number less than `2**64` for compatibility reasons\\n   */\\n  function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n    result = 0;\\n    uint256 temp_value = _value;\\n    for (uint256 i; i < 8; ++i) {\\n      result = (result << 8) | (temp_value & 0xFF);\\n      temp_value >>= 8;\\n    }\\n\\n    assert(0 == temp_value); // fully converted\\n    result <<= (24 * 8);\\n  }\\n\\n  function _getDepositDataRoot(\\n    bytes memory _pubkey,\\n    bytes memory _withdrawalCredentials,\\n    bytes memory _signature,\\n    uint256 _stakeAmount\\n  ) internal pure returns (bytes32) {\\n    require(_stakeAmount >= 1 ether, \\\"DepositContract: deposit value too low\\\");\\n    require(_stakeAmount % 1 gwei == 0, \\\"DepositContract: deposit value not multiple of gwei\\\");\\n\\n    uint256 deposit_amount = _stakeAmount / 1 gwei;\\n    bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\\n    bytes32 signatureRoot = sha256(\\n      abi.encodePacked(\\n        sha256(BytesLib.slice(_signature, 0, 64)),\\n        sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\\n      )\\n    );\\n\\n    bytes32 depositDataRoot = sha256(\\n      abi.encodePacked(\\n        sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\\n        sha256(abi.encodePacked(_toLittleEndian64(deposit_amount), signatureRoot))\\n      )\\n    );\\n\\n    return depositDataRoot;\\n  }\\n\\n  /**\\n   * @notice converts an address to withdrawal credential, used on validator creation\\n   */\\n  function addressToWC(address wcAddress) internal pure returns (bytes memory) {\\n    uint256 w = 1 << 248;\\n\\n    return abi.encodePacked(bytes32(w) | bytes32(uint256(uint160(address(wcAddress)))));\\n  }\\n\\n  /**\\n   * @notice deposit to DEPOSIT_CONTRACT and initiate a validator.\\n   */\\n  function depositValidator(\\n    bytes calldata pubkey,\\n    bytes memory withdrawalCredential,\\n    bytes memory signature,\\n    uint256 amount\\n  ) internal {\\n    DEPOSIT_CONTRACT.deposit{value: amount}(\\n      pubkey,\\n      withdrawalCredential,\\n      signature,\\n      _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\\n    );\\n  }\\n}\\n\",\"keccak256\":\"0x71fa2b28cf5299abb9cfd8d7b8130c84f104b7a74d3ee2d6f5274e2fcc9a7ab2\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/OracleExtensionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// external - libraries\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n// internal - globals\\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \\\"../../../globals/macros.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {VALIDATOR_STATE} from \\\"../../../globals/validator_state.sol\\\";\\n// internal - structs\\nimport {DataStoreModuleStorage} from \\\"../../DataStoreModule/structs/storage.sol\\\";\\nimport {StakeModuleStorage} from \\\"../structs/storage.sol\\\";\\n// internal - libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {DepositContractLib as DCL} from \\\"./DepositContractLib.sol\\\";\\nimport {StakeModuleLib as SML} from \\\"./StakeModuleLib.sol\\\";\\n\\n/**\\n * @title OEL: Oracle Extension Library\\n *\\n * @notice An extension to SML\\n * @notice Oracle, named Telescope, handles some operations for The Staking Library,\\n * * using the logic explained below.\\n *\\n * @dev review: DataStoreModule for the id based isolated storage logic.\\n * @dev review: StakeModuleLib for base staking logic.\\n *\\n * @dev Telescope is currently responsible for 4 tasks:\\n * * Updating the on-chain price of all pools with a MerkleRoot for minting operations\\n * * Updating the on-chain balances info of all validators with a MerkleRoot for withdrawal operations\\n * * Confirming validator proposals\\n * * Regulating the Node Operators\\n *\\n * 1. updateVerificationIndex: Confirming validator proposals\\n * * 2 step process is essential to prevent the frontrunning with a problematic withdrawalCredential: https://bit.ly/3Tkc6UC\\n * * Simply, all proposed validator has an index bound to them,\\n * * n representing the latest proposal: (0,n]\\n * * Telescope verifies the validator data provided in proposeStake:\\n * * especially sig1, sig31 and withdrawal credentials.\\n * * Telescope confirms the latest index verified and states the faulty validator proposals (aliens)\\n * * If a validator proposal is faulty then it's state is set to 69, refer to globals/validator_state.sol\\n *\\n * 2. regulateOperators: Regulating the Operators\\n * * Operators can act faulty in many different ways. To prevent such actions,\\n * * Telescope regulates them with well defined limitations.\\n * * Currently only issue is the fee theft, meaning operators have not\\n * * used the withdrawal contract for miner fees or MEV boost.\\n * * There can be other restrictions in the future.\\n *\\n * 2. reportBeacon: Continous Data from Beacon chain: Price Merkle Root & Balances Merkle Root & # of active validators\\n * * 1. Oracle Nodes calculate the price of its derivative, according to the validator data such as balance and fees.\\n * * 2. If a pool doesn't have a validator, the price is kept the same.\\n * * 3. A merkle tree is constructed with the order of allIdsByType array.\\n * * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root.\\n * * 5. Anyone can update the price of the derivative  by calling priceSync() functions with correct merkle proofs\\n * * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update.\\n * * 7. Updates the regulation around Monopolies and provides BALANCE_MERKLE_ROOT to be used within withdrawal process.\\n *\\n * @dev Most external functions have OracleOnly modifier. Except: priceSync, priceSyncBatch, blameExit and blameProposal.\\n *\\n * @dev This is an external library, requires deployment.\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary OracleExtensionLib {\\n  using DSML for DataStoreModuleStorage;\\n  using SML for StakeModuleStorage;\\n\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n  /// @notice effective on MONOPOLY_THRESHOLD, limiting the active validators: Set to 1%\\n  uint256 internal constant MONOPOLY_RATIO = 1e8; // PERCENTAGE_DENOMINATOR / 100;\\n\\n  /// @notice sensible value for the minimum beacon chain validators. No reasoning.\\n  uint256 internal constant MIN_VALIDATOR_COUNT = 50000;\\n\\n  /// @notice limiting the access for Operators in case of bad/malicious/faulty behaviour\\n  uint256 internal constant PRISON_SENTENCE = 14 days;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event Alienated(bytes pubkey);\\n  event VerificationIndexUpdated(uint256 validatorVerificationIndex);\\n  event FeeTheft(uint256 indexed id, bytes proofs);\\n  event Prisoned(uint256 indexed operatorId, bytes proof, uint256 releaseTimestamp);\\n  event YieldDistributed(uint256 indexed poolId, uint256 amount);\\n  event OracleReported(\\n    bytes32 priceMerkleRoot,\\n    bytes32 balanceMerkleRoot,\\n    uint256 monopolyThreshold\\n  );\\n\\n  /**\\n   * @custom:section                           ** MODIFIERS **\\n   */\\n  modifier onlyOracle(StakeModuleStorage storage self) {\\n    require(msg.sender == self.ORACLE_POSITION, \\\"OEL:sender not ORACLE\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @custom:section                                       ** VERIFICATION INDEX **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   *\\n   * @notice \\\"Alien\\\" is a validator that is created with a faulty withdrawal\\n   * credential or signatures, this is a malicious act.\\n   * @notice Alienation results in imprisonment for the operator of the faulty validator proposal.\\n   * @dev While alienating a validator we should adjust the 'surplus' and 'secured'\\n   * balances of the pool accordingly\\n   * @dev We should adjust the 'proposedValidators' to fix allowances.\\n   */\\n  function _alienateValidator(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 verificationIndex,\\n    bytes calldata _pk\\n  ) internal {\\n    require(self.validators[_pk].index <= verificationIndex, \\\"OEL:unexpected index\\\");\\n    require(\\n      self.validators[_pk].state == VALIDATOR_STATE.PROPOSED,\\n      \\\"OEL:not all pubkeys are pending\\\"\\n    );\\n\\n    uint256 operatorId = self.validators[_pk].operatorId;\\n    _imprison(DATASTORE, operatorId, _pk);\\n\\n    uint256 poolId = self.validators[_pk].poolId;\\n    DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT);\\n    DATASTORE.addUint(poolId, rks.surplus, DCL.DEPOSIT_AMOUNT);\\n\\n    DATASTORE.subUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), 1);\\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.alienValidators), 1);\\n\\n    self.validators[_pk].state = VALIDATOR_STATE.ALIENATED;\\n\\n    emit Alienated(_pk);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   *\\n   * @notice Updating VERIFICATION_INDEX, signaling that it is safe to activate\\n   * the validator proposals with lower index than new VERIFICATION_INDEX\\n   * @param validatorVerificationIndex (inclusive) index of the highest validator that is verified to be activated\\n   * @param alienatedPubkeys faulty proposals within the range of new and old verification indexes.\\n   */\\n  function updateVerificationIndex(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 validatorVerificationIndex,\\n    bytes[] calldata alienatedPubkeys\\n  ) external onlyOracle(self) {\\n    require(self.VALIDATORS_INDEX >= validatorVerificationIndex, \\\"OEL:high VERIFICATION_INDEX\\\");\\n    require(validatorVerificationIndex > self.VERIFICATION_INDEX, \\\"OEL:low VERIFICATION_INDEX\\\");\\n\\n    uint256 alienatedPubkeysLen = alienatedPubkeys.length;\\n    for (uint256 i; i < alienatedPubkeysLen; ) {\\n      _alienateValidator(self, DATASTORE, validatorVerificationIndex, alienatedPubkeys[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    self.VERIFICATION_INDEX = validatorVerificationIndex;\\n    emit VerificationIndexUpdated(validatorVerificationIndex);\\n  }\\n\\n  /**\\n   * @dev                                       ** REGULATING OPERATORS **\\n   */\\n\\n  /**\\n   * @custom:section                           ** PRISON **\\n   *\\n   * When node operators act in a malicious way, which can also be interpreted as\\n   * an honest mistake like using a faulty signature, Oracle imprisons the operator.\\n   * These conditions are:\\n   * * 1. Created a malicious validator(alien): faulty withdrawal credential, faulty signatures etc.\\n   * * 2. Have not respect the validatorPeriod (or blamed for some other valid case)\\n   * * 3. Stole block fees or MEV boost rewards from the pool\\n   *\\n   * @dev this section lacks a potential punishable act, for now early exits are not enforced:\\n   * While state is EXIT_REQUESTED: validator requested exit, but it hasn't been executed.\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Put an operator in prison\\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function _imprison(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    bytes calldata _proof\\n  ) internal {\\n    SML._authenticate(DATASTORE, _operatorId, false, false, [true, false]);\\n\\n    DATASTORE.writeUint(_operatorId, rks.release, block.timestamp + PRISON_SENTENCE);\\n\\n    emit Prisoned(_operatorId, _proof, block.timestamp + PRISON_SENTENCE);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice imprisoning an Operator if the validator proposal is approved but have not been executed.\\n   * @dev anyone can call this function while the state is PROPOSED\\n   * @dev this check can be problematic in the case the beaconchain deposit delay is > BEACON_DELAY_ENTRY,\\n   * * depending on the expected delay of telescope approvals. However, BEACON_DELAY_ENTRY can be adjusted by the Governance.\\n   * @dev _canStake checks == VALIDATOR_STATE.PROPOSED.\\n   */\\n  function blameProposal(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    bytes calldata pk\\n  ) external {\\n    uint256 verificationIndex = self.VERIFICATION_INDEX;\\n    require(self._canStake(pk, verificationIndex), \\\"OEL:cannot blame proposal\\\");\\n    require(\\n      block.timestamp > self.validators[pk].createdAt + self.BEACON_DELAY_ENTRY,\\n      \\\"OEL:acceptable delay\\\"\\n    );\\n\\n    _alienateValidator(self, DATASTORE, verificationIndex, pk);\\n  }\\n\\n  /**\\n   * @notice imprisoning an Operator if the validator have not been exited until expected exit\\n   * @dev normally, oracle should verify the signed exit request on beacon chain for a (deterministic) epoch\\n   * * before approval. This function enforces it further for the stakers.\\n   * @dev anyone can call this function while the state is ACTIVE or EXIT_REQUESTED\\n   * @dev if operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned\\n   */\\n  function blameExit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    bytes calldata pk,\\n    uint256 beaconBalance,\\n    uint256 withdrawnBalance,\\n    bytes32[] calldata balanceProof\\n  ) external {\\n    uint64 state = self.validators[pk].state;\\n    require(\\n      state == VALIDATOR_STATE.ACTIVE || state == VALIDATOR_STATE.EXIT_REQUESTED,\\n      \\\"OEL:unexpected validator state\\\"\\n    );\\n    require(\\n      block.timestamp >\\n        self.validators[pk].createdAt + self.validators[pk].period + self.BEACON_DELAY_EXIT,\\n      \\\"OEL:validator is active or acceptable delay\\\"\\n    );\\n\\n    // verify balances\\n    bytes32 leaf = keccak256(\\n      bytes.concat(keccak256(abi.encode(pk, beaconBalance, withdrawnBalance)))\\n    );\\n    require(\\n      MerkleProof.verify(balanceProof, self.BALANCE_MERKLE_ROOT, leaf),\\n      \\\"OEL:proof not valid\\\"\\n    );\\n\\n    require(beaconBalance != 0, \\\"OEL:already exited\\\");\\n\\n    _imprison(DATASTORE, self.validators[pk].operatorId, pk);\\n  }\\n\\n  /**\\n  \\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice regulating operators, currently only regulation is towards fee theft, can add more stuff in the future.\\n   * @param feeThefts Operator ids who have stolen MEV or block rewards detected\\n   * @param proofs  BlockNumber, tx or any other referance as a proof\\n   * @dev Stuff here result in imprisonment\\n   */\\n  function regulateOperators(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256[] calldata feeThefts,\\n    bytes[] calldata proofs\\n  ) external onlyOracle(self) {\\n    require(feeThefts.length == proofs.length, \\\"OEL:invalid proofs\\\");\\n\\n    uint256 feeTheftsLen = feeThefts.length;\\n    for (uint256 i; i < feeTheftsLen; ) {\\n      _imprison(DATASTORE, feeThefts[i], proofs[i]);\\n\\n      emit FeeTheft(feeThefts[i], proofs[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** CONTINUOUS UPDATES **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT.\\n   * Also reports all of the validator balances with a BALANCE_MERKLE_ROOT.\\n   * Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD\\n   *\\n   * @param allValidatorsCount Number of all validators within BeaconChain, all of them.\\n   * Prevents monopolies.\\n   */\\n  function reportBeacon(\\n    StakeModuleStorage storage self,\\n    bytes32 priceMerkleRoot,\\n    bytes32 balanceMerkleRoot,\\n    uint256 allValidatorsCount\\n  ) external onlyOracle(self) {\\n    require(allValidatorsCount > MIN_VALIDATOR_COUNT, \\\"OEL:low validator count\\\");\\n\\n    self.PRICE_MERKLE_ROOT = priceMerkleRoot;\\n    self.BALANCE_MERKLE_ROOT = balanceMerkleRoot;\\n    self.ORACLE_UPDATE_TIMESTAMP = block.timestamp;\\n\\n    uint256 newThreshold = (allValidatorsCount * MONOPOLY_RATIO) / PERCENTAGE_DENOMINATOR;\\n    self.MONOPOLY_THRESHOLD = newThreshold;\\n\\n    emit OracleReported(priceMerkleRoot, balanceMerkleRoot, newThreshold);\\n  }\\n\\n  /**\\n   * @custom:section                           **  PRICE UPDATE **\\n   *\\n   * @dev Permissionless.\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-internal\\n   *\\n   * @dev in order to prevent faulty updates to the derivative prices there are boundaries to price updates.\\n   * 1. Price should not be increased more than DAILY_PRICE_INCREASE_LIMIT\\n   *  with the factor of how many days since priceUpdateTimestamp has past.\\n   * 2. Price should not be decreased more than DAILY_PRICE_DECREASE_LIMIT\\n   *  with the factor of how many days since priceUpdateTimestamp has past.\\n   *\\n   * @dev Worth noting, if price drops more than x%, UP TO (slashing percentage/x) days deposits/withdrawals are halted.\\n   * Example:\\n   * * A pool can have only one validator, it can get slashed.\\n   * * Lets say max decrease is 5%, and 50% is slashed.\\n   * * Then deposits/withdrawals are halted for 10 days.\\n   * This is not a bug, but a safe circuit-breaker.\\n   * This logic have effects the withdrawal contract logic.\\n   */\\n  function _sanityCheck(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _newPrice\\n  ) internal view {\\n    require(DATASTORE.readUint(_id, rks.TYPE) == ID_TYPE.POOL, \\\"OEL:not a pool?\\\");\\n\\n    uint256 lastUpdate = self.gETH.priceUpdateTimestamp(_id);\\n    uint256 dayPercentSinceUpdate = ((block.timestamp - lastUpdate) * PERCENTAGE_DENOMINATOR) /\\n      1 days;\\n\\n    uint256 curPrice = self.gETH.pricePerShare(_id);\\n\\n    uint256 maxPriceIncrease = ((curPrice *\\n      self.DAILY_PRICE_INCREASE_LIMIT *\\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\\n\\n    uint256 maxPriceDecrease = ((curPrice *\\n      self.DAILY_PRICE_DECREASE_LIMIT *\\n      dayPercentSinceUpdate) / PERCENTAGE_DENOMINATOR) / PERCENTAGE_DENOMINATOR;\\n\\n    require(\\n      (_newPrice + maxPriceDecrease >= curPrice) && (_newPrice <= curPrice + maxPriceIncrease),\\n      \\\"OEL:price is insane, price update is halted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   *\\n   * @notice syncing the price of g-derivatives after checking the merkle proofs and the sanity of the price.\\n   * @param _price price of the derivative denominated in gETH.denominator()\\n   * @param _priceProof merkle proofs\\n   */\\n  function _priceSync(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _price,\\n    bytes32[] calldata _priceProof\\n  ) internal {\\n    require(\\n      self.ORACLE_UPDATE_TIMESTAMP > self.gETH.priceUpdateTimestamp(_poolId),\\n      \\\"OEL:no price change\\\"\\n    );\\n\\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_poolId, _price))));\\n    require(\\n      MerkleProof.verify(_priceProof, self.PRICE_MERKLE_ROOT, leaf),\\n      \\\"OEL:not all proofs are valid\\\"\\n    );\\n\\n    _sanityCheck(self, DATASTORE, _poolId, _price);\\n\\n    address yieldReceiver = DATASTORE.readAddress(_poolId, rks.yieldReceiver);\\n\\n    if (yieldReceiver == address(0)) {\\n      self.gETH.setPricePerShare(_price, _poolId);\\n    } else {\\n      uint256 currentPrice = self.gETH.pricePerShare(_poolId);\\n      if (_price > currentPrice) {\\n        uint256 supplyDiff = ((_price - currentPrice) * self.gETH.totalSupply(_poolId)) /\\n          gETH_DENOMINATOR;\\n        self.gETH.mint(address(this), _poolId, supplyDiff, \\\"\\\");\\n        self.gETH.safeTransferFrom(address(this), yieldReceiver, _poolId, supplyDiff, \\\"\\\");\\n        emit YieldDistributed(_poolId, supplyDiff);\\n      } else {\\n        self.gETH.setPricePerShare(_price, _poolId);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   *\\n   * @notice external function to set a derivative price on Portal\\n   * @param price price of the derivative denominated in gETH.denominator()\\n   * @param priceProof merkle proofs\\n   */\\n  function priceSync(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 price,\\n    bytes32[] calldata priceProof\\n  ) external {\\n    _priceSync(self, DATASTORE, poolId, price, priceProof);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   *\\n   * @notice external function to set a multiple derivatives price at once, saves gas.\\n   * @param prices price of the derivative denominated in gETH.denominator()\\n   * @param priceProofs merkle proofs\\n   */\\n  function priceSyncBatch(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256[] calldata poolIds,\\n    uint256[] calldata prices,\\n    bytes32[][] calldata priceProofs\\n  ) external {\\n    require(poolIds.length == prices.length, \\\"OEL:array lengths not equal\\\");\\n    require(poolIds.length == priceProofs.length, \\\"OEL:array lengths not equal\\\");\\n\\n    uint256 poolIdsLen = poolIds.length;\\n    for (uint256 i; i < poolIdsLen; ) {\\n      _priceSync(self, DATASTORE, poolIds[i], prices[i], priceProofs[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x17073d70c752b15e7df86a222f4167a139ce911cb0c7226c7b5b4224162aedc1\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/libs/StakeModuleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - globals\\nimport {ID_TYPE} from \\\"../../../globals/id_type.sol\\\";\\nimport {PERCENTAGE_DENOMINATOR, gETH_DENOMINATOR} from \\\"../../../globals/macros.sol\\\";\\nimport {VALIDATOR_STATE} from \\\"../../../globals/validator_state.sol\\\";\\nimport {RESERVED_KEY_SPACE as rks} from \\\"../../../globals/reserved_key_space.sol\\\";\\n// internal - interfaces\\nimport {IgETH} from \\\"../../../interfaces/IgETH.sol\\\";\\nimport {IGeodePackage} from \\\"../../../interfaces/packages/IGeodePackage.sol\\\";\\nimport {ILiquidityPool} from \\\"../../../interfaces/packages/ILiquidityPool.sol\\\";\\nimport {IWhitelist} from \\\"../../../interfaces/helpers/IWhitelist.sol\\\";\\n// internal - structs\\nimport {DataStoreModuleStorage} from \\\"../../DataStoreModule/structs/storage.sol\\\";\\nimport {StakeModuleStorage} from \\\"../structs/storage.sol\\\";\\nimport {ConstantValidatorData} from \\\"../structs/helpers.sol\\\";\\nimport {Validator} from \\\"../structs/utils.sol\\\";\\n// internal - libraries\\nimport {DataStoreModuleLib as DSML} from \\\"../../DataStoreModule/libs/DataStoreModuleLib.sol\\\";\\nimport {DepositContractLib as DCL} from \\\"./DepositContractLib.sol\\\";\\n\\n/**\\n * @title SML: Stake Module Library (The Staking Library)\\n *\\n * @notice Creating a global standard for Staking, allowing anyone to OWN a trustless staking pool,\\n * improving the user experience for stakers and removing the \\\"need\\\" for centralized or decentralized intermediaries.\\n * * Exclusively contains functions related to:\\n * * 1. Pool and Operator management, after initiation (review IEL).\\n * * 2. Validator Delegation.\\n * * 3. Depositing.\\n * * 4. Staking Operations.\\n *\\n * @dev review: DataStoreModule for the id based isolated storage logic.\\n * @dev review: InitiatorExtensionLib for initiator functions.\\n * @dev review: OracleExtensionLib for oracle logic.\\n *\\n * @dev Every pool is isolated and every validator is unique. We segregate all the risk.\\n *\\n * @dev CONTROLLER and Maintainer:\\n * CONTROLLER is the owner of an ID, it manages the pool/operator. Its security is exteremely important.\\n * maintainer is the worker, can be used to automate some daily tasks:\\n * * distributing validators for Staking Pools or creating validators for Operators.\\n * * not so crucial in terms of security.\\n *\\n * @dev Users:\\n * Type 4 : Permissioned Operators\\n * * Needs to be onboarded by the Dual Governance (Senate + Governance).\\n * * Maintains Beacon Chain Validators on behalf of the Staking Pools.\\n * * Can participate in the Operator Marketplace after initiation.\\n * * Can utilize maintainers for staking operations.\\n *\\n * Type 5 : Permissionless Configurable Staking Pools\\n * * Permissionless to create.\\n * * Can utilize powers of packages and middlewares such as Bound Liquidity Pools, gETHMiddlewares etc.\\n * * Can be public or private, can use a whitelist if private.\\n * * Can utilize maintainers for validator distribution on Operator Marketplace.\\n * * Uses a Withdrawal Contract to be given as withdrawalCredential on validator creation,\\n * * accruing rewards and keeping Staked Ether safe and isolated.\\n *\\n * @dev Packages:\\n * An ID can only point to one version of a Package at a time.\\n * Built by utilizing the Modules!\\n * Can be upgraded by a dual governance, via pullUpgrade.\\n * * A Package's dual governance consists of Portal(governance) and the pool owner(senate).\\n *\\n * Type 10011 : Withdrawal Contract\\n * * Mandatory.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Staking Pools are in \\\"Isolation Mode\\\" until their Withdrawal Contract is upgraded.\\n * * * Meaning, no more Depositing or Validator Proposal can happen.\\n * * Custodian of the validator funds after creation, including any type of rewards and fees.\\n *\\n * Type 10021 : Liquidity Pool implementation\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Version Release Requires the approval of Senate\\n * * Upgrading to a new version is optional for pool owners.\\n * * * Liquidity Pools are in \\\"Isolation Mode\\\" until upgraded.\\n *\\n * @dev Middlewares:\\n * Can support many different versions that can be utilized by the Pool Owners.\\n * No particular way to build one.\\n * Cannot be upgraded.\\n * Currently only gETHMiddlewares.\\n *\\n * Type 20011 : gETHMiddleware\\n * * Optional.\\n * * CONTROLLER is the implementation contract position (always)\\n * * Requires the approval of Senate\\n * * Currently should be utilized on initiation.\\n *\\n * @dev Contracts relying on this library must initialize StakeModuleLib.StakeModuleStorage\\n *\\n * @dev Functions are protected with authentication function\\n *\\n * @author Ice Bear & Crash Bandicoot\\n */\\n\\nlibrary StakeModuleLib {\\n  using DSML for DataStoreModuleStorage;\\n\\n  /**\\n   * @custom:section                           ** CONSTANTS **\\n   */\\n\\n  /// @notice limiting the GOVERNANCE_FEE to 5%\\n  uint256 internal constant MAX_POOL_INFRASTRUCTURE_FEE = 5e8; // (PERCENTAGE_DENOMINATOR * 5) / 100;\\n\\n  /// @notice limit the beacon delays on entry and exit since it can be adjusted by the governance.\\n  uint256 internal constant MAX_BEACON_DELAY = 90 days; // = MIN_VALIDATOR_PERIOD\\n\\n  /// @notice limiting the pool and operator maintenance fee, 10%\\n  uint256 internal constant MAX_MAINTENANCE_FEE = 1e9; // (PERCENTAGE_DENOMINATOR * 10) / 100;\\n\\n  /// @notice effective on allowance per operator, prevents overflow. Exclusive, save gas with +1.\\n  uint256 internal constant MAX_ALLOWANCE = 1e6;\\n\\n  /// @notice price of gETH is only valid for 24H, minting is not allowed afterwards.\\n  uint256 internal constant PRICE_EXPIRY = 24 hours;\\n\\n  /// @notice ignoring any buybacks if the Liquidity Pool has a low debt\\n  uint256 internal constant IGNORABLE_DEBT = 1 ether;\\n\\n  /// @notice limiting the operator.validatorPeriod, between 3 months to 2 years\\n  uint256 internal constant MIN_VALIDATOR_PERIOD = 90 days; // 3 * 30 days\\n  uint256 internal constant MAX_VALIDATOR_PERIOD = 730 days; // 2 * 365 days\\n\\n  /// @notice some parameter changes are effective after a delay\\n  uint256 internal constant SWITCH_LATENCY = 3 days;\\n\\n  /**\\n   * @custom:section                           ** EVENTS **\\n   */\\n  event InfrastructureFeeSet(uint256 _type, uint256 fee);\\n  event BeaconDelaySet(uint256 entryDelay, uint256 exitDelay);\\n  event VisibilitySet(uint256 id, bool isPrivate);\\n  event YieldReceiverSet(uint256 indexed poolId, address yieldReceiver);\\n  event MaintainerChanged(uint256 indexed id, address newMaintainer);\\n  event FeeSwitched(uint256 indexed id, uint256 fee, uint256 effectiveAfter);\\n  event ValidatorPeriodSwitched(uint256 indexed operatorId, uint256 period, uint256 effectiveAfter);\\n  event Delegation(uint256 poolId, uint256 indexed operatorId, uint256 allowance);\\n  event FallbackOperator(uint256 poolId, uint256 indexed operatorId, uint256 threshold);\\n  event Deposit(uint256 indexed poolId, uint256 boughtgETH, uint256 mintedgETH);\\n  event StakeProposal(uint256 poolId, uint256 operatorId, bytes[] pubkeys);\\n  event Stake(bytes[] pubkeys);\\n  event ExitRequest(bytes pubkey);\\n  event Exit(bytes pubkey);\\n\\n  /**\\n   * @custom:section                           ** GOVERNING **\\n   *\\n   * @custom:visibility -> external\\n   * @dev IMPORTANT! These functions should be governed by a governance! Which is not done here!\\n   */\\n\\n  /**\\n   * @notice Set the maxiumum allowed beacon delay for blaming validators on creation and exit.\\n   * @dev high beacon delays will affect the ux negatively, low delays can cause issues for operators.\\n   */\\n  function setBeaconDelays(StakeModuleStorage storage self, uint256 entry, uint256 exit) external {\\n    require(entry < MAX_BEACON_DELAY, \\\"SML:> MAX\\\");\\n    require(exit < MAX_BEACON_DELAY, \\\"SML:> MAX\\\");\\n\\n    self.BEACON_DELAY_ENTRY = entry;\\n    self.BEACON_DELAY_EXIT = exit;\\n\\n    emit BeaconDelaySet(entry, exit);\\n  }\\n\\n  /**\\n   * @notice Set a fee (denominated in PERCENTAGE_DENOMINATOR) for any given TYPE.\\n   * @dev Changing the Staking Pool fee, only applies to the newly created validators.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   */\\n  function setInfrastructureFee(\\n    StakeModuleStorage storage self,\\n    uint256 _type,\\n    uint256 fee\\n  ) external {\\n    if (_type == ID_TYPE.POOL) {\\n      require(fee <= MAX_POOL_INFRASTRUCTURE_FEE, \\\"PORTAL:> MAX\\\");\\n    } else {\\n      require(fee < PERCENTAGE_DENOMINATOR, \\\"SML:> 100%\\\");\\n    }\\n\\n    self.infrastructureFees[_type] = fee;\\n    emit InfrastructureFeeSet(_type, fee);\\n  }\\n\\n  /**\\n   * @custom:section                           ** AUTHENTICATION **\\n   *\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  /**\\n   * @notice restricts the access to given function based on TYPE and msg.sender\\n   * @param _expectCONTROLLER restricts the access to only CONTROLLER.\\n   * @param _expectMaintainer restricts the access to only maintainer.\\n   * @param _restrictionMap Restricts which TYPEs can pass the authentication.\\n   * * [0: Operator = TYPE(4), 1: Pool = TYPE(5)]\\n   * @dev can only be used after an ID is initiated\\n   * @dev CONTROLLERS and maintainers of the Prisoned Operators cannot access.\\n   */\\n  function _authenticate(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    bool _expectCONTROLLER,\\n    bool _expectMaintainer,\\n    bool[2] memory _restrictionMap\\n  ) internal view {\\n    require(DATASTORE.readUint(_id, rks.initiated) != 0, \\\"SML:not initiated\\\");\\n\\n    uint256 typeOfId = DATASTORE.readUint(_id, rks.TYPE);\\n\\n    if (typeOfId == ID_TYPE.OPERATOR) {\\n      require(_restrictionMap[0], \\\"SML:TYPE not allowed\\\");\\n      if (_expectCONTROLLER || _expectMaintainer) {\\n        require(!isPrisoned(DATASTORE, _id), \\\"SML:prisoned, get in touch with governance\\\");\\n      }\\n    } else if (typeOfId == ID_TYPE.POOL) {\\n      require(_restrictionMap[1], \\\"SML:TYPE not allowed\\\");\\n    } else {\\n      revert(\\\"SML:invalid TYPE\\\");\\n    }\\n\\n    if (_expectMaintainer) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.maintainer),\\n        \\\"SML:sender not maintainer\\\"\\n      );\\n      return;\\n    }\\n\\n    if (_expectCONTROLLER) {\\n      require(\\n        msg.sender == DATASTORE.readAddress(_id, rks.CONTROLLER),\\n        \\\"SML:sender not CONTROLLER\\\"\\n      );\\n      return;\\n    }\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** POOL VISIBILITY **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice changes the visibility of the pool\\n   * @param makePrivate true if pool should be private, false for public pools\\n   * @dev whitelist is cleared when pool is set to public, to prevent legacy bugs if ever made private again.\\n   * Note private pools can whitelist addresses with the help of a third party contract.\\n   */\\n  function setPoolVisibility(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bool makePrivate\\n  ) public {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(makePrivate != isPrivatePool(DATASTORE, poolId), \\\"SML:already set\\\");\\n\\n    DATASTORE.writeUint(poolId, rks.privatePool, makePrivate ? 1 : 0);\\n\\n    if (!makePrivate) {\\n      DATASTORE.writeAddress(poolId, rks.whitelist, address(0));\\n    }\\n\\n    emit VisibilitySet(poolId, makePrivate);\\n  }\\n\\n  /**\\n   * @notice private pools can whitelist addresses with the help of a third party contract.\\n   * @dev Whitelisting contracts should implement IWhitelist interface.\\n   */\\n  function setWhitelist(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address whitelist\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n    require(isPrivatePool(DATASTORE, poolId), \\\"SML:must be private pool\\\");\\n\\n    DATASTORE.writeAddress(poolId, rks.whitelist, whitelist);\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the pool is private\\n   */\\n  function isPrivatePool(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return (DATASTORE.readUint(poolId, rks.privatePool) == 1);\\n  }\\n\\n  /**\\n   * @notice checks if the Whitelist allows staker to use given private pool\\n   * @dev Owner of the pool doesn't need whitelisting\\n   * @dev Otherwise requires a whitelisting address to be set\\n   */\\n  function isWhitelisted(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address staker\\n  ) public view returns (bool) {\\n    if (DATASTORE.readAddress(poolId, rks.CONTROLLER) == staker) {\\n      return true;\\n    }\\n\\n    address whitelist = DATASTORE.readAddress(poolId, rks.whitelist);\\n    if (whitelist == address(0)) {\\n      return false;\\n    }\\n\\n    if (whitelist.code.length > 0) {\\n      try IWhitelist(whitelist).isAllowed(staker) returns (bool _isAllowed) {\\n        return _isAllowed;\\n      } catch {\\n        return false;\\n      }\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** ID MANAGEMENT **\\n   *\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** YIELD SEPARATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Set the yield receiver address to activate or deactivete yield separation logic.\\n   * * If set other than address(0) separation will be activated, if set back to address(0)\\n   * * separation will be deactivated again.\\n   * @param poolId the gETH id of the Pool\\n   * @param yieldReceiver address of the yield receiver\\n   * @dev Only CONTROLLER of pool can set yield receier.\\n   */\\n  function setYieldReceiver(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    address yieldReceiver\\n  ) external {\\n    _authenticate(DATASTORE, poolId, true, false, [false, true]);\\n\\n    DATASTORE.writeAddress(poolId, rks.yieldReceiver, yieldReceiver);\\n    emit YieldReceiverSet(poolId, yieldReceiver);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** MAINTAINER **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Set the maintainer address on initiation or later\\n   * @param _newMaintainer address of the new maintainer\\n   */\\n  function _setMaintainer(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    address _newMaintainer\\n  ) internal {\\n    require(_newMaintainer != address(0), \\\"SML:maintainer cannot be zero\\\");\\n\\n    DATASTORE.writeAddress(_id, rks.maintainer, _newMaintainer);\\n    emit MaintainerChanged(_id, _newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\\n   * @dev there can only be 1 maintainer per ID.\\n   * @dev it is wise to change the maintainer before the CONTROLLER, in case of any migration\\n   * @dev we don't use _authenticate here because malicious maintainers can imprison operators\\n   * * and prevent them entering here, smh.\\n   */\\n  function changeMaintainer(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    address newMaintainer\\n  ) external {\\n    require(DATASTORE.readUint(id, rks.initiated) != 0, \\\"SML:ID is not initiated\\\");\\n    require(msg.sender == DATASTORE.readAddress(id, rks.CONTROLLER), \\\"SML:sender not CONTROLLER\\\");\\n    uint256 typeOfId = DATASTORE.readUint(id, rks.TYPE);\\n    require(typeOfId == ID_TYPE.OPERATOR || typeOfId == ID_TYPE.POOL, \\\"SML:invalid TYPE\\\");\\n\\n    _setMaintainer(DATASTORE, id, newMaintainer);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** MAINTENANCE FEE **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice Gets fee as a percentage, PERCENTAGE_DENOMINATOR = 100%\\n   *\\n   * @dev respecs to the switching delay.\\n   *\\n   * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100\\n   */\\n  function getMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 fee) {\\n    if (DATASTORE.readUint(id, rks.feeSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorFee);\\n    }\\n    return DATASTORE.readUint(id, rks.fee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set fee with NO DELAY\\n   */\\n  function _setMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _newFee\\n  ) internal {\\n    require(_newFee <= MAX_MAINTENANCE_FEE, \\\"SML:> MAX_MAINTENANCE_FEE\\\");\\n    DATASTORE.writeUint(_id, rks.fee, _newFee);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Changes the fee that is applied to the newly created validators, with A DELAY OF SWITCH_LATENCY.\\n   * @dev Cannot be called again while its currently switching.\\n   * @dev advise that 100% == PERCENTAGE_DENOMINATOR\\n   */\\n  function switchMaintenanceFee(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 newFee\\n  ) external {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(block.timestamp > DATASTORE.readUint(id, rks.feeSwitch), \\\"SML:currently switching\\\");\\n\\n    DATASTORE.writeUint(id, rks.priorFee, DATASTORE.readUint(id, rks.fee));\\n    DATASTORE.writeUint(id, rks.feeSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setMaintenanceFee(DATASTORE, id, newFee);\\n\\n    emit FeeSwitched(id, newFee, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** INTERNAL WALLET **\\n   *\\n   * @dev Internal wallet of an ID accrues fees over time.\\n   * It is also used by Node Operators to fund 1 ETH per validator proposal, which is reimbursed if/when activated.\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice Simply increases the balance of an IDs Maintainer wallet\\n   * @param _value Ether (in Wei) amount to increase the wallet balance.\\n   */\\n  function _increaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    DATASTORE.addUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @notice To decrease the balance of an Operator's wallet internally\\n   * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\\n   */\\n  function _decreaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _id,\\n    uint256 _value\\n  ) internal {\\n    require(DATASTORE.readUint(_id, rks.wallet) >= _value, \\\"SML:insufficient wallet balance\\\");\\n    DATASTORE.subUint(_id, rks.wallet, _value);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice external function to increase the internal wallet balance\\n   * @dev anyone can increase the balance directly, useful for withdrawalContracts and fees etc.\\n   */\\n  function increaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, false, false, [true, true]);\\n    _increaseWalletBalance(DATASTORE, id, msg.value);\\n    success = true;\\n  }\\n\\n  /**\\n   * @notice external function to decrease the internal wallet balance\\n   * @dev only CONTROLLER can decrease the balance externally,\\n   * @return success if the amount was sent and deducted\\n   */\\n  function decreaseWalletBalance(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id,\\n    uint256 value\\n  ) external returns (bool success) {\\n    _authenticate(DATASTORE, id, true, false, [true, true]);\\n\\n    require(address(this).balance >= value, \\\"SML:insufficient contract balance\\\");\\n\\n    _decreaseWalletBalance(DATASTORE, id, value);\\n    address controller = DATASTORE.readAddress(id, rks.CONTROLLER);\\n\\n    (success, ) = payable(controller).call{value: value}(\\\"\\\");\\n    require(success, \\\"SML:Failed to send ETH\\\");\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** OPERATORS PERIOD **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  function getValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 id\\n  ) public view returns (uint256 period) {\\n    if (DATASTORE.readUint(id, rks.periodSwitch) > block.timestamp) {\\n      return DATASTORE.readUint(id, rks.priorPeriod);\\n    }\\n    return DATASTORE.readUint(id, rks.validatorPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice internal function to set validator period with NO DELAY\\n   */\\n  function _setValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _operatorId,\\n    uint256 _newPeriod\\n  ) internal {\\n    require(_newPeriod >= MIN_VALIDATOR_PERIOD, \\\"SML:< MIN_VALIDATOR_PERIOD\\\");\\n    require(_newPeriod <= MAX_VALIDATOR_PERIOD, \\\"SML:> MAX_VALIDATOR_PERIOD\\\");\\n\\n    DATASTORE.writeUint(_operatorId, rks.validatorPeriod, _newPeriod);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice updates validatorPeriod for given operator, with A DELAY OF SWITCH_LATENCY.\\n   * @dev limited by MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD\\n   */\\n  function switchValidatorPeriod(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId,\\n    uint256 newPeriod\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, true, false, [true, false]);\\n\\n    require(\\n      block.timestamp > DATASTORE.readUint(operatorId, rks.periodSwitch),\\n      \\\"SML:currently switching\\\"\\n    );\\n\\n    DATASTORE.writeUint(\\n      operatorId,\\n      rks.priorPeriod,\\n      DATASTORE.readUint(operatorId, rks.validatorPeriod)\\n    );\\n    DATASTORE.writeUint(operatorId, rks.periodSwitch, block.timestamp + SWITCH_LATENCY);\\n\\n    _setValidatorPeriod(DATASTORE, operatorId, newPeriod);\\n\\n    emit ValidatorPeriodSwitched(operatorId, newPeriod, block.timestamp + SWITCH_LATENCY);\\n  }\\n\\n  /**\\n   * @custom:section                           ** PRISON **\\n   *\\n   * @custom:visibility -> view-public\\n   * @dev check OEL.blameProposal and OEL.blameExit for imprisonment details\\n   */\\n\\n  /**\\n   * @notice Checks if the given operator is Prisoned\\n   * @dev rks.release key refers to the end of the last imprisonment, when the limitations of operator is lifted\\n   */\\n  function isPrisoned(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId\\n  ) public view returns (bool) {\\n    return (block.timestamp < DATASTORE.readUint(operatorId, rks.release));\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR DELEGATION **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice maximum number of remaining operator allowance that the given Operator is allowed to create for given Pool\\n   * @dev an operator cannot create new validators if:\\n   * * 1. operator is a monopoly\\n   * * 2. allowance is filled\\n   * * * But if operator is set as a fallback, it can if set fallbackThreshold is reached on all allowances.\\n   * @dev If operator withdraws a validator, then able to create a new one.\\n   * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowance\\n   * @dev allowance doesn't change when new validators created or old ones are unstaked.\\n   */\\n  function operatorAllowance(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId\\n  ) public view returns (uint256 remValidators) {\\n    // monopoly check\\n    {\\n      // readUint for an array gives us length\\n      uint256 numOperatorValidators = DATASTORE.readUint(operatorId, rks.validators);\\n      uint256 monopoly_threshold = self.MONOPOLY_THRESHOLD;\\n      if (numOperatorValidators >= monopoly_threshold) {\\n        return 0;\\n      } else {\\n        remValidators = monopoly_threshold - numOperatorValidators;\\n      }\\n    }\\n\\n    // fallback check\\n    {\\n      if (operatorId == DATASTORE.readUint(poolId, rks.fallbackOperator)) {\\n        // readUint for an array gives us length\\n        uint256 numPoolValidators = DATASTORE.readUint(poolId, rks.validators);\\n        uint256 totalAllowance = DATASTORE.readUint(poolId, rks.totalAllowance);\\n\\n        if (\\n          totalAllowance == 0 ||\\n          (((numPoolValidators * PERCENTAGE_DENOMINATOR) / totalAllowance) >=\\n            DATASTORE.readUint(poolId, rks.fallbackThreshold))\\n        ) {\\n          return remValidators;\\n        }\\n      }\\n    }\\n\\n    // approval check\\n    {\\n      uint256 allowance = DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.allowance));\\n      uint256 pooledValidators = DATASTORE.readUint(\\n        poolId,\\n        DSML.getKey(operatorId, rks.proposedValidators)\\n      ) + DATASTORE.readUint(poolId, DSML.getKey(operatorId, rks.activeValidators));\\n      if (pooledValidators >= allowance) {\\n        return 0;\\n      } else {\\n        uint256 remAllowance = allowance - pooledValidators;\\n        if (remValidators > remAllowance) {\\n          remValidators = remAllowance;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice To give allowence to node operator for a pool. It re-sets the allowance with the given value.\\n   * @dev The value that is returned is not the new allowance, but the old one since it is required\\n   * * at the point where it is being returned.\\n   * @return oldAllowance to be used later, nothing is done with it within this function.\\n   */\\n  function _approveOperator(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 allowance\\n  ) internal returns (uint256 oldAllowance) {\\n    bytes32 allowanceKey = DSML.getKey(operatorId, rks.allowance);\\n\\n    oldAllowance = DATASTORE.readUint(poolId, allowanceKey);\\n    DATASTORE.writeUint(poolId, allowanceKey, allowance);\\n\\n    emit Delegation(poolId, operatorId, allowance);\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool with a given number of validators.\\n   * * This number can be set again at any given point in the future.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorIds array of Operator IDs to allow them create validators\\n   * @param allowances the MAX number of validators that can be created by the Operator, for given Pool\\n   * @dev When decreased the approved validator count below current active+proposed validators,\\n   * operator cannot create new validators.\\n   */\\n  function delegate(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256[] calldata operatorIds,\\n    uint256[] calldata allowances\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n    uint256 operatorIdsLen = operatorIds.length;\\n    require(operatorIdsLen == allowances.length, \\\"SML:allowances should match\\\");\\n\\n    for (uint256 i; i < operatorIdsLen; ) {\\n      require(\\n        DATASTORE.readUint(operatorIds[i], rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:id not operator\\\"\\n      );\\n      require(allowances[i] <= MAX_ALLOWANCE, \\\"SML:> MAX_ALLOWANCE, set fallback\\\");\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    uint256 newCumulativeSubset;\\n    uint256 oldCumulativeSubset;\\n    for (uint256 i; i < operatorIdsLen; ) {\\n      newCumulativeSubset += allowances[i];\\n      oldCumulativeSubset += _approveOperator(DATASTORE, poolId, operatorIds[i], allowances[i]);\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    if (newCumulativeSubset > oldCumulativeSubset) {\\n      DATASTORE.addUint(poolId, rks.totalAllowance, newCumulativeSubset - oldCumulativeSubset);\\n    } else if (newCumulativeSubset < oldCumulativeSubset) {\\n      DATASTORE.subUint(poolId, rks.totalAllowance, oldCumulativeSubset - newCumulativeSubset);\\n    }\\n  }\\n\\n  /**\\n   * @notice To allow a Node Operator run validators for your Pool without a limit\\n   * * after pool reaches a given treshold as percentage.\\n   * * fallback operator and percentage can be set again at any given point in the future.\\n   * * cannot set an operator as a fallback operator while it is currently in prison.\\n   * @param poolId the gETH id of the Pool\\n   * @param operatorId Operator ID to allow create validators\\n   * @param fallbackThreshold the percentage (with PERCENTAGE_DENOMINATOR) that fallback operator\\n   * * is activated for given Pool. Should not be greater than 100.\\n   */\\n  function setFallbackOperator(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    uint256 fallbackThreshold\\n  ) external {\\n    _authenticate(DATASTORE, poolId, false, true, [false, true]);\\n\\n    if (operatorId == 0) {\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, 0);\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, 0);\\n      emit FallbackOperator(poolId, 0, 0);\\n    } else {\\n      require(\\n        DATASTORE.readUint(operatorId, rks.TYPE) == ID_TYPE.OPERATOR,\\n        \\\"SML:fallback not operator\\\"\\n      );\\n\\n      require(\\n        fallbackThreshold <= PERCENTAGE_DENOMINATOR,\\n        \\\"SML:threshold cannot be greater than 100\\\"\\n      );\\n\\n      DATASTORE.writeUint(poolId, rks.fallbackThreshold, fallbackThreshold);\\n      DATASTORE.writeUint(poolId, rks.fallbackOperator, operatorId);\\n\\n      emit FallbackOperator(poolId, operatorId, fallbackThreshold);\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** POOLING  **\\n   */\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT HELPERS **\\n   */\\n\\n  /**\\n   * @custom:visibility -> view-internal\\n   */\\n\\n  function _isGeodePackageIsolated(address _packageAddress) internal view returns (bool) {\\n    return IGeodePackage(_packageAddress).isolationMode();\\n  }\\n\\n  /**\\n   * @notice returns wrapped bound liquidity pool. If deployed, if not in isolationMode.\\n   * @dev returns address(0) if no pool or it is under isolation\\n   */\\n  function _getLiquidityPool(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId\\n  ) internal view returns (ILiquidityPool) {\\n    address liqPool = DATASTORE.readAddress(_poolId, rks.liquidityPool);\\n    if (liqPool == address(0)) {\\n      return ILiquidityPool(address(0));\\n    } else if (_isGeodePackageIsolated(liqPool)) {\\n      return ILiquidityPool(address(0));\\n    } else {\\n      return ILiquidityPool(liqPool);\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> view-public\\n   */\\n\\n  /**\\n   * @notice returns true if the price is valid:\\n   * - last price syncinc happened less than 24h\\n   * - there has been no oracle reports since the last update\\n   *\\n   * @dev known bug / feature: if there have been no oracle updates,\\n   * * this function will return true.\\n   *\\n   * lastupdate + PRICE_EXPIRY >= block.timestamp ? true\\n   *    : lastupdate >= self.ORACLE_UPDATE_TIMESTAMP ? true\\n   *    : false\\n   */\\n  function isPriceValid(\\n    StakeModuleStorage storage self,\\n    uint256 poolId\\n  ) public view returns (bool isValid) {\\n    uint256 lastupdate = self.gETH.priceUpdateTimestamp(poolId);\\n    unchecked {\\n      isValid =\\n        lastupdate + PRICE_EXPIRY >= block.timestamp &&\\n        lastupdate >= self.ORACLE_UPDATE_TIMESTAMP;\\n    }\\n  }\\n\\n  /**\\n   * @notice checks if staking is allowed in given staking pool\\n   * @notice staking is not allowed if:\\n   * 1. Price is not valid\\n   * 2. WithdrawalContract is in Isolation Mode, can have many reasons\\n   */\\n  function isMintingAllowed(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId\\n  ) public view returns (bool) {\\n    return\\n      (isPriceValid(self, poolId)) &&\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract)));\\n  }\\n\\n  /**\\n   * @custom:subsection                           ** DEPOSIT **\\n   */\\n\\n  /**\\n   * @custom:visibility -> internal\\n   */\\n\\n  /**\\n   * @notice mints gETH for a given ETH amount, keeps the tokens in Portal.\\n   * @dev fails if minting is not allowed: invalid price, or isolationMode.\\n   */\\n  function _mintgETH(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _ethAmount\\n  ) internal returns (uint256 mintedgETH) {\\n    require(isMintingAllowed(self, DATASTORE, _poolId), \\\"SML:minting is not allowed\\\");\\n\\n    uint256 price = self.gETH.pricePerShare(_poolId);\\n    require(price > 0, \\\"SML:price is zero?\\\");\\n\\n    mintedgETH = (((_ethAmount * gETH_DENOMINATOR) / price));\\n    self.gETH.mint(address(this), _poolId, mintedgETH, \\\"\\\");\\n    DATASTORE.addUint(_poolId, rks.surplus, _ethAmount);\\n  }\\n\\n  /**\\n   * @notice conducts a buyback using the given liquidity pool\\n   * @param _poolId id of the gETH that will be bought\\n   * @param _maxEthToSell max ETH amount to sell in the liq pool\\n   * @param _deadline TX is expected to revert by Swap.sol if not meet\\n   * @dev this function assumes that pool is deployed by deployLiquidityPool\\n   * as index 0 is ETH and index 1 is gETH!\\n   */\\n  function _buyback(\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 _poolId,\\n    uint256 _maxEthToSell,\\n    uint256 _deadline\\n  ) internal returns (uint256 remETH, uint256 boughtgETH) {\\n    ILiquidityPool LP = _getLiquidityPool(DATASTORE, _poolId);\\n    // skip if no liquidity pool is found\\n    if (address(LP) != address(0)) {\\n      uint256 debt = LP.getDebt();\\n      // skip if debt is too low\\n      if (debt > IGNORABLE_DEBT) {\\n        if (_maxEthToSell > debt) {\\n          // if debt is lower, then only sell debt\\n          remETH = _maxEthToSell - debt;\\n        } else {\\n          // if eth is lower, then sell all eth, remETH already 0\\n          debt = _maxEthToSell;\\n        }\\n        // SWAP in LP\\n        boughtgETH = LP.swap{value: debt}(0, 1, debt, 0, _deadline);\\n      } else {\\n        remETH = _maxEthToSell;\\n      }\\n    } else {\\n      remETH = _maxEthToSell;\\n    }\\n  }\\n\\n  /**\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Allowing users to deposit into a staking pool.\\n   * @notice If a pool is not public, only the controller and if there is a whitelist contract, the whitelisted addresses can deposit.\\n   * @param poolId id of the staking pool, liquidity pool and gETH to be used.\\n   * @param mingETH liquidity pool parameter\\n   * @param deadline liquidity pool parameter\\n   * @dev an example for minting + buybacks\\n   * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\\n   * * debt  msgValue\\n   * * 100   10  => buyback\\n   * * 100   100 => buyback\\n   * * 10    100 => buyback + mint\\n   * * 1     x   => mint\\n   * * 0.5   x   => mint\\n   * * 0     x   => mint\\n   */\\n  function deposit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 mingETH,\\n    uint256 deadline,\\n    address receiver\\n  ) external returns (uint256 boughtgETH, uint256 mintedgETH) {\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(msg.value > 0, \\\"SML:msg.value cannot be zero\\\");\\n    require(deadline > block.timestamp, \\\"SML:deadline not met\\\");\\n    require(receiver != address(0), \\\"SML:receiver is zero address\\\");\\n\\n    if (isPrivatePool(DATASTORE, poolId)) {\\n      require(isWhitelisted(DATASTORE, poolId, msg.sender), \\\"SML:sender not whitelisted\\\");\\n    }\\n\\n    uint256 remEth = msg.value;\\n    (remEth, boughtgETH) = _buyback(DATASTORE, poolId, remEth, deadline);\\n\\n    if (remEth > 0) {\\n      mintedgETH = _mintgETH(self, DATASTORE, poolId, remEth);\\n    }\\n\\n    require(boughtgETH + mintedgETH >= mingETH, \\\"SML:less than minimum\\\");\\n\\n    // send back to user\\n    self.gETH.safeTransferFrom(address(this), receiver, poolId, boughtgETH + mintedgETH, \\\"\\\");\\n\\n    emit Deposit(poolId, boughtgETH, mintedgETH);\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR CREATION **\\n   *\\n   * @dev Creation of a Validator takes 2 steps: propose and beacon stake.\\n   * Before entering stake() function, _canStake verifies the eligibility of\\n   * given pubKey that is proposed by an operator with proposeStake function.\\n   * Eligibility is defined by an optimistic alienation, check OracleUtils._alienateValidator() for info.\\n   */\\n\\n  /**\\n   * @custom:visibility -> view\\n   */\\n\\n  /**\\n   * @notice internal function to check if a validator can use the pool funds\\n   *\\n   *  @param _pubkey BLS12-381 public key of the validator\\n   *  @return true if:\\n   *   - pubkey should be proposed\\n   *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\\n   *   - the validator's index is already covered by VERIFICATION_INDEX. Updated by Telescope.\\n   */\\n  function _canStake(\\n    StakeModuleStorage storage self,\\n    bytes calldata _pubkey,\\n    uint256 _verificationIndex\\n  ) internal view returns (bool) {\\n    return\\n      (self.validators[_pubkey].state == VALIDATOR_STATE.PROPOSED) &&\\n      (self.validators[_pubkey].index <= _verificationIndex);\\n  }\\n\\n  /**\\n   * @notice external function to check if a validator can use the pool funds\\n   */\\n  function canStake(\\n    StakeModuleStorage storage self,\\n    bytes calldata pubkey\\n  ) external view returns (bool) {\\n    return _canStake(self, pubkey, self.VERIFICATION_INDEX);\\n  }\\n\\n  /**\\n   * @dev -> external\\n   */\\n\\n  /**\\n   * @notice Validator Credentials Proposal function, first step of crating validators.\\n   * * Once a pubKey is proposed and not alienated after verificationIndex updated,\\n   * * it is optimistically allowed to take funds from staking pools.\\n   *\\n   * @param poolId the id of the staking pool\\n   * @param operatorId the id of the Operator whose maintainer calling this function\\n   * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\\n   * @param signatures1 Array of BLS12-381 signatures that will be used to send 1 ETH from the Operator's\\n   * maintainer balance\\n   * @param signatures31 Array of BLS12-381 signatures that will be used to send 31 ETH from pool on stake() function call\\n   *\\n   * @dev DCL.DEPOSIT_AMOUNT_PRESTAKE = 1 ether, DCL.DEPOSIT_AMOUNT = 32 ether which is the minimum amount to create a validator.\\n   * 31 Ether will be staked after verification of oracles. 32 in total.\\n   * 1 ether will be sent back to Node Operator when the finalized deposit is successful.\\n   * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\\n   * @dev ProposeStake requires enough funds within Wallet.\\n   * @dev Max number of validators to propose is per call is MAX_DEPOSITS_PER_CALL (currently 50)\\n   */\\n  function proposeStake(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys,\\n    bytes[] calldata signatures1,\\n    bytes[] calldata signatures31\\n  ) external {\\n    // checks\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n    _authenticate(DATASTORE, poolId, false, false, [false, true]);\\n    require(\\n      !(_isGeodePackageIsolated(DATASTORE.readAddress(poolId, rks.withdrawalContract))),\\n      \\\"SML:withdrawalContract is isolated\\\"\\n    );\\n\\n    uint256 pkLen = pubkeys.length;\\n\\n    require((pkLen > 0) && (pkLen <= DCL.MAX_DEPOSITS_PER_CALL), \\\"SML:1 - 50 validators\\\");\\n\\n    require(\\n      pkLen == signatures1.length && pkLen == signatures31.length,\\n      \\\"SML:invalid input length\\\"\\n    );\\n\\n    require(\\n      operatorAllowance(self, DATASTORE, poolId, operatorId) >= pkLen,\\n      \\\"SML:insufficient allowance\\\"\\n    );\\n\\n    require(\\n      DATASTORE.readUint(poolId, rks.surplus) >= DCL.DEPOSIT_AMOUNT * pkLen,\\n      \\\"SML:not enough surplus\\\"\\n    );\\n\\n    _decreaseWalletBalance(DATASTORE, operatorId, (pkLen * DCL.DEPOSIT_AMOUNT_PRESTAKE));\\n\\n    for (uint256 i; i < pkLen; ) {\\n      require(pubkeys[i].length == DCL.PUBKEY_LENGTH, \\\"SML:PUBKEY_LENGTH ERROR\\\");\\n      require(signatures1[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n      require(signatures31[i].length == DCL.SIGNATURE_LENGTH, \\\"SML:SIGNATURE_LENGTH ERROR\\\");\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    ConstantValidatorData memory valData = ConstantValidatorData({\\n      index: uint64(self.VALIDATORS_INDEX + 1),\\n      period: uint64(getValidatorPeriod(DATASTORE, operatorId)),\\n      poolFee: getMaintenanceFee(DATASTORE, poolId),\\n      operatorFee: getMaintenanceFee(DATASTORE, operatorId),\\n      infrastructureFee: self.infrastructureFees[ID_TYPE.POOL],\\n      withdrawalCredential: DATASTORE.readBytes(poolId, rks.withdrawalCredential)\\n    });\\n\\n    for (uint256 i; i < pkLen; ) {\\n      require(\\n        self.validators[pubkeys[i]].state == VALIDATOR_STATE.NONE,\\n        \\\"SML: used or alienated pk\\\"\\n      );\\n\\n      self.validators[pubkeys[i]] = Validator(\\n        VALIDATOR_STATE.PROPOSED,\\n        valData.index + uint64(i),\\n        uint64(block.timestamp),\\n        valData.period,\\n        poolId,\\n        operatorId,\\n        valData.poolFee,\\n        valData.operatorFee,\\n        valData.infrastructureFee,\\n        signatures31[i]\\n      );\\n\\n      DCL.depositValidator(\\n        pubkeys[i],\\n        valData.withdrawalCredential,\\n        signatures1[i],\\n        DCL.DEPOSIT_AMOUNT_PRESTAKE\\n      );\\n\\n      unchecked {\\n        i += 1;\\n      }\\n    }\\n\\n    DATASTORE.subUint(poolId, rks.surplus, (pkLen * DCL.DEPOSIT_AMOUNT));\\n    DATASTORE.addUint(poolId, rks.secured, (pkLen * DCL.DEPOSIT_AMOUNT));\\n\\n    DATASTORE.addUint(poolId, DSML.getKey(operatorId, rks.proposedValidators), pkLen);\\n    DATASTORE.appendBytesArrayBatch(poolId, rks.validators, pubkeys);\\n    DATASTORE.appendBytesArrayBatch(operatorId, rks.validators, pubkeys);\\n\\n    self.VALIDATORS_INDEX += pkLen;\\n\\n    emit StakeProposal(poolId, operatorId, pubkeys);\\n  }\\n\\n  /**\\n   *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\\n   *  1 Eth per successful validator boostraping is returned back to Wallet.\\n   *\\n   *  @param operatorId the id of the Operator whose maintainer calling this function\\n   *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\\n   *\\n   *  @dev To save gas cost, pubkeys should be arranged by poolIds.\\n   *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\\n   *  pk1, pk2, pk3 from pool1\\n   *  pk4, pk5 from pool2\\n   *  pk6 from pool3\\n   *  separate them in similar groups as much as possible.\\n   *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 50)\\n   *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\\n   */\\n  function stake(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 operatorId,\\n    bytes[] calldata pubkeys\\n  ) external {\\n    _authenticate(DATASTORE, operatorId, false, true, [true, false]);\\n\\n    require(\\n      (pubkeys.length > 0) && (pubkeys.length <= DCL.MAX_DEPOSITS_PER_CALL),\\n      \\\"SML:1 - 50 validators\\\"\\n    );\\n\\n    {\\n      uint256 pubkeysLen = pubkeys.length;\\n      uint256 _verificationIndex = self.VERIFICATION_INDEX;\\n      for (uint256 j; j < pubkeysLen; ) {\\n        require(\\n          _canStake(self, pubkeys[j], _verificationIndex),\\n          \\\"SML:not all pubkeys are stakeable\\\"\\n        );\\n\\n        require(\\n          self.validators[pubkeys[j]].operatorId == operatorId,\\n          \\\"SML:not all pubkeys belong to operator\\\"\\n        );\\n\\n        unchecked {\\n          j += 1;\\n        }\\n      }\\n    }\\n\\n    {\\n      bytes32 activeValKey = DSML.getKey(operatorId, rks.activeValidators);\\n      bytes32 proposedValKey = DSML.getKey(operatorId, rks.proposedValidators);\\n      uint256 poolId = self.validators[pubkeys[0]].poolId;\\n      bytes memory withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n\\n      uint256 lastIdChange = 0;\\n      for (uint256 i; i < pubkeys.length; ) {\\n        uint256 newPoolId = self.validators[pubkeys[i]].poolId;\\n        if (poolId != newPoolId) {\\n          uint256 sinceLastIdChange;\\n\\n          unchecked {\\n            sinceLastIdChange = i - lastIdChange;\\n          }\\n\\n          DATASTORE.subUint(poolId, rks.secured, (DCL.DEPOSIT_AMOUNT * (sinceLastIdChange)));\\n          DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n          DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n\\n          lastIdChange = i;\\n          poolId = newPoolId;\\n          withdrawalCredential = DATASTORE.readBytes(poolId, rks.withdrawalCredential);\\n        }\\n\\n        DCL.depositValidator(\\n          pubkeys[i],\\n          withdrawalCredential,\\n          self.validators[pubkeys[i]].signature31,\\n          (DCL.DEPOSIT_AMOUNT - DCL.DEPOSIT_AMOUNT_PRESTAKE)\\n        );\\n\\n        self.validators[pubkeys[i]].state = VALIDATOR_STATE.ACTIVE;\\n\\n        unchecked {\\n          i += 1;\\n        }\\n      }\\n      {\\n        uint256 sinceLastIdChange;\\n        unchecked {\\n          sinceLastIdChange = pubkeys.length - lastIdChange;\\n        }\\n\\n        DATASTORE.subUint(poolId, rks.secured, DCL.DEPOSIT_AMOUNT * (sinceLastIdChange));\\n        DATASTORE.subUint(poolId, proposedValKey, (sinceLastIdChange));\\n        DATASTORE.addUint(poolId, activeValKey, (sinceLastIdChange));\\n      }\\n\\n      _increaseWalletBalance(DATASTORE, operatorId, DCL.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length);\\n\\n      emit Stake(pubkeys);\\n    }\\n  }\\n\\n  /**\\n   * @custom:section                           ** VALIDATOR EXITS **\\n   *\\n   * @custom:visibility -> external\\n   */\\n\\n  /**\\n   * @notice Notifies the node operator with ExitRequest event\\n   * @dev Prevents the request if validator is still within the MIN_VALIDATOR_PERIOD\\n   * @dev Only the active validators can be called for an exit\\n   * @dev Can only be called by the withdrawalContract of the pool given validator belongs to.\\n   */\\n  function requestExit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bytes calldata pk\\n  ) external {\\n    require(\\n      block.timestamp > self.validators[pk].createdAt + MIN_VALIDATOR_PERIOD,\\n      \\\"SML:early exit not allowed\\\"\\n    );\\n    require(\\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\\n      \\\"SML:sender is not withdrawal contract\\\"\\n    );\\n    require(self.validators[pk].poolId == poolId, \\\"SML:incorrect poolId\\\");\\n    require(self.validators[pk].state == VALIDATOR_STATE.ACTIVE, \\\"SML:not an active validator\\\");\\n\\n    self.validators[pk].state = VALIDATOR_STATE.EXIT_REQUESTED;\\n\\n    emit ExitRequest(pk);\\n  }\\n\\n  /**\\n   * @notice Finalizes the exit process for a validator.\\n   * @dev Strongly advised to be called right after the exiting process is over.\\n   * @dev Operators can exit at any time they want.\\n   * @dev Can only be called by the withdrawalContract of the pool given validator belongs to.\\n   */\\n  function finalizeExit(\\n    StakeModuleStorage storage self,\\n    DataStoreModuleStorage storage DATASTORE,\\n    uint256 poolId,\\n    bytes calldata pk\\n  ) external {\\n    require(\\n      msg.sender == DATASTORE.readAddress(poolId, rks.withdrawalContract),\\n      \\\"SML:sender is not withdrawal contract\\\"\\n    );\\n    require(self.validators[pk].poolId == poolId, \\\"SML:incorrect poolId\\\");\\n\\n    uint256 state = self.validators[pk].state;\\n    require(\\n      state == VALIDATOR_STATE.ACTIVE || state == VALIDATOR_STATE.EXIT_REQUESTED,\\n      \\\"SML:not an active validator\\\"\\n    );\\n\\n    self.validators[pk].state = VALIDATOR_STATE.EXITED;\\n\\n    emit Exit(pk);\\n  }\\n}\\n\",\"keccak256\":\"0xb2ad84e9da445ef750efde3a8a93c1d4585f259780b86b0f00d117884d49dd22\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @notice Helper Struct to pack constant data that does not change per validator on batch proposals\\n * * needed for that famous Solidity feature.\\n */\\nstruct ConstantValidatorData {\\n  uint64 index;\\n  uint64 period;\\n  uint256 poolFee;\\n  uint256 operatorFee;\\n  uint256 infrastructureFee;\\n  bytes withdrawalCredential;\\n}\\n\",\"keccak256\":\"0x8286f4ad690287eafbab5c63f0fc4716dd00faac4a378a449feda104d50a9f5c\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// internal - interfaces\\nimport {IgETH} from \\\"../../../interfaces/IgETH.sol\\\";\\n// internal - structs\\nimport {Validator} from \\\"./utils.sol\\\";\\n\\n/**\\n * @notice Storage struct for the Pooled Liquid Staking logic\\n * @param gETH constant, ERC1155, all Geode Staking Derivatives.\\n * @param ORACLE_POSITION constant, address of the Oracle https://github.com/Geodefi/Telescope-Eth\\n * @param VALIDATORS_INDEX total number of validators that are proposed at any given point.\\n * * Includes all validators: proposed, active, alienated, exited.\\n * @param VERIFICATION_INDEX the highest index of the validators that are verified (as not alien) by the Holy Oracle.\\n * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated by the Holy Oracle.\\n * @param BEACON_DELAY_ENTRY allowed max delay between the creation of an (approved) proposal and stake() call, per the beaconchain entry queue.\\n * @param BEACON_DELAY_EXIT allowed max delay between an exit request and its finalization with finalizeExit() call, per the beaconchain exit queue.\\n * @param INITIATION_DEPOSIT the initial deposit amount that is required for a name to be reserved by the pool, prevents sybil attacks.\\n * @param ORACLE_UPDATE_TIMESTAMP timestamp of the latest oracle update\\n * @param DAILY_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval, per second.\\n * @param DAILY_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval, per second.\\n * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, updated by the Holy Oracle.\\n * @param GOVERNANCE_FEE **reserved** Although it is 0 right now, It can be updated in the future.\\n * @param BALANCE_MERKLE_ROOT merkle root of the balances and other validator related data, useful on withdrawals, updated by the Holy Oracle.\\n * @param validators pubkey => Validator, contains all the data about proposed, alienated, active, exit-called and fully exited validators.\\n * @param packages TYPE => version id, pointing to the latest versions of the given package.\\n * * Like default Withdrawal Contract version.\\n * @param middlewares TYPE => version id => isAllowed, useful to check if given version of the middleware can be used.\\n * * Like all the whitelisted gETHMiddlewares.\\n * @param fees TYPE->PERCENTAGE, we can set a fee for any defined TYPE then use it in related operations.\\n * * POOL type sets validator fees. Liqudity Pool Package type sets fee on swaps.\\n *\\n * @dev normally we would put custom:storage-location erc7201:geode.storage.StakeModule\\n * but compiler throws an error... So np for now, just MAKE SURE.\\n **/\\nstruct StakeModuleStorage {\\n  IgETH gETH;\\n  address ORACLE_POSITION;\\n  uint256 VALIDATORS_INDEX;\\n  uint256 VERIFICATION_INDEX;\\n  uint256 MONOPOLY_THRESHOLD;\\n  uint256 BEACON_DELAY_ENTRY;\\n  uint256 BEACON_DELAY_EXIT;\\n  uint256 INITIATION_DEPOSIT;\\n  uint256 ORACLE_UPDATE_TIMESTAMP;\\n  uint256 DAILY_PRICE_INCREASE_LIMIT;\\n  uint256 DAILY_PRICE_DECREASE_LIMIT;\\n  bytes32 PRICE_MERKLE_ROOT;\\n  bytes32 BALANCE_MERKLE_ROOT;\\n  mapping(bytes => Validator) validators;\\n  mapping(uint256 => uint256) packages;\\n  mapping(uint256 => mapping(uint256 => bool)) middlewares;\\n  mapping(uint256 => uint256) infrastructureFees;\\n}\\n\",\"keccak256\":\"0x94037907996f62bda5a6f36653b385b5fae51aba5dd73a08f19e5b303af23e18\",\"license\":\"MIT\"},\"contracts/modules/StakeModule/structs/utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/**\\n * @param state state of the validator, refer to globals.sol\\n * @param index representing this validator's placement on the chronological order of the validators proposals\\n * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\\n * @param period the latest point in time the operator is allowed to maintain this validator (createdAt + validatorPeriod).\\n * @param poolId needed for withdrawal_credential\\n * @param operatorId needed for staking after allowance\\n * @param poolFee percentage of the rewards that will go to pool's maintainer, locked when the validator is proposed\\n * @param operatorFee percentage of the rewards that will go to operator's maintainer, locked when the validator is proposed\\n * @param infrastructureFee all fees are crucial for the price calculation by the oracle, even if its zero.\\n * @param signature31 BLS12-381 signature for the validator, used when the remaining 31 ETH is sent on validator activation.\\n **/\\nstruct Validator {\\n  uint64 state;\\n  uint64 index;\\n  uint64 createdAt;\\n  uint64 period;\\n  uint256 poolId;\\n  uint256 operatorId;\\n  uint256 poolFee;\\n  uint256 operatorFee;\\n  uint256 infrastructureFee;\\n  bytes signature31;\\n}\\n\",\"keccak256\":\"0xbbd41f0da602f5bc6cfd7ff7d4feec259d3266f87c711a5c16070d529da441e6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x611f4c61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063a849957311610065578063a8499573146100ee578063ab0534bb1461010e578063d2da84c91461012e578063e3391a1f1461014e57600080fd5b80630bbc72be1461008c578063182f4f49146100ae5780633352002f146100ce575b600080fd5b81801561009857600080fd5b506100ac6100a73660046119b6565b61016e565b005b8180156100ba57600080fd5b506100ac6100c9366004611a62565b610291565b8180156100da57600080fd5b506100ac6100e9366004611a94565b610397565b8180156100fa57600080fd5b506100ac610109366004611b35565b6104f4565b81801561011a57600080fd5b506100ac610129366004611b87565b6105ee565b81801561013a57600080fd5b506100ac610149366004611bfb565b6108b7565b81801561015a57600080fd5b506100ac610169366004611c7d565b610a02565b8483146101c25760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6172726179206c656e67746873206e6f7420657175616c000000000060448201526064015b60405180910390fd5b8481146102115760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6172726179206c656e67746873206e6f7420657175616c000000000060448201526064016101b9565b8460005b818110156102855761027d8a8a8a8a8581811061023457610234611cd4565b9050602002013589898681811061024d5761024d611cd4565b9050602002013588888781811061026657610266611cd4565b90506020028101906102789190611cea565b610a18565b600101610215565b50505050505050505050565b600184015484906001600160a01b031633146102bf5760405162461bcd60e51b81526004016101b990611d33565b61c35082116103105760405162461bcd60e51b815260206004820152601760248201527f4f454c3a6c6f772076616c696461746f7220636f756e7400000000000000000060448201526064016101b9565b600b8501849055600c850183905542600886015560006402540be40061033a6305f5e10085611d78565b6103449190611d8f565b6004870181905560408051878152602081018790529081018290529091507ffeb6b9f0f1c25e93a31c59bc49721cfd063408fd1d78dcddcf2541b6535f821b9060600160405180910390a1505050505050565b600185015485906001600160a01b031633146103c55760405162461bcd60e51b81526004016101b990611d33565b83866002015410156104195760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6869676820564552494649434154494f4e5f494e444558000000000060448201526064016101b9565b8560030154841161046c5760405162461bcd60e51b815260206004820152601a60248201527f4f454c3a6c6f7720564552494649434154494f4e5f494e44455800000000000060448201526064016101b9565b8160005b818110156104af576104a788888888888681811061049057610490611cd4565b90506020028101906104a29190611db1565b610efe565b600101610470565b50600387018590556040518581527f5741e1f31a5b295a42632c4a80216d28bf245e6f0ee679b887d8ecd7b94517ee906020015b60405180910390a150505050505050565b600384015461050585848484611167565b6105515760405162461bcd60e51b815260206004820152601960248201527f4f454c3a63616e6e6f7420626c616d652070726f706f73616c0000000000000060448201526064016101b9565b846005015485600d01848460405161056a929190611df7565b9081526040519081900360200190205461059591906001600160401b03600160801b90910416611e07565b42116105da5760405162461bcd60e51b81526020600482015260146024820152734f454c3a61636365707461626c652064656c617960601b60448201526064016101b9565b6105e78585838686610efe565b5050505050565b600088600d018787604051610604929190611df7565b908152604051908190036020019020546001600160401b03169050600281148061063757506001600160401b0381166003145b6106835760405162461bcd60e51b815260206004820152601e60248201527f4f454c3a756e65787065637465642076616c696461746f72207374617465000060448201526064016101b9565b886006015489600d01888860405161069c929190611df7565b908152604051908190036020018120546001600160401b03600160c01b9091041690600d8c01906106d0908b908b90611df7565b908152604051908190036020019020546106fb91906001600160401b03600160801b90910416611e1a565b6001600160401b031661070e9190611e07565b42116107705760405162461bcd60e51b815260206004820152602b60248201527f4f454c3a76616c696461746f7220697320616374697665206f7220616363657060448201526a7461626c652064656c617960a81b60648201526084016101b9565b6000878787876040516020016107899493929190611e6a565b60408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506107ff848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250505050600c8c0154836111e5565b6108415760405162461bcd60e51b815260206004820152601360248201527213d1530e9c1c9bdbd9881b9bdd081d985b1a59606a1b60448201526064016101b9565b856000036108865760405162461bcd60e51b815260206004820152601260248201527113d1530e985b1c9958591e48195e1a5d195960721b60448201526064016101b9565b610285898b600d018a8a60405161089e929190611df7565b9081526020016040518091039020600201548a8a6111fb565b600186015486906001600160a01b031633146108e55760405162461bcd60e51b81526004016101b990611d33565b8382146109295760405162461bcd60e51b81526020600482015260126024820152714f454c3a696e76616c69642070726f6f667360701b60448201526064016101b9565b8360005b818110156109f75761097b8888888481811061094b5761094b611cd4565b9050602002013587878581811061096457610964611cd4565b90506020028101906109769190611db1565b6111fb565b86868281811061098d5761098d611cd4565b905060200201357f6fcceef20658dabea5d70961ac50b4a6a8726c24cce97029fd59ebb91a4d03668686848181106109c7576109c7611cd4565b90506020028101906109d99190611db1565b6040516109e7929190611e91565b60405180910390a260010161092d565b505050505050505050565b610a10868686868686610a18565b505050505050565b855460405163908d67ed60e01b8152600481018690526001600160a01b039091169063908d67ed90602401602060405180830381865afa158015610a60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a849190611ead565b866008015411610acc5760405162461bcd60e51b81526020600482015260136024820152724f454c3a6e6f207072696365206368616e676560681b60448201526064016101b9565b604080516020810186905290810184905260009060600160408051601f1981840301815282825280516020918201209083015201604051602081830303815290604052805190602001209050610b59838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250505050600b890154836111e5565b610ba55760405162461bcd60e51b815260206004820152601c60248201527f4f454c3a6e6f7420616c6c2070726f6f6673206172652076616c69640000000060448201526064016101b9565b610bb187878787611294565b6000610bce87876c3cb4b2b6322932b1b2b4bb32b960991b6114ea565b90506001600160a01b038116610c475787546040516322af599760e01b815260048101879052602481018890526001600160a01b03909116906322af599790604401600060405180830381600087803b158015610c2a57600080fd5b505af1158015610c3e573d6000803e3d6000fd5b50505050610ef4565b875460405163f759cc3b60e01b8152600481018890526000916001600160a01b03169063f759cc3b90602401602060405180830381865afa158015610c90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb49190611ead565b905080861115610e8e57885460405163bd85b03960e01b815260048101899052600091670de0b6b3a7640000916001600160a01b039091169063bd85b03990602401602060405180830381865afa158015610d13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d379190611ead565b610d41848a611ec6565b610d4b9190611d78565b610d559190611d8f565b8a5460405163731133e960e01b8152306004820152602481018b90526044810183905260806064820152600060848201529192506001600160a01b03169063731133e99060a401600060405180830381600087803b158015610db657600080fd5b505af1158015610dca573d6000803e3d6000fd5b50508b54604051637921219560e11b81523060048201526001600160a01b038781166024830152604482018d90526064820186905260a06084830152600060a4830152909116925063f242432a915060c401600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050877ffe4996cd48c364c468cee70dd6b9061874ff01b05c5ea49311cbcabd9b9cb61582604051610e8091815260200190565b60405180910390a2506109f7565b88546040516322af599760e01b815260048101889052602481018990526001600160a01b03909116906322af599790604401600060405180830381600087803b158015610eda57600080fd5b505af1158015610eee573d6000803e3d6000fd5b50505050505b5050505050505050565b8285600d018383604051610f13929190611df7565b908152604051908190036020019020546001600160401b03600160401b909104161115610f795760405162461bcd60e51b815260206004820152601460248201527309e8a9874eadccaf0e0cac6e8cac840d2dcc8caf60631b60448201526064016101b9565b600160ff1685600d018383604051610f92929190611df7565b908152604051908190036020019020546001600160401b031614610ff85760405162461bcd60e51b815260206004820152601f60248201527f4f454c3a6e6f7420616c6c207075626b657973206172652070656e64696e670060448201526064016101b9565b600085600d01838360405161100e929190611df7565b908152602001604051809103902060020154905061102e858285856111fb565b600086600d018484604051611044929190611df7565b9081526040519081900360200190206001015490506110788682661cd958dd5c995960ca1b6801bc16d674ec80000061151e565b611097868266737572706c757360c81b6801bc16d674ec800000611557565b6110c4816110ba847170726f706f73656456616c696461746f727360701b611585565b889190600161151e565b6110ee816110e4846e616c69656e56616c696461746f727360881b611585565b8891906001611557565b604560ff1687600d018585604051611107929190611df7565b90815260405190819003602001812080546001600160401b039390931667ffffffffffffffff19909316929092179091557f7033b7b89d1818b80f9a85b8d604a07ec95f439c75d7ed56caef4d57a1013975906104e39086908690611e91565b6000600160ff1685600d018585604051611182929190611df7565b908152604051908190036020019020546001600160401b03161480156111dc57508185600d0185856040516111b8929190611df7565b908152604051908190036020019020546001600160401b03600160401b9091041611155b95945050505050565b6000826111f285846115b1565b14949350505050565b604080518082019091526001815260006020820181905261122191869186918190611600565b611246836672656c6561736560c81b61123d6212750042611e07565b879291906118c7565b827f6cc873968ba5c560db266aea333bf3b836de0031c3be1d57c3ab7618880a045283836112776212750042611e07565b60405161128693929190611ed9565b60405180910390a250505050565b60056112a88484635459504560e01b6118ef565b146112e75760405162461bcd60e51b815260206004820152600f60248201526e4f454c3a6e6f74206120706f6f6c3f60881b60448201526064016101b9565b835460405163908d67ed60e01b8152600481018490526000916001600160a01b03169063908d67ed90602401602060405180830381865afa158015611330573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113549190611ead565b90506000620151806402540be40061136c8442611ec6565b6113769190611d78565b6113809190611d8f565b865460405163f759cc3b60e01b8152600481018790529192506000916001600160a01b039091169063f759cc3b90602401602060405180830381865afa1580156113ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f29190611ead565b905060006402540be40080848a600901548561140e9190611d78565b6114189190611d78565b6114229190611d8f565b61142c9190611d8f565b905060006402540be40080858b600a0154866114489190611d78565b6114529190611d78565b61145c9190611d8f565b6114669190611d8f565b9050826114738288611e07565b1015801561148a57506114868284611e07565b8611155b6109f75760405162461bcd60e51b815260206004820152602b60248201527f4f454c3a707269636520697320696e73616e652c20707269636520757064617460448201526a19481a5cc81a185b1d195960aa1b60648201526084016101b9565b60008360030160006114fc8585611585565b81526020810191909152604001600020546001600160a01b0316949350505050565b8084600101600061152f8686611585565b8152602001908152602001600020600082825461154c9190611ec6565b909155505050505050565b808460010160006115688686611585565b8152602001908152602001600020600082825461154c9190611e07565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600081815b84518110156115f6576115e2828683815181106115d5576115d5611cd4565b6020026020010151611919565b9150806115ee81611efd565b9150506115b6565b5090505b92915050565b6116178585681a5b9a5d1a585d195960ba1b6118ef565b60000361165a5760405162461bcd60e51b815260206004820152601160248201527014d3530e9b9bdd081a5b9a5d1a585d1959607a1b60448201526064016101b9565b600061166e8686635459504560e01b6118ef565b90506004810361173a5781516116bd5760405162461bcd60e51b815260206004820152601460248201527314d3530e95165411481b9bdd08185b1b1bddd95960621b60448201526064016101b9565b83806116c65750825b15611735576116d5868661194b565b156117355760405162461bcd60e51b815260206004820152602a60248201527f534d4c3a707269736f6e65642c2067657420696e20746f756368207769746820604482015269676f7665726e616e636560b01b60648201526084016101b9565b6117c5565b6005810361178a5760208201516117355760405162461bcd60e51b815260206004820152601460248201527314d3530e95165411481b9bdd08185b1b1bddd95960621b60448201526064016101b9565b60405162461bcd60e51b815260206004820152601060248201526f534d4c3a696e76616c6964205459504560801b60448201526064016101b9565b8215611849576117e386866936b0b4b73a30b4b732b960b11b6114ea565b6001600160a01b0316336001600160a01b0316146118435760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572206e6f74206d61696e7461696e65720000000000000060448201526064016101b9565b506105e7565b8315610a105761186786866921a7a72a2927a62622a960b11b6114ea565b6001600160a01b0316336001600160a01b0316146118435760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572206e6f7420434f4e54524f4c4c45520000000000000060448201526064016101b9565b808460010160006118d88686611585565b815260208101919091526040016000205550505050565b60008360010160006119018585611585565b81526020019081526020016000205490509392505050565b6000818310611935576000828152602084905260409020611944565b60008381526020839052604090205b9392505050565b600061196283836672656c6561736560c81b6118ef565b42109392505050565b60008083601f84011261197d57600080fd5b5081356001600160401b0381111561199457600080fd5b6020830191508360208260051b85010111156119af57600080fd5b9250929050565b60008060008060008060008060a0898b0312156119d257600080fd5b883597506020890135965060408901356001600160401b03808211156119f757600080fd5b611a038c838d0161196b565b909850965060608b0135915080821115611a1c57600080fd5b611a288c838d0161196b565b909650945060808b0135915080821115611a4157600080fd5b50611a4e8b828c0161196b565b999c989b5096995094979396929594505050565b60008060008060808587031215611a7857600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060808688031215611aac57600080fd5b85359450602086013593506040860135925060608601356001600160401b03811115611ad757600080fd5b611ae38882890161196b565b969995985093965092949392505050565b60008083601f840112611b0657600080fd5b5081356001600160401b03811115611b1d57600080fd5b6020830191508360208285010111156119af57600080fd5b60008060008060608587031215611b4b57600080fd5b843593506020850135925060408501356001600160401b03811115611b6f57600080fd5b611b7b87828801611af4565b95989497509550505050565b60008060008060008060008060c0898b031215611ba357600080fd5b883597506020890135965060408901356001600160401b0380821115611bc857600080fd5b611bd48c838d01611af4565b909850965060608b0135955060808b0135945060a08b0135915080821115611a4157600080fd5b60008060008060008060808789031215611c1457600080fd5b863595506020870135945060408701356001600160401b0380821115611c3957600080fd5b611c458a838b0161196b565b90965094506060890135915080821115611c5e57600080fd5b50611c6b89828a0161196b565b979a9699509497509295939492505050565b60008060008060008060a08789031215611c9657600080fd5b8635955060208701359450604087013593506060870135925060808701356001600160401b03811115611cc857600080fd5b611c6b89828a0161196b565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611d0157600080fd5b8301803591506001600160401b03821115611d1b57600080fd5b6020019150600581901b36038213156119af57600080fd5b6020808252601590820152744f454c3a73656e646572206e6f74204f5241434c4560581b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176115fa576115fa611d62565b600082611dac57634e487b7160e01b600052601260045260246000fd5b500490565b6000808335601e19843603018112611dc857600080fd5b8301803591506001600160401b03821115611de257600080fd5b6020019150368190038213156119af57600080fd5b8183823760009101908152919050565b808201808211156115fa576115fa611d62565b6001600160401b03818116838216019080821115611e3a57611e3a611d62565b5092915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b606081526000611e7e606083018688611e41565b6020830194909452506040015292915050565b602081526000611ea5602083018486611e41565b949350505050565b600060208284031215611ebf57600080fd5b5051919050565b818103818111156115fa576115fa611d62565b604081526000611eed604083018587611e41565b9050826020830152949350505050565b600060018201611f0f57611f0f611d62565b506001019056fea2646970667358221220b972f3c43b8acd8351e5675bd44ff21177c3bd0dd957d08b61a2d89148b6321d64736f6c63430008140033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063a849957311610065578063a8499573146100ee578063ab0534bb1461010e578063d2da84c91461012e578063e3391a1f1461014e57600080fd5b80630bbc72be1461008c578063182f4f49146100ae5780633352002f146100ce575b600080fd5b81801561009857600080fd5b506100ac6100a73660046119b6565b61016e565b005b8180156100ba57600080fd5b506100ac6100c9366004611a62565b610291565b8180156100da57600080fd5b506100ac6100e9366004611a94565b610397565b8180156100fa57600080fd5b506100ac610109366004611b35565b6104f4565b81801561011a57600080fd5b506100ac610129366004611b87565b6105ee565b81801561013a57600080fd5b506100ac610149366004611bfb565b6108b7565b81801561015a57600080fd5b506100ac610169366004611c7d565b610a02565b8483146101c25760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6172726179206c656e67746873206e6f7420657175616c000000000060448201526064015b60405180910390fd5b8481146102115760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6172726179206c656e67746873206e6f7420657175616c000000000060448201526064016101b9565b8460005b818110156102855761027d8a8a8a8a8581811061023457610234611cd4565b9050602002013589898681811061024d5761024d611cd4565b9050602002013588888781811061026657610266611cd4565b90506020028101906102789190611cea565b610a18565b600101610215565b50505050505050505050565b600184015484906001600160a01b031633146102bf5760405162461bcd60e51b81526004016101b990611d33565b61c35082116103105760405162461bcd60e51b815260206004820152601760248201527f4f454c3a6c6f772076616c696461746f7220636f756e7400000000000000000060448201526064016101b9565b600b8501849055600c850183905542600886015560006402540be40061033a6305f5e10085611d78565b6103449190611d8f565b6004870181905560408051878152602081018790529081018290529091507ffeb6b9f0f1c25e93a31c59bc49721cfd063408fd1d78dcddcf2541b6535f821b9060600160405180910390a1505050505050565b600185015485906001600160a01b031633146103c55760405162461bcd60e51b81526004016101b990611d33565b83866002015410156104195760405162461bcd60e51b815260206004820152601b60248201527f4f454c3a6869676820564552494649434154494f4e5f494e444558000000000060448201526064016101b9565b8560030154841161046c5760405162461bcd60e51b815260206004820152601a60248201527f4f454c3a6c6f7720564552494649434154494f4e5f494e44455800000000000060448201526064016101b9565b8160005b818110156104af576104a788888888888681811061049057610490611cd4565b90506020028101906104a29190611db1565b610efe565b600101610470565b50600387018590556040518581527f5741e1f31a5b295a42632c4a80216d28bf245e6f0ee679b887d8ecd7b94517ee906020015b60405180910390a150505050505050565b600384015461050585848484611167565b6105515760405162461bcd60e51b815260206004820152601960248201527f4f454c3a63616e6e6f7420626c616d652070726f706f73616c0000000000000060448201526064016101b9565b846005015485600d01848460405161056a929190611df7565b9081526040519081900360200190205461059591906001600160401b03600160801b90910416611e07565b42116105da5760405162461bcd60e51b81526020600482015260146024820152734f454c3a61636365707461626c652064656c617960601b60448201526064016101b9565b6105e78585838686610efe565b5050505050565b600088600d018787604051610604929190611df7565b908152604051908190036020019020546001600160401b03169050600281148061063757506001600160401b0381166003145b6106835760405162461bcd60e51b815260206004820152601e60248201527f4f454c3a756e65787065637465642076616c696461746f72207374617465000060448201526064016101b9565b886006015489600d01888860405161069c929190611df7565b908152604051908190036020018120546001600160401b03600160c01b9091041690600d8c01906106d0908b908b90611df7565b908152604051908190036020019020546106fb91906001600160401b03600160801b90910416611e1a565b6001600160401b031661070e9190611e07565b42116107705760405162461bcd60e51b815260206004820152602b60248201527f4f454c3a76616c696461746f7220697320616374697665206f7220616363657060448201526a7461626c652064656c617960a81b60648201526084016101b9565b6000878787876040516020016107899493929190611e6a565b60408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506107ff848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250505050600c8c0154836111e5565b6108415760405162461bcd60e51b815260206004820152601360248201527213d1530e9c1c9bdbd9881b9bdd081d985b1a59606a1b60448201526064016101b9565b856000036108865760405162461bcd60e51b815260206004820152601260248201527113d1530e985b1c9958591e48195e1a5d195960721b60448201526064016101b9565b610285898b600d018a8a60405161089e929190611df7565b9081526020016040518091039020600201548a8a6111fb565b600186015486906001600160a01b031633146108e55760405162461bcd60e51b81526004016101b990611d33565b8382146109295760405162461bcd60e51b81526020600482015260126024820152714f454c3a696e76616c69642070726f6f667360701b60448201526064016101b9565b8360005b818110156109f75761097b8888888481811061094b5761094b611cd4565b9050602002013587878581811061096457610964611cd4565b90506020028101906109769190611db1565b6111fb565b86868281811061098d5761098d611cd4565b905060200201357f6fcceef20658dabea5d70961ac50b4a6a8726c24cce97029fd59ebb91a4d03668686848181106109c7576109c7611cd4565b90506020028101906109d99190611db1565b6040516109e7929190611e91565b60405180910390a260010161092d565b505050505050505050565b610a10868686868686610a18565b505050505050565b855460405163908d67ed60e01b8152600481018690526001600160a01b039091169063908d67ed90602401602060405180830381865afa158015610a60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a849190611ead565b866008015411610acc5760405162461bcd60e51b81526020600482015260136024820152724f454c3a6e6f207072696365206368616e676560681b60448201526064016101b9565b604080516020810186905290810184905260009060600160408051601f1981840301815282825280516020918201209083015201604051602081830303815290604052805190602001209050610b59838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250505050600b890154836111e5565b610ba55760405162461bcd60e51b815260206004820152601c60248201527f4f454c3a6e6f7420616c6c2070726f6f6673206172652076616c69640000000060448201526064016101b9565b610bb187878787611294565b6000610bce87876c3cb4b2b6322932b1b2b4bb32b960991b6114ea565b90506001600160a01b038116610c475787546040516322af599760e01b815260048101879052602481018890526001600160a01b03909116906322af599790604401600060405180830381600087803b158015610c2a57600080fd5b505af1158015610c3e573d6000803e3d6000fd5b50505050610ef4565b875460405163f759cc3b60e01b8152600481018890526000916001600160a01b03169063f759cc3b90602401602060405180830381865afa158015610c90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb49190611ead565b905080861115610e8e57885460405163bd85b03960e01b815260048101899052600091670de0b6b3a7640000916001600160a01b039091169063bd85b03990602401602060405180830381865afa158015610d13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d379190611ead565b610d41848a611ec6565b610d4b9190611d78565b610d559190611d8f565b8a5460405163731133e960e01b8152306004820152602481018b90526044810183905260806064820152600060848201529192506001600160a01b03169063731133e99060a401600060405180830381600087803b158015610db657600080fd5b505af1158015610dca573d6000803e3d6000fd5b50508b54604051637921219560e11b81523060048201526001600160a01b038781166024830152604482018d90526064820186905260a06084830152600060a4830152909116925063f242432a915060c401600060405180830381600087803b158015610e3657600080fd5b505af1158015610e4a573d6000803e3d6000fd5b50505050877ffe4996cd48c364c468cee70dd6b9061874ff01b05c5ea49311cbcabd9b9cb61582604051610e8091815260200190565b60405180910390a2506109f7565b88546040516322af599760e01b815260048101889052602481018990526001600160a01b03909116906322af599790604401600060405180830381600087803b158015610eda57600080fd5b505af1158015610eee573d6000803e3d6000fd5b50505050505b5050505050505050565b8285600d018383604051610f13929190611df7565b908152604051908190036020019020546001600160401b03600160401b909104161115610f795760405162461bcd60e51b815260206004820152601460248201527309e8a9874eadccaf0e0cac6e8cac840d2dcc8caf60631b60448201526064016101b9565b600160ff1685600d018383604051610f92929190611df7565b908152604051908190036020019020546001600160401b031614610ff85760405162461bcd60e51b815260206004820152601f60248201527f4f454c3a6e6f7420616c6c207075626b657973206172652070656e64696e670060448201526064016101b9565b600085600d01838360405161100e929190611df7565b908152602001604051809103902060020154905061102e858285856111fb565b600086600d018484604051611044929190611df7565b9081526040519081900360200190206001015490506110788682661cd958dd5c995960ca1b6801bc16d674ec80000061151e565b611097868266737572706c757360c81b6801bc16d674ec800000611557565b6110c4816110ba847170726f706f73656456616c696461746f727360701b611585565b889190600161151e565b6110ee816110e4846e616c69656e56616c696461746f727360881b611585565b8891906001611557565b604560ff1687600d018585604051611107929190611df7565b90815260405190819003602001812080546001600160401b039390931667ffffffffffffffff19909316929092179091557f7033b7b89d1818b80f9a85b8d604a07ec95f439c75d7ed56caef4d57a1013975906104e39086908690611e91565b6000600160ff1685600d018585604051611182929190611df7565b908152604051908190036020019020546001600160401b03161480156111dc57508185600d0185856040516111b8929190611df7565b908152604051908190036020019020546001600160401b03600160401b9091041611155b95945050505050565b6000826111f285846115b1565b14949350505050565b604080518082019091526001815260006020820181905261122191869186918190611600565b611246836672656c6561736560c81b61123d6212750042611e07565b879291906118c7565b827f6cc873968ba5c560db266aea333bf3b836de0031c3be1d57c3ab7618880a045283836112776212750042611e07565b60405161128693929190611ed9565b60405180910390a250505050565b60056112a88484635459504560e01b6118ef565b146112e75760405162461bcd60e51b815260206004820152600f60248201526e4f454c3a6e6f74206120706f6f6c3f60881b60448201526064016101b9565b835460405163908d67ed60e01b8152600481018490526000916001600160a01b03169063908d67ed90602401602060405180830381865afa158015611330573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113549190611ead565b90506000620151806402540be40061136c8442611ec6565b6113769190611d78565b6113809190611d8f565b865460405163f759cc3b60e01b8152600481018790529192506000916001600160a01b039091169063f759cc3b90602401602060405180830381865afa1580156113ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f29190611ead565b905060006402540be40080848a600901548561140e9190611d78565b6114189190611d78565b6114229190611d8f565b61142c9190611d8f565b905060006402540be40080858b600a0154866114489190611d78565b6114529190611d78565b61145c9190611d8f565b6114669190611d8f565b9050826114738288611e07565b1015801561148a57506114868284611e07565b8611155b6109f75760405162461bcd60e51b815260206004820152602b60248201527f4f454c3a707269636520697320696e73616e652c20707269636520757064617460448201526a19481a5cc81a185b1d195960aa1b60648201526084016101b9565b60008360030160006114fc8585611585565b81526020810191909152604001600020546001600160a01b0316949350505050565b8084600101600061152f8686611585565b8152602001908152602001600020600082825461154c9190611ec6565b909155505050505050565b808460010160006115688686611585565b8152602001908152602001600020600082825461154c9190611e07565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600081815b84518110156115f6576115e2828683815181106115d5576115d5611cd4565b6020026020010151611919565b9150806115ee81611efd565b9150506115b6565b5090505b92915050565b6116178585681a5b9a5d1a585d195960ba1b6118ef565b60000361165a5760405162461bcd60e51b815260206004820152601160248201527014d3530e9b9bdd081a5b9a5d1a585d1959607a1b60448201526064016101b9565b600061166e8686635459504560e01b6118ef565b90506004810361173a5781516116bd5760405162461bcd60e51b815260206004820152601460248201527314d3530e95165411481b9bdd08185b1b1bddd95960621b60448201526064016101b9565b83806116c65750825b15611735576116d5868661194b565b156117355760405162461bcd60e51b815260206004820152602a60248201527f534d4c3a707269736f6e65642c2067657420696e20746f756368207769746820604482015269676f7665726e616e636560b01b60648201526084016101b9565b6117c5565b6005810361178a5760208201516117355760405162461bcd60e51b815260206004820152601460248201527314d3530e95165411481b9bdd08185b1b1bddd95960621b60448201526064016101b9565b60405162461bcd60e51b815260206004820152601060248201526f534d4c3a696e76616c6964205459504560801b60448201526064016101b9565b8215611849576117e386866936b0b4b73a30b4b732b960b11b6114ea565b6001600160a01b0316336001600160a01b0316146118435760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572206e6f74206d61696e7461696e65720000000000000060448201526064016101b9565b506105e7565b8315610a105761186786866921a7a72a2927a62622a960b11b6114ea565b6001600160a01b0316336001600160a01b0316146118435760405162461bcd60e51b815260206004820152601960248201527f534d4c3a73656e646572206e6f7420434f4e54524f4c4c45520000000000000060448201526064016101b9565b808460010160006118d88686611585565b815260208101919091526040016000205550505050565b60008360010160006119018585611585565b81526020019081526020016000205490509392505050565b6000818310611935576000828152602084905260409020611944565b60008381526020839052604090205b9392505050565b600061196283836672656c6561736560c81b6118ef565b42109392505050565b60008083601f84011261197d57600080fd5b5081356001600160401b0381111561199457600080fd5b6020830191508360208260051b85010111156119af57600080fd5b9250929050565b60008060008060008060008060a0898b0312156119d257600080fd5b883597506020890135965060408901356001600160401b03808211156119f757600080fd5b611a038c838d0161196b565b909850965060608b0135915080821115611a1c57600080fd5b611a288c838d0161196b565b909650945060808b0135915080821115611a4157600080fd5b50611a4e8b828c0161196b565b999c989b5096995094979396929594505050565b60008060008060808587031215611a7857600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060808688031215611aac57600080fd5b85359450602086013593506040860135925060608601356001600160401b03811115611ad757600080fd5b611ae38882890161196b565b969995985093965092949392505050565b60008083601f840112611b0657600080fd5b5081356001600160401b03811115611b1d57600080fd5b6020830191508360208285010111156119af57600080fd5b60008060008060608587031215611b4b57600080fd5b843593506020850135925060408501356001600160401b03811115611b6f57600080fd5b611b7b87828801611af4565b95989497509550505050565b60008060008060008060008060c0898b031215611ba357600080fd5b883597506020890135965060408901356001600160401b0380821115611bc857600080fd5b611bd48c838d01611af4565b909850965060608b0135955060808b0135945060a08b0135915080821115611a4157600080fd5b60008060008060008060808789031215611c1457600080fd5b863595506020870135945060408701356001600160401b0380821115611c3957600080fd5b611c458a838b0161196b565b90965094506060890135915080821115611c5e57600080fd5b50611c6b89828a0161196b565b979a9699509497509295939492505050565b60008060008060008060a08789031215611c9657600080fd5b8635955060208701359450604087013593506060870135925060808701356001600160401b03811115611cc857600080fd5b611c6b89828a0161196b565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611d0157600080fd5b8301803591506001600160401b03821115611d1b57600080fd5b6020019150600581901b36038213156119af57600080fd5b6020808252601590820152744f454c3a73656e646572206e6f74204f5241434c4560581b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b80820281158282048414176115fa576115fa611d62565b600082611dac57634e487b7160e01b600052601260045260246000fd5b500490565b6000808335601e19843603018112611dc857600080fd5b8301803591506001600160401b03821115611de257600080fd5b6020019150368190038213156119af57600080fd5b8183823760009101908152919050565b808201808211156115fa576115fa611d62565b6001600160401b03818116838216019080821115611e3a57611e3a611d62565b5092915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b606081526000611e7e606083018688611e41565b6020830194909452506040015292915050565b602081526000611ea5602083018486611e41565b949350505050565b600060208284031215611ebf57600080fd5b5051919050565b818103818111156115fa576115fa611d62565b604081526000611eed604083018587611e41565b9050826020830152949350505050565b600060018201611f0f57611f0f611d62565b506001019056fea2646970667358221220b972f3c43b8acd8351e5675bd44ff21177c3bd0dd957d08b61a2d89148b6321d64736f6c63430008140033",
  "libraries": {
    "StakeModuleLib": "0xe5614F21772a3DB0F658a5860E153D09Ef1BF01B"
  },
  "devdoc": {
    "author": "Ice Bear & Crash Bandicoot",
    "details": "review: DataStoreModule for the id based isolated storage logic.review: StakeModuleLib for base staking logic.Telescope is currently responsible for 4 tasks: * Updating the on-chain price of all pools with a MerkleRoot for minting operations * Updating the on-chain balances info of all validators with a MerkleRoot for withdrawal operations * Confirming validator proposals * Regulating the Node Operators 1. updateVerificationIndex: Confirming validator proposals * 2 step process is essential to prevent the frontrunning with a problematic withdrawalCredential: https://bit.ly/3Tkc6UC * Simply, all proposed validator has an index bound to them, * n representing the latest proposal: (0,n] * Telescope verifies the validator data provided in proposeStake: * especially sig1, sig31 and withdrawal credentials. * Telescope confirms the latest index verified and states the faulty validator proposals (aliens) * If a validator proposal is faulty then it's state is set to 69, refer to globals/validator_state.sol 2. regulateOperators: Regulating the Operators * Operators can act faulty in many different ways. To prevent such actions, * Telescope regulates them with well defined limitations. * Currently only issue is the fee theft, meaning operators have not * used the withdrawal contract for miner fees or MEV boost. * There can be other restrictions in the future. 2. reportBeacon: Continous Data from Beacon chain: Price Merkle Root & Balances Merkle Root & # of active validators * 1. Oracle Nodes calculate the price of its derivative, according to the validator data such as balance and fees. * 2. If a pool doesn't have a validator, the price is kept the same. * 3. A merkle tree is constructed with the order of allIdsByType array. * 4. A watcher collects all the signatures from Multiple Oracle Nodes, and submits the merkle root. * 5. Anyone can update the price of the derivative  by calling priceSync() functions with correct merkle proofs * 6. Minting is allowed within PRICE_EXPIRY (24H) after the last price update. * 7. Updates the regulation around Monopolies and provides BALANCE_MERKLE_ROOT to be used within withdrawal process.Most external functions have OracleOnly modifier. Except: priceSync, priceSyncBatch, blameExit and blameProposal.This is an external library, requires deployment.",
    "events": {
      "Alienated(bytes)": {
        "custom:section": "** EVENTS **"
      }
    },
    "kind": "dev",
    "methods": {
      "blameExit(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes,uint256,uint256,bytes32[])": {
        "details": "normally, oracle should verify the signed exit request on beacon chain for a (deterministic) epoch * before approval. This function enforces it further for the stakers.anyone can call this function while the state is ACTIVE or EXIT_REQUESTEDif operator has given enough allowance, they SHOULD rotate the validators to avoid being prisoned"
      },
      "blameProposal(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes)": {
        "details": "anyone can call this function while the state is PROPOSEDthis check can be problematic in the case the beaconchain deposit delay is > BEACON_DELAY_ENTRY, * depending on the expected delay of telescope approvals. However, BEACON_DELAY_ENTRY can be adjusted by the Governance._canStake checks == VALIDATOR_STATE.PROPOSED."
      },
      "priceSync(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,bytes32[])": {
        "custom:visibility": "-> external",
        "params": {
          "price": "price of the derivative denominated in gETH.denominator()",
          "priceProof": "merkle proofs"
        }
      },
      "priceSyncBatch(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],uint256[],bytes32[][])": {
        "custom:visibility": "-> external",
        "params": {
          "priceProofs": "merkle proofs",
          "prices": "price of the derivative denominated in gETH.denominator()"
        }
      },
      "regulateOperators(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],bytes[])": {
        "details": "Stuff here result in imprisonment",
        "params": {
          "feeThefts": "Operator ids who have stolen MEV or block rewards detected",
          "proofs": "BlockNumber, tx or any other referance as a proof"
        }
      },
      "reportBeacon(StakeModuleStorage storage,bytes32,bytes32,uint256)": {
        "params": {
          "allValidatorsCount": "Number of all validators within BeaconChain, all of them. Prevents monopolies."
        }
      },
      "updateVerificationIndex(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,bytes[])": {
        "custom:visibility": "-> external",
        "params": {
          "alienatedPubkeys": "faulty proposals within the range of new and old verification indexes.",
          "validatorVerificationIndex": "(inclusive) index of the highest validator that is verified to be activated"
        }
      }
    },
    "title": "OEL: Oracle Extension Library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "blameExit(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes,uint256,uint256,bytes32[])": {
        "notice": "imprisoning an Operator if the validator have not been exited until expected exit"
      },
      "blameProposal(StakeModuleStorage storage,DataStoreModuleStorage storage,bytes)": {
        "notice": "imprisoning an Operator if the validator proposal is approved but have not been executed."
      },
      "priceSync(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,uint256,bytes32[])": {
        "notice": "external function to set a derivative price on Portal"
      },
      "priceSyncBatch(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],uint256[],bytes32[][])": {
        "notice": "external function to set a multiple derivatives price at once, saves gas."
      },
      "regulateOperators(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256[],bytes[])": {
        "notice": "regulating operators, currently only regulation is towards fee theft, can add more stuff in the future."
      },
      "reportBeacon(StakeModuleStorage storage,bytes32,bytes32,uint256)": {
        "notice": "Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT. Also reports all of the validator balances with a BALANCE_MERKLE_ROOT. Then, updates the ORACLE_UPDATE_TIMESTAMP and MONOPOLY_THRESHOLD"
      },
      "updateVerificationIndex(StakeModuleStorage storage,DataStoreModuleStorage storage,uint256,bytes[])": {
        "notice": "Updating VERIFICATION_INDEX, signaling that it is safe to activate the validator proposals with lower index than new VERIFICATION_INDEX"
      }
    },
    "notice": "An extension to SMLOracle, named Telescope, handles some operations for The Staking Library, * using the logic explained below.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}