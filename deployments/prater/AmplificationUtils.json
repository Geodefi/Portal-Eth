{
  "address": "0x869F38F67B4ce01bE313B903d51E4349f25a31E6",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "initialTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "futureTime",
          "type": "uint256"
        }
      ],
      "name": "RampA",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "currentA",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "time",
          "type": "uint256"
        }
      ],
      "name": "StopRampA",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "A_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_A",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x6ede2037725b54f0b2af8d5566a0861bd41fd8f56687ae9fc7e423c9d7662f3d",
  "receipt": {
    "to": null,
    "from": "0x5297F1EA60D4b60E85eF323DECEc1A907295B6E6",
    "contractAddress": "0x869F38F67B4ce01bE313B903d51E4349f25a31E6",
    "transactionIndex": 112,
    "gasUsed": "380060",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x93b4dfdee93975cc2dced23e95a9e07aab082fbf15f16ef38fff68b93a8bb9d9",
    "transactionHash": "0x6ede2037725b54f0b2af8d5566a0861bd41fd8f56687ae9fc7e423c9d7662f3d",
    "logs": [],
    "blockNumber": 7845391,
    "cumulativeGasUsed": "22932281",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ee39b7d5d718f6bdbf221f88cbfb986f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"futureTime\",\"type\":\"uint256\"}],\"name\":\"RampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"A_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_A\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getA(SwapUtils.Swap storage)\":{\"details\":\"See the StableSwap paper for details\",\"params\":{\"self\":\"Swap struct to read from\"},\"returns\":{\"_0\":\"A parameter\"}},\"getAPrecise(SwapUtils.Swap storage)\":{\"details\":\"See the StableSwap paper for details\",\"params\":{\"self\":\"Swap struct to read from\"},\"returns\":{\"_0\":\"A parameter in its raw precision form\"}},\"rampA(SwapUtils.Swap storage,uint256,uint256)\":{\"params\":{\"futureA_\":\"the new A to ramp towards\",\"futureTime_\":\"timestamp when the new A should be reached\",\"self\":\"Swap struct to update\"}},\"stopRampA(SwapUtils.Swap storage)\":{\"params\":{\"self\":\"Swap struct to update\"}}},\"title\":\"AmplificationUtils library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getA(SwapUtils.Swap storage)\":{\"notice\":\"Return A, the amplification coefficient * n * (n - 1)\"},\"getAPrecise(SwapUtils.Swap storage)\":{\"notice\":\"Return A in its raw precision\"},\"rampA(SwapUtils.Swap storage,uint256,uint256)\":{\"notice\":\"Start ramping up or down A parameter towards given futureA_ and futureTime_ Checks if the change is too rapid, and commits the new A value only when it falls under the limit range.\"},\"stopRampA(SwapUtils.Swap storage)\":{\"notice\":\"Stops ramping A immediately. Once this function is called, rampA() cannot be called for another 24 hours\"}},\"notice\":\"A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct. This library assumes the struct is fully validated.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Portal/withdrawalPool/utils/AmplificationUtils.sol\":\"AmplificationUtils\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Portal/withdrawalPool/utils/AmplificationUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.7;\\r\\nimport \\\"./SwapUtils.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title AmplificationUtils library\\r\\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\\r\\n * This library assumes the struct is fully validated.\\r\\n */\\r\\nlibrary AmplificationUtils {\\r\\n    event RampA(\\r\\n        uint256 oldA,\\r\\n        uint256 newA,\\r\\n        uint256 initialTime,\\r\\n        uint256 futureTime\\r\\n    );\\r\\n    event StopRampA(uint256 currentA, uint256 time);\\r\\n\\r\\n    // Constant values used in ramping A calculations\\r\\n    uint256 public constant A_PRECISION = 100;\\r\\n    uint256 public constant MAX_A = 10**6;\\r\\n    uint256 private constant MAX_A_CHANGE = 2;\\r\\n    uint256 private constant MIN_RAMP_TIME = 14 days;\\r\\n\\r\\n    /**\\r\\n     * @notice Return A, the amplification coefficient * n * (n - 1)\\r\\n     * @dev See the StableSwap paper for details\\r\\n     * @param self Swap struct to read from\\r\\n     * @return A parameter\\r\\n     */\\r\\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\\r\\n        return _getAPrecise(self) / (A_PRECISION);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return A in its raw precision\\r\\n     * @dev See the StableSwap paper for details\\r\\n     * @param self Swap struct to read from\\r\\n     * @return A parameter in its raw precision form\\r\\n     */\\r\\n    function getAPrecise(SwapUtils.Swap storage self)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getAPrecise(self);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return A in its raw precision\\r\\n     * @dev See the StableSwap paper for details\\r\\n     * @param self Swap struct to read from\\r\\n     * @return A parameter in its raw precision form\\r\\n     */\\r\\n    function _getAPrecise(SwapUtils.Swap storage self)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 t1 = self.futureATime; // time when ramp is finished\\r\\n        uint256 a1 = self.futureA; // final A value when ramp is finished\\r\\n\\r\\n        if (block.timestamp < t1) {\\r\\n            uint256 t0 = self.initialATime; // time when ramp is started\\r\\n            uint256 a0 = self.initialA; // initial A value when ramp is started\\r\\n            if (a1 > a0) {\\r\\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\\r\\n                return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\\r\\n            } else {\\r\\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\\r\\n                return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\\r\\n            }\\r\\n        } else {\\r\\n            return a1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\\r\\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\\r\\n     * the limit range.\\r\\n     * @param self Swap struct to update\\r\\n     * @param futureA_ the new A to ramp towards\\r\\n     * @param futureTime_ timestamp when the new A should be reached\\r\\n     */\\r\\n    function rampA(\\r\\n        SwapUtils.Swap storage self,\\r\\n        uint256 futureA_,\\r\\n        uint256 futureTime_\\r\\n    ) external {\\r\\n        require(\\r\\n            block.timestamp >= self.initialATime + 1 days,\\r\\n            \\\"Wait 1 day before starting ramp\\\"\\r\\n        );\\r\\n        require(\\r\\n            futureTime_ >= block.timestamp + MIN_RAMP_TIME,\\r\\n            \\\"Insufficient ramp time\\\"\\r\\n        );\\r\\n        require(\\r\\n            futureA_ > 0 && futureA_ < MAX_A,\\r\\n            \\\"futureA_ must be > 0 and < MAX_A\\\"\\r\\n        );\\r\\n\\r\\n        uint256 initialAPrecise = _getAPrecise(self);\\r\\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\\r\\n\\r\\n        if (futureAPrecise < initialAPrecise) {\\r\\n            require(\\r\\n                futureAPrecise * MAX_A_CHANGE >= initialAPrecise,\\r\\n                \\\"futureA_ is too small\\\"\\r\\n            );\\r\\n        } else {\\r\\n            require(\\r\\n                futureAPrecise <= initialAPrecise * MAX_A_CHANGE,\\r\\n                \\\"futureA_ is too large\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        self.initialA = initialAPrecise;\\r\\n        self.futureA = futureAPrecise;\\r\\n        self.initialATime = block.timestamp;\\r\\n        self.futureATime = futureTime_;\\r\\n\\r\\n        emit RampA(\\r\\n            initialAPrecise,\\r\\n            futureAPrecise,\\r\\n            block.timestamp,\\r\\n            futureTime_\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\\r\\n     * cannot be called for another 24 hours\\r\\n     * @param self Swap struct to update\\r\\n     */\\r\\n    function stopRampA(SwapUtils.Swap storage self) external {\\r\\n        require(self.futureATime > block.timestamp, \\\"Ramp is already stopped\\\");\\r\\n\\r\\n        uint256 currentA = _getAPrecise(self);\\r\\n        self.initialA = currentA;\\r\\n        self.futureA = currentA;\\r\\n        self.initialATime = block.timestamp;\\r\\n        self.futureATime = block.timestamp;\\r\\n\\r\\n        emit StopRampA(currentA, block.timestamp);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6e0d49caae81c6e466ee008d56cf4872295d3dbf9bc597d7511f3f92a30c0bfe\",\"license\":\"MIT\"},\"contracts/Portal/withdrawalPool/utils/MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.7;\\r\\n\\r\\n/**\\r\\n * @title MathUtils library\\r\\n * @notice  Contains functions for calculating differences between two uint256.\\r\\n */\\r\\nlibrary MathUtils {\\r\\n    /**\\r\\n     * @notice Compares a and b and returns true if the difference between a and b\\r\\n     *         is less than 1 or equal to each other.\\r\\n     * @param a uint256 to compare with\\r\\n     * @param b uint256 to compare with\\r\\n     * @return True if the difference between a and b is less than 1 or equal,\\r\\n     *         otherwise return false\\r\\n     */\\r\\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\\r\\n        return (difference(a, b) <= 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates absolute difference between a and b\\r\\n     * @param a uint256 to compare with\\r\\n     * @param b uint256 to compare with\\r\\n     * @return Difference between a and b\\r\\n     */\\r\\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a > b) {\\r\\n            return a - b;\\r\\n        }\\r\\n        return b - a;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd0a9d28938cecdc3d7cc70f1847c15fa726d2a8e25e87aaf06e98cf3b995a33d\",\"license\":\"MIT\"},\"contracts/Portal/withdrawalPool/utils/SwapUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.7;\\r\\n\\r\\nimport \\\"./MathUtils.sol\\\";\\r\\nimport \\\"./AmplificationUtils.sol\\\";\\r\\nimport \\\"../../../interfaces/ILPToken.sol\\\";\\r\\nimport \\\"../../../interfaces/IgETH.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SwapUtils library\\r\\n *\\r\\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\\r\\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\\r\\n * Admin functions should be protected within contracts using this library.\\r\\n *\\r\\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities with some changes.\\r\\n * The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals\\r\\n * relying on the Oracle Price, with the help of Liquidity Providers.\\r\\n * It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions.\\r\\n * Because the underlying price of the staked assets are expected to raise in time.\\r\\n * One can see this similar to accomplishing a \\\"rebasing\\\" logic, with the help of a trusted price source.\\r\\n *\\r\\n * @dev Whenever \\\"Effective Balance\\\" is mentioned it refers to the balance projected with underlying price.\\r\\n */\\r\\nlibrary SwapUtils {\\r\\n    using MathUtils for uint256;\\r\\n\\r\\n    /*** EVENTS ***/\\r\\n\\r\\n    event TokenSwap(\\r\\n        address indexed buyer,\\r\\n        uint256 tokensSold,\\r\\n        uint256 tokensBought,\\r\\n        uint128 soldId,\\r\\n        uint128 boughtId\\r\\n    );\\r\\n    event AddLiquidity(\\r\\n        address indexed provider,\\r\\n        uint256[] tokenAmounts,\\r\\n        uint256[] fees,\\r\\n        uint256 invariant,\\r\\n        uint256 lpTokenSupply\\r\\n    );\\r\\n    event RemoveLiquidity(\\r\\n        address indexed provider,\\r\\n        uint256[] tokenAmounts,\\r\\n        uint256 lpTokenSupply\\r\\n    );\\r\\n    event RemoveLiquidityOne(\\r\\n        address indexed provider,\\r\\n        uint256 lpTokenAmount,\\r\\n        uint256 lpTokenSupply,\\r\\n        uint256 boughtId,\\r\\n        uint256 tokensBought\\r\\n    );\\r\\n    event RemoveLiquidityImbalance(\\r\\n        address indexed provider,\\r\\n        uint256[] tokenAmounts,\\r\\n        uint256[] fees,\\r\\n        uint256 invariant,\\r\\n        uint256 lpTokenSupply\\r\\n    );\\r\\n    event NewAdminFee(uint256 newAdminFee);\\r\\n    event NewSwapFee(uint256 newSwapFee);\\r\\n\\r\\n    struct Swap {\\r\\n        IgETH gETH;\\r\\n        ILPToken lpToken;\\r\\n        uint256 pooledTokenId;\\r\\n        // variables around the ramp management of A,\\r\\n        // the amplification coefficient * n * (n - 1)\\r\\n        // see https://curve.fi/stableswap-paper.pdf for details\\r\\n        uint256 initialA;\\r\\n        uint256 futureA;\\r\\n        uint256 initialATime;\\r\\n        uint256 futureATime;\\r\\n        // fee calculation\\r\\n        uint256 swapFee;\\r\\n        uint256 adminFee;\\r\\n        // gETH contract reference\\r\\n        // the pool balance as [ETH, gETH]\\r\\n        // the contract's actual token balance might differ\\r\\n        uint256[] balances;\\r\\n    }\\r\\n\\r\\n    // Struct storing variables used in calculations in the\\r\\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\\r\\n    struct CalculateWithdrawOneTokenDYInfo {\\r\\n        uint256 d0;\\r\\n        uint256 d1;\\r\\n        uint256 newY;\\r\\n        uint256 feePerToken;\\r\\n        uint256 preciseA;\\r\\n    }\\r\\n\\r\\n    // Struct storing variables used in calculations in the\\r\\n    // {add,remove} Liquidity functions to avoid stack too deep errors\\r\\n    struct ManageLiquidityInfo {\\r\\n        ILPToken lpToken;\\r\\n        uint256 d0;\\r\\n        uint256 d1;\\r\\n        uint256 d2;\\r\\n        uint256 preciseA;\\r\\n        uint256 totalSupply;\\r\\n        uint256[] balances;\\r\\n    }\\r\\n\\r\\n    // the denominator used to calculate admin and LP fees. For example, an\\r\\n    // LP fee is BoughtAmount.mul(fee).div(PERCENTAGE_DENOMINATOR)\\r\\n    uint256 private constant PERCENTAGE_DENOMINATOR = 10**10;\\r\\n\\r\\n    // Max swap fee is 1% or 100bps of each swap\\r\\n    uint256 public constant MAX_SWAP_FEE = 10**8;\\r\\n\\r\\n    // Max adminFee is 100% of the swapFee\\r\\n    // adminFee does not add additional fee on top of swapFee\\r\\n    // instead it takes a certain percentage of the swapFee.\\r\\n    // Therefore it has no impact on users but only on the earnings of LPs\\r\\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\\r\\n\\r\\n    // Constant value used as max loop limit\\r\\n    uint256 private constant MAX_LOOP_LIMIT = 256;\\r\\n\\r\\n    /*** VIEW & PURE FUNCTIONS ***/\\r\\n\\r\\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\\r\\n        return AmplificationUtils._getAPrecise(self);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\r\\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\r\\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\r\\n     * @param balance balance that will be taken into calculation\\r\\n     * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\\r\\n     */\\r\\n    function _pricedIn(\\r\\n        Swap storage self,\\r\\n        uint256 balance,\\r\\n        uint256 i\\r\\n    ) internal view returns (uint256) {\\r\\n        return\\r\\n            i == 1\\r\\n                ? (balance * self.gETH.pricePerShare(self.pooledTokenId)) /\\r\\n                    self.gETH.denominator()\\r\\n                : balance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\r\\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\r\\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\r\\n     * @param balance balance that will be taken into calculation\\r\\n     * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\\r\\n     */\\r\\n    function _pricedOut(\\r\\n        Swap storage self,\\r\\n        uint256 balance,\\r\\n        uint256 i\\r\\n    ) internal view returns (uint256) {\\r\\n        return\\r\\n            i == 1\\r\\n                ? (balance * self.gETH.denominator()) /\\r\\n                    self.gETH.pricePerShare(self.pooledTokenId)\\r\\n                : balance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\r\\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\r\\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\r\\n     * @param balances ARRAY of balances that will be taken into calculation\\r\\n     */\\r\\n    function _pricedInBatch(Swap storage self, uint256[] memory balances)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory _p = new uint256[](balances.length);\\r\\n        _p[0] = balances[0];\\r\\n        _p[1] =\\r\\n            (balances[1] * self.gETH.pricePerShare(self.pooledTokenId)) /\\r\\n            self.gETH.denominator();\\r\\n        return _p;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\\r\\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\\r\\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\\r\\n     * @param balances ARRAY of balances that will be taken into calculation\\r\\n     */\\r\\n    function _pricedOutBatch(Swap storage self, uint256[] memory balances)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory _p = new uint256[](balances.length);\\r\\n        _p[0] = balances[0];\\r\\n        _p[1] =\\r\\n            (balances[1] * self.gETH.denominator()) /\\r\\n            self.gETH.pricePerShare(self.pooledTokenId);\\r\\n        return _p;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the dy, the amount of selected token that user receives and\\r\\n     * the fee of withdrawing in one token\\r\\n     * @param tokenAmount the amount to withdraw in the pool's precision\\r\\n     * @param tokenIndex which token will be withdrawn\\r\\n     * @param self Swap struct to read from\\r\\n     * @return the amount of token user will receive\\r\\n     */\\r\\n    function calculateWithdrawOneToken(\\r\\n        Swap storage self,\\r\\n        uint256 tokenAmount,\\r\\n        uint8 tokenIndex\\r\\n    ) external view returns (uint256) {\\r\\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\\r\\n            self,\\r\\n            tokenAmount,\\r\\n            tokenIndex,\\r\\n            self.lpToken.totalSupply()\\r\\n        );\\r\\n        return availableTokenAmount;\\r\\n    }\\r\\n\\r\\n    function _calculateWithdrawOneToken(\\r\\n        Swap storage self,\\r\\n        uint256 tokenAmount,\\r\\n        uint8 tokenIndex,\\r\\n        uint256 totalSupply\\r\\n    ) internal view returns (uint256, uint256) {\\r\\n        uint256 dy;\\r\\n        uint256 newY;\\r\\n        uint256 currentY;\\r\\n\\r\\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\\r\\n            self,\\r\\n            tokenIndex,\\r\\n            tokenAmount,\\r\\n            totalSupply\\r\\n        );\\r\\n\\r\\n        // dy_0 (without fees)\\r\\n        // dy, dy_0 - dy\\r\\n\\r\\n        uint256 dySwapFee = currentY - newY - dy;\\r\\n\\r\\n        return (dy, dySwapFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the dy of withdrawing in one token\\r\\n     * @param self Swap struct to read from\\r\\n     * @param tokenIndex which token will be withdrawn\\r\\n     * @param tokenAmount the amount to withdraw in the pools precision\\r\\n     * @return the d and the new y after withdrawing one token\\r\\n     */\\r\\n    function calculateWithdrawOneTokenDY(\\r\\n        Swap storage self,\\r\\n        uint8 tokenIndex,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 totalSupply\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Get the current D, then solve the stableswap invariant\\r\\n        // y_i for D - tokenAmount\\r\\n\\r\\n        require(tokenIndex < 2, \\\"Token index out of range\\\");\\r\\n\\r\\n        CalculateWithdrawOneTokenDYInfo\\r\\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\\r\\n        v.preciseA = _getAPrecise(self);\\r\\n        v.d0 = getD(_pricedInBatch(self, self.balances), v.preciseA);\\r\\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\\r\\n\\r\\n        require(\\r\\n            tokenAmount <= self.balances[tokenIndex],\\r\\n            \\\"Withdraw exceeds available\\\"\\r\\n        );\\r\\n\\r\\n        v.newY = _pricedOut(\\r\\n            self,\\r\\n            getYD(\\r\\n                v.preciseA,\\r\\n                tokenIndex,\\r\\n                _pricedInBatch(self, self.balances),\\r\\n                v.d1\\r\\n            ),\\r\\n            tokenIndex\\r\\n        );\\r\\n\\r\\n        uint256[] memory xpReduced = new uint256[](2);\\r\\n\\r\\n        v.feePerToken = self.swapFee / 2;\\r\\n        for (uint256 i = 0; i < 2; i++) {\\r\\n            uint256 xpi = self.balances[i];\\r\\n            xpReduced[i] =\\r\\n                xpi -\\r\\n                (((\\r\\n                    (i == tokenIndex)\\r\\n                        ? (xpi * v.d1) / v.d0 - v.newY\\r\\n                        : xpi - ((xpi * v.d1) / (v.d0))\\r\\n                ) * (v.feePerToken)) / (PERCENTAGE_DENOMINATOR));\\r\\n        }\\r\\n\\r\\n        uint256 dy = xpReduced[tokenIndex] -\\r\\n            _pricedOut(\\r\\n                self,\\r\\n                (\\r\\n                    getYD(\\r\\n                        v.preciseA,\\r\\n                        tokenIndex,\\r\\n                        _pricedInBatch(self, xpReduced),\\r\\n                        v.d1\\r\\n                    )\\r\\n                ),\\r\\n                tokenIndex\\r\\n            );\\r\\n        dy = dy - 1;\\r\\n\\r\\n        return (dy, v.newY, self.balances[tokenIndex]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get Debt, The amount of buyback for stable pricing.\\r\\n     * @param xp a  set of pool balances. Array should be the same cardinality\\r\\n     * as the pool.\\r\\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\r\\n     * See the StableSwap paper for details\\r\\n     * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\\r\\n     */\\r\\n    function _getDebt(\\r\\n        Swap storage self,\\r\\n        uint256[] memory xp,\\r\\n        uint256 a\\r\\n    ) internal view returns (uint256) {\\r\\n        uint256 halfD = getD(xp, a) / 2;\\r\\n        if (xp[0] >= halfD) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            uint256 dy = xp[1] - halfD;\\r\\n            uint256 feeHalf = (dy * self.swapFee) / PERCENTAGE_DENOMINATOR / 2;\\r\\n            uint256 debt = halfD - xp[0] + feeHalf;\\r\\n            return debt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\\r\\n     */\\r\\n    function getDebt(Swap storage self) external view returns (uint256) {\\r\\n        // might change when price is in.\\r\\n        return\\r\\n            _getDebt(\\r\\n                self,\\r\\n                _pricedInBatch(self, self.balances),\\r\\n                _getAPrecise(self)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the price of a token in the pool with given\\r\\n     *  balances and a particular D.\\r\\n     *\\r\\n     * @dev This is accomplished via solving the invariant iteratively.\\r\\n     * See the StableSwap paper and Curve.fi implementation for further details.\\r\\n     *\\r\\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\\r\\n     * x_1**2 + b*x_1 = c\\r\\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\\r\\n     *\\r\\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\\r\\n     * @param tokenIndex Index of token we are calculating for.\\r\\n     * @param xp a  set of pool balances. Array should be\\r\\n     * the same cardinality as the pool.\\r\\n     * @param d the stableswap invariant\\r\\n     * @return the price of the token, in the same precision as in xp\\r\\n     */\\r\\n    function getYD(\\r\\n        uint256 a,\\r\\n        uint8 tokenIndex,\\r\\n        uint256[] memory xp,\\r\\n        uint256 d\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 numTokens = 2;\\r\\n        require(tokenIndex < numTokens, \\\"Token not found\\\");\\r\\n\\r\\n        uint256 c = d;\\r\\n        uint256 s;\\r\\n        uint256 nA = a * numTokens;\\r\\n\\r\\n        for (uint256 i = 0; i < numTokens; i++) {\\r\\n            if (i != tokenIndex) {\\r\\n                s = s + xp[i];\\r\\n                c = (c * d) / (xp[i] * (numTokens));\\r\\n                // If we were to protect the division loss we would have to keep the denominator separate\\r\\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\\r\\n                // c = c * D * D * D * ... overflow!\\r\\n            }\\r\\n        }\\r\\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\\r\\n\\r\\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\r\\n        uint256 yPrev;\\r\\n        uint256 y = d;\\r\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\r\\n            yPrev = y;\\r\\n            y = ((y * y) + c) / (2 * y + b - d);\\r\\n            if (y.within1(yPrev)) {\\r\\n                return y;\\r\\n            }\\r\\n        }\\r\\n        revert(\\\"Approximation did not converge\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\\r\\n     * @param xp a  set of pool balances. Array should be the same cardinality\\r\\n     * as the pool.\\r\\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\r\\n     * See the StableSwap paper for details\\r\\n     * @return the invariant, at the precision of the pool\\r\\n     */\\r\\n    function getD(uint256[] memory xp, uint256 a)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 numTokens = 2;\\r\\n        uint256 s = xp[0] + xp[1];\\r\\n        if (s == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 prevD;\\r\\n        uint256 d = s;\\r\\n        uint256 nA = a * numTokens;\\r\\n\\r\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\r\\n            uint256 dP = (d**(numTokens + 1)) /\\r\\n                (numTokens**numTokens * xp[0] * xp[1]);\\r\\n            prevD = d;\\r\\n            d =\\r\\n                ((((nA * s) / AmplificationUtils.A_PRECISION) +\\r\\n                    dP *\\r\\n                    numTokens) * (d)) /\\r\\n                (((nA - AmplificationUtils.A_PRECISION) * (d)) /\\r\\n                    (AmplificationUtils.A_PRECISION) +\\r\\n                    ((numTokens + 1) * dP));\\r\\n\\r\\n            if (d.within1(prevD)) {\\r\\n                return d;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\\r\\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\\r\\n        // function which does not rely on D.\\r\\n        revert(\\\"D does not converge\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the virtual price, to help calculate profit\\r\\n     * @param self Swap struct to read from\\r\\n     * @return the virtual price\\r\\n     */\\r\\n    function getVirtualPrice(Swap storage self)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 d = getD(\\r\\n            _pricedInBatch(self, self.balances),\\r\\n            _getAPrecise(self)\\r\\n        );\\r\\n        ILPToken lpToken = self.lpToken;\\r\\n        uint256 supply = lpToken.totalSupply();\\r\\n        if (supply > 0) {\\r\\n            return (d * 10**18) / supply;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the new balances of the tokens given the indexes of the token\\r\\n     * that is swapped from (FROM) and the token that is swapped to (TO).\\r\\n     * This function is used as a helper function to calculate how much TO token\\r\\n     * the user should receive on swap.\\r\\n     *\\r\\n     * @param preciseA precise form of amplification coefficient\\r\\n     * @param tokenIndexFrom index of FROM token\\r\\n     * @param tokenIndexTo index of TO token\\r\\n     * @param x the new total amount of FROM token\\r\\n     * @param xp balances of the tokens in the pool\\r\\n     * @return the amount of TO token that should remain in the pool\\r\\n     */\\r\\n    function getY(\\r\\n        uint256 preciseA,\\r\\n        uint8 tokenIndexFrom,\\r\\n        uint8 tokenIndexTo,\\r\\n        uint256 x,\\r\\n        uint256[] memory xp\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 numTokens = 2;\\r\\n        require(\\r\\n            tokenIndexFrom != tokenIndexTo,\\r\\n            \\\"Can't compare token to itself\\\"\\r\\n        );\\r\\n        require(\\r\\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\\r\\n            \\\"Tokens must be in pool\\\"\\r\\n        );\\r\\n\\r\\n        uint256 d = getD(xp, preciseA);\\r\\n        uint256 c = d;\\r\\n        uint256 s = x;\\r\\n        uint256 nA = numTokens * (preciseA);\\r\\n\\r\\n        c = (c * d) / (x * numTokens);\\r\\n        c = (c * d * (AmplificationUtils.A_PRECISION)) / (nA * numTokens);\\r\\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\r\\n\\r\\n        uint256 yPrev;\\r\\n        uint256 y = d;\\r\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\r\\n            yPrev = y;\\r\\n            y = ((y * y) + c) / (2 * y + b - d);\\r\\n            if (y.within1(yPrev)) {\\r\\n                return y;\\r\\n            }\\r\\n        }\\r\\n        revert(\\\"Approximation did not converge\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Externally calculates a swap between two tokens.\\r\\n     * @param self Swap struct to read from\\r\\n     * @param tokenIndexFrom the token to sell\\r\\n     * @param tokenIndexTo the token to buy\\r\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\r\\n     * use the amount that gets transferred after the fee.\\r\\n     * @return dy the number of tokens the user will get\\r\\n     */\\r\\n    function calculateSwap(\\r\\n        Swap storage self,\\r\\n        uint8 tokenIndexFrom,\\r\\n        uint8 tokenIndexTo,\\r\\n        uint256 dx\\r\\n    ) external view returns (uint256 dy) {\\r\\n        (dy, ) = _calculateSwap(\\r\\n            self,\\r\\n            tokenIndexFrom,\\r\\n            tokenIndexTo,\\r\\n            dx,\\r\\n            self.balances\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internally calculates a swap between two tokens.\\r\\n     *\\r\\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\\r\\n     * using the token contracts.\\r\\n     *\\r\\n     * @param self Swap struct to read from\\r\\n     * @param tokenIndexFrom the token to sell\\r\\n     * @param tokenIndexTo the token to buy\\r\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\r\\n     * use the amount that gets transferred after the fee.\\r\\n     * @return dy the number of tokens the user will get\\r\\n     * @return dyFee the associated fee\\r\\n     */\\r\\n    function _calculateSwap(\\r\\n        Swap storage self,\\r\\n        uint8 tokenIndexFrom,\\r\\n        uint8 tokenIndexTo,\\r\\n        uint256 dx,\\r\\n        uint256[] memory balances\\r\\n    ) internal view returns (uint256 dy, uint256 dyFee) {\\r\\n        require(\\r\\n            tokenIndexFrom < balances.length && tokenIndexTo < balances.length,\\r\\n            \\\"Token index out of range\\\"\\r\\n        );\\r\\n        uint256 x = _pricedIn(\\r\\n            self,\\r\\n            dx + balances[tokenIndexFrom],\\r\\n            tokenIndexFrom\\r\\n        );\\r\\n\\r\\n        uint256[] memory pricedBalances = _pricedInBatch(self, balances);\\r\\n\\r\\n        uint256 y = _pricedOut(\\r\\n            self,\\r\\n            getY(\\r\\n                _getAPrecise(self),\\r\\n                tokenIndexFrom,\\r\\n                tokenIndexTo,\\r\\n                x,\\r\\n                pricedBalances\\r\\n            ),\\r\\n            tokenIndexTo // => not id, index !!!\\r\\n        );\\r\\n        dy = balances[tokenIndexTo] - y - 1;\\r\\n        dyFee = (dy * self.swapFee) / (PERCENTAGE_DENOMINATOR);\\r\\n        dy = dy - dyFee;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Uses _calculateRemoveLiquidity with Effective Balances,\\r\\n     * then projects the prices to the token amounts\\r\\n     * to get Real Balances, before removing them from pool.\\r\\n     */\\r\\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        return\\r\\n            _pricedOutBatch(\\r\\n                self,\\r\\n                _calculateRemoveLiquidity(\\r\\n                    _pricedInBatch(self, self.balances),\\r\\n                    amount,\\r\\n                    self.lpToken.totalSupply()\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A simple method to calculate amount of each underlying\\r\\n     * tokens that is returned upon burning given amount of\\r\\n     * LP tokens\\r\\n     *\\r\\n     * @param amount the amount of LP tokens that would to be burned on\\r\\n     * withdrawal\\r\\n     * @return array of amounts of tokens user will receive\\r\\n     */\\r\\n    function _calculateRemoveLiquidity(\\r\\n        uint256[] memory balances,\\r\\n        uint256 amount,\\r\\n        uint256 totalSupply\\r\\n    ) internal pure returns (uint256[] memory) {\\r\\n        require(amount <= totalSupply, \\\"Cannot exceed total supply\\\");\\r\\n\\r\\n        uint256[] memory amounts = new uint256[](2);\\r\\n\\r\\n        amounts[0] = (balances[0] * amount) / totalSupply;\\r\\n        amounts[1] = (balances[1] * amount) / totalSupply;\\r\\n\\r\\n        return amounts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A simple method to calculate prices from deposits or\\r\\n     * withdrawals, excluding fees but including slippage. This is\\r\\n     * helpful as an input into the various \\\"min\\\" parameters on calls\\r\\n     * to fight front-running\\r\\n     *\\r\\n     * @dev This shouldn't be used outside frontends for user estimates.\\r\\n     *\\r\\n     * @param self Swap struct to read from\\r\\n     * @param amounts an array of token amounts to deposit or withdrawal,\\r\\n     * corresponding to pooledTokens. The amount should be in each\\r\\n     * pooled token's native precision. If a token charges a fee on transfers,\\r\\n     * use the amount that gets transferred after the fee.\\r\\n     * @param deposit whether this is a deposit or a withdrawal\\r\\n     * @return if deposit was true, total amount of lp token that will be minted and if\\r\\n     * deposit was false, total amount of lp token that will be burned\\r\\n     */\\r\\n    function calculateTokenAmount(\\r\\n        Swap storage self,\\r\\n        uint256[] calldata amounts,\\r\\n        bool deposit\\r\\n    ) external view returns (uint256) {\\r\\n        uint256 a = _getAPrecise(self);\\r\\n        uint256[] memory balances = self.balances;\\r\\n\\r\\n        uint256 d0 = getD(_pricedInBatch(self, balances), a);\\r\\n        for (uint256 i = 0; i < balances.length; i++) {\\r\\n            if (deposit) {\\r\\n                balances[i] = balances[i] + amounts[i];\\r\\n            } else {\\r\\n                require(\\r\\n                    amounts[i] <= balances[i],\\r\\n                    \\\"Cannot withdraw more than available\\\"\\r\\n                );\\r\\n                balances[i] = balances[i] - amounts[i];\\r\\n            }\\r\\n        }\\r\\n        uint256 d1 = getD(_pricedInBatch(self, balances), a);\\r\\n        uint256 totalSupply = self.lpToken.totalSupply();\\r\\n\\r\\n        if (deposit) {\\r\\n            return ((d1 - d0) * totalSupply) / d0;\\r\\n        } else {\\r\\n            return ((d0 - d1) * totalSupply) / d0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice return accumulated amount of admin fees of the token with given index\\r\\n     * @param self Swap struct to read from\\r\\n     * @param index Index of the pooled token\\r\\n     * @return admin balance in the token's precision\\r\\n     */\\r\\n    function getAdminBalance(Swap storage self, uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(index < 2, \\\"Token index out of range\\\");\\r\\n        if (index == 0) return address(this).balance - (self.balances[index]);\\r\\n\\r\\n        if (index == 1)\\r\\n            return\\r\\n                self.gETH.balanceOf(address(this), self.pooledTokenId) -\\r\\n                (self.balances[index]);\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /*** STATE MODIFYING FUNCTIONS ***/\\r\\n\\r\\n    /**\\r\\n     * @notice swap two tokens in the pool\\r\\n     * @param self Swap struct to read from and write to\\r\\n     * @param tokenIndexFrom the token the user wants to sell\\r\\n     * @param tokenIndexTo the token the user wants to buy\\r\\n     * @param dx the amount of tokens the user wants to sell\\r\\n     * @param minDy the min amount the user would like to receive, or revert.\\r\\n     * @return amount of token user received on swap\\r\\n     */\\r\\n    function swap(\\r\\n        Swap storage self,\\r\\n        uint8 tokenIndexFrom,\\r\\n        uint8 tokenIndexTo,\\r\\n        uint256 dx,\\r\\n        uint256 minDy\\r\\n    ) external returns (uint256) {\\r\\n        IgETH gETHReference = self.gETH;\\r\\n        if (tokenIndexFrom == 0) {\\r\\n            // Means user is selling some ETH to the pool to get some gETH.\\r\\n            // In which case, we need to send exactly that amount of ETH.\\r\\n            require(dx == msg.value, \\\"Cannot swap more/less than you sent\\\");\\r\\n        }\\r\\n        if (tokenIndexFrom == 1) {\\r\\n            // Means user is selling some gETH to the pool to get some ETH.\\r\\n\\r\\n            require(\\r\\n                dx <= gETHReference.balanceOf(msg.sender, self.pooledTokenId),\\r\\n                \\\"Cannot swap more than you own\\\"\\r\\n            );\\r\\n\\r\\n            // Transfer tokens first\\r\\n            uint256 beforeBalance = gETHReference.balanceOf(\\r\\n                address(this),\\r\\n                self.pooledTokenId\\r\\n            );\\r\\n            gETHReference.safeTransferFrom(\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                self.pooledTokenId,\\r\\n                dx,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n\\r\\n            // Use the actual transferred amount for AMM math\\r\\n            dx =\\r\\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\\r\\n                beforeBalance;\\r\\n        }\\r\\n\\r\\n        uint256 dy;\\r\\n        uint256 dyFee;\\r\\n        // Meaning the real balances *without* any effect of underlying price\\r\\n        // However, when we call _calculateSwap, it uses pricedIn function before calculation,\\r\\n        // and pricedOut function after the calculation. So, we don't need to use priceOut here.\\r\\n        uint256[] memory balances = self.balances;\\r\\n        (dy, dyFee) = _calculateSwap(\\r\\n            self,\\r\\n            tokenIndexFrom,\\r\\n            tokenIndexTo,\\r\\n            dx,\\r\\n            balances\\r\\n        );\\r\\n\\r\\n        require(dy >= minDy, \\\"Swap didn't result in min tokens\\\");\\r\\n        uint256 dyAdminFee = (dyFee * self.adminFee) / PERCENTAGE_DENOMINATOR;\\r\\n\\r\\n        // To prevent any Reentrancy, balances are updated before transfering the tokens.\\r\\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\\r\\n        self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\\r\\n\\r\\n        if (tokenIndexTo == 0) {\\r\\n            // Means contract is going to send Idle Ether (ETH)\\r\\n            (bool sent, ) = payable(msg.sender).call{value: dy}(\\\"\\\");\\r\\n            require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\r\\n        }\\r\\n        if (tokenIndexTo == 1) {\\r\\n            // Means contract is going to send staked ETH (gETH)\\r\\n            gETHReference.safeTransferFrom(\\r\\n                address(this),\\r\\n                msg.sender,\\r\\n                self.pooledTokenId,\\r\\n                dy,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\r\\n\\r\\n        return dy;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add liquidity to the pool\\r\\n     * @param self Swap struct to read from and write to\\r\\n     * @param amounts the amounts of each token to add, in their native precision\\r\\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\\r\\n     * should mint, otherwise revert. Handy for front-running mitigation\\r\\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\\r\\n     * @return amount of LP token user received\\r\\n     */\\r\\n    function addLiquidity(\\r\\n        Swap storage self,\\r\\n        uint256[] memory amounts,\\r\\n        uint256 minToMint\\r\\n    ) external returns (uint256) {\\r\\n        require(amounts.length == 2, \\\"Amounts must match pooled tokens\\\");\\r\\n        require(\\r\\n            amounts[0] == msg.value,\\r\\n            \\\"SwapUtils: received less or more ETH than expected\\\"\\r\\n        );\\r\\n        IgETH gETHReference = self.gETH;\\r\\n        // current state\\r\\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\\r\\n            self.lpToken,\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            _getAPrecise(self),\\r\\n            0,\\r\\n            self.balances\\r\\n        );\\r\\n        v.totalSupply = v.lpToken.totalSupply();\\r\\n        if (v.totalSupply != 0) {\\r\\n            v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\\r\\n        }\\r\\n\\r\\n        uint256[] memory newBalances = new uint256[](2);\\r\\n        newBalances[0] = v.balances[0] + msg.value;\\r\\n\\r\\n        for (uint256 i = 0; i < 2; i++) {\\r\\n            require(\\r\\n                v.totalSupply != 0 || amounts[i] > 0,\\r\\n                \\\"Must supply all tokens in pool\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        {\\r\\n            // Transfer tokens first\\r\\n            uint256 beforeBalance = gETHReference.balanceOf(\\r\\n                address(this),\\r\\n                self.pooledTokenId\\r\\n            );\\r\\n            gETHReference.safeTransferFrom(\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                self.pooledTokenId,\\r\\n                amounts[1],\\r\\n                \\\"\\\"\\r\\n            );\\r\\n\\r\\n            // Update the amounts[] with actual transfer amount\\r\\n            amounts[1] =\\r\\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\\r\\n                beforeBalance;\\r\\n\\r\\n            newBalances[1] = v.balances[1] + amounts[1];\\r\\n        }\\r\\n\\r\\n        // invariant after change\\r\\n        v.d1 = getD(_pricedInBatch(self, newBalances), v.preciseA);\\r\\n        require(v.d1 > v.d0, \\\"D should increase\\\");\\r\\n\\r\\n        // updated to reflect fees and calculate the user's LP tokens\\r\\n        v.d2 = v.d1;\\r\\n        uint256[] memory fees = new uint256[](2);\\r\\n\\r\\n        if (v.totalSupply != 0) {\\r\\n            uint256 feePerToken = self.swapFee / 2;\\r\\n            for (uint256 i = 0; i < 2; i++) {\\r\\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\r\\n                fees[i] =\\r\\n                    (feePerToken * (idealBalance.difference(newBalances[i]))) /\\r\\n                    (PERCENTAGE_DENOMINATOR);\\r\\n                self.balances[i] =\\r\\n                    newBalances[i] -\\r\\n                    ((fees[i] * (self.adminFee)) / (PERCENTAGE_DENOMINATOR));\\r\\n                newBalances[i] = newBalances[i] - (fees[i]);\\r\\n            }\\r\\n            v.d2 = getD(_pricedInBatch(self, newBalances), v.preciseA);\\r\\n        } else {\\r\\n            // the initial depositor doesn't pay fees\\r\\n            self.balances = newBalances;\\r\\n        }\\r\\n\\r\\n        uint256 toMint;\\r\\n        if (v.totalSupply == 0) {\\r\\n            toMint = v.d1;\\r\\n        } else {\\r\\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\\r\\n        }\\r\\n\\r\\n        require(toMint >= minToMint, \\\"Couldn't mint min requested\\\");\\r\\n\\r\\n        // mint the user's LP tokens\\r\\n        v.lpToken.mint(msg.sender, toMint);\\r\\n\\r\\n        emit AddLiquidity(\\r\\n            msg.sender,\\r\\n            amounts,\\r\\n            fees,\\r\\n            v.d1,\\r\\n            v.totalSupply + toMint\\r\\n        );\\r\\n        return toMint;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn LP tokens to remove liquidity from the pool.\\r\\n     * @dev Liquidity can always be removed, even when the pool is paused.\\r\\n     * @param self Swap struct to read from and write to\\r\\n     * @param amount the amount of LP tokens to burn\\r\\n     * @param minAmounts the minimum amounts of each token in the pool\\r\\n     * acceptable for this burn. Useful as a front-running mitigation\\r\\n     * @return amounts of tokens the user received\\r\\n     */\\r\\n    function removeLiquidity(\\r\\n        Swap storage self,\\r\\n        uint256 amount,\\r\\n        uint256[] calldata minAmounts\\r\\n    ) external returns (uint256[] memory) {\\r\\n        ILPToken lpToken = self.lpToken;\\r\\n        IgETH gETHReference = self.gETH;\\r\\n        require(amount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\r\\n        require(minAmounts.length == 2, \\\"minAmounts must match poolTokens\\\");\\r\\n\\r\\n        uint256[] memory balances = self.balances;\\r\\n        uint256 totalSupply = lpToken.totalSupply();\\r\\n\\r\\n        uint256[] memory amounts = _pricedOutBatch(\\r\\n            self,\\r\\n            _calculateRemoveLiquidity(\\r\\n                _pricedInBatch(self, balances),\\r\\n                amount,\\r\\n                totalSupply\\r\\n            )\\r\\n        );\\r\\n\\r\\n        for (uint256 i = 0; i < amounts.length; i++) {\\r\\n            require(amounts[i] >= minAmounts[i], \\\"amounts[i] < minAmounts[i]\\\");\\r\\n            self.balances[i] = balances[i] - amounts[i];\\r\\n        }\\r\\n\\r\\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\r\\n        lpToken.burnFrom(msg.sender, amount);\\r\\n\\r\\n        (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\\\"\\\");\\r\\n        require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\r\\n\\r\\n        gETHReference.safeTransferFrom(\\r\\n            address(this),\\r\\n            msg.sender,\\r\\n            self.pooledTokenId,\\r\\n            amounts[1],\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\\r\\n        return amounts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Remove liquidity from the pool all in one token.\\r\\n     * @param self Swap struct to read from and write to\\r\\n     * @param tokenAmount the amount of the lp tokens to burn\\r\\n     * @param tokenIndex the index of the token you want to receive\\r\\n     * @param minAmount the minimum amount to withdraw, otherwise revert\\r\\n     * @return amount chosen token that user received\\r\\n     */\\r\\n    function removeLiquidityOneToken(\\r\\n        Swap storage self,\\r\\n        uint256 tokenAmount,\\r\\n        uint8 tokenIndex,\\r\\n        uint256 minAmount\\r\\n    ) external returns (uint256) {\\r\\n        ILPToken lpToken = self.lpToken;\\r\\n        IgETH gETHReference = self.gETH;\\r\\n\\r\\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\r\\n        require(tokenIndex < 2, \\\"Token not found\\\");\\r\\n\\r\\n        uint256 totalSupply = lpToken.totalSupply();\\r\\n\\r\\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\\r\\n            self,\\r\\n            tokenAmount,\\r\\n            tokenIndex,\\r\\n            totalSupply\\r\\n        );\\r\\n\\r\\n        require(dy >= minAmount, \\\"dy < minAmount\\\");\\r\\n\\r\\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\r\\n        self.balances[tokenIndex] =\\r\\n            self.balances[tokenIndex] -\\r\\n            (dy + ((dyFee * (self.adminFee)) / (PERCENTAGE_DENOMINATOR)));\\r\\n        lpToken.burnFrom(msg.sender, tokenAmount);\\r\\n\\r\\n        if (tokenIndex == 0) {\\r\\n            (bool sent, ) = payable(msg.sender).call{value: dy}(\\\"\\\");\\r\\n            require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\r\\n        }\\r\\n        if (tokenIndex == 1) {\\r\\n            gETHReference.safeTransferFrom(\\r\\n                address(this),\\r\\n                msg.sender,\\r\\n                self.pooledTokenId,\\r\\n                dy,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit RemoveLiquidityOne(\\r\\n            msg.sender,\\r\\n            tokenAmount,\\r\\n            totalSupply,\\r\\n            tokenIndex,\\r\\n            dy\\r\\n        );\\r\\n\\r\\n        return dy;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Remove liquidity from the pool, weighted differently than the\\r\\n     * pool's current balances.\\r\\n     *\\r\\n     * @param self Swap struct to read from and write to\\r\\n     * @param amounts how much of each token to withdraw\\r\\n     * @param maxBurnAmount the max LP token provider is willing to pay to\\r\\n     * remove liquidity. Useful as a front-running mitigation.\\r\\n     * @return actual amount of LP tokens burned in the withdrawal\\r\\n     */\\r\\n    function removeLiquidityImbalance(\\r\\n        Swap storage self,\\r\\n        uint256[] memory amounts,\\r\\n        uint256 maxBurnAmount\\r\\n    ) public returns (uint256) {\\r\\n        IgETH gETHReference = self.gETH;\\r\\n\\r\\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\\r\\n            self.lpToken,\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            _getAPrecise(self),\\r\\n            0,\\r\\n            self.balances\\r\\n        );\\r\\n        v.totalSupply = v.lpToken.totalSupply();\\r\\n\\r\\n        require(amounts.length == 2, \\\"Amounts should match pool tokens\\\");\\r\\n\\r\\n        require(\\r\\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\\r\\n                maxBurnAmount != 0,\\r\\n            \\\">LP.balanceOf\\\"\\r\\n        );\\r\\n\\r\\n        uint256 feePerToken = self.swapFee / 2;\\r\\n        uint256[] memory fees = new uint256[](2);\\r\\n\\r\\n        {\\r\\n            uint256[] memory balances1 = new uint256[](2);\\r\\n\\r\\n            v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\\r\\n            for (uint256 i = 0; i < 2; i++) {\\r\\n                require(\\r\\n                    amounts[i] <= v.balances[i],\\r\\n                    \\\"Cannot withdraw more than available\\\"\\r\\n                );\\r\\n                balances1[i] = v.balances[i] - amounts[i];\\r\\n            }\\r\\n            v.d1 = getD(_pricedInBatch(self, balances1), v.preciseA);\\r\\n\\r\\n            for (uint256 i = 0; i < 2; i++) {\\r\\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\r\\n                uint256 difference = idealBalance.difference(balances1[i]);\\r\\n                fees[i] = (feePerToken * difference) / PERCENTAGE_DENOMINATOR;\\r\\n                uint256 adminFee = self.adminFee;\\r\\n                {\\r\\n                    self.balances[i] =\\r\\n                        balances1[i] -\\r\\n                        ((fees[i] * adminFee) / PERCENTAGE_DENOMINATOR);\\r\\n                }\\r\\n                balances1[i] = balances1[i] - fees[i];\\r\\n            }\\r\\n\\r\\n            v.d2 = getD(_pricedInBatch(self, balances1), v.preciseA);\\r\\n        }\\r\\n\\r\\n        uint256 tokenAmount = ((v.d0 - v.d2) * (v.totalSupply)) / v.d0;\\r\\n        require(tokenAmount != 0, \\\"Burnt amount cannot be zero\\\");\\r\\n        tokenAmount = tokenAmount + 1;\\r\\n\\r\\n        require(tokenAmount <= maxBurnAmount, \\\"tokenAmount > maxBurnAmount\\\");\\r\\n\\r\\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\\r\\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\\r\\n\\r\\n        (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\\\"\\\");\\r\\n        require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\r\\n\\r\\n        gETHReference.safeTransferFrom(\\r\\n            address(this),\\r\\n            msg.sender,\\r\\n            self.pooledTokenId,\\r\\n            amounts[1],\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit RemoveLiquidityImbalance(\\r\\n            msg.sender,\\r\\n            amounts,\\r\\n            fees,\\r\\n            v.d1,\\r\\n            v.totalSupply - tokenAmount\\r\\n        );\\r\\n\\r\\n        return tokenAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice donate ETH and gETH to the pool as fee with respect to derivative price\\r\\n     * @param self Swap struct to deposit fees\\r\\n     * @param EthDonation amount of ETH to donate into the pool\\r\\n     * @param gEthDonation amount of gETH to donate into the pool\\r\\n     */\\r\\n    function donateBalancedFees(\\r\\n        Swap storage self,\\r\\n        uint256 EthDonation,\\r\\n        uint256 gEthDonation\\r\\n    ) external returns (uint256, uint256) {\\r\\n        {\\r\\n            IgETH gETHReference = self.gETH;\\r\\n            // Transfer tokens first\\r\\n            uint256 beforeBalance = gETHReference.balanceOf(\\r\\n                address(this),\\r\\n                self.pooledTokenId\\r\\n            );\\r\\n            gETHReference.safeTransferFrom(\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                self.pooledTokenId,\\r\\n                gEthDonation,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n\\r\\n            // Use the actual transferred amount\\r\\n            gEthDonation =\\r\\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\\r\\n                beforeBalance;\\r\\n        }\\r\\n        require(\\r\\n            _pricedIn(self, gEthDonation, 1) == EthDonation,\\r\\n            \\\"SwapUtils: MUST respect to derivative price\\\"\\r\\n        );\\r\\n        self.balances[0] +=\\r\\n            EthDonation -\\r\\n            (EthDonation * self.adminFee) /\\r\\n            PERCENTAGE_DENOMINATOR;\\r\\n        self.balances[1] +=\\r\\n            gEthDonation -\\r\\n            (gEthDonation * self.adminFee) /\\r\\n            PERCENTAGE_DENOMINATOR;\\r\\n        return (EthDonation, gEthDonation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw all admin fees to a given address\\r\\n     * @param self Swap struct to withdraw fees from\\r\\n     * @param to Address to send the fees to\\r\\n     */\\r\\n    function withdrawAdminFees(Swap storage self, address to) external {\\r\\n        IgETH gETHReference = self.gETH;\\r\\n        uint256 tokenBalance = gETHReference.balanceOf(\\r\\n            address(this),\\r\\n            self.pooledTokenId\\r\\n        ) - self.balances[1];\\r\\n        if (tokenBalance != 0) {\\r\\n            gETHReference.safeTransferFrom(\\r\\n                address(this),\\r\\n                to,\\r\\n                self.pooledTokenId,\\r\\n                tokenBalance,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 etherBalance = address(this).balance - self.balances[0];\\r\\n        if (etherBalance != 0) {\\r\\n            (bool sent, ) = payable(msg.sender).call{value: etherBalance}(\\\"\\\");\\r\\n            require(sent, \\\"SwapUtils: Failed to send Ether\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the admin fee\\r\\n     * @dev adminFee cannot be higher than 100% of the swap fee\\r\\n     * @param self Swap struct to update\\r\\n     * @param newAdminFee new admin fee to be applied on future transactions\\r\\n     */\\r\\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\\r\\n        require(newAdminFee <= MAX_ADMIN_FEE, \\\"Fee is too high\\\");\\r\\n        self.adminFee = newAdminFee;\\r\\n\\r\\n        emit NewAdminFee(newAdminFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice update the swap fee\\r\\n     * @dev fee cannot be higher than 1% of each swap\\r\\n     * @param self Swap struct to update\\r\\n     * @param newSwapFee new swap fee to be applied on future transactions\\r\\n     */\\r\\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\\r\\n        require(newSwapFee <= MAX_SWAP_FEE, \\\"Fee is too high\\\");\\r\\n        self.swapFee = newSwapFee;\\r\\n\\r\\n        emit NewSwapFee(newSwapFee);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x62501de74fa223ca4e9bc9b9f7fb4daafca4693d36d64386e7a74cbaf7bb77f3\",\"license\":\"MIT\"},\"contracts/interfaces/ILPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity =0.8.7;\\r\\n\\r\\ninterface ILPToken {\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    function burnFrom(address account, uint256 amount) external;\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function initialize(string memory name, string memory symbol)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function mint(address recipient, uint256 amount) external;\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function renounceOwnership() external;\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function transferOwnership(address newOwner) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x6b2b267ab9433da79265b376641d50d5ac1c6ed77bdb822b58f908fc0b70ed9d\",\"license\":\"MIT\"},\"contracts/interfaces/IgETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.7;\\r\\n\\r\\ninterface IgETH {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    function uri(uint256) external view returns (string memory);\\r\\n\\r\\n    function balanceOf(address account, uint256 id)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    function isApprovedForAll(address account, address operator)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        address account,\\r\\n        uint256 id,\\r\\n        uint256 value\\r\\n    ) external;\\r\\n\\r\\n    function burnBatch(\\r\\n        address account,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory values\\r\\n    ) external;\\r\\n\\r\\n    function totalSupply(uint256 id) external view returns (uint256);\\r\\n\\r\\n    function exists(uint256 id) external view returns (bool);\\r\\n\\r\\n    function mint(\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function mintBatch(\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function pause() external;\\r\\n\\r\\n    function unpause() external;\\r\\n\\r\\n    function denominator() external view returns (uint256);\\r\\n\\r\\n    function pricePerShare(uint256 id) external view returns (uint256);\\r\\n\\r\\n    function priceUpdateTimestamp(uint256 id) external view returns (uint256);\\r\\n\\r\\n    function setPricePerShare(uint256 price, uint256 id) external;\\r\\n\\r\\n    function isInterface(address _interface, uint256 id)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function setInterface(\\r\\n        address _interface,\\r\\n        uint256 id,\\r\\n        bool isSet\\r\\n    ) external;\\r\\n\\r\\n    function updateMinterRole(address Minter) external;\\r\\n\\r\\n    function updatePauserRole(address Pauser) external;\\r\\n\\r\\n    function updateOracleRole(address Oracle) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x233c5eef588ce7699ead6ef2eddd219104331f819ffab3ac5dcd9a5aa09667f7\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6105e961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c8063396984151461007157806358fdd79b1461008d578063b0a14cfc146100af578063c9b64dcb146100c2578063d011f918146100d5578063f14e211e146100dd575b600080fd5b61007b620f424081565b60405190815260200160405180910390f35b81801561009957600080fd5b506100ad6100a8366004610501565b6100fd565b005b61007b6100bd3660046104e8565b61034e565b61007b6100d03660046104e8565b61036b565b61007b606481565b8180156100e957600080fd5b506100ad6100f83660046104e8565b610376565b600583015461010f906201518061052d565b4210156101635760405162461bcd60e51b815260206004820152601f60248201527f57616974203120646179206265666f7265207374617274696e672072616d700060448201526064015b60405180910390fd5b610170621275004261052d565b8110156101b85760405162461bcd60e51b8152602060048201526016602482015275496e73756666696369656e742072616d702074696d6560501b604482015260640161015a565b6000821180156101ca5750620f424082105b6102165760405162461bcd60e51b815260206004820181905260248201527f667574757265415f206d757374206265203e203020616e64203c204d41585f41604482015260640161015a565b600061022184610437565b90506000610230606485610567565b9050818110156102915781610246600283610567565b101561028c5760405162461bcd60e51b8152602060048201526015602482015274199d5d1d5c995057c81a5cc81d1bdbc81cdb585b1b605a1b604482015260640161015a565b6102e3565b61029c600283610567565b8111156102e35760405162461bcd60e51b8152602060048201526015602482015274667574757265415f20697320746f6f206c6172676560581b604482015260640161015a565b600385018290556004850181905542600586018190556006860184905560408051848152602081018490528082019290925260608201859052517fa2b71ec6df949300b59aab36b55e189697b750119dd349fcfa8c0f779e83c2549181900360800190a15050505050565b6000606461035b83610437565b6103659190610545565b92915050565b600061036582610437565b428160060154116103c95760405162461bcd60e51b815260206004820152601760248201527f52616d7020697320616c72656164792073746f70706564000000000000000000604482015260640161015a565b60006103d482610437565b60038301819055600483018190554260058401819055600684018190556040519192507f46e22fb3709ad289f62ce63d469248536dbc78d82b84a3d7e74ad606dc2019389161042b91848252602082015260400190565b60405180910390a15050565b6006810154600482015460009190428211156104e15760058401546003850154808311156104a5576104698285610586565b6104738342610586565b61047d8386610586565b6104879190610567565b6104919190610545565b61049b908261052d565b9695505050505050565b6104af8285610586565b6104b98342610586565b6104c38584610586565b6104cd9190610567565b6104d79190610545565b61049b9082610586565b9392505050565b6000602082840312156104fa57600080fd5b5035919050565b60008060006060848603121561051657600080fd5b505081359360208301359350604090920135919050565b600082198211156105405761054061059d565b500190565b60008261056257634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156105815761058161059d565b500290565b6000828210156105985761059861059d565b500390565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220dd4075a0b5b8cc8e7951379b3d243d4f679b3e1185fa366c743c498c3dd4216064736f6c63430008070033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c8063396984151461007157806358fdd79b1461008d578063b0a14cfc146100af578063c9b64dcb146100c2578063d011f918146100d5578063f14e211e146100dd575b600080fd5b61007b620f424081565b60405190815260200160405180910390f35b81801561009957600080fd5b506100ad6100a8366004610501565b6100fd565b005b61007b6100bd3660046104e8565b61034e565b61007b6100d03660046104e8565b61036b565b61007b606481565b8180156100e957600080fd5b506100ad6100f83660046104e8565b610376565b600583015461010f906201518061052d565b4210156101635760405162461bcd60e51b815260206004820152601f60248201527f57616974203120646179206265666f7265207374617274696e672072616d700060448201526064015b60405180910390fd5b610170621275004261052d565b8110156101b85760405162461bcd60e51b8152602060048201526016602482015275496e73756666696369656e742072616d702074696d6560501b604482015260640161015a565b6000821180156101ca5750620f424082105b6102165760405162461bcd60e51b815260206004820181905260248201527f667574757265415f206d757374206265203e203020616e64203c204d41585f41604482015260640161015a565b600061022184610437565b90506000610230606485610567565b9050818110156102915781610246600283610567565b101561028c5760405162461bcd60e51b8152602060048201526015602482015274199d5d1d5c995057c81a5cc81d1bdbc81cdb585b1b605a1b604482015260640161015a565b6102e3565b61029c600283610567565b8111156102e35760405162461bcd60e51b8152602060048201526015602482015274667574757265415f20697320746f6f206c6172676560581b604482015260640161015a565b600385018290556004850181905542600586018190556006860184905560408051848152602081018490528082019290925260608201859052517fa2b71ec6df949300b59aab36b55e189697b750119dd349fcfa8c0f779e83c2549181900360800190a15050505050565b6000606461035b83610437565b6103659190610545565b92915050565b600061036582610437565b428160060154116103c95760405162461bcd60e51b815260206004820152601760248201527f52616d7020697320616c72656164792073746f70706564000000000000000000604482015260640161015a565b60006103d482610437565b60038301819055600483018190554260058401819055600684018190556040519192507f46e22fb3709ad289f62ce63d469248536dbc78d82b84a3d7e74ad606dc2019389161042b91848252602082015260400190565b60405180910390a15050565b6006810154600482015460009190428211156104e15760058401546003850154808311156104a5576104698285610586565b6104738342610586565b61047d8386610586565b6104879190610567565b6104919190610545565b61049b908261052d565b9695505050505050565b6104af8285610586565b6104b98342610586565b6104c38584610586565b6104cd9190610567565b6104d79190610545565b61049b9082610586565b9392505050565b6000602082840312156104fa57600080fd5b5035919050565b60008060006060848603121561051657600080fd5b505081359360208301359350604090920135919050565b600082198211156105405761054061059d565b500190565b60008261056257634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156105815761058161059d565b500290565b6000828210156105985761059861059d565b500390565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220dd4075a0b5b8cc8e7951379b3d243d4f679b3e1185fa366c743c498c3dd4216064736f6c63430008070033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getA(SwapUtils.Swap storage)": {
        "details": "See the StableSwap paper for details",
        "params": {
          "self": "Swap struct to read from"
        },
        "returns": {
          "_0": "A parameter"
        }
      },
      "getAPrecise(SwapUtils.Swap storage)": {
        "details": "See the StableSwap paper for details",
        "params": {
          "self": "Swap struct to read from"
        },
        "returns": {
          "_0": "A parameter in its raw precision form"
        }
      },
      "rampA(SwapUtils.Swap storage,uint256,uint256)": {
        "params": {
          "futureA_": "the new A to ramp towards",
          "futureTime_": "timestamp when the new A should be reached",
          "self": "Swap struct to update"
        }
      },
      "stopRampA(SwapUtils.Swap storage)": {
        "params": {
          "self": "Swap struct to update"
        }
      }
    },
    "title": "AmplificationUtils library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getA(SwapUtils.Swap storage)": {
        "notice": "Return A, the amplification coefficient * n * (n - 1)"
      },
      "getAPrecise(SwapUtils.Swap storage)": {
        "notice": "Return A in its raw precision"
      },
      "rampA(SwapUtils.Swap storage,uint256,uint256)": {
        "notice": "Start ramping up or down A parameter towards given futureA_ and futureTime_ Checks if the change is too rapid, and commits the new A value only when it falls under the limit range."
      },
      "stopRampA(SwapUtils.Swap storage)": {
        "notice": "Stops ramping A immediately. Once this function is called, rampA() cannot be called for another 24 hours"
      }
    },
    "notice": "A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct. This library assumes the struct is fully validated.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}