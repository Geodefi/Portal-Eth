{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\n// This interface is designed to be compatible with the Vyper version.\r\n/// @notice This is the Ethereum 2.0 deposit contract interface.\r\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\r\ninterface IDepositContract {\r\n    /// @notice A processed deposit event.\r\n    event DepositEvent(\r\n        bytes pubkey,\r\n        bytes withdrawal_credentials,\r\n        bytes amount,\r\n        bytes signature,\r\n        bytes index\r\n    );\r\n\r\n    /// @notice Submit a Phase 0 DepositData object.\r\n    /// @param pubkey A BLS12-381 public key.\r\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\r\n    /// @param signature A BLS12-381 signature.\r\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\r\n    /// Used as a protection against malformed input.\r\n    function deposit(\r\n        bytes calldata pubkey,\r\n        bytes calldata withdrawal_credentials,\r\n        bytes calldata signature,\r\n        bytes32 deposit_data_root\r\n    ) external payable;\r\n\r\n    /// @notice Query the current deposit root hash.\r\n    /// @return The deposit root hash.\r\n    function get_deposit_root() external view returns (bytes32);\r\n\r\n    /// @notice Query the current deposit count.\r\n    /// @return The deposit count encoded as a little endian 64-bit number.\r\n    function get_deposit_count() external view returns (bytes memory);\r\n}\r\n"
    },
    "contracts/Portal/utils/DepositContractUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"../../interfaces/IDepositContract.sol\";\r\nimport \"../helpers/BytesLib.sol\";\r\n\r\nlibrary DepositContractUtils {\r\n    IDepositContract internal constant DEPOSIT_CONTRACT =\r\n        IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);\r\n    uint256 internal constant PUBKEY_LENGTH = 48;\r\n    uint256 internal constant SIGNATURE_LENGTH = 96;\r\n    uint256 internal constant WITHDRAWAL_CREDENTIALS_LENGTH = 32;\r\n    uint256 internal constant DEPOSIT_AMOUNT = 32 ether;\r\n    uint256 internal constant DEPOSIT_AMOUNT_PRESTAKE = 1 ether;\r\n    uint256 internal constant MAX_DEPOSITS_PER_CALL = 64;\r\n\r\n    /**\r\n     * @dev Padding memory array with zeroes up to 64 bytes on the right\r\n     * @param _b Memory array of size 32 .. 64\r\n     */\r\n    function _pad64(bytes memory _b) internal pure returns (bytes memory) {\r\n        assert(_b.length >= 32 && _b.length <= 64);\r\n        if (64 == _b.length) return _b;\r\n\r\n        bytes memory zero32 = new bytes(32);\r\n        assembly {\r\n            mstore(add(zero32, 0x20), 0)\r\n        }\r\n\r\n        if (32 == _b.length) return BytesLib.concat(_b, zero32);\r\n        else\r\n            return\r\n                BytesLib.concat(\r\n                    _b,\r\n                    BytesLib.slice(zero32, 0, uint256(64 - _b.length))\r\n                );\r\n    }\r\n\r\n    /**\r\n     * @dev Converting value to little endian bytes and padding up to 32 bytes on the right\r\n     * @param _value Number less than `2**64` for compatibility reasons\r\n     */\r\n    function _toLittleEndian64(uint256 _value)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = 0;\r\n        uint256 temp_value = _value;\r\n        for (uint256 i = 0; i < 8; ++i) {\r\n            result = (result << 8) | (temp_value & 0xFF);\r\n            temp_value >>= 8;\r\n        }\r\n\r\n        assert(0 == temp_value); // fully converted\r\n        result <<= (24 * 8);\r\n    }\r\n\r\n    function _getDepositDataRoot(\r\n        bytes memory _pubkey,\r\n        bytes memory _withdrawalCredentials,\r\n        bytes memory _signature,\r\n        uint256 _stakeAmount\r\n    ) internal pure returns (bytes32) {\r\n        require(\r\n            _stakeAmount >= 1 ether,\r\n            \"DepositContract: deposit value too low\"\r\n        );\r\n        require(\r\n            _stakeAmount % 1 gwei == 0,\r\n            \"DepositContract: deposit value not multiple of gwei\"\r\n        );\r\n\r\n        uint256 deposit_amount = _stakeAmount / 1 gwei;\r\n        bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\r\n        bytes32 signatureRoot = sha256(\r\n            abi.encodePacked(\r\n                sha256(BytesLib.slice(_signature, 0, 64)),\r\n                sha256(\r\n                    _pad64(\r\n                        BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        bytes32 depositDataRoot = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\r\n                sha256(\r\n                    abi.encodePacked(\r\n                        _toLittleEndian64(deposit_amount),\r\n                        signatureRoot\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        return depositDataRoot;\r\n    }\r\n\r\n    function addressToWC(address wcAddress)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 w = 1 << 248;\r\n\r\n        return\r\n            abi.encodePacked(\r\n                bytes32(w) | bytes32(uint256(uint160(address(wcAddress))))\r\n            );\r\n    }\r\n\r\n    function depositValidator(\r\n        bytes calldata pubkey,\r\n        bytes memory withdrawalCredential,\r\n        bytes memory signature,\r\n        uint256 amount\r\n    ) internal {\r\n        DEPOSIT_CONTRACT.deposit{value: amount}(\r\n            pubkey,\r\n            withdrawalCredential,\r\n            signature,\r\n            _getDepositDataRoot(pubkey, withdrawalCredential, signature, amount)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity =0.8.7;\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes)\r\n        internal\r\n    {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes.slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(\r\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\r\n                2\r\n            )\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes.slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(\r\n                    add(tempBytes, lengthmod),\r\n                    mul(0x20, iszero(lengthmod))\r\n                )\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(\r\n                        add(\r\n                            add(_bytes, lengthmod),\r\n                            mul(0x20, iszero(lengthmod))\r\n                        ),\r\n                        _start\r\n                    )\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint8)\r\n    {\r\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint64)\r\n    {\r\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                    // the next line is the loop condition:\r\n                    // while(uint256(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes.slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(\r\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\r\n                2\r\n            )\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes.slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint256(mc < end) + cb == 2)\r\n                        for {\r\n\r\n                        } eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/utils/StakeUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"./DataStoreUtilsLib.sol\";\r\nimport {DepositContractUtils as DCU} from \"./DepositContractUtilsLib.sol\";\r\nimport \"./MaintainerUtilsLib.sol\";\r\nimport \"./OracleUtilsLib.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\nimport \"../../interfaces/IMiniGovernance.sol\";\r\nimport \"../../interfaces/ISwap.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title StakeUtils library\r\n * @notice Exclusively contains functions related to ETH Liquid Staking design\r\n * @notice biggest part of the functionality is related to Dynamic Staking Pools\r\n * which relies on continuous buybacks (DWP) to maintain the price health with debt/surplus calculations\r\n * @dev Contracts relying on this library must initialize StakeUtils.StakePool\r\n * @dev ALL \"fee\" variables are limited by PERCENTAGE_DENOMINATOR.\r\n * * For example, when fee is equal to PERCENTAGE_DENOMINATOR/2, it means 50% of the fee\r\n * Note refer to DataStoreUtils before reviewing\r\n * Note refer to MaintainerUtilsLib before reviewing\r\n * Note refer to OracleUtilsLib before reviewing\r\n * Note *suggested* refer to GeodeUtils before reviewing\r\n * Note beware of the staking pool and operator implementations:\r\n *\r\n * Type 4 stands for Operators:\r\n * They maintain Beacon Chain Validators on behalf of Planets and Comets\r\n * * only if they are allowed to\r\n * Operators have properties like fee(as a percentage), maintainer.\r\n *\r\n * Type 5 stands for Public Staking Pool (Planets):\r\n * * Every Planet is also an Operator by design.\r\n * * * Planets inherits Operator functionalities and parameters, with additional\r\n * * * properties related to miniGovernances and staking pools - surplus, secured, withdrawalPool etc.\r\n * * ID of a pool represents an id of gETH.\r\n * * For now, creation of staking pools are not permissionless but the usage of it is.\r\n * * * Meaning Everyone can stake and unstake using public pools.\r\n *\r\n * Type 6 stands for Private Staking Pools (Comets):\r\n * * It is permissionless, one can directly create a Comet by simply\r\n * * * choosing a name and sending MIN_AMOUNT which is expected to be 32 ether.\r\n * * GeodeUtils generates IDs based on types, meaning same name can be used for a Planet and a Comet simultaneously.\r\n * * The creation process is permissionless but staking is not.\r\n * * * Meaning Only Comet's maintainer can stake but everyone can hold the derivative\r\n * * In Comets, there is a Withdrawal Queue instead of DWP.\r\n * * NOT IMPLEMENTED YET\r\n *\r\n * Type 11 stands for a new Mini Governance implementation id:\r\n * * like always CONTROLLER is the implementation contract position\r\n * * requires the approval of Senate\r\n * * Pools are in \"Isolation Mode\" until their mini governance is upgraded to given proposal ID.\r\n * * * Meaning, no more Depositing or Staking can happen.\r\n */\r\n\r\nlibrary StakeUtils {\r\n    event ValidatorPeriodUpdated(uint256 operatorId, uint256 newPeriod);\r\n    event OperatorApproval(\r\n        uint256 planetId,\r\n        uint256 operatorId,\r\n        uint256 allowance\r\n    );\r\n    event PoolPaused(uint256 id);\r\n    event PoolUnpaused(uint256 id);\r\n    event ProposeStaked(bytes pubkey, uint256 planetId, uint256 operatorId);\r\n    event BeaconStaked(bytes pubkey);\r\n    event UnstakeSignal(uint256 poolId, bytes pubkey);\r\n    event ParamsUpdated(\r\n        address DEFAULT_gETH_INTERFACE_,\r\n        address DEFAULT_DWP_,\r\n        address DEFAULT_LP_TOKEN_,\r\n        uint256 MAX_MAINTAINER_FEE_,\r\n        uint256 BOOSTRAP_PERIOD_,\r\n        uint256 PERIOD_PRICE_INCREASE_LIMIT_,\r\n        uint256 PERIOD_PRICE_DECREASE_LIMIT_,\r\n        uint256 COMET_TAX_\r\n    );\r\n    event WithdrawalBoostChanged(\r\n        uint256 poolId,\r\n        uint256 withdrawalBoost,\r\n        uint256 effectiveAfter\r\n    );\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n    using MaintainerUtils for DataStoreUtils.DataStore;\r\n    using OracleUtils for OracleUtils.Oracle;\r\n\r\n    /**\r\n     * @notice StakePool includes the parameters related to multiple Staking Pool Contracts.\r\n     * @notice Dynamic Staking Pool contains a staking pool that works with a *bound* Withdrawal Pool (DWP) to create best pricing\r\n     * for the staking derivative. Withdrawal Pools (DWP) uses StableSwap algorithm with Dynamic Pegs.\r\n     * @param gETH ERC1155 contract that keeps the totalSupply, pricePerShare and balances of all StakingPools by ID\r\n     * @param DEFAULT_gETH_INTERFACE default interface for the g-derivative, currently equivalent to ERC20\r\n     * @param DEFAULT_DWP Dynamic Withdrawal Pool implementation, a STABLESWAP pool that will be used for given ID\r\n     * @param DEFAULT_LP_TOKEN LP token implementation that will be used for DWP of given ID\r\n     * @param MINI_GOVERNANCE_VERSION  limited to be changed with the senate approval.\r\n     * * versioning is done by GeodeUtils.proposal.id, implementation is stored in DataStore.id.controller\r\n     * @param MAX_MAINTAINER_FEE  limits fees, set by GOVERNANCE\r\n     * @param BOOSTRAP_PERIOD during this period the surplus of the pool can not be burned for withdrawals, initially set to 6 months\r\n     * @param BOOST_SWITCH_LATENCY when a maintainer changes the withdrawalBoost, it is effective after a delay\r\n     * @param COMET_TAX tax that will be taken from private pools, limited by MAX_MAINTAINER_FEE, set by GOVERNANCE\r\n     * @dev gETH should not be changed, ever!\r\n     * @dev changing some of these parameters (gETH, ORACLE) MUST require a contract upgrade to ensure security.\r\n     * We can change this in the future with a better GeodeUtils design, giving every update a type, like MINI_GOVERNANCE_VERSION\r\n     **/\r\n    struct StakePool {\r\n        IgETH gETH;\r\n        OracleUtils.Oracle TELESCOPE;\r\n        address GOVERNANCE;\r\n        address DEFAULT_gETH_INTERFACE;\r\n        address DEFAULT_DWP;\r\n        address DEFAULT_LP_TOKEN;\r\n        uint256 MINI_GOVERNANCE_VERSION;\r\n        uint256 MAX_MAINTAINER_FEE;\r\n        uint256 BOOSTRAP_PERIOD;\r\n        uint256 BOOST_SWITCH_LATENCY;\r\n        uint256 COMET_TAX;\r\n        uint256[5] __gap;\r\n    }\r\n\r\n    /// @notice PERCENTAGE_DENOMINATOR represents 100%\r\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10**10;\r\n\r\n    /// @notice limiting the operator.validatorPeriod, currently around 5 years\r\n    uint256 public constant MIN_VALIDATOR_PERIOD = 60 days;\r\n    uint256 public constant MAX_VALIDATOR_PERIOD = 1825 days;\r\n\r\n    /// @notice ignoring any buybacks if the DWP has a low debt\r\n    uint256 public constant IGNORABLE_DEBT = 1 ether;\r\n\r\n    // uint256 public constant BOOST_SWITCH_LATENCY = 3 days;\r\n\r\n    modifier onlyGovernance(StakePool storage self) {\r\n        require(\r\n            msg.sender == self.GOVERNANCE,\r\n            \"StakeUtils: sender NOT GOVERNANCE\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** gETH specific functions **\r\n     */\r\n\r\n    /**\r\n     * @notice sets a erc1155Interface for gETH\r\n     * @param _interface address of the new gETH ERC1155 interface for given ID\r\n     * @dev every interface has a unique index within \"interfaces\" dynamic array.\r\n     * * even if unsetted, it just replaces the implementation with address(0) for obvious security reasons\r\n     */\r\n    function setInterface(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        address _interface\r\n    ) public {\r\n        DATASTORE.authenticate(id, true, [false, true, true]);\r\n\r\n        uint256 interfacesLength = DATASTORE.readUintForId(\r\n            id,\r\n            \"interfacesLength\"\r\n        );\r\n        require(\r\n            !self.gETH.isInterface(_interface, id),\r\n            \"StakeUtils: already interface\"\r\n        );\r\n        DATASTORE.writeAddressForId(\r\n            id,\r\n            DataStoreUtils.getKey(interfacesLength, \"interfaces\"),\r\n            _interface\r\n        );\r\n        DATASTORE.addUintForId(id, \"interfacesLength\", 1);\r\n        self.gETH.setInterface(_interface, id, true);\r\n    }\r\n\r\n    /**\r\n     * @notice unsets a erc1155Interface for gETH with given index -acquired from allInterfaces()-\r\n     * @param index index of given interface at the \"interfaces\" dynamic array\r\n     * @dev every interface has a unique interface index within interfaces dynamic array.\r\n     * * even if unsetted, it just replaces the implementation with address(0) for obvious security reasons\r\n     * @dev old Interfaces will still be active if not unsetted\r\n     */\r\n    function unsetInterface(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 index\r\n    ) external {\r\n        DATASTORE.authenticate(id, true, [false, true, true]);\r\n\r\n        address _interface = DATASTORE.readAddressForId(\r\n            id,\r\n            DataStoreUtils.getKey(index, \"interfaces\")\r\n        );\r\n        require(\r\n            _interface != address(0) && self.gETH.isInterface(_interface, id),\r\n            \"StakeUtils: already NOT interface\"\r\n        );\r\n        DATASTORE.writeAddressForId(\r\n            id,\r\n            DataStoreUtils.getKey(index, \"interfaces\"),\r\n            address(0)\r\n        );\r\n        self.gETH.setInterface(_interface, id, false);\r\n    }\r\n\r\n    /**\r\n     * @notice lists all interfaces, unsetted interfaces will return address(0)\r\n     */\r\n    function allInterfaces(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (address[] memory) {\r\n        uint256 interfacesLength = DATASTORE.readUintForId(\r\n            id,\r\n            \"interfacesLength\"\r\n        );\r\n        address[] memory interfaces = new address[](interfacesLength);\r\n        for (uint256 i = 0; i < interfacesLength; i++) {\r\n            interfaces[i] = DATASTORE.readAddressForId(\r\n                id,\r\n                DataStoreUtils.getKey(i, \"interfaces\")\r\n            );\r\n        }\r\n        return interfaces;\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** Maintainer Initiators **\r\n     */\r\n    /**\r\n     * @notice initiates ID as an node operator\r\n     * @dev requires ID to be approved as a node operator with a specific CONTROLLER\r\n     * @param _validatorPeriod the expected maximum staking interval. This value should between\r\n     * * MIN_VALIDATOR_PERIOD and MAX_VALIDATOR_PERIOD values defined as constants above,\r\n     * * this check is done inside updateValidatorPeriod function.\r\n     * Operator can unstake at any given point before this period ends.\r\n     * If operator disobeys this rule, it can be prisoned with blameOperator()\r\n     */\r\n    function initiateOperator(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        uint256 _validatorPeriod\r\n    ) external {\r\n        require(\r\n            _fee <= self.MAX_MAINTAINER_FEE,\r\n            \"StakeUtils: MAX_MAINTAINER_FEE ERROR\"\r\n        );\r\n        DATASTORE.initiateOperator(_id, _fee, _maintainer);\r\n        updateValidatorPeriod(DATASTORE, _id, _validatorPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice initiates ID as a planet (public pool)\r\n     * @dev requires ID to be approved as a planet with a specific CONTROLLER\r\n     * @param _interfaceSpecs 0: interface name, 1: interface symbol, currently ERC20 specs.\r\n     */\r\n    function initiatePlanet(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        string[2] calldata _interfaceSpecs\r\n    ) external {\r\n        require(\r\n            _fee <= self.MAX_MAINTAINER_FEE,\r\n            \"StakeUtils: MAX_MAINTAINER_FEE ERROR\"\r\n        );\r\n\r\n        address[5] memory addressSpecs = [\r\n            address(self.gETH),\r\n            _maintainer,\r\n            self.DEFAULT_gETH_INTERFACE,\r\n            self.DEFAULT_DWP,\r\n            self.DEFAULT_LP_TOKEN\r\n        ];\r\n        uint256[3] memory uintSpecs = [_id, _fee, self.MINI_GOVERNANCE_VERSION];\r\n        (\r\n            address miniGovernance,\r\n            address gInterface,\r\n            address WithdrawalPool\r\n        ) = DATASTORE.initiatePlanet(uintSpecs, addressSpecs, _interfaceSpecs);\r\n\r\n        DATASTORE.writeBytesForId(\r\n            _id,\r\n            \"withdrawalCredential\",\r\n            DCU.addressToWC(miniGovernance)\r\n        );\r\n\r\n        setInterface(self, DATASTORE, _id, gInterface);\r\n\r\n        // initially 1 ETHER = 1 ETHER\r\n        self.gETH.setPricePerShare(1 ether, _id);\r\n\r\n        // transfer ownership of DWP to GOVERNANCE\r\n        Ownable(WithdrawalPool).transferOwnership(self.GOVERNANCE);\r\n        // approve token so we can use it in buybacks\r\n        self.gETH.setApprovalForAll(WithdrawalPool, true);\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** Governance specific functions **\r\n     */\r\n\r\n    /**\r\n     * @notice called when a proposal(TYPE=11) for a new MiniGovernance is approved by Senate\r\n     * @dev CONTROLLER of the proposal id represents the implementation address\r\n     * @dev This function seems like everyone can call, but it is called inside portal after approveProposal function\r\n     * * and approveProposal has onlySenate modifier, can be called only by senate.\r\n     */\r\n    function setMiniGovernanceVersion(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external {\r\n        require(DATASTORE.readUintForId(id, \"TYPE\") == 11);\r\n        self.MINI_GOVERNANCE_VERSION = id;\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** Maintainer specific functions **\r\n     */\r\n\r\n    /**\r\n     * @notice changes maintainer of the given operator (TYPE 4)\r\n     * @dev Seems like authenticate is not correct, but authenticate checks for maintainer\r\n     * and this function expects controller and DATASTORE.changeMaintainer checks that.\r\n     */\r\n    function changeOperatorMaintainer(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        address newMaintainer\r\n    ) external {\r\n        DATASTORE.authenticate(id, false, [true, false, false]);\r\n        DATASTORE.changeMaintainer(id, newMaintainer);\r\n    }\r\n\r\n    /**\r\n     * @notice changes pool maintainer  (TYPE 5-6) + conducts a Senate change on miniGovernance\r\n     * @dev requires the old Password and a new passwordHash, this saves the MiniGovernance contract\r\n     * from Double Horn Attack: when Both Senate and Governance is malicious.\r\n     * @dev currently this is enough to ensure the future implementations will improve the miniGovernance security,\r\n     * * we are also working on improving the Isolation Mode, which will allow Portal-less withdrawals for all pool types\r\n     * @dev Seems like authenticate is not correct, but authenticate checks for maintainer\r\n     * and this function expects controller and DATASTORE.changeMaintainer checks that.\r\n     */\r\n    function changePoolMaintainer(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        bytes calldata password,\r\n        bytes32 newPasswordHash,\r\n        address newMaintainer\r\n    ) external {\r\n        DATASTORE.authenticate(id, false, [false, true, true]);\r\n\r\n        bool success = miniGovernanceById(DATASTORE, id).changeMaintainer(\r\n            password,\r\n            newPasswordHash,\r\n            newMaintainer\r\n        );\r\n        require(success, \"StakeUtils: unsuccessful interaction\");\r\n        DATASTORE.changeMaintainer(id, newMaintainer);\r\n    }\r\n\r\n    /**\r\n     * @param newFee new fee percentage in terms of PERCENTAGE_DENOMINATOR, reverts if given more than MAX_MAINTAINER_FEE\r\n     * @dev there is a 7 days delay before the new fee is activated,\r\n     * * this protect the pool maintainers from making bad operator choices\r\n     */\r\n    function switchMaintainerFee(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 newFee\r\n    ) external {\r\n        DATASTORE.authenticate(id, true, [true, true, true]);\r\n        require(\r\n            newFee <= self.MAX_MAINTAINER_FEE,\r\n            \"StakeUtils: MAX_MAINTAINER_FEE ERROR\"\r\n        );\r\n        DATASTORE.switchMaintainerFee(id, newFee);\r\n    }\r\n\r\n    /**\r\n     * @dev only maintainer can increase the balance directly,\r\n     * * other than that it also collects validator rewards\r\n     */\r\n    function increaseMaintainerWallet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external returns (bool success) {\r\n        DATASTORE.authenticate(id, true, [true, true, false]);\r\n\r\n        return DATASTORE._increaseMaintainerWallet(id, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev only maintainer can decrease the balance directly,\r\n     * * other than that it can be used to propose Validators\r\n     * @dev if a maintainer is in prison, it can not decrease the wallet\r\n     */\r\n    function decreaseMaintainerWallet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 value\r\n    ) external returns (bool success) {\r\n        DATASTORE.authenticate(id, true, [true, true, true]);\r\n\r\n        require(\r\n            !OracleUtils.isPrisoned(DATASTORE, id),\r\n            \"StakeUtils: you are in prison, get in touch with governance\"\r\n        );\r\n\r\n        require(\r\n            address(this).balance >= value,\r\n            \"StakeUtils: not enough balance in Portal (?)\"\r\n        );\r\n\r\n        bool decreased = DATASTORE._decreaseMaintainerWallet(id, value);\r\n\r\n        (bool sent, ) = msg.sender.call{value: value}(\"\");\r\n        require(decreased && sent, \"StakeUtils: Failed to send ETH\");\r\n        return sent;\r\n    }\r\n\r\n    /**\r\n     * @notice                           ** Pool - Operator interactions **\r\n     */\r\n    /**\r\n     * @param withdrawalBoost the percentage of arbitrague that will be shared\r\n     * with Operator on Unstake. Can be used to incentivise Unstakes in case of depeg\r\n     * @dev to prevent malicious swings in the withdrawal boost that can harm the competition,\r\n     * Boost changes is also has a delay.\r\n     */\r\n    function switchWithdrawalBoost(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 withdrawalBoost\r\n    ) external {\r\n        DATASTORE.authenticate(poolId, true, [false, true, true]);\r\n        DATASTORE.writeUintForId(\r\n            poolId,\r\n            \"priorBoost\",\r\n            DATASTORE.readUintForId(poolId, \"withdrawalBoost\")\r\n        );\r\n        DATASTORE.writeUintForId(\r\n            poolId,\r\n            \"boostSwitch\",\r\n            block.timestamp + self.BOOST_SWITCH_LATENCY\r\n        );\r\n        DATASTORE.writeUintForId(poolId, \"withdrawalBoost\", withdrawalBoost);\r\n\r\n        emit WithdrawalBoostChanged(\r\n            poolId,\r\n            withdrawalBoost,\r\n            block.timestamp + self.BOOST_SWITCH_LATENCY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice returns the withdrawalBoost with a time delay\r\n     */\r\n    function getWithdrawalBoost(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) internal view returns (uint256 boost) {\r\n        if (DATASTORE.readUintForId(id, \"boostSwitch\") > block.timestamp) {\r\n            return DATASTORE.readUintForId(id, \"priorBoost\");\r\n        }\r\n        return DATASTORE.readUintForId(id, \"withdrawalBoost\");\r\n    }\r\n\r\n    /** *\r\n     * @notice operatorAllowence is the number of validators that the given Operator is allowed to create on behalf of the Planet\r\n     * @dev an operator can not create new validators if:\r\n     * * 1. allowence is 0 (zero)\r\n     * * 2. lower than the current (proposed + active) number of validators\r\n     * * But if operator withdraws a validator, then able to create a new one.\r\n     * @dev prestake checks the approved validator count to make sure the number of validators are not bigger than allowence\r\n     * @dev allowence doesn't change when new validators created or old ones are unstaked.\r\n     * @return allowance\r\n     */\r\n    function operatorAllowance(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 operatorId\r\n    ) public view returns (uint256 allowance) {\r\n        allowance = DATASTORE.readUintForId(\r\n            poolId,\r\n            DataStoreUtils.getKey(operatorId, \"allowance\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice To allow a Node Operator run validators for your Planet with Max number of validators.\r\n     * * This number can be set again at any given point in the future.\r\n     *\r\n     * @dev If planet decreases the approved validator count, below current running validator,\r\n     * operator can only withdraw until to new allowence.\r\n     * @dev only maintainer of _planetId can approve an Operator\r\n     * @param poolId the gETH id of the Planet, only Maintainer can call this function\r\n     * @param operatorId the id of the Operator to allow them create validators for a given Planet\r\n     * @param allowance the MAX number of validators that can be created by the Operator for a given Planet\r\n     */\r\n    function approveOperator(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        uint256 allowance\r\n    ) external returns (bool) {\r\n        DATASTORE.authenticate(poolId, true, [false, true, true]);\r\n        DATASTORE.authenticate(operatorId, false, [true, true, false]);\r\n\r\n        DATASTORE.writeUintForId(\r\n            poolId,\r\n            DataStoreUtils.getKey(operatorId, \"allowance\"),\r\n            allowance\r\n        );\r\n\r\n        emit OperatorApproval(poolId, operatorId, allowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice                ** Operator (TYPE 4 and 5) specific functions **\r\n     */\r\n\r\n    /**\r\n     * @notice updates validatorPeriod for given operator, limited by MAX_VALIDATOR_PERIOD\r\n     */\r\n    function updateValidatorPeriod(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 operatorId,\r\n        uint256 newPeriod\r\n    ) public {\r\n        DATASTORE.authenticate(operatorId, true, [true, true, false]);\r\n        require(\r\n            newPeriod <= MIN_VALIDATOR_PERIOD,\r\n            \"StekeUtils: should be more than MIN_VALIDATOR_PERIOD\"\r\n        );\r\n        require(\r\n            newPeriod <= MAX_VALIDATOR_PERIOD,\r\n            \"StekeUtils: should be less than MAX_VALIDATOR_PERIOD\"\r\n        );\r\n        DATASTORE.writeUintForId(operatorId, \"validatorPeriod\", newPeriod);\r\n        emit ValidatorPeriodUpdated(operatorId, newPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** STAKING POOL (TYPE 5 and 6)  specific functions **\r\n     */\r\n\r\n    /**\r\n     * @notice returns miniGovernance as a contract\r\n     */\r\n    function miniGovernanceById(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id\r\n    ) internal view returns (IMiniGovernance) {\r\n        return\r\n            IMiniGovernance(DATASTORE.readAddressForId(_id, \"miniGovernance\"));\r\n    }\r\n\r\n    /**\r\n     * @notice returns withdrawalPool as a contract\r\n     */\r\n    function withdrawalPoolById(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id\r\n    ) internal view returns (ISwap) {\r\n        return ISwap(DATASTORE.readAddressForId(_id, \"withdrawalPool\"));\r\n    }\r\n\r\n    /**\r\n     * @dev pausing requires pool to be NOT paused already\r\n     */\r\n    function pauseStakingForPool(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external {\r\n        DATASTORE.authenticate(id, true, [false, true, true]);\r\n\r\n        require(\r\n            DATASTORE.readUintForId(id, \"stakePaused\") == 0,\r\n            \"StakeUtils: staking already paused\"\r\n        );\r\n\r\n        DATASTORE.writeUintForId(id, \"stakePaused\", 1); // meaning true\r\n        emit PoolPaused(id);\r\n    }\r\n\r\n    /**\r\n     * @dev unpausing requires pool to be paused already\r\n     */\r\n    function unpauseStakingForPool(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external {\r\n        DATASTORE.authenticate(id, true, [false, true, true]);\r\n\r\n        require(\r\n            DATASTORE.readUintForId(id, \"stakePaused\") == 1,\r\n            \"StakeUtils: staking already NOT paused\"\r\n        );\r\n\r\n        DATASTORE.writeUintForId(id, \"stakePaused\", 0); // meaning false\r\n        emit PoolUnpaused(id);\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** DEPOSIT(user) functions **\r\n     */\r\n\r\n    /**\r\n     * @notice checks if staking is allowed in a pool.\r\n     * * when a pool is paused for staking NO new funds can be minted.\r\n     * @notice staking is not allowed if:\r\n     * 1. MiniGovernance is in Isolation Mode, this means it is not upgraded to current version\r\n     * 2. Staking is simply paused by the Pool maintainer\r\n     * @dev minting is paused when stakePaused == 1, meaning true.\r\n     */\r\n    function canDeposit(DataStoreUtils.DataStore storage DATASTORE, uint256 _id)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            DATASTORE.readUintForId(_id, \"stakePaused\") == 0 &&\r\n            !(miniGovernanceById(DATASTORE, _id).isolationMode());\r\n    }\r\n\r\n    /**\r\n     * @notice conducts a buyback using the given withdrawal pool,\r\n     * @param to address to send bought gETH(id). burns the tokens if to=address(0), transfers if not\r\n     * @param poolId id of the gETH that will be bought\r\n     * @param sellEth ETH amount to sell\r\n     * @param minToBuy TX is expected to revert by Swap.sol if not meet\r\n     * @param deadline TX is expected to revert by Swap.sol if not meet\r\n     * @dev this function assumes that pool is deployed by deployWithdrawalPool\r\n     * as index 0 is eth and index 1 is Geth\r\n     */\r\n    function _buyback(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        address to,\r\n        uint256 poolId,\r\n        uint256 sellEth,\r\n        uint256 minToBuy,\r\n        uint256 deadline\r\n    ) internal returns (uint256 outAmount) {\r\n        // SWAP in WP\r\n        outAmount = withdrawalPoolById(DATASTORE, poolId).swap{value: sellEth}(\r\n            0,\r\n            1,\r\n            sellEth,\r\n            minToBuy,\r\n            deadline\r\n        );\r\n        if (to == address(0)) {\r\n            // burn\r\n            self.gETH.burn(address(this), poolId, outAmount);\r\n        } else {\r\n            // send back to user\r\n            self.gETH.safeTransferFrom(\r\n                address(this),\r\n                to,\r\n                poolId,\r\n                outAmount,\r\n                \"\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allowing users to deposit into a public staking pool.\r\n     * * Buys from DWP if price is low -debt-, mints new tokens if surplus is sent -more than debt-\r\n     * @param planetId id of the staking pool, withdrawal pool and gETH to be used.\r\n     * @param mingETH withdrawal pool parameter\r\n     * @param deadline withdrawal pool parameter\r\n     * // debt  msg.value\r\n     * // 100   10  => buyback\r\n     * // 100   100 => buyback\r\n     * // 10    100 => buyback + mint\r\n     * // 1     x   => mint\r\n     * // 0.5   x   => mint\r\n     * // 0     x   => mint\r\n     */\r\n    function depositPlanet(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 planetId,\r\n        uint256 mingETH,\r\n        uint256 deadline\r\n    ) external returns (uint256 totalgETH) {\r\n        DATASTORE.authenticate(planetId, false, [false, true, false]);\r\n\r\n        require(msg.value > 1e15, \"StakeUtils: at least 0.001 eth \");\r\n        require(deadline > block.timestamp, \"StakeUtils: deadline not met\");\r\n        require(canDeposit(DATASTORE, planetId), \"StakeUtils: minting paused\");\r\n        uint256 debt = withdrawalPoolById(DATASTORE, planetId).getDebt();\r\n        if (debt >= msg.value) {\r\n            return\r\n                _buyback(\r\n                    self,\r\n                    DATASTORE,\r\n                    msg.sender,\r\n                    planetId,\r\n                    msg.value,\r\n                    mingETH,\r\n                    deadline\r\n                );\r\n        } else {\r\n            uint256 boughtgETH = 0;\r\n            uint256 remEth = msg.value;\r\n            if (debt > IGNORABLE_DEBT) {\r\n                boughtgETH = _buyback(\r\n                    self,\r\n                    DATASTORE,\r\n                    msg.sender,\r\n                    planetId,\r\n                    debt,\r\n                    0,\r\n                    deadline\r\n                );\r\n                remEth -= debt;\r\n            }\r\n            uint256 mintedgETH = (\r\n                ((remEth * self.gETH.denominator()) /\r\n                    self.gETH.pricePerShare(planetId))\r\n            );\r\n            self.gETH.mint(msg.sender, planetId, mintedgETH, \"\");\r\n            DATASTORE.addUintForId(planetId, \"surplus\", remEth);\r\n\r\n            require(\r\n                boughtgETH + mintedgETH >= mingETH,\r\n                \"StakeUtils: less than mingETH\"\r\n            );\r\n            if (self.TELESCOPE._isOracleActive()) {\r\n                bytes32 dailyBufferKey = DataStoreUtils.getKey(\r\n                    block.timestamp -\r\n                        (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n                    \"mintBuffer\"\r\n                );\r\n                DATASTORE.addUintForId(planetId, dailyBufferKey, mintedgETH);\r\n            }\r\n            return boughtgETH + mintedgETH;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** WITHDRAWAL(user) functions **\r\n     */\r\n\r\n    /**\r\n     * @notice figuring out how much of gETH and ETH should be donated in case of _burnSurplus\r\n     * @dev Refering to improvement proposal, fees are donated to DWP when surplus\r\n     * is being used as a withdrawal source. This is necessary to:\r\n     * 1. create a financial cost for boostrap period\r\n     */\r\n    function _donateBalancedFees(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 burnSurplus,\r\n        uint256 burnGeth\r\n    ) internal returns (uint256 EthDonation, uint256 gEthDonation) {\r\n        // find half of the fees to burn from surplus\r\n        uint256 fee = withdrawalPoolById(DATASTORE, poolId).getSwapFee();\r\n        EthDonation = (burnSurplus * fee) / PERCENTAGE_DENOMINATOR / 2;\r\n\r\n        // find the remaining half as gETH with respect to PPS\r\n        gEthDonation = (burnGeth * fee) / PERCENTAGE_DENOMINATOR / 2;\r\n\r\n        //send both fees to DWP\r\n        withdrawalPoolById(DATASTORE, poolId).donateBalancedFees{\r\n            value: EthDonation\r\n        }(EthDonation, gEthDonation);\r\n    }\r\n\r\n    /**\r\n     * @dev Refering to improvement proposal, it is now allowed to use surplus to\r\n     * * withdraw from public pools (after boostrap period).\r\n     * * This means, \"surplus\" becomes a parameter of, freshly named, Dynamic Staking Pools\r\n     * * which is the combination of DWP+public staking pools. Now, (assumed) there wont be\r\n     * * surplus and debt at the same time.\r\n     * @dev burnBuffer should be increased if the ORACLE is active, otherwise we can not\r\n     * verify the legitacy of Telescope price calculations\r\n     */\r\n    function _burnSurplus(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 gEthToWithdraw\r\n    ) internal returns (uint256, uint256) {\r\n        uint256 pps = self.gETH.pricePerShare(poolId);\r\n\r\n        uint256 spentGeth = gEthToWithdraw;\r\n        uint256 spentSurplus = ((spentGeth * pps) / self.gETH.denominator());\r\n        uint256 surplus = DATASTORE.readUintForId(poolId, \"surplus\");\r\n        if (spentSurplus >= surplus) {\r\n            spentSurplus = surplus;\r\n            spentGeth = ((spentSurplus * self.gETH.denominator()) / pps);\r\n        }\r\n\r\n        (uint256 EthDonation, uint256 gEthDonation) = _donateBalancedFees(\r\n            DATASTORE,\r\n            poolId,\r\n            spentSurplus,\r\n            spentGeth\r\n        );\r\n\r\n        DATASTORE.subUintForId(poolId, \"surplus\", spentSurplus);\r\n        self.gETH.burn(address(this), poolId, spentGeth - gEthDonation);\r\n\r\n        if (self.TELESCOPE._isOracleActive()) {\r\n            bytes32 dailyBufferKey = DataStoreUtils.getKey(\r\n                block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n                \"burnBuffer\"\r\n            );\r\n            DATASTORE.addUintForId(poolId, dailyBufferKey, spentGeth);\r\n        }\r\n\r\n        return (spentSurplus - (EthDonation * 2), gEthToWithdraw - spentGeth);\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw funds from Dynamic Staking Pool (Public Staking Pool + DWP)\r\n     * * If not in Boostrap Period, first checks the surplus, than swaps from DWP to create debt\r\n     * @param gEthToWithdraw amount of g-derivative that should be withdrawn\r\n     * @param minETH TX is expected to revert by Swap.sol if not meet\r\n     * @param deadline TX is expected to revert by Swap.sol if not meet\r\n     */\r\n    function withdrawPlanet(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 gEthToWithdraw,\r\n        uint256 minETH,\r\n        uint256 deadline\r\n    ) external returns (uint256 EthToSend) {\r\n        DATASTORE.authenticate(poolId, false, [false, true, false]);\r\n\r\n        require(deadline > block.timestamp, \"StakeUtils: deadline not met\");\r\n        {\r\n            // transfer token first\r\n            uint256 beforeBalance = self.gETH.balanceOf(address(this), poolId);\r\n\r\n            self.gETH.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                poolId,\r\n                gEthToWithdraw,\r\n                \"\"\r\n            );\r\n            // Use the transferred amount\r\n            gEthToWithdraw =\r\n                self.gETH.balanceOf(address(this), poolId) -\r\n                beforeBalance;\r\n        }\r\n\r\n        if (\r\n            block.timestamp >\r\n            DATASTORE.readUintForId(poolId, \"initiated\") + self.BOOSTRAP_PERIOD\r\n        ) {\r\n            (EthToSend, gEthToWithdraw) = _burnSurplus(\r\n                self,\r\n                DATASTORE,\r\n                poolId,\r\n                gEthToWithdraw\r\n            );\r\n        }\r\n\r\n        if (gEthToWithdraw > 0) {\r\n            EthToSend += withdrawalPoolById(DATASTORE, poolId).swap(\r\n                1,\r\n                0,\r\n                gEthToWithdraw,\r\n                EthToSend >= minETH ? 0 : minETH - EthToSend,\r\n                deadline\r\n            );\r\n        }\r\n        (bool sent, ) = payable(msg.sender).call{value: EthToSend}(\"\");\r\n        require(sent, \"StakeUtils: Failed to send Ether\");\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** STAKE(operator) functions **\r\n     */\r\n\r\n    /**\r\n     * @notice internal function that checks if validator is allowed\r\n     * by Telescope and also not in isolationMode\r\n     */\r\n    function _canStake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata pubkey,\r\n        uint256 verificationIndex\r\n    ) internal view returns (bool) {\r\n        return\r\n            self.TELESCOPE._canStake(pubkey, verificationIndex) &&\r\n            !(\r\n                miniGovernanceById(\r\n                    DATASTORE,\r\n                    self.TELESCOPE._validators[pubkey].poolId\r\n                ).isolationMode()\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice external function to check if a validator can use planet funds\r\n     */\r\n    function canStake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata pubkey\r\n    ) external view returns (bool) {\r\n        return\r\n            _canStake(\r\n                self,\r\n                DATASTORE,\r\n                pubkey,\r\n                self.TELESCOPE.VERIFICATION_INDEX\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Validator Credentials Proposal function, first step of crating validators.\r\n     * * Once a pubKey is proposed and not alienated for some time,\r\n     * * it is optimistically allowed to take funds from staking pools.\r\n     *\r\n     * @param poolId the id of the staking pool whose TYPE can be 5 or 6.\r\n     * @param operatorId the id of the Operator whose maintainer calling this function\r\n     * @param pubkeys  Array of BLS12-381 public keys of the validators that will be proposed\r\n     * @param signatures Array of BLS12-381 signatures of the validators that will be proposed\r\n     *\r\n     * @dev DEPOSIT_AMOUNT_PRESTAKE = 1 ether, which is the minimum number to create validator.\r\n     * 31 Ether will be staked after verification of oracles. 32 in total.\r\n     * 1 ether will be sent back to Node Operator when finalized deposit is successful.\r\n     * @dev ProposeStake requires enough allowance from Staking Pools to Operators.\r\n     * @dev ProposeStake requires enough funds within maintainerWallet.\r\n     * @dev Max number of validators to propose is MAX_DEPOSITS_PER_CALL (currently 64)\r\n     */\r\n    function proposeStake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        bytes[] calldata signatures\r\n    ) external {\r\n        DATASTORE.authenticate(operatorId, true, [true, true, false]);\r\n        DATASTORE.authenticate(poolId, false, [false, true, true]);\r\n        require(\r\n            !OracleUtils.isPrisoned(DATASTORE, operatorId),\r\n            \"StakeUtils: operator is in prison, get in touch with governance\"\r\n        );\r\n\r\n        require(\r\n            pubkeys.length == signatures.length,\r\n            \"StakeUtils: pubkeys and signatures NOT same length\"\r\n        );\r\n        require(\r\n            pubkeys.length > 0 && pubkeys.length <= DCU.MAX_DEPOSITS_PER_CALL,\r\n            \"StakeUtils: MAX 64 nodes\"\r\n        );\r\n        require(\r\n            (DATASTORE.readUintForId(operatorId, \"totalActiveValidators\") +\r\n                pubkeys.length) <= self.TELESCOPE.MONOPOLY_THRESHOLD,\r\n            \"StakeUtils: IceBear does NOT like monopolies\"\r\n        );\r\n        require(\r\n            (DATASTORE.readUintForId(\r\n                poolId,\r\n                DataStoreUtils.getKey(operatorId, \"proposedValidators\")\r\n            ) +\r\n                DATASTORE.readUintForId(\r\n                    poolId,\r\n                    DataStoreUtils.getKey(operatorId, \"activeValidators\")\r\n                ) +\r\n                pubkeys.length) <=\r\n                operatorAllowance(DATASTORE, poolId, operatorId),\r\n            \"StakeUtils: NOT enough allowance\"\r\n        );\r\n\r\n        require(\r\n            DATASTORE.readUintForId(poolId, \"surplus\") >=\r\n                DCU.DEPOSIT_AMOUNT * pubkeys.length,\r\n            \"StakeUtils: NOT enough surplus\"\r\n        );\r\n\r\n        DATASTORE._decreaseMaintainerWallet(\r\n            operatorId,\r\n            pubkeys.length * DCU.DEPOSIT_AMOUNT_PRESTAKE\r\n        );\r\n\r\n        DATASTORE.subUintForId(\r\n            poolId,\r\n            \"surplus\",\r\n            (DCU.DEPOSIT_AMOUNT * pubkeys.length)\r\n        );\r\n\r\n        {\r\n            uint256[2] memory fees = [\r\n                DATASTORE.getMaintainerFee(poolId),\r\n                DATASTORE.getMaintainerFee(operatorId)\r\n            ];\r\n            bytes memory withdrawalCredential = DATASTORE.readBytesForId(\r\n                poolId,\r\n                \"withdrawalCredential\"\r\n            );\r\n            uint256 expectedExit = block.timestamp +\r\n                DATASTORE.readUintForId(operatorId, \"validatorPeriod\");\r\n            uint256 nextValidatorsIndex = self.TELESCOPE.VALIDATORS_INDEX + 1;\r\n            for (uint256 i; i < pubkeys.length; i++) {\r\n                require(\r\n                    self.TELESCOPE._validators[pubkeys[i]].state == 0,\r\n                    \"StakeUtils: Pubkey already used or alienated\"\r\n                );\r\n                require(\r\n                    pubkeys[i].length == DCU.PUBKEY_LENGTH,\r\n                    \"StakeUtils: PUBKEY_LENGTH ERROR\"\r\n                );\r\n                require(\r\n                    signatures[i].length == DCU.SIGNATURE_LENGTH,\r\n                    \"StakeUtils: SIGNATURE_LENGTH ERROR\"\r\n                );\r\n\r\n                DCU.depositValidator(\r\n                    pubkeys[i],\r\n                    withdrawalCredential,\r\n                    signatures[i],\r\n                    DCU.DEPOSIT_AMOUNT_PRESTAKE\r\n                );\r\n\r\n                self.TELESCOPE._validators[pubkeys[i]] = OracleUtils.Validator(\r\n                    1,\r\n                    nextValidatorsIndex + i,\r\n                    poolId,\r\n                    operatorId,\r\n                    fees[0],\r\n                    fees[1],\r\n                    block.timestamp,\r\n                    expectedExit,\r\n                    signatures[i]\r\n                );\r\n                emit ProposeStaked(pubkeys[i], poolId, operatorId);\r\n            }\r\n        }\r\n\r\n        DATASTORE.addUintForId(\r\n            poolId,\r\n            DataStoreUtils.getKey(operatorId, \"proposedValidators\"),\r\n            pubkeys.length\r\n        );\r\n        DATASTORE.addUintForId(\r\n            poolId,\r\n            \"secured\",\r\n            (DCU.DEPOSIT_AMOUNT * pubkeys.length)\r\n        );\r\n\r\n        self.TELESCOPE.VALIDATORS_INDEX += pubkeys.length;\r\n    }\r\n\r\n    /**\r\n     *  @notice Sends 31 Eth from staking pool to validators that are previously created with ProposeStake.\r\n     *  1 Eth per successful validator boostraping is returned back to MaintainerWallet.\r\n     *\r\n     *  @param operatorId the id of the Operator whose maintainer calling this function\r\n     *  @param pubkeys  Array of BLS12-381 public keys of the validators that are already proposed with ProposeStake.\r\n     *\r\n     *  @dev To save gas cost, pubkeys should be arranged by planedIds.\r\n     *  ex: [pk1, pk2, pk3, pk4, pk5, pk6, pk7]\r\n     *  pk1, pk2, pk3 from planet1\r\n     *  pk4, pk5 from planet2\r\n     *  pk6 from planet3\r\n     *  seperate them in similar groups as much as possible.\r\n     *  @dev Max number of validators to boostrap is MAX_DEPOSITS_PER_CALL (currently 64)\r\n     *  @dev A pubkey that is alienated will not get through. Do not frontrun during ProposeStake.\r\n     */\r\n    function beaconStake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys\r\n    ) external {\r\n        DATASTORE.authenticate(operatorId, true, [true, true, false]);\r\n\r\n        require(\r\n            !self.TELESCOPE._isOracleActive(),\r\n            \"StakeUtils: ORACLE is active\"\r\n        );\r\n        require(\r\n            pubkeys.length > 0 && pubkeys.length <= DCU.MAX_DEPOSITS_PER_CALL,\r\n            \"StakeUtils: MAX 64 nodes\"\r\n        );\r\n        {\r\n            uint256 verificationIndex = self.TELESCOPE.VERIFICATION_INDEX;\r\n            for (uint256 j; j < pubkeys.length; j++) {\r\n                require(\r\n                    _canStake(self, DATASTORE, pubkeys[j], verificationIndex),\r\n                    \"StakeUtils: NOT all pubkeys are stakeable\"\r\n                );\r\n            }\r\n        }\r\n        {\r\n            bytes32 activeValKey = DataStoreUtils.getKey(\r\n                operatorId,\r\n                \"activeValidators\"\r\n            );\r\n            bytes32 proposedValKey = DataStoreUtils.getKey(\r\n                operatorId,\r\n                \"proposedValidators\"\r\n            );\r\n\r\n            uint256 planetId = self.TELESCOPE._validators[pubkeys[0]].poolId;\r\n            bytes memory withdrawalCredential = DATASTORE.readBytesForId(\r\n                planetId,\r\n                \"withdrawalCredential\"\r\n            );\r\n\r\n            uint256 lastPlanetChange;\r\n            for (uint256 i; i < pubkeys.length; i++) {\r\n                if (planetId != self.TELESCOPE._validators[pubkeys[i]].poolId) {\r\n                    DATASTORE.subUintForId(\r\n                        planetId,\r\n                        \"secured\",\r\n                        (DCU.DEPOSIT_AMOUNT * (i - lastPlanetChange))\r\n                    );\r\n                    DATASTORE.addUintForId(\r\n                        planetId,\r\n                        activeValKey,\r\n                        (i - lastPlanetChange)\r\n                    );\r\n                    DATASTORE.subUintForId(\r\n                        planetId,\r\n                        proposedValKey,\r\n                        (i - lastPlanetChange)\r\n                    );\r\n                    lastPlanetChange = i;\r\n                    planetId = self.TELESCOPE._validators[pubkeys[i]].poolId;\r\n                    withdrawalCredential = DATASTORE.readBytesForId(\r\n                        planetId,\r\n                        \"withdrawalCredential\"\r\n                    );\r\n                }\r\n\r\n                bytes memory signature = self\r\n                    .TELESCOPE\r\n                    ._validators[pubkeys[i]]\r\n                    .signature;\r\n                DCU.depositValidator(\r\n                    pubkeys[i],\r\n                    withdrawalCredential,\r\n                    signature,\r\n                    DCU.DEPOSIT_AMOUNT - DCU.DEPOSIT_AMOUNT_PRESTAKE\r\n                );\r\n\r\n                self.TELESCOPE._validators[pubkeys[i]].state = 2;\r\n                emit BeaconStaked(pubkeys[i]);\r\n            }\r\n\r\n            DATASTORE.subUintForId(\r\n                planetId,\r\n                \"secured\",\r\n                DCU.DEPOSIT_AMOUNT * (pubkeys.length - lastPlanetChange)\r\n            );\r\n            DATASTORE.addUintForId(\r\n                planetId,\r\n                activeValKey,\r\n                (pubkeys.length - lastPlanetChange)\r\n            );\r\n            DATASTORE.subUintForId(\r\n                planetId,\r\n                proposedValKey,\r\n                (pubkeys.length - lastPlanetChange)\r\n            );\r\n            DATASTORE.addUintForId(\r\n                operatorId,\r\n                \"totalActiveValidators\",\r\n                pubkeys.length\r\n            );\r\n        }\r\n        DATASTORE._increaseMaintainerWallet(\r\n            operatorId,\r\n            DCU.DEPOSIT_AMOUNT_PRESTAKE * pubkeys.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** UNSTAKE(operator) functions **\r\n     */\r\n\r\n    /**\r\n     * @notice allows improsening an Operator if the validator have not been exited until expectedExit\r\n     * @dev anyone can call this function\r\n     * @dev if operator has given enough allowence, they can rotate the validators to avoid being prisoned\r\n     */\r\n    function blameOperator(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata pk\r\n    ) external {\r\n        if (\r\n            block.timestamp > self.TELESCOPE._validators[pk].expectedExit &&\r\n            self.TELESCOPE._validators[pk].state != 3\r\n        ) {\r\n            OracleUtils.imprison(\r\n                DATASTORE,\r\n                self.TELESCOPE._validators[pk].operatorId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice allows giving a unstake signal, meaning validator has been exited.\r\n     * * And boost can be claimed upon arrival of the funds.\r\n     * @dev to maintain the health of Geode Universe, we should protect the race conditions.\r\n     * * opeators should know when others are unstaking so they don't spend money for no boost.\r\n     */\r\n    function signalUnstake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes[] calldata pubkeys\r\n    ) external {\r\n        uint256 expectedOperator = self\r\n            .TELESCOPE\r\n            ._validators[pubkeys[0]]\r\n            .operatorId;\r\n\r\n        DATASTORE.authenticate(expectedOperator, true, [true, true, false]);\r\n\r\n        for (uint256 i = 0; i < pubkeys.length; i++) {\r\n            require(self.TELESCOPE._validators[pubkeys[i]].state == 2);\r\n            require(\r\n                self.TELESCOPE._validators[pubkeys[i]].operatorId ==\r\n                    expectedOperator\r\n            );\r\n\r\n            self.TELESCOPE._validators[pubkeys[i]].state = 3;\r\n\r\n            emit UnstakeSignal(\r\n                self.TELESCOPE._validators[pubkeys[i]].poolId,\r\n                pubkeys[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Operator finalizing an Unstake event by calling Telescope's multisig:\r\n     * * distributing fees + boost\r\n     * * distributes rewards by burning the derivative\r\n     * * does a buyback if necessary\r\n     * * putting the extra within surplus.\r\n     * @param isExit according to eip-4895, there can be multiple ways to distriute the rewards\r\n     * * and not all of them requires exit. Even in such cases reward can be catched from\r\n     * * withdrawal credential and distributed.\r\n     *\r\n     * @dev although OnlyOracle, logically this has nothing to do with Telescope.\r\n     * * So we are keeping it here.\r\n     * * @dev operator is prisoned if:\r\n     * 1. withdrawn without signalled, being sneaky. in such case they also doesn't receive the boost\r\n     * 2. signalled without withdrawal, deceiving other operators\r\n     */\r\n    function fetchUnstake(\r\n        StakePool storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        uint256[] calldata balances,\r\n        bool[] calldata isExit\r\n    ) external {\r\n        require(\r\n            msg.sender == self.TELESCOPE.ORACLE_POSITION,\r\n            \"StakeUtils: sender NOT ORACLE\"\r\n        );\r\n        require(\r\n            !self.TELESCOPE._isOracleActive(),\r\n            \"StakeUtils: ORACLE is active\"\r\n        );\r\n\r\n        uint256 cumBal;\r\n        uint256[2] memory fees;\r\n        {\r\n            uint256 exitCount;\r\n\r\n            for (uint256 i = 0; i < pubkeys.length; i++) {\r\n                uint256 balance = balances[i];\r\n                cumBal += balances[i];\r\n\r\n                if (isExit[i]) {\r\n                    exitCount += 1;\r\n                    if (balance > DCU.DEPOSIT_AMOUNT) {\r\n                        balance -= DCU.DEPOSIT_AMOUNT;\r\n                    } else {\r\n                        balance = 0;\r\n                    }\r\n                }\r\n\r\n                if (balance > 0) {\r\n                    fees[0] += ((balance *\r\n                        self.TELESCOPE._validators[pubkeys[i]].poolFee) /\r\n                        PERCENTAGE_DENOMINATOR);\r\n\r\n                    if (poolId != operatorId) {\r\n                        fees[1] += ((balance *\r\n                            self\r\n                                .TELESCOPE\r\n                                ._validators[pubkeys[i]]\r\n                                .operatorFee) / PERCENTAGE_DENOMINATOR);\r\n                    }\r\n                }\r\n            }\r\n\r\n            {\r\n                bool success = miniGovernanceById(DATASTORE, poolId)\r\n                    .claimUnstake(cumBal);\r\n                require(success, \"StakeUtils: Failed to claim\");\r\n            }\r\n\r\n            // decrease the sum of isExit activeValidators and totalValidators\r\n            DATASTORE.subUintForId(\r\n                poolId,\r\n                DataStoreUtils.getKey(operatorId, \"activeValidators\"),\r\n                exitCount\r\n            );\r\n            DATASTORE.subUintForId(\r\n                operatorId,\r\n                \"totalActiveValidators\",\r\n                exitCount\r\n            );\r\n\r\n            cumBal = cumBal - (fees[0] + fees[1]);\r\n        }\r\n\r\n        uint256 debt = withdrawalPoolById(DATASTORE, poolId).getDebt();\r\n        if (debt > IGNORABLE_DEBT) {\r\n            {\r\n                uint256 boost = getWithdrawalBoost(DATASTORE, poolId);\r\n                if (boost > 0 && poolId != operatorId) {\r\n                    uint256 arb = withdrawalPoolById(DATASTORE, poolId)\r\n                        .calculateSwap(0, 1, cumBal);\r\n                    arb -=\r\n                        (cumBal * self.gETH.denominator()) /\r\n                        self.gETH.pricePerShare(poolId);\r\n                    boost = (arb * boost) / PERCENTAGE_DENOMINATOR;\r\n\r\n                    fees[1] += boost;\r\n                    cumBal -= boost;\r\n                }\r\n            }\r\n\r\n            if (debt > cumBal) {\r\n                debt = cumBal;\r\n            }\r\n            _buyback(\r\n                self,\r\n                DATASTORE,\r\n                address(0), // burn\r\n                poolId,\r\n                debt,\r\n                0,\r\n                type(uint256).max\r\n            );\r\n            cumBal -= debt;\r\n        }\r\n\r\n        if (cumBal > 0) {\r\n            DATASTORE.addUintForId(poolId, \"surplus\", cumBal);\r\n        }\r\n\r\n        DATASTORE._increaseMaintainerWallet(poolId, fees[0]);\r\n        DATASTORE._increaseMaintainerWallet(operatorId, fees[1]);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/utils/DataStoreUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title Storage Management Library for dynamic structs, based on data types and ids\r\n *\r\n * DataStoreUtils is a storage management tool designed to create a safe and scalable\r\n * storage layout with the help of ids and keys.\r\n * Mainly focusing on upgradable contracts with multiple user types to create a\r\n * sustainable development environment.\r\n *\r\n * In summary, extra gas cost that would be saved with Storage packing are\r\n * ignored to create upgradable structs*.\r\n *\r\n * IDs are the representation of a user with any given key as properties.\r\n * Type for ID is not mandatory, not all IDs should have an explicit type.\r\n * Thus there is no checks of types or keys.\r\n *\r\n * @notice distinct id and key pairs return different storage slots\r\n *\r\n */\r\nlibrary DataStoreUtils {\r\n    /**\r\n     * @notice Main Struct for reading and writing data to storage for given (id, key) pairs\r\n     * @param allIdsByType optional categorization for given ID, requires direct access, type => id[]\r\n     * @param uintData keccak(id, key) =>  returns uint256\r\n     * @param bytesData keccak(id, key) => returns bytes\r\n     * @param addressData keccak(id, key) =>  returns address\r\n     * @dev any other storage type can be expressed as bytes\r\n     */\r\n    struct DataStore {\r\n        mapping(uint256 => uint256[]) allIdsByType;\r\n        mapping(bytes32 => uint256) uintData;\r\n        mapping(bytes32 => bytes) bytesData;\r\n        mapping(bytes32 => address) addressData;\r\n        uint256[12] __gap;\r\n    }\r\n\r\n    /**\r\n     *                              ** HELPER **\r\n     **/\r\n\r\n    /**\r\n     * @notice hashes given id with parameter to be used as key in getters and setters\r\n     * @return key bytes32 hash of id and parameter to be stored\r\n     **/\r\n    function getKey(uint256 _id, bytes32 _param)\r\n        internal\r\n        pure\r\n        returns (bytes32 key)\r\n    {\r\n        key = keccak256(abi.encodePacked(_id, _param));\r\n    }\r\n\r\n    /**\r\n     *                              **DATA GETTERS **\r\n     **/\r\n\r\n    function readUintForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key\r\n    ) internal view returns (uint256 data) {\r\n        data = self.uintData[getKey(_id, _key)];\r\n    }\r\n\r\n    function readBytesForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key\r\n    ) internal view returns (bytes memory data) {\r\n        data = self.bytesData[getKey(_id, _key)];\r\n    }\r\n\r\n    function readAddressForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key\r\n    ) internal view returns (address data) {\r\n        data = self.addressData[getKey(_id, _key)];\r\n    }\r\n\r\n    /**\r\n     *                              **DATA SETTERS **\r\n     **/\r\n    function writeUintForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 _data\r\n    ) internal {\r\n        self.uintData[getKey(_id, _key)] = _data;\r\n    }\r\n\r\n    function addUintForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 _addend\r\n    ) internal {\r\n        self.uintData[getKey(_id, _key)] += _addend;\r\n    }\r\n\r\n    function subUintForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 _minuend\r\n    ) internal {\r\n        self.uintData[getKey(_id, _key)] -= _minuend;\r\n    }\r\n\r\n    function writeBytesForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        bytes memory _data\r\n    ) internal {\r\n        self.bytesData[getKey(_id, _key)] = _data;\r\n    }\r\n\r\n    function writeAddressForId(\r\n        DataStore storage self,\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        address _data\r\n    ) internal {\r\n        self.addressData[getKey(_id, _key)] = _data;\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/utils/MaintainerUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./DataStoreUtilsLib.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\nimport \"../../interfaces/IMiniGovernance.sol\";\r\nimport {IERC20InterfacePermitUpgradable as IgETHInterface} from \"../../interfaces/IERC20InterfacePermitUpgradable.sol\";\r\nimport \"../../interfaces/ISwap.sol\";\r\nimport \"../../interfaces/ILPToken.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title MaintainerUtils library to be used with a DataStore\r\n * @notice for Geode, there are different TYPEs active within Staking operations.\r\n * These types(4,5,6) always has a maintainer.\r\n * The staking logic is shaped around the control of maintainers over pools.\r\n *\r\n * @dev ALL \"fee\" variables are limited by PERCENTAGE_DENOMINATOR = 100%\r\n * Note refer to DataStoreUtils before reviewing\r\n */\r\nlibrary MaintainerUtils {\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n\r\n    event IdInitiated(uint256 id, uint256 TYPE);\r\n    event MaintainerChanged(uint256 id, address newMaintainer);\r\n    event MaintainerFeeSwitched(\r\n        uint256 id,\r\n        uint256 fee,\r\n        uint256 effectiveTimestamp // the timestamp when the fee will start to be used after switch\r\n    );\r\n\r\n    /// @notice PERCENTAGE_DENOMINATOR represents 100%\r\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10**10;\r\n\r\n    /// @notice when a maintainer changes the fee, it is effective after a delay\r\n    uint256 public constant FEE_SWITCH_LATENCY = 3 days;\r\n\r\n    /// @notice default DWP parameters\r\n    uint256 public constant DEFAULT_A = 60;\r\n    uint256 public constant DEFAULT_FEE = (4 * PERCENTAGE_DENOMINATOR) / 10000;\r\n    uint256 public constant DEFAULT_ADMIN_FEE =\r\n        (5 * PERCENTAGE_DENOMINATOR) / 10;\r\n\r\n    modifier initiator(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _TYPE,\r\n        uint256 _id,\r\n        address _maintainer\r\n    ) {\r\n        require(\r\n            msg.sender == DATASTORE.readAddressForId(_id, \"CONTROLLER\"),\r\n            \"MaintainerUtils: sender NOT CONTROLLER\"\r\n        );\r\n        require(\r\n            DATASTORE.readUintForId(_id, \"TYPE\") == _TYPE,\r\n            \"MaintainerUtils: id NOT correct TYPE\"\r\n        );\r\n        require(\r\n            DATASTORE.readUintForId(_id, \"initiated\") == 0,\r\n            \"MaintainerUtils: already initiated\"\r\n        );\r\n\r\n        DATASTORE.writeAddressForId(_id, \"maintainer\", _maintainer);\r\n\r\n        _;\r\n\r\n        DATASTORE.writeUintForId(_id, \"initiated\", block.timestamp);\r\n\r\n        emit IdInitiated(_id, _TYPE);\r\n    }\r\n\r\n    /**\r\n     * @notice restricts the access to given function based on TYPE\r\n     * @notice also allows onlyMaintainer check whenever required\r\n     * @param expectMaintainer restricts the access to only maintainer\r\n     * @param restrictionMap 0: Operator = TYPE(4), Planet = TYPE(5), Comet = TYPE(6),\r\n     */\r\n    function authenticate(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        bool expectMaintainer,\r\n        bool[3] memory restrictionMap\r\n    ) internal view {\r\n        if (expectMaintainer) {\r\n            require(\r\n                msg.sender == DATASTORE.readAddressForId(id, \"maintainer\"),\r\n                \"MaintainerUtils: sender NOT maintainer\"\r\n            );\r\n        }\r\n        uint256 typeOfId = DATASTORE.readUintForId(id, \"TYPE\");\r\n        if (typeOfId == 4) {\r\n            require(\r\n                restrictionMap[0] == true,\r\n                \"MaintainerUtils: TYPE NOT allowed\"\r\n            );\r\n        } else if (typeOfId == 5) {\r\n            require(\r\n                restrictionMap[1] == true,\r\n                \"MaintainerUtils: TYPE NOT allowed\"\r\n            );\r\n        } else if (typeOfId == 6) {\r\n            require(\r\n                restrictionMap[2] == true,\r\n                \"MaintainerUtils: TYPE NOT allowed\"\r\n            );\r\n        } else revert(\"MaintainerUtils: invalid TYPE\");\r\n    }\r\n\r\n    /**\r\n     * @notice                      ** Initiate ID functions **\r\n     */\r\n\r\n    /**\r\n     * @notice initiates ID as a node operator\r\n     * @dev requires ID to be approved as a node operator with a specific CONTROLLER\r\n     */\r\n    function initiateOperator(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 fee,\r\n        address maintainer\r\n    ) external initiator(DATASTORE, 4, id, maintainer) {\r\n        DATASTORE.writeUintForId(id, \"fee\", fee);\r\n    }\r\n\r\n    /**\r\n     * @notice initiates ID as a planet (public pool): deploys a miniGovernance, a Dynamic Withdrawal Pool, an ERC1155Interface\r\n     * @dev requires ID to be approved as a planet with a specific CONTROLLER\r\n     * @param uintSpecs 0:_id, 1:_fee, 2:_MINI_GOVERNANCE_VERSION\r\n     * @param addressSpecs 0:gETH, 1:_maintainer, 2:DEFAULT_gETH_INTERFACE_, 3:DEFAULT_DWP, 4:DEFAULT_LP_TOKEN\r\n     * @param interfaceSpecs 0: interface name, 1: interface symbol\r\n     */\r\n    function initiatePlanet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256[3] memory uintSpecs,\r\n        address[5] memory addressSpecs,\r\n        string[2] calldata interfaceSpecs\r\n    )\r\n        external\r\n        initiator(DATASTORE, 5, uintSpecs[0], addressSpecs[1])\r\n        returns (\r\n            address miniGovernance,\r\n            address gInterface,\r\n            address withdrawalPool\r\n        )\r\n    {\r\n        DATASTORE.writeUintForId(uintSpecs[0], \"fee\", uintSpecs[1]);\r\n        {\r\n            miniGovernance = _deployMiniGovernance(\r\n                DATASTORE,\r\n                addressSpecs[0],\r\n                uintSpecs[0],\r\n                uintSpecs[2],\r\n                addressSpecs[1]\r\n            );\r\n        }\r\n        {\r\n            gInterface = Clones.clone(addressSpecs[2]);\r\n            IgETHInterface(gInterface).initialize(\r\n                uintSpecs[0],\r\n                interfaceSpecs[0],\r\n                interfaceSpecs[1],\r\n                addressSpecs[0]\r\n            );\r\n        }\r\n        {\r\n            withdrawalPool = _deployWithdrawalPool(\r\n                DATASTORE,\r\n                uintSpecs[0],\r\n                addressSpecs[0],\r\n                addressSpecs[3],\r\n                addressSpecs[4]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice initiates ID as a comet (private pool)\r\n     * @dev requires ID to be approved as comet with a specific CONTROLLER,\r\n     * NOTE CONTROLLER check will be surpassed with portal.\r\n     */\r\n    function initiateComet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 fee,\r\n        address maintainer\r\n    ) external initiator(DATASTORE, 6, id, maintainer) {\r\n        DATASTORE.writeUintForId(id, \"fee\", fee);\r\n    }\r\n\r\n    /**\r\n     * @notice deploys a mini governance contract that will be used as a withdrawal credential\r\n     * using an approved MINI_GOVERNANCE_VERSION\r\n     * @return miniGovernance address which is deployed\r\n     */\r\n    function _deployMiniGovernance(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        address _gETH,\r\n        uint256 _id,\r\n        uint256 _versionId,\r\n        address _maintainer\r\n    ) internal returns (address miniGovernance) {\r\n        ERC1967Proxy newGovernance = new ERC1967Proxy(\r\n            DATASTORE.readAddressForId(_versionId, \"CONTROLLER\"),\r\n            abi.encodeWithSelector(\r\n                IMiniGovernance(address(0)).initialize.selector,\r\n                _gETH,\r\n                address(this),\r\n                _maintainer,\r\n                _id,\r\n                _versionId\r\n            )\r\n        );\r\n        DATASTORE.writeAddressForId(\r\n            _id,\r\n            \"miniGovernance\",\r\n            address(newGovernance)\r\n        );\r\n        miniGovernance = address(newGovernance);\r\n    }\r\n\r\n    /**\r\n     * @notice deploys a new withdrawal pool using DEFAULT_DWP\r\n     * @dev sets the withdrawal pool and LP token for id\r\n     * @return withdrawalPool address which is deployed\r\n     */\r\n    function _deployWithdrawalPool(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id,\r\n        address _gETH,\r\n        address _DEFAULT_DWP,\r\n        address _DEFAULT_LP_TOKEN\r\n    ) internal returns (address withdrawalPool) {\r\n        withdrawalPool = Clones.clone(_DEFAULT_DWP);\r\n        bytes memory NAME = DATASTORE.readBytesForId(_id, \"NAME\");\r\n        address WPToken = ISwap(withdrawalPool).initialize(\r\n            IgETH(_gETH),\r\n            _id,\r\n            string(abi.encodePacked(NAME, \"-Geode LP Token\")),\r\n            string(abi.encodePacked(NAME, \"-LP\")),\r\n            DEFAULT_A,\r\n            DEFAULT_FEE,\r\n            DEFAULT_ADMIN_FEE,\r\n            _DEFAULT_LP_TOKEN\r\n        );\r\n        DATASTORE.writeAddressForId(_id, \"withdrawalPool\", withdrawalPool);\r\n        DATASTORE.writeAddressForId(_id, \"LPToken\", WPToken);\r\n    }\r\n\r\n    /**\r\n     * @notice \"Maintainer\" is a shared logic (like \"NAME\") by both operators and private or public pools.\r\n     * Maintainers have permissiones to maintain the given id like setting a new fee or interface as\r\n     * well as creating validators etc. for operators.\r\n     * @dev every ID has one maintainer that is set by CONTROLLER\r\n     */\r\n    function getMaintainerFromId(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (address maintainer) {\r\n        maintainer = DATASTORE.readAddressForId(id, \"maintainer\");\r\n    }\r\n\r\n    /**\r\n     * @notice CONTROLLER of the ID can change the maintainer to any address other than ZERO_ADDRESS\r\n     * @dev it is wise to change the CONTROLLER before the maintainer, in case of any migration\r\n     * @dev handle with care\r\n     * NOTE intended (suggested) usage is to set a contract address that will govern the id for maintainer,\r\n     * while keeping the controller as a multisig or provide smt like 0x000000000000000000000000000000000000dEaD\r\n     */\r\n    function changeMaintainer(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        address newMaintainer\r\n    ) external {\r\n        require(\r\n            msg.sender == DATASTORE.readAddressForId(id, \"CONTROLLER\"),\r\n            \"MaintainerUtils: sender NOT CONTROLLER\"\r\n        );\r\n        require(\r\n            newMaintainer != address(0),\r\n            \"MaintainerUtils: maintainer can NOT be zero\"\r\n        );\r\n\r\n        DATASTORE.writeAddressForId(id, \"maintainer\", newMaintainer);\r\n        emit MaintainerChanged(id, newMaintainer);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets fee percentage in terms of PERCENTAGE_DENOMINATOR.\r\n     * @dev even if MAX_MAINTAINER_FEE is decreased later, it returns limited maximum.\r\n     * @param id planet, comet or operator ID\r\n     * @return fee = percentage * PERCENTAGE_DENOMINATOR / 100 as a perfcentage\r\n     */\r\n    function getMaintainerFee(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) internal view returns (uint256 fee) {\r\n        if (DATASTORE.readUintForId(id, \"feeSwitch\") > block.timestamp) {\r\n            return DATASTORE.readUintForId(id, \"priorFee\");\r\n        }\r\n        return DATASTORE.readUintForId(id, \"fee\");\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the fee that is applied by distributeFee on Oracle Updates.\r\n     * @dev advise that 100% == PERCENTAGE_DENOMINATOR\r\n     * @param id planet, comet or operator ID\r\n     */\r\n    function switchMaintainerFee(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        uint256 newFee\r\n    ) external {\r\n        DATASTORE.writeUintForId(\r\n            id,\r\n            \"priorFee\",\r\n            DATASTORE.readUintForId(id, \"fee\")\r\n        );\r\n        DATASTORE.writeUintForId(\r\n            id,\r\n            \"feeSwitch\",\r\n            block.timestamp + FEE_SWITCH_LATENCY\r\n        );\r\n        DATASTORE.writeUintForId(id, \"fee\", newFee);\r\n\r\n        emit MaintainerFeeSwitched(\r\n            id,\r\n            newFee,\r\n            block.timestamp + FEE_SWITCH_LATENCY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice When a fee is collected it is put in the maintainer's wallet\r\n     * @notice Maintainer wallet also keeps Ether put in Portal by Operator Maintainer to make proposeStake easier, instead of sending n ETH to contract\r\n     * while preStaking for n validator(s) for each time. Operator can put some ETHs to their wallet\r\n     * and from there, ETHs can be used to proposeStake. Then when it is approved and staked, it will be\r\n     * added back to the wallet to be used for other proposeStake calls.\r\n     * @param id the id of the Maintainer\r\n     * @return walletBalance the balance of Operator with the given _operatorId has\r\n     */\r\n    function getMaintainerWalletBalance(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (uint256 walletBalance) {\r\n        walletBalance = DATASTORE.readUintForId(id, \"wallet\");\r\n    }\r\n\r\n    /**\r\n     * @notice To increase the balance of a Maintainer's wallet\r\n     * @param _id the id of the Operator\r\n     * @param _value Ether (in Wei) amount to increase the wallet balance.\r\n     * @return success boolean value which is true if successful, should be used by Operator is Maintainer is a contract.\r\n     */\r\n    function _increaseMaintainerWallet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id,\r\n        uint256 _value\r\n    ) internal returns (bool success) {\r\n        DATASTORE.addUintForId(_id, \"wallet\", _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice To decrease the balance of an Operator's wallet\r\n     * @dev only maintainer can decrease the balance\r\n     * @param _id the id of the Operator\r\n     * @param _value Ether (in Wei) amount to decrease the wallet balance and send back to Maintainer.\r\n     * @return success boolean value which is \"sent\", should be used by Operator is Maintainer is a contract.\r\n     */\r\n    function _decreaseMaintainerWallet(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _id,\r\n        uint256 _value\r\n    ) internal returns (bool success) {\r\n        require(\r\n            DATASTORE.readUintForId(_id, \"wallet\") >= _value,\r\n            \"MaintainerUtils: NOT enough balance in wallet\"\r\n        );\r\n\r\n        DATASTORE.subUintForId(_id, \"wallet\", _value);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/utils/OracleUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"./DataStoreUtilsLib.sol\";\r\nimport {DepositContractUtils as DCU} from \"./DepositContractUtilsLib.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title OracleUtils library to be used within stakeUtils\r\n * @notice Oracle, named Telescope, is responsible from 2 tasks:\r\n * * regulating the validator creations and exits\r\n * * syncs the price of all pools with merkleroot\r\n *\r\n * Regulating the validators/operators:\r\n * * state 1: validators is proposed since enough allowence is given from pool maintainers, 1 ETH is locked from maintainerWallet\r\n * * state 2: stake was approved by Oracle, operator used user funds to activate the validator, 1 ETH is released\r\n * * state 69: validator was malicious(alien), probably front-runned with a problematic withdrawalCredential, (https://bit.ly/3Tkc6UC)\r\n * * state 3: validator is exited. However, if the signal turns out to be false, then Telescope reports and sets to state 2, prisoning the operator.\r\n * * * Reports the Total number of Beacon validators to make sure no operator is running more validators then they should within Geode Universe.\r\n *\r\n *\r\n * Syncing the Prices:\r\n * * Telescope works the first 30 minutes of every day(GMT), with an archive node that points the first second.\r\n * * Catches the beacon chain balances and decreases the fees, groups them by ids\r\n * * Creates a merkle root, by simply calculating all prices from every pool, either private or public\r\n * * Verifies merkle root with price proofs of all public pools.\r\n * * * Private pools need to verify their own price once a day, otherwise minting is not allowed.\r\n * * * * This is why merkle root of all prices is needed\r\n *\r\n * @dev Prisoned Validator:\r\n * * 1. created a malicious validator(alien)\r\n * * 2. withdrawn without a signal\r\n * * 3. signaled but not withdrawn\r\n * * 4. did not respect the validatorPeriod\r\n *\r\n * @dev ALL \"fee\" variables are limited by PERCENTAGE_DENOMINATOR = 100%\r\n * Note refer to DataStoreUtils before reviewing\r\n */\r\n\r\nlibrary OracleUtils {\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n\r\n    event Alienated(bytes pubkey);\r\n    event Busted(bytes pubkey);\r\n    event Prisoned(uint256 id, uint256 releaseTimestamp);\r\n    event Released(uint256 id);\r\n    event VerificationIndexUpdated(uint256 validatorVerificationIndex);\r\n    event FeeTheft(uint256 id, uint256 blockNumber);\r\n\r\n    /**\r\n     * @param state 0: inactive, 1: proposed/cured validator, 2: active validator, 3: exited,  69: alienated proposal\r\n     * @param index representing this validators placement on the chronological order of the proposed validators\r\n     * @param planetId needed for withdrawal_credential\r\n     * @param operatorId needed for staking after allowence\r\n     * @param poolFee percentage of the rewards that will got to pool's maintainer, locked when the validator is created\r\n     * @param operatorFee percentage of the rewards that will got to operator's maintainer, locked when the validator is created\r\n     * @param createdAt the timestamp pointing the proposal to create a validator with given pubkey.\r\n     * @param expectedExit expected timestamp of the exit of validator. Calculated with operator[\"validatorPeriod\"]\r\n     * @param signature BLS12-381 signature of the validator\r\n     **/\r\n    struct Validator {\r\n        uint8 state;\r\n        uint256 index;\r\n        uint256 poolId;\r\n        uint256 operatorId;\r\n        uint256 poolFee;\r\n        uint256 operatorFee;\r\n        uint256 createdAt;\r\n        uint256 expectedExit;\r\n        bytes signature;\r\n    }\r\n    /**\r\n     * @param ORACLE_POSITION https://github.com/Geodefi/Telescope-Eth\r\n     * @param ORACLE_UPDATE_TIMESTAMP the timestamp of the latest oracle update\r\n     * @param MONOPOLY_THRESHOLD max number of validators 1 operator is allowed to operate, updated daily by oracle\r\n     * @param VALIDATORS_INDEX total number of validators that are proposed at some point. includes all states of validators.\r\n     * @param VERIFICATION_INDEX the highest index of the validators that are verified ( to be not alien ) by Telescope. Updated by Telescope.\r\n     * @param PERIOD_PRICE_INCREASE_LIMIT limiting the price increases for one oracle period, 24h. Effective for any time interval\r\n     * @param PERIOD_PRICE_DECREASE_LIMIT limiting the price decreases for one oracle period, 24h. Effective for any time interval\r\n     * @param PRICE_MERKLE_ROOT merkle root of the prices of every pool, planet or comet\r\n     * @param _validators contains all the data about proposed or/and active validators\r\n     **/\r\n    struct Oracle {\r\n        IgETH gETH;\r\n        address ORACLE_POSITION;\r\n        uint256 ORACLE_UPDATE_TIMESTAMP;\r\n        uint256 MONOPOLY_THRESHOLD;\r\n        uint256 VALIDATORS_INDEX;\r\n        uint256 VERIFICATION_INDEX;\r\n        uint256 PERIOD_PRICE_INCREASE_LIMIT;\r\n        uint256 PERIOD_PRICE_DECREASE_LIMIT;\r\n        bytes32 PRICE_MERKLE_ROOT;\r\n        mapping(bytes => Validator) _validators;\r\n        uint256[6] __gap;\r\n    }\r\n\r\n    /// @notice PERCENTAGE_DENOMINATOR represents 100%\r\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10**10;\r\n\r\n    /// @notice Oracle is active for the first 30 min of every day\r\n    uint256 public constant ORACLE_PERIOD = 1 days;\r\n    uint256 public constant ORACLE_ACTIVE_PERIOD = 30 minutes;\r\n\r\n    /// @notice effective on MONOPOLY_THRESHOLD, limiting the active validators, set to 5% at start.\r\n    uint256 public constant MONOPOLY_RATIO = (5 * PERCENTAGE_DENOMINATOR) / 100;\r\n\r\n    /// @notice limiting some abilities of Operators in case of bad behaviour\r\n    uint256 public constant PRISON_SENTENCE = 30 days;\r\n\r\n    modifier onlyOracle(Oracle storage self) {\r\n        require(\r\n            msg.sender == self.ORACLE_POSITION,\r\n            \"OracleUtils: sender NOT ORACLE\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    function getValidator(Oracle storage self, bytes calldata pubkey)\r\n        external\r\n        view\r\n        returns (Validator memory)\r\n    {\r\n        return self._validators[pubkey];\r\n    }\r\n\r\n    /**\r\n     * @notice Oracle is only allowed for a period every day & some operations are stopped then\r\n     * @return false if the last oracle update happened already (within the current daily period)\r\n     */\r\n    function _isOracleActive(Oracle storage self) internal view returns (bool) {\r\n        return\r\n            (block.timestamp % ORACLE_PERIOD <= ORACLE_ACTIVE_PERIOD) &&\r\n            (self.ORACLE_UPDATE_TIMESTAMP <\r\n                block.timestamp - ORACLE_ACTIVE_PERIOD);\r\n    }\r\n\r\n    /**\r\n     * @notice              ** Regulating the Operators and PubKeys **\r\n     */\r\n\r\n    /**\r\n     * @notice Checks if the given operator is Prisoned\r\n     * @dev \"released\" key refers to the end of the last imprisonment, the limit on the abilities of operator is lifted then\r\n     */\r\n    function isPrisoned(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _operatorId\r\n    ) internal view returns (bool _isPrisoned) {\r\n        _isPrisoned =\r\n            block.timestamp <= DATASTORE.readUintForId(_operatorId, \"released\");\r\n    }\r\n\r\n    /**\r\n     * @notice releases an imprisoned operator immidately\r\n     * @dev in different situations such as a faulty improsenment or coordinated testing periods\r\n     * * Governance can vote on releasing the prisoners\r\n     * @dev onlyGovernance check is in Portal\r\n     */\r\n    function releasePrisoned(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 operatorId\r\n    ) external {\r\n        require(\r\n            isPrisoned(DATASTORE, operatorId),\r\n            \"OracleUtils: NOT in prison\"\r\n        );\r\n        DATASTORE.writeUintForId(operatorId, \"released\", block.timestamp);\r\n        emit Released(operatorId);\r\n    }\r\n\r\n    /**\r\n     * @notice Put an operator in prison, \"release\" points to the date the operator will be out\r\n     */\r\n    function imprison(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _operatorId\r\n    ) internal {\r\n        DATASTORE.writeUintForId(\r\n            _operatorId,\r\n            \"released\",\r\n            block.timestamp + PRISON_SENTENCE\r\n        );\r\n        emit Prisoned(_operatorId, block.timestamp + PRISON_SENTENCE);\r\n    }\r\n\r\n    /**\r\n     * @notice checks if a validator can use pool funds\r\n     * Creation of a Validator takes 2 steps.\r\n     * Before entering beaconStake function, _canStake verifies the eligibility of\r\n     * given pubKey that is proposed by an operator with proposeStake function.\r\n     * Eligibility is defined by an optimistic alienation, check alienate() for info.\r\n     *\r\n     *  @param pubkey BLS12-381 public key of the validator\r\n     *  @return true if:\r\n     *   - pubkey should be proposeStaked\r\n     *   - pubkey should not be alienated (https://bit.ly/3Tkc6UC)\r\n     *   - validator's index should be lower than VERIFICATION_INDEX. Updated by Telescope.\r\n     *  else:\r\n     *      return false\r\n     * @dev to optimize batch checks verificationIndex is taken as a memeory param\r\n     */\r\n    function _canStake(\r\n        Oracle storage self,\r\n        bytes calldata pubkey,\r\n        uint256 verificationIndex\r\n    ) internal view returns (bool) {\r\n        return\r\n            self._validators[pubkey].state == 1 &&\r\n            self._validators[pubkey].index <= verificationIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice An \"Alien\" is a validator that is created with a false withdrawal credential, this is a malicious act.\r\n     * @dev imprisonates the operator who proposed a malicious validator.\r\n     */\r\n    function _alienateValidator(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata _pk\r\n    ) internal {\r\n        require(\r\n            self._validators[_pk].state == 1,\r\n            \"OracleUtils: NOT all alienPubkeys are pending\"\r\n        );\r\n        uint256 planetId = self._validators[_pk].poolId;\r\n        DATASTORE.subUintForId(planetId, \"secured\", DCU.DEPOSIT_AMOUNT);\r\n        DATASTORE.addUintForId(planetId, \"surplus\", DCU.DEPOSIT_AMOUNT);\r\n        self._validators[_pk].state = 69;\r\n\r\n        imprison(DATASTORE, self._validators[_pk].operatorId);\r\n        emit Alienated(_pk);\r\n    }\r\n\r\n    /**\r\n     * @notice \"Busting\" refers to a false signal, meaning there is a signal but no Unstake\r\n     * @dev imprisonates the operator who signaled a fake Unstake\r\n     */\r\n    function _bustSignal(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata _pk\r\n    ) internal {\r\n        require(\r\n            self._validators[_pk].state == 3,\r\n            \"OracleUtils: pubkey is NOT signaled\"\r\n        );\r\n        self._validators[_pk].state == 2;\r\n\r\n        imprison(DATASTORE, self._validators[_pk].operatorId);\r\n        emit Busted(_pk);\r\n    }\r\n\r\n    /**\r\n     * @notice \"Busting\" refers to unsignaled withdrawal, meaning there is an unstake but no Signal\r\n     * @dev imprisonates the operator who haven't signal the unstake\r\n     */\r\n    function _bustExit(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes calldata _pk\r\n    ) internal {\r\n        require(\r\n            self._validators[_pk].state == 2,\r\n            \"OracleUtils: Signaled, cannot be busted\"\r\n        );\r\n        self._validators[_pk].state == 3;\r\n\r\n        imprison(DATASTORE, self._validators[_pk].operatorId);\r\n        emit Busted(_pk);\r\n    }\r\n\r\n    /**\r\n     * @notice Updating VERIFICATION_INDEX, signaling that it is safe to allow\r\n     * validators with lower index than VERIFICATION_INDEX to stake with staking pool funds\r\n     * @param allValidatorsCount total number of validators to figure out what is the current Monopoly Requirement\r\n     * @param validatorVerificationIndex index of the highest validator that is verified to be activated\r\n     * @param alienatedPubkeys proposals with lower index than new_index who frontrunned proposeStake\r\n     * with incorrect withdrawal credential results in imprisonment.\r\n     */\r\n    function updateVerificationIndex(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 allValidatorsCount,\r\n        uint256 validatorVerificationIndex,\r\n        bytes[] calldata alienatedPubkeys\r\n    ) external onlyOracle(self) {\r\n        require(!_isOracleActive(self), \"OracleUtils: oracle is active\");\r\n        require(allValidatorsCount > 4999, \"OracleUtils: low validator count\");\r\n        require(\r\n            self.VALIDATORS_INDEX >= validatorVerificationIndex,\r\n            \"OracleUtils: high VERIFICATION_INDEX\"\r\n        );\r\n        require(\r\n            validatorVerificationIndex >= self.VERIFICATION_INDEX,\r\n            \"OracleUtils: low VERIFICATION_INDEX\"\r\n        );\r\n        self.VERIFICATION_INDEX = validatorVerificationIndex;\r\n\r\n        for (uint256 i; i < alienatedPubkeys.length; i++) {\r\n            _alienateValidator(self, DATASTORE, alienatedPubkeys[i]);\r\n        }\r\n\r\n        self.MONOPOLY_THRESHOLD =\r\n            (allValidatorsCount * MONOPOLY_RATIO) /\r\n            PERCENTAGE_DENOMINATOR;\r\n\r\n        emit VerificationIndexUpdated(validatorVerificationIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice regulating operators within Geode with verifiable proofs\r\n     * @param bustedExits validators that have not signaled before Unstake\r\n     * @param bustedSignals validators that are \"mistakenly:)\" signaled but not Unstaked\r\n     * @param feeThefts [0]: Operator ids who have stolen MEV or block rewards, [1]: detected BlockNumber as proof\r\n     * @dev Both of these functions results in imprisonment.\r\n     */\r\n    function regulateOperators(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes[] calldata bustedExits,\r\n        bytes[] calldata bustedSignals,\r\n        uint256[2][] calldata feeThefts\r\n    ) external onlyOracle(self) {\r\n        require(!_isOracleActive(self), \"OracleUtils: oracle is active\");\r\n\r\n        for (uint256 i; i < bustedExits.length; i++) {\r\n            _bustExit(self, DATASTORE, bustedExits[i]);\r\n        }\r\n\r\n        for (uint256 j; j < bustedSignals.length; j++) {\r\n            _bustSignal(self, DATASTORE, bustedSignals[j]);\r\n        }\r\n\r\n        for (uint256 k; k < feeThefts.length; k++) {\r\n            imprison(DATASTORE, feeThefts[0][k]);\r\n            emit FeeTheft(feeThefts[0][k], feeThefts[1][k]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice                          ** Updating PricePerShare **\r\n     */\r\n\r\n    /**\r\n     * @notice calculates the current price and expected report price\r\n     * @dev surplus at the oracle time is found with the help of mint and burn buffers\r\n     * @param _dailyBufferMintKey represents the gETH minted during oracleActivePeriod, unique to every day\r\n     * @param _dailyBufferBurnKey represents the gETH burned during oracleActivePeriod, unique to every day\r\n     * @dev calculates the totalEther amount, decreases the amount minted while oracle was working (first 30m),\r\n     * finds the expected Oracle price by totalEther / supply , finds the current price by unbufferedEther / unbufferedSupply\r\n     */\r\n    function _findPricesClearBuffer(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes32 _dailyBufferMintKey,\r\n        bytes32 _dailyBufferBurnKey,\r\n        uint256 _poolId,\r\n        uint256 _beaconBalance\r\n    ) internal returns (uint256, uint256) {\r\n        uint256 totalEther = _beaconBalance +\r\n            DATASTORE.readUintForId(_poolId, \"secured\") +\r\n            DATASTORE.readUintForId(_poolId, \"surplus\");\r\n\r\n        uint256 supply = self.gETH.totalSupply(_poolId);\r\n        uint256 price = self.gETH.pricePerShare(_poolId);\r\n        uint256 unbufferedEther = totalEther -\r\n            (DATASTORE.readUintForId(_poolId, _dailyBufferMintKey) * price) /\r\n            self.gETH.totalSupply(_poolId);\r\n\r\n        unbufferedEther +=\r\n            (DATASTORE.readUintForId(_poolId, _dailyBufferBurnKey) * price) /\r\n            self.gETH.denominator();\r\n\r\n        uint256 unbufferedSupply = supply -\r\n            DATASTORE.readUintForId(_poolId, _dailyBufferMintKey);\r\n\r\n        unbufferedSupply += DATASTORE.readUintForId(\r\n            _poolId,\r\n            _dailyBufferBurnKey\r\n        );\r\n\r\n        // clears daily buffer for the gas refund\r\n        DATASTORE.writeUintForId(_poolId, _dailyBufferMintKey, 0);\r\n        DATASTORE.writeUintForId(_poolId, _dailyBufferBurnKey, 0);\r\n\r\n        return (unbufferedEther / unbufferedSupply, totalEther / supply);\r\n    }\r\n\r\n    /**\r\n     * @dev in order to prevent attacks from malicious Oracle there are boundaries to price & fee updates.\r\n     * 1. Price should not be increased more than PERIOD_PRICE_INCREASE_LIMIT\r\n     *  with the factor of how many days since oracleUpdateTimestamp has past.\r\n     * 2. Price should not be decreased more than PERIOD_PRICE_DECREASE_LIMIT\r\n     *  with the factor of how many days since oracleUpdateTimestamp has past.\r\n     */\r\n    function _sanityCheck(\r\n        Oracle storage self,\r\n        uint256 _id,\r\n        uint256 _periodsSinceUpdate,\r\n        uint256 _newPrice\r\n    ) internal view {\r\n        uint256 curPrice = self.gETH.pricePerShare(_id);\r\n        uint256 maxPrice = curPrice +\r\n            ((curPrice *\r\n                self.PERIOD_PRICE_INCREASE_LIMIT *\r\n                _periodsSinceUpdate) / PERCENTAGE_DENOMINATOR);\r\n\r\n        uint256 minPrice = curPrice -\r\n            ((curPrice *\r\n                self.PERIOD_PRICE_DECREASE_LIMIT *\r\n                _periodsSinceUpdate) / PERCENTAGE_DENOMINATOR);\r\n\r\n        require(\r\n            _newPrice >= minPrice && _newPrice <= maxPrice,\r\n            \"OracleUtils: price is insane\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice syncing the price of g-derivative after checking the merkle proofs and the sanity of it.\r\n     * @param _beaconBalance the total balance -excluding fees- of all validators of this pool\r\n     * @param _periodsSinceUpdate time(s) since the last update of the g-derivative's price.\r\n     * while public pools are using ORACLE_UPDATE_TIMESTAMP, private pools will refer gEth.priceUpdateTimestamp()\r\n     * @param _priceProofs the merkle proof of the latests prices that are reported by Telescope\r\n     * @dev if merkle proof holds the oracle price, new price is the current price of the derivative\r\n     */\r\n    function _priceSync(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes32[2] memory _dailyBufferKeys,\r\n        uint256 _poolId,\r\n        uint256 _beaconBalance,\r\n        uint256 _periodsSinceUpdate, // calculation for this changes for private pools\r\n        bytes32[] calldata _priceProofs // uint256 prices[]\r\n    ) internal {\r\n        (uint256 oraclePrice, uint256 price) = _findPricesClearBuffer(\r\n            self,\r\n            DATASTORE,\r\n            _dailyBufferKeys[0],\r\n            _dailyBufferKeys[1],\r\n            _poolId,\r\n            _beaconBalance\r\n        );\r\n        _sanityCheck(self, _poolId, _periodsSinceUpdate, oraclePrice);\r\n        bytes32 node = keccak256(abi.encodePacked(_poolId, oraclePrice));\r\n\r\n        require(\r\n            MerkleProof.verify(_priceProofs, self.PRICE_MERKLE_ROOT, node),\r\n            \"OracleUtils: NOT all proofs are valid\"\r\n        );\r\n\r\n        self.gETH.setPricePerShare(price, _poolId);\r\n    }\r\n\r\n    /**\r\n     * @notice Telescope reports all of the g-derivate prices with a new PRICE_MERKLE_ROOT\r\n     * @notice after report updates the prices of the public pools\r\n     * @notice updates the ORACLE_UPDATE_TIMESTAMP\r\n     * @dev if merkle proof holds the oracle price, new price is the found price of the derivative\r\n     */\r\n    function reportOracle(\r\n        Oracle storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        bytes32 merkleRoot,\r\n        uint256[] calldata beaconBalances,\r\n        bytes32[][] calldata priceProofs\r\n    ) external onlyOracle(self) {\r\n        require(_isOracleActive(self), \"OracleUtils: oracle is NOT active\");\r\n\r\n        {\r\n            uint256 planetCount = DATASTORE.allIdsByType[5].length;\r\n            require(\r\n                beaconBalances.length == planetCount,\r\n                \"OracleUtils: incorrect beaconBalances length\"\r\n            );\r\n            require(\r\n                priceProofs.length == planetCount,\r\n                \"OracleUtils: incorrect priceProofs length\"\r\n            );\r\n        }\r\n\r\n        self.PRICE_MERKLE_ROOT = merkleRoot;\r\n\r\n        uint256 periodsSinceUpdate = (block.timestamp +\r\n            ORACLE_ACTIVE_PERIOD -\r\n            self.ORACLE_UPDATE_TIMESTAMP) / ORACLE_PERIOD;\r\n\r\n        // refering the first second of the period: block.timestamp - (block.timestamp % ORACLE_PERIOD)\r\n        bytes32[2] memory dailyBufferKeys = [\r\n            DataStoreUtils.getKey(\r\n                block.timestamp - (block.timestamp % ORACLE_PERIOD),\r\n                \"mintBuffer\"\r\n            ),\r\n            DataStoreUtils.getKey(\r\n                block.timestamp - (block.timestamp % ORACLE_PERIOD),\r\n                \"burnBuffer\"\r\n            )\r\n        ];\r\n\r\n        for (uint256 i = 0; i < beaconBalances.length; i++) {\r\n            _priceSync(\r\n                self,\r\n                DATASTORE,\r\n                dailyBufferKeys,\r\n                DATASTORE.allIdsByType[5][i],\r\n                beaconBalances[i],\r\n                periodsSinceUpdate,\r\n                priceProofs[i]\r\n            );\r\n        }\r\n        self.ORACLE_UPDATE_TIMESTAMP =\r\n            block.timestamp -\r\n            (block.timestamp % ORACLE_PERIOD);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IgETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\ninterface IgETH {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function uri(uint256) external view returns (string memory);\r\n\r\n    function balanceOf(address account, uint256 id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(address account, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) external;\r\n\r\n    function burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory values\r\n    ) external;\r\n\r\n    function totalSupply(uint256 id) external view returns (uint256);\r\n\r\n    function exists(uint256 id) external view returns (bool);\r\n\r\n    function mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function denominator() external view returns (uint256);\r\n\r\n    function pricePerShare(uint256 id) external view returns (uint256);\r\n\r\n    function priceUpdateTimestamp(uint256 id) external view returns (uint256);\r\n\r\n    function setPricePerShare(uint256 price, uint256 id) external;\r\n\r\n    function isInterface(address _interface, uint256 id)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function setInterface(\r\n        address _interface,\r\n        uint256 id,\r\n        bool isSet\r\n    ) external;\r\n\r\n    function updateMinterRole(address Minter) external;\r\n\r\n    function updatePauserRole(address Pauser) external;\r\n\r\n    function updateOracleRole(address Oracle) external;\r\n}\r\n"
    },
    "contracts/interfaces/IMiniGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"../Portal/utils/GeodeUtilsLib.sol\";\r\n\r\ninterface IMiniGovernance {\r\n    function initialize(\r\n        address _gETH,\r\n        address _PORTAL,\r\n        address _MAINTAINER,\r\n        uint256 _ID,\r\n        uint256 _VERSION\r\n    ) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function getCurrentVersion() external view returns (uint256);\r\n\r\n    function getProposedVersion() external view returns (uint256);\r\n\r\n    function isolationMode() external view returns (bool);\r\n\r\n    function fetchUpgradeProposal() external;\r\n\r\n    function approveProposal(uint256 _id) external;\r\n\r\n    function refreshSenate(bytes32 newPassword) external;\r\n\r\n    function changeMaintainer(\r\n        bytes calldata password,\r\n        bytes32 newPasswordHash,\r\n        address newMaintainer\r\n    ) external returns (bool success);\r\n\r\n    function claimUnstake(uint256 claim) external returns (bool success);\r\n}\r\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"./IgETH.sol\";\r\n\r\ninterface ISwap {\r\n    function donateBalancedFees(uint256 EthDonation, uint256 gEthDonation)\r\n        external\r\n        payable\r\n        returns (uint256, uint256);\r\n\r\n    // pool data view functions\r\n    function getERC1155() external view returns (address);\r\n\r\n    function getA() external view returns (uint256);\r\n\r\n    function getAPrecise() external view returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n\r\n    function getToken() external view returns (uint256);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    function getDebt() external view returns (uint256);\r\n\r\n    function getAdminBalance(uint256 index) external view returns (uint256);\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function initialize(\r\n        IgETH _gEth,\r\n        uint256 _pooledTokenId,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) external returns (address lpToken);\r\n\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function withdrawAdminFees() external;\r\n\r\n    function setAdminFee(uint256 newAdminFee) external;\r\n\r\n    function setSwapFee(uint256 newSwapFee) external;\r\n\r\n    function rampA(uint256 futureA, uint256 futureTime) external;\r\n\r\n    function stopRampA() external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC20InterfacePermitUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"./IgETH.sol\";\r\n\r\ninterface IERC20InterfacePermitUpgradable {\r\n    function initialize(\r\n        uint256 id_,\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address gETH_1155\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/ILPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\ninterface ILPToken {\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        returns (bool);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        returns (bool);\r\n\r\n    function initialize(string memory name, string memory symbol)\r\n        external\r\n        returns (bool);\r\n\r\n    function mint(address recipient, uint256 amount) external;\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function renounceOwnership() external;\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "contracts/Portal/utils/GeodeUtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"./DataStoreUtilsLib.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title GeodeUtils library\r\n * @notice Exclusively contains functions responsible for administration of DATASTORE,\r\n * including functions related to \"limited upgradability\" with Senate & Proposals.\r\n * @dev Contracts relying on this library must initialize GeodeUtils.Universe\r\n * @dev ALL \"fee\" variables are limited by PERCENTAGE_DENOMINATOR = 100%\r\n * @dev Admin functions are already protected\r\n * Note this library contains both functions called by users(ID) (approveSenate) and admins(GOVERNANCE, SENATE)\r\n * Note refer to DataStoreUtils before reviewing\r\n */\r\nlibrary GeodeUtils {\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n\r\n    event GovernanceTaxUpdated(uint256 newFee);\r\n    event MaxGovernanceTaxUpdated(uint256 newMaxFee);\r\n    event ControllerChanged(uint256 id, address newCONTROLLER);\r\n    event Proposed(\r\n        uint256 id,\r\n        address CONTROLLER,\r\n        uint256 TYPE,\r\n        uint256 deadline\r\n    );\r\n    event ProposalApproved(uint256 id);\r\n    event ElectorTypeSet(uint256 TYPE, bool isElector);\r\n    event Vote(uint256 proposalId, uint256 electorId);\r\n    event NewSenate(address senate, uint256 senateExpiry);\r\n\r\n    /**\r\n     * @notice Proposal basically refers to give the control of an ID to a CONTROLLER.\r\n     *\r\n     * @notice A Proposal has 4 specs:\r\n     * @param TYPE: separates the proposals and related functionality between different ID types.\r\n     * * RESERVED TYPES on GeodeUtils:\r\n     * * * TYPE 0: inactive\r\n     * * * TYPE 1: Senate: controls state of governance, contract updates and other members of A Universe\r\n     * * * TYPE 2: Upgrade: address of the implementation for desired contract upgrade\r\n     * * * TYPE 3: **gap** : formally it represented the admin contract, however since UUPS is being used as a upgrade path,\r\n     * this TYPE is now reserved.\r\n     *\r\n     * @param name: id is created by keccak(name, type)\r\n     *\r\n     * @param CONTROLLER: the address that refers to the change that is proposed by given proposal ID.\r\n     * * This slot can refer to the controller of an id, a new implementation contract, a new Senate etc.\r\n     *\r\n     * @param deadline: refers to last timestamp until a proposal expires, limited by MAX_PROPOSAL_DURATION\r\n     * * Expired proposals can not be approved by Senate\r\n     * * Expired proposals can not be overriden by new proposals\r\n     **/\r\n    struct Proposal {\r\n        address CONTROLLER;\r\n        uint256 TYPE;\r\n        bytes NAME;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /**\r\n     * @notice Universe is A blockchain. In this case, it defines Ethereum\r\n     * @param GOVERNANCE a community that works to improve the core product and ensures its adoption in the DeFi ecosystem\r\n     * Suggests updates, such as new planets, operators, comets, contract upgrades and new Senate, on the Ecosystem -without any permission to force them-\r\n     * @param SENATE An address that controls the state of governance, updates and other users in the Geode Ecosystem\r\n     * Note SENATE is proposed by Governance and voted by all elector types, operates if ⌊2/3⌋ approves.\r\n     * @param GOVERNANCE_TAX operation fee of the given contract, acquired by GOVERNANCE. Limited by MAX_GOVERNANCE_TAX\r\n     * @param MAX_GOVERNANCE_TAX set by SENATE, limited by PERCENTAGE_DENOMINATOR\r\n     * @param SENATE_EXPIRY refers to the last timestamp that SENATE can continue operating. Enforces a new election, limited by MAX_SENATE_PERIOD\r\n     * @param approvedUpgrade only 1 implementation contract can be \"approved\" at any given time. @dev safe to set to address(0) after every upgrade\r\n     * @param _electorCount increased when a new id is added with _electorTypes[id] == true\r\n     * @param _electorTypes only given types can vote @dev MUST only change during upgrades.\r\n     * @param _proposalForId proposals are kept seperately instead of setting the parameters of id in DATASTORE, and then setting it's type; to allow surpassing type checks to save gas cost\r\n     **/\r\n    struct Universe {\r\n        address SENATE;\r\n        address GOVERNANCE;\r\n        uint256 GOVERNANCE_TAX;\r\n        uint256 MAX_GOVERNANCE_TAX;\r\n        uint256 SENATE_EXPIRY;\r\n        address approvedUpgrade;\r\n        uint256 _electorCount;\r\n        mapping(uint256 => bool) _electorTypes;\r\n        mapping(uint256 => Proposal) _proposalForId;\r\n        uint256[7] __gap;\r\n    }\r\n\r\n    /// @notice PERCENTAGE_DENOMINATOR represents 100%\r\n    uint256 public constant PERCENTAGE_DENOMINATOR = 10**10;\r\n\r\n    uint32 public constant MIN_PROPOSAL_DURATION = 1 days;\r\n    uint32 public constant MAX_PROPOSAL_DURATION = 2 weeks;\r\n    uint32 public constant MAX_SENATE_PERIOD = 365 days; // 1 year\r\n\r\n    modifier onlySenate(Universe storage self) {\r\n        require(msg.sender == self.SENATE, \"GeodeUtils: SENATE role needed\");\r\n        require(\r\n            block.timestamp < self.SENATE_EXPIRY,\r\n            \"GeodeUtils: SENATE not active\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance(Universe storage self) {\r\n        require(\r\n            msg.sender == self.GOVERNANCE,\r\n            \"GeodeUtils: GOVERNANCE role needed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyController(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) {\r\n        require(\r\n            msg.sender == DATASTORE.readAddressForId(id, \"CONTROLLER\"),\r\n            \"GeodeUtils: CONTROLLER role needed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *                                         ** UNIVERSE GETTERS **\r\n     **/\r\n\r\n    /**\r\n     * @return address of SENATE\r\n     **/\r\n    function getSenate(Universe storage self) external view returns (address) {\r\n        return self.SENATE;\r\n    }\r\n\r\n    /**\r\n     * @return address of GOVERNANCE\r\n     **/\r\n    function getGovernance(Universe storage self)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return self.GOVERNANCE;\r\n    }\r\n\r\n    /**\r\n     * @notice MAX_GOVERNANCE_TAX must limit GOVERNANCE_TAX even if MAX is changed\r\n     * @return active GOVERNANCE_TAX, limited by MAX_GOVERNANCE_TAX\r\n     */\r\n    function getGovernanceTax(Universe storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.GOVERNANCE_TAX;\r\n    }\r\n\r\n    /**\r\n     *  @return MAX_GOVERNANCE_TAX\r\n     */\r\n    function getMaxGovernanceTax(Universe storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.MAX_GOVERNANCE_TAX;\r\n    }\r\n\r\n    /**\r\n     * @return the expiration date of current SENATE as a timestamp\r\n     */\r\n    function getSenateExpiry(Universe storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.SENATE_EXPIRY;\r\n    }\r\n\r\n    /**\r\n     *                                         ** UNIVERSE SETTERS **\r\n     */\r\n\r\n    /**\r\n     * @dev can not set the fee more than MAX_GOVERNANCE_TAX\r\n     * @dev no need to check PERCENTAGE_DENOMINATOR because MAX_GOVERNANCE_TAX is limited already\r\n     * @return true if the operation was succesful, might be helpful when governance rights are distributed\r\n     */\r\n    function setGovernanceTax(Universe storage self, uint256 newFee)\r\n        external\r\n        onlyGovernance(self)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            newFee <= self.MAX_GOVERNANCE_TAX,\r\n            \"GeodeUtils: cannot be more than MAX_GOVERNANCE_TAX\"\r\n        );\r\n\r\n        self.GOVERNANCE_TAX = newFee;\r\n\r\n        emit GovernanceTaxUpdated(newFee);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev can not set a fee more than PERCENTAGE_DENOMINATOR (100%)\r\n     * @return true if the operation was succesful\r\n     */\r\n    function setMaxGovernanceTax(Universe storage self, uint256 newMaxFee)\r\n        external\r\n        onlySenate(self)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            newMaxFee <= PERCENTAGE_DENOMINATOR,\r\n            \"GeodeUtils: fee more than 100%\"\r\n        );\r\n\r\n        self.MAX_GOVERNANCE_TAX = newMaxFee;\r\n\r\n        emit MaxGovernanceTaxUpdated(newMaxFee);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *                                          ** ID **\r\n     */\r\n\r\n    /**\r\n     * @dev Some TYPEs may require permissionless creation. But to allow anyone to claim any ID,\r\n     * meaning malicious actors can claim names and operate pools to mislead people. To prevent this\r\n     * TYPEs will be considered during id generation.\r\n     */\r\n    function _generateId(bytes calldata _NAME, uint256 _TYPE)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(_NAME, _TYPE)));\r\n    }\r\n\r\n    /**\r\n     * @dev returns address(0) for empty ids, mandatory\r\n     */\r\n    function getCONTROLLERFromId(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (address) {\r\n        return DATASTORE.readAddressForId(id, \"CONTROLLER\");\r\n    }\r\n\r\n    /**\r\n     * @dev returns uint(0) for empty ids, mandatory\r\n     */\r\n    function getTYPEFromId(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (uint256) {\r\n        return DATASTORE.readUintForId(id, \"TYPE\");\r\n    }\r\n\r\n    /**\r\n     * @dev returns bytes(0) for empty ids, mandatory\r\n     */\r\n    function getNAMEFromId(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external view returns (bytes memory) {\r\n        return DATASTORE.readBytesForId(id, \"NAME\");\r\n    }\r\n\r\n    /**\r\n     * @notice only the current CONTROLLER can change\r\n     * @dev this operation can not be reverted by the old CONTROLLER\r\n     * @dev in case the current controller wants to remove the\r\n     * need to upgrade to Controller they should provide smt like 0x000000000000000000000000000000000000dEaD\r\n     */\r\n    function changeIdCONTROLLER(\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id,\r\n        address newCONTROLLER\r\n    ) external onlyController(DATASTORE, id) {\r\n        require(\r\n            newCONTROLLER != address(0),\r\n            \"GeodeUtils: CONTROLLER can not be zero\"\r\n        );\r\n\r\n        DATASTORE.writeAddressForId(id, \"CONTROLLER\", newCONTROLLER);\r\n\r\n        emit ControllerChanged(id, newCONTROLLER);\r\n    }\r\n\r\n    /**\r\n     *                                          ** PROPOSALS **\r\n     */\r\n\r\n    /**\r\n     * CONTROLLER Proposals\r\n     */\r\n\r\n    function getProposal(Universe storage self, uint256 id)\r\n        external\r\n        view\r\n        returns (Proposal memory)\r\n    {\r\n        return self._proposalForId[id];\r\n    }\r\n\r\n    /**\r\n     * @notice a proposal can never be overriden.\r\n     * @notice DATASTORE(id) will not be updated until the proposal is approved.\r\n     * @dev refer to structure of Proposal for explanations of params\r\n     */\r\n    function newProposal(\r\n        Universe storage self,\r\n        address _CONTROLLER,\r\n        uint256 _TYPE,\r\n        bytes calldata _NAME,\r\n        uint256 duration\r\n    ) external returns (uint256 id) {\r\n        require(\r\n            duration >= MIN_PROPOSAL_DURATION,\r\n            \"GeodeUtils: duration should be higher than MIN_PROPOSAL_DURATION\"\r\n        );\r\n        require(\r\n            duration <= MAX_PROPOSAL_DURATION,\r\n            \"GeodeUtils: duration exceeds MAX_PROPOSAL_DURATION\"\r\n        );\r\n\r\n        id = _generateId(_NAME, _TYPE);\r\n\r\n        require(\r\n            self._proposalForId[id].deadline == 0,\r\n            \"GeodeUtils: NAME already proposed\"\r\n        );\r\n\r\n        self._proposalForId[id] = Proposal({\r\n            CONTROLLER: _CONTROLLER,\r\n            TYPE: _TYPE,\r\n            NAME: _NAME,\r\n            deadline: block.timestamp + duration\r\n        });\r\n\r\n        emit Proposed(id, _CONTROLLER, _TYPE, block.timestamp + duration);\r\n    }\r\n\r\n    /**\r\n     *  @notice type specific changes for reserved_types(1,2,3) are implemented here,\r\n     *  any other addition should take place in Portal, as not related\r\n     *  @param id given ID proposal that has been approved by Senate\r\n     *  @dev Senate should not be able to approve approved proposals\r\n     *  @dev Senate should not be able to approve expired proposals\r\n     *  @dev Senate should not be able to approve SENATE proposals :)\r\n     */\r\n    function approveProposal(\r\n        Universe storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 id\r\n    ) external onlySenate(self) {\r\n        require(\r\n            self._proposalForId[id].deadline > block.timestamp,\r\n            \"GeodeUtils: proposal expired\"\r\n        );\r\n        require(\r\n            self._proposalForId[id].TYPE != 1,\r\n            \"GeodeUtils: Senate can not approve Senate Election\"\r\n        );\r\n\r\n        DATASTORE.writeAddressForId(\r\n            id,\r\n            \"CONTROLLER\",\r\n            self._proposalForId[id].CONTROLLER\r\n        );\r\n        DATASTORE.writeUintForId(id, \"TYPE\", self._proposalForId[id].TYPE);\r\n        DATASTORE.writeBytesForId(id, \"NAME\", self._proposalForId[id].NAME);\r\n\r\n        if (self._proposalForId[id].TYPE == 2) {\r\n            self.approvedUpgrade = self._proposalForId[id].CONTROLLER;\r\n        }\r\n\r\n        if (self._electorTypes[DATASTORE.readUintForId(id, \"TYPE\")]) {\r\n            self._electorCount += 1;\r\n        }\r\n\r\n        DATASTORE.allIdsByType[self._proposalForId[id].TYPE].push(id);\r\n        self._proposalForId[id].deadline = block.timestamp;\r\n\r\n        emit ProposalApproved(id);\r\n    }\r\n\r\n    /**\r\n     * SENATE Proposals\r\n     */\r\n\r\n    /**\r\n     * @notice only elector types can vote for senate\r\n     * @param _TYPE selected type\r\n     * @param isElector true if selected _type can vote for senate from now on\r\n     * @dev can not set with the same value again, preventing double increment/decrements\r\n     */\r\n    function setElectorType(\r\n        Universe storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 _TYPE,\r\n        bool isElector\r\n    ) external onlyGovernance(self) {\r\n        require(\r\n            self._electorTypes[_TYPE] != isElector,\r\n            \"GeodeUtils: type already _isElector\"\r\n        );\r\n        require(\r\n            _TYPE != 0 && _TYPE != 1 && _TYPE != 2 && _TYPE != 3,\r\n            \"GeodeUtils: 0, Senate, Upgrade cannot be elector\"\r\n        );\r\n\r\n        self._electorTypes[_TYPE] = isElector;\r\n\r\n        if (isElector) {\r\n            self._electorCount += DATASTORE.allIdsByType[_TYPE].length;\r\n        } else {\r\n            self._electorCount -= DATASTORE.allIdsByType[_TYPE].length;\r\n        }\r\n\r\n        emit ElectorTypeSet(_TYPE, isElector);\r\n    }\r\n\r\n    /**\r\n     * @notice Proposed CONTROLLER is the new Senate after 2/3 of the electors approved\r\n     * NOTE mathematically, min 4 elector is needed for (c+1)*2/3 to work properly\r\n     * @notice id can not vote if:\r\n     * - approved already\r\n     * - proposal is expired\r\n     * - not its type is elector\r\n     * - not senate proposal\r\n     * @param electorId should have the voting rights, msg.sender should be the CONTROLLER of given ID\r\n     * @dev pins id as \"voted\" when approved\r\n     * @dev increases \"approvalCount\" of proposalId by 1 when approved\r\n     */\r\n    function approveSenate(\r\n        Universe storage self,\r\n        DataStoreUtils.DataStore storage DATASTORE,\r\n        uint256 proposalId,\r\n        uint256 electorId\r\n    ) external onlyController(DATASTORE, electorId) {\r\n        require(\r\n            self._proposalForId[proposalId].TYPE == 1,\r\n            \"GeodeUtils: NOT Senate Proposal\"\r\n        );\r\n        require(\r\n            self._proposalForId[proposalId].deadline >= block.timestamp,\r\n            \"GeodeUtils: proposal expired\"\r\n        );\r\n        require(\r\n            self._electorTypes[DATASTORE.readUintForId(electorId, \"TYPE\")],\r\n            \"GeodeUtils: NOT an elector\"\r\n        );\r\n        require(\r\n            DATASTORE.readUintForId(\r\n                proposalId,\r\n                DataStoreUtils.getKey(electorId, \"voted\")\r\n            ) == 0,\r\n            \" GeodeUtils: already approved\"\r\n        );\r\n\r\n        DATASTORE.writeUintForId(\r\n            proposalId,\r\n            DataStoreUtils.getKey(electorId, \"voted\"),\r\n            1\r\n        );\r\n        DATASTORE.addUintForId(proposalId, \"approvalCount\", 1);\r\n\r\n        if (\r\n            DATASTORE.readUintForId(proposalId, \"approvalCount\") >=\r\n            ((self._electorCount + 1) * 2) / 3\r\n        ) {\r\n            self._proposalForId[proposalId].deadline = block.timestamp;\r\n            _setSenate(\r\n                self,\r\n                self._proposalForId[proposalId].CONTROLLER,\r\n                MAX_SENATE_PERIOD\r\n            );\r\n        }\r\n\r\n        emit Vote(proposalId, electorId);\r\n    }\r\n\r\n    function _setSenate(\r\n        Universe storage self,\r\n        address _newSenate,\r\n        uint256 _senatePeriod\r\n    ) internal {\r\n        self.SENATE = _newSenate;\r\n        self.SENATE_EXPIRY = block.timestamp + _senatePeriod;\r\n\r\n        emit NewSenate(self.SENATE, self.SENATE_EXPIRY);\r\n    }\r\n\r\n    /**\r\n     * @notice Get if it is allowed to change a specific contract with the current version.\r\n     * @return True if it is allowed by senate and false if not.\r\n     * @dev address(0) should return false\r\n     * @dev DO NOT TOUCH, EVER! WHATEVER YOU DEVELOP IN FUCKING 3022\r\n     **/\r\n    function isUpgradeAllowed(\r\n        Universe storage self,\r\n        address proposedImplementation\r\n    ) external view returns (bool) {\r\n        return\r\n            self.approvedUpgrade != address(0) &&\r\n            self.approvedUpgrade == proposedImplementation;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Portal/withdrawalPool/utils/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"./MathUtils.sol\";\r\nimport \"./AmplificationUtils.sol\";\r\nimport \"../../../interfaces/ILPToken.sol\";\r\nimport \"../../../interfaces/IgETH.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n *\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n *\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities with some changes.\r\n * The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals\r\n * relying on the Oracle Price, with the help of Liquidity Providers.\r\n * It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions.\r\n * Because the underlying price of the staked assets are expected to raise in time.\r\n * One can see this similar to accomplishing a \"rebasing\" logic, with the help of a trusted price source.\r\n *\r\n * @dev Whenever \"Effective Balance\" is mentioned it refers to the balance projected with underlying price.\r\n */\r\nlibrary SwapUtils {\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n\r\n    struct Swap {\r\n        IgETH gETH;\r\n        ILPToken lpToken;\r\n        uint256 pooledTokenId;\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        // gETH contract reference\r\n        // the pool balance as [ETH, gETH]\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // {add,remove} Liquidity functions to avoid stack too deep errors\r\n    struct ManageLiquidityInfo {\r\n        ILPToken lpToken;\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n        uint256 totalSupply;\r\n        uint256[] balances;\r\n    }\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee is BoughtAmount.mul(fee).div(PERCENTAGE_DENOMINATOR)\r\n    uint256 private constant PERCENTAGE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // instead it takes a certain percentage of the swapFee.\r\n    // Therefore it has no impact on users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        return AmplificationUtils._getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\r\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\r\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\r\n     * @param balance balance that will be taken into calculation\r\n     * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\r\n     */\r\n    function _pricedIn(\r\n        Swap storage self,\r\n        uint256 balance,\r\n        uint256 i\r\n    ) internal view returns (uint256) {\r\n        return\r\n            i == 1\r\n                ? (balance * self.gETH.pricePerShare(self.pooledTokenId)) /\r\n                    self.gETH.denominator()\r\n                : balance;\r\n    }\r\n\r\n    /**\r\n     * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\r\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\r\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\r\n     * @param balance balance that will be taken into calculation\r\n     * @param i if i is 0 it means we are dealing with ETH, if i is 1 it is gETH\r\n     */\r\n    function _pricedOut(\r\n        Swap storage self,\r\n        uint256 balance,\r\n        uint256 i\r\n    ) internal view returns (uint256) {\r\n        return\r\n            i == 1\r\n                ? (balance * self.gETH.denominator()) /\r\n                    self.gETH.pricePerShare(self.pooledTokenId)\r\n                : balance;\r\n    }\r\n\r\n    /**\r\n     * @notice This function MULTIPLIES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\r\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\r\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\r\n     * @param balances ARRAY of balances that will be taken into calculation\r\n     */\r\n    function _pricedInBatch(Swap storage self, uint256[] memory balances)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory _p = new uint256[](balances.length);\r\n        _p[0] = balances[0];\r\n        _p[1] =\r\n            (balances[1] * self.gETH.pricePerShare(self.pooledTokenId)) /\r\n            self.gETH.denominator();\r\n        return _p;\r\n    }\r\n\r\n    /**\r\n     * @notice This function DIVIDES the Staked Ether token (gETH) balance with underlying relative price (pricePerShare),\r\n     * to keep pricing around 1-OraclePrice instead of 1-1 like stableSwap pool.\r\n     * @dev this function assumes prices are sent with the indexes that [ETH, gETH]\r\n     * @param balances ARRAY of balances that will be taken into calculation\r\n     */\r\n    function _pricedOutBatch(Swap storage self, uint256[] memory balances)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory _p = new uint256[](balances.length);\r\n        _p[0] = balances[0];\r\n        _p[1] =\r\n            (balances[1] * self.gETH.denominator()) /\r\n            self.gETH.pricePerShare(self.pooledTokenId);\r\n        return _p;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            self.lpToken.totalSupply()\r\n        );\r\n        return availableTokenAmount;\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n        uint256 currentY;\r\n\r\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\r\n            self,\r\n            tokenIndex,\r\n            tokenAmount,\r\n            totalSupply\r\n        );\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = currentY - newY - dy;\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 totalSupply\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n\r\n        require(tokenIndex < 2, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(_pricedInBatch(self, self.balances), v.preciseA);\r\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\r\n\r\n        require(\r\n            tokenAmount <= self.balances[tokenIndex],\r\n            \"Withdraw exceeds available\"\r\n        );\r\n\r\n        v.newY = _pricedOut(\r\n            self,\r\n            getYD(\r\n                v.preciseA,\r\n                tokenIndex,\r\n                _pricedInBatch(self, self.balances),\r\n                v.d1\r\n            ),\r\n            tokenIndex\r\n        );\r\n\r\n        uint256[] memory xpReduced = new uint256[](2);\r\n\r\n        v.feePerToken = self.swapFee / 2;\r\n        for (uint256 i = 0; i < 2; i++) {\r\n            uint256 xpi = self.balances[i];\r\n            xpReduced[i] =\r\n                xpi -\r\n                (((\r\n                    (i == tokenIndex)\r\n                        ? (xpi * v.d1) / v.d0 - v.newY\r\n                        : xpi - ((xpi * v.d1) / (v.d0))\r\n                ) * (v.feePerToken)) / (PERCENTAGE_DENOMINATOR));\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex] -\r\n            _pricedOut(\r\n                self,\r\n                (\r\n                    getYD(\r\n                        v.preciseA,\r\n                        tokenIndex,\r\n                        _pricedInBatch(self, xpReduced),\r\n                        v.d1\r\n                    )\r\n                ),\r\n                tokenIndex\r\n            );\r\n        dy = dy - 1;\r\n\r\n        return (dy, v.newY, self.balances[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Get Debt, The amount of buyback for stable pricing.\r\n     * @param xp a  set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\r\n     */\r\n    function _getDebt(\r\n        Swap storage self,\r\n        uint256[] memory xp,\r\n        uint256 a\r\n    ) internal view returns (uint256) {\r\n        uint256 halfD = getD(xp, a) / 2;\r\n        if (xp[0] >= halfD) {\r\n            return 0;\r\n        } else {\r\n            uint256 dy = xp[1] - halfD;\r\n            uint256 feeHalf = (dy * self.swapFee) / PERCENTAGE_DENOMINATOR / 2;\r\n            uint256 debt = halfD - xp[0] + feeHalf;\r\n            return debt;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\r\n     */\r\n    function getDebt(Swap storage self) external view returns (uint256) {\r\n        // might change when price is in.\r\n        return\r\n            _getDebt(\r\n                self,\r\n                _pricedInBatch(self, self.balances),\r\n                _getAPrecise(self)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     *  balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a  set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = 2;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a * numTokens;\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s + xp[i];\r\n                c = (c * d) / (xp[i] * (numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\r\n\r\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = ((y * y) + c) / (2 * y + b - d);\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a  set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = 2;\r\n        uint256 s = xp[0] + xp[1];\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a * numTokens;\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = (d**(numTokens + 1)) /\r\n                (numTokens**numTokens * xp[0] * xp[1]);\r\n            prevD = d;\r\n            d =\r\n                ((((nA * s) / AmplificationUtils.A_PRECISION) +\r\n                    dP *\r\n                    numTokens) * (d)) /\r\n                (((nA - AmplificationUtils.A_PRECISION) * (d)) /\r\n                    (AmplificationUtils.A_PRECISION) +\r\n                    ((numTokens + 1) * dP));\r\n\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price\r\n     */\r\n    function getVirtualPrice(Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 d = getD(\r\n            _pricedInBatch(self, self.balances),\r\n            _getAPrecise(self)\r\n        );\r\n        ILPToken lpToken = self.lpToken;\r\n        uint256 supply = lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return (d * 10**18) / supply;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = 2;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s = x;\r\n        uint256 nA = numTokens * (preciseA);\r\n\r\n        c = (c * d) / (x * numTokens);\r\n        c = (c * d * (AmplificationUtils.A_PRECISION)) / (nA * numTokens);\r\n        uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\r\n\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = ((y * y) + c) / (2 * y + b - d);\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            self.balances\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256[] memory balances\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        require(\r\n            tokenIndexFrom < balances.length && tokenIndexTo < balances.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 x = _pricedIn(\r\n            self,\r\n            dx + balances[tokenIndexFrom],\r\n            tokenIndexFrom\r\n        );\r\n\r\n        uint256[] memory pricedBalances = _pricedInBatch(self, balances);\r\n\r\n        uint256 y = _pricedOut(\r\n            self,\r\n            getY(\r\n                _getAPrecise(self),\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                x,\r\n                pricedBalances\r\n            ),\r\n            tokenIndexTo // => not id, index !!!\r\n        );\r\n        dy = balances[tokenIndexTo] - y - 1;\r\n        dyFee = (dy * self.swapFee) / (PERCENTAGE_DENOMINATOR);\r\n        dy = dy - dyFee;\r\n    }\r\n\r\n    /**\r\n     * @notice Uses _calculateRemoveLiquidity with Effective Balances,\r\n     * then projects the prices to the token amounts\r\n     * to get Real Balances, before removing them from pool.\r\n     */\r\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return\r\n            _pricedOutBatch(\r\n                self,\r\n                _calculateRemoveLiquidity(\r\n                    _pricedInBatch(self, self.balances),\r\n                    amount,\r\n                    self.lpToken.totalSupply()\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function _calculateRemoveLiquidity(\r\n        uint256[] memory balances,\r\n        uint256 amount,\r\n        uint256 totalSupply\r\n    ) internal pure returns (uint256[] memory) {\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256[] memory amounts = new uint256[](2);\r\n\r\n        amounts[0] = (balances[0] * amount) / totalSupply;\r\n        amounts[1] = (balances[1] * amount) / totalSupply;\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = _getAPrecise(self);\r\n        uint256[] memory balances = self.balances;\r\n\r\n        uint256 d0 = getD(_pricedInBatch(self, balances), a);\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            if (deposit) {\r\n                balances[i] = balances[i] + amounts[i];\r\n            } else {\r\n                require(\r\n                    amounts[i] <= balances[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n                balances[i] = balances[i] - amounts[i];\r\n            }\r\n        }\r\n        uint256 d1 = getD(_pricedInBatch(self, balances), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return ((d1 - d0) * totalSupply) / d0;\r\n        } else {\r\n            return ((d0 - d1) * totalSupply) / d0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < 2, \"Token index out of range\");\r\n        if (index == 0) return address(this).balance - (self.balances[index]);\r\n\r\n        if (index == 1)\r\n            return\r\n                self.gETH.balanceOf(address(this), self.pooledTokenId) -\r\n                (self.balances[index]);\r\n        return 0;\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        IgETH gETHReference = self.gETH;\r\n        if (tokenIndexFrom == 0) {\r\n            // Means user is selling some ETH to the pool to get some gETH.\r\n            // In which case, we need to send exactly that amount of ETH.\r\n            require(dx == msg.value, \"Cannot swap more/less than you sent\");\r\n        }\r\n        if (tokenIndexFrom == 1) {\r\n            // Means user is selling some gETH to the pool to get some ETH.\r\n\r\n            require(\r\n                dx <= gETHReference.balanceOf(msg.sender, self.pooledTokenId),\r\n                \"Cannot swap more than you own\"\r\n            );\r\n\r\n            // Transfer tokens first\r\n            uint256 beforeBalance = gETHReference.balanceOf(\r\n                address(this),\r\n                self.pooledTokenId\r\n            );\r\n            gETHReference.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                self.pooledTokenId,\r\n                dx,\r\n                \"\"\r\n            );\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            dx =\r\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\r\n                beforeBalance;\r\n        }\r\n\r\n        uint256 dy;\r\n        uint256 dyFee;\r\n        // Meaning the real balances *without* any effect of underlying price\r\n        // However, when we call _calculateSwap, it uses pricedIn function before calculation,\r\n        // and pricedOut function after the calculation. So, we don't need to use priceOut here.\r\n        uint256[] memory balances = self.balances;\r\n        (dy, dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            balances\r\n        );\r\n\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n        uint256 dyAdminFee = (dyFee * self.adminFee) / PERCENTAGE_DENOMINATOR;\r\n\r\n        // To prevent any Reentrancy, balances are updated before transfering the tokens.\r\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\r\n        self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\r\n\r\n        if (tokenIndexTo == 0) {\r\n            // Means contract is going to send Idle Ether (ETH)\r\n            (bool sent, ) = payable(msg.sender).call{value: dy}(\"\");\r\n            require(sent, \"SwapUtils: Failed to send Ether\");\r\n        }\r\n        if (tokenIndexTo == 1) {\r\n            // Means contract is going to send staked ETH (gETH)\r\n            gETHReference.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                self.pooledTokenId,\r\n                dy,\r\n                \"\"\r\n            );\r\n        }\r\n\r\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint\r\n    ) external returns (uint256) {\r\n        require(amounts.length == 2, \"Amounts must match pooled tokens\");\r\n        require(\r\n            amounts[0] == msg.value,\r\n            \"SwapUtils: received less or more ETH than expected\"\r\n        );\r\n        IgETH gETHReference = self.gETH;\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            self.lpToken,\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            0,\r\n            self.balances\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\r\n        }\r\n\r\n        uint256[] memory newBalances = new uint256[](2);\r\n        newBalances[0] = v.balances[0] + msg.value;\r\n\r\n        for (uint256 i = 0; i < 2; i++) {\r\n            require(\r\n                v.totalSupply != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n        }\r\n\r\n        {\r\n            // Transfer tokens first\r\n            uint256 beforeBalance = gETHReference.balanceOf(\r\n                address(this),\r\n                self.pooledTokenId\r\n            );\r\n            gETHReference.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                self.pooledTokenId,\r\n                amounts[1],\r\n                \"\"\r\n            );\r\n\r\n            // Update the amounts[] with actual transfer amount\r\n            amounts[1] =\r\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\r\n                beforeBalance;\r\n\r\n            newBalances[1] = v.balances[1] + amounts[1];\r\n        }\r\n\r\n        // invariant after change\r\n        v.d1 = getD(_pricedInBatch(self, newBalances), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256[] memory fees = new uint256[](2);\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = self.swapFee / 2;\r\n            for (uint256 i = 0; i < 2; i++) {\r\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\r\n                fees[i] =\r\n                    (feePerToken * (idealBalance.difference(newBalances[i]))) /\r\n                    (PERCENTAGE_DENOMINATOR);\r\n                self.balances[i] =\r\n                    newBalances[i] -\r\n                    ((fees[i] * (self.adminFee)) / (PERCENTAGE_DENOMINATOR));\r\n                newBalances[i] = newBalances[i] - (fees[i]);\r\n            }\r\n            v.d2 = getD(_pricedInBatch(self, newBalances), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (v.totalSupply == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        v.lpToken.mint(msg.sender, toMint);\r\n\r\n        emit AddLiquidity(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply + toMint\r\n        );\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts\r\n    ) external returns (uint256[] memory) {\r\n        ILPToken lpToken = self.lpToken;\r\n        IgETH gETHReference = self.gETH;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(minAmounts.length == 2, \"minAmounts must match poolTokens\");\r\n\r\n        uint256[] memory balances = self.balances;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        uint256[] memory amounts = _pricedOutBatch(\r\n            self,\r\n            _calculateRemoveLiquidity(\r\n                _pricedInBatch(self, balances),\r\n                amount,\r\n                totalSupply\r\n            )\r\n        );\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = balances[i] - amounts[i];\r\n        }\r\n\r\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\"\");\r\n        require(sent, \"SwapUtils: Failed to send Ether\");\r\n\r\n        gETHReference.safeTransferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            self.pooledTokenId,\r\n            amounts[1],\r\n            \"\"\r\n        );\r\n\r\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        ILPToken lpToken = self.lpToken;\r\n        IgETH gETHReference = self.gETH;\r\n\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < 2, \"Token not found\");\r\n\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            totalSupply\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\r\n        self.balances[tokenIndex] =\r\n            self.balances[tokenIndex] -\r\n            (dy + ((dyFee * (self.adminFee)) / (PERCENTAGE_DENOMINATOR)));\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        if (tokenIndex == 0) {\r\n            (bool sent, ) = payable(msg.sender).call{value: dy}(\"\");\r\n            require(sent, \"SwapUtils: Failed to send Ether\");\r\n        }\r\n        if (tokenIndex == 1) {\r\n            gETHReference.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                self.pooledTokenId,\r\n                dy,\r\n                \"\"\r\n            );\r\n        }\r\n\r\n        emit RemoveLiquidityOne(\r\n            msg.sender,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        IgETH gETHReference = self.gETH;\r\n\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            self.lpToken,\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            0,\r\n            self.balances\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        require(amounts.length == 2, \"Amounts should match pool tokens\");\r\n\r\n        require(\r\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\r\n                maxBurnAmount != 0,\r\n            \">LP.balanceOf\"\r\n        );\r\n\r\n        uint256 feePerToken = self.swapFee / 2;\r\n        uint256[] memory fees = new uint256[](2);\r\n\r\n        {\r\n            uint256[] memory balances1 = new uint256[](2);\r\n\r\n            v.d0 = getD(_pricedInBatch(self, v.balances), v.preciseA);\r\n            for (uint256 i = 0; i < 2; i++) {\r\n                require(\r\n                    amounts[i] <= v.balances[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n                balances1[i] = v.balances[i] - amounts[i];\r\n            }\r\n            v.d1 = getD(_pricedInBatch(self, balances1), v.preciseA);\r\n\r\n            for (uint256 i = 0; i < 2; i++) {\r\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = (feePerToken * difference) / PERCENTAGE_DENOMINATOR;\r\n                uint256 adminFee = self.adminFee;\r\n                {\r\n                    self.balances[i] =\r\n                        balances1[i] -\r\n                        ((fees[i] * adminFee) / PERCENTAGE_DENOMINATOR);\r\n                }\r\n                balances1[i] = balances1[i] - fees[i];\r\n            }\r\n\r\n            v.d2 = getD(_pricedInBatch(self, balances1), v.preciseA);\r\n        }\r\n\r\n        uint256 tokenAmount = ((v.d0 - v.d2) * (v.totalSupply)) / v.d0;\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount + 1;\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        // To prevent any Reentrancy, LP tokens are burned before transfering the tokens.\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        (bool sent, ) = payable(msg.sender).call{value: amounts[0]}(\"\");\r\n        require(sent, \"SwapUtils: Failed to send Ether\");\r\n\r\n        gETHReference.safeTransferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            self.pooledTokenId,\r\n            amounts[1],\r\n            \"\"\r\n        );\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply - tokenAmount\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice donate ETH and gETH to the pool as fee with respect to derivative price\r\n     * @param self Swap struct to deposit fees\r\n     * @param EthDonation amount of ETH to donate into the pool\r\n     * @param gEthDonation amount of gETH to donate into the pool\r\n     */\r\n    function donateBalancedFees(\r\n        Swap storage self,\r\n        uint256 EthDonation,\r\n        uint256 gEthDonation\r\n    ) external returns (uint256, uint256) {\r\n        {\r\n            IgETH gETHReference = self.gETH;\r\n            // Transfer tokens first\r\n            uint256 beforeBalance = gETHReference.balanceOf(\r\n                address(this),\r\n                self.pooledTokenId\r\n            );\r\n            gETHReference.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                self.pooledTokenId,\r\n                gEthDonation,\r\n                \"\"\r\n            );\r\n\r\n            // Use the actual transferred amount\r\n            gEthDonation =\r\n                gETHReference.balanceOf(address(this), self.pooledTokenId) -\r\n                beforeBalance;\r\n        }\r\n        require(\r\n            _pricedIn(self, gEthDonation, 1) == EthDonation,\r\n            \"SwapUtils: MUST respect to derivative price\"\r\n        );\r\n        self.balances[0] +=\r\n            EthDonation -\r\n            (EthDonation * self.adminFee) /\r\n            PERCENTAGE_DENOMINATOR;\r\n        self.balances[1] +=\r\n            gEthDonation -\r\n            (gEthDonation * self.adminFee) /\r\n            PERCENTAGE_DENOMINATOR;\r\n        return (EthDonation, gEthDonation);\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external {\r\n        IgETH gETHReference = self.gETH;\r\n        uint256 tokenBalance = gETHReference.balanceOf(\r\n            address(this),\r\n            self.pooledTokenId\r\n        ) - self.balances[1];\r\n        if (tokenBalance != 0) {\r\n            gETHReference.safeTransferFrom(\r\n                address(this),\r\n                to,\r\n                self.pooledTokenId,\r\n                tokenBalance,\r\n                \"\"\r\n            );\r\n        }\r\n\r\n        uint256 etherBalance = address(this).balance - self.balances[0];\r\n        if (etherBalance != 0) {\r\n            (bool sent, ) = payable(msg.sender).call{value: etherBalance}(\"\");\r\n            require(sent, \"SwapUtils: Failed to send Ether\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/withdrawalPool/utils/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\n/**\r\n * @title MathUtils library\r\n * @notice  Contains functions for calculating differences between two uint256.\r\n */\r\nlibrary MathUtils {\r\n    /**\r\n     * @notice Compares a and b and returns true if the difference between a and b\r\n     *         is less than 1 or equal to each other.\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return True if the difference between a and b is less than 1 or equal,\r\n     *         otherwise return false\r\n     */\r\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return (difference(a, b) <= 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a - b;\r\n        }\r\n        return b - a;\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/withdrawalPool/utils/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"./SwapUtils.sol\";\r\n\r\n/**\r\n * @title AmplificationUtils library\r\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\r\n * This library assumes the struct is fully validated.\r\n */\r\nlibrary AmplificationUtils {\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self) / (A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(SwapUtils.Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(SwapUtils.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        SwapUtils.Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) external {\r\n        require(\r\n            block.timestamp >= self.initialATime + 1 days,\r\n            \"Wait 1 day before starting ramp\"\r\n        );\r\n        require(\r\n            futureTime_ >= block.timestamp + MIN_RAMP_TIME,\r\n            \"Insufficient ramp time\"\r\n        );\r\n        require(\r\n            futureA_ > 0 && futureA_ < MAX_A,\r\n            \"futureA_ must be > 0 and < MAX_A\"\r\n        );\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(\r\n                futureAPrecise * MAX_A_CHANGE >= initialAPrecise,\r\n                \"futureA_ is too small\"\r\n            );\r\n        } else {\r\n            require(\r\n                futureAPrecise <= initialAPrecise * MAX_A_CHANGE,\r\n                \"futureA_ is too large\"\r\n            );\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(\r\n            initialAPrecise,\r\n            futureAPrecise,\r\n            block.timestamp,\r\n            futureTime_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(SwapUtils.Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n\r\n        uint256 currentA = _getAPrecise(self);\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/ERC1155SupplyMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MITs\r\n\r\npragma solidity =0.8.7;\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\r\n\r\n/**\r\n * ERC1155SupplyMinterPauser is an ERC1155 implementation that inherites 2 openzeppelin contracts: ERC1155Supply and ERC1155PresetMinterPauser\r\n *\r\n * @dev only difference between ERC1155SupplyMinterPauser and Openzeppelin's implementation is\r\n * _doSafeTransferAcceptanceCheck is being virtual.\r\n *\r\n * TO REPRODUCE the ERC1155SupplyMinterPauser on diffchecker link::\r\n * Formatter: Prettier: https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode\r\n * 0. Open a new file on vscode: ERC1155SupplyMinterPauser.sol (or name it whatever you want with .sol extension)\r\n *\r\n * 1. put ERC1155: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cb3f2ab900e39c5ab6e0de6663edf06f573b834f/contracts/token/ERC1155/ERC1155.sol\r\n * 1.2 delete imports and comments on top of the contract.\r\n *\r\n * 2. put this under the file ERC1155Burnable: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cb3f2ab900e39c5ab6e0de6663edf06f573b834f/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\r\n * 2.2 delete imports and comments on top of the contract.\r\n *\r\n * 3. put this under the file ERC1155Pausable: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cb3f2ab900e39c5ab6e0de6663edf06f573b834f/contracts/token/ERC1155/extensions/ERC1155Pausable.sol\r\n * 3.2 delete imports and comments on top of the contract.\r\n *\r\n * 4. put this under the file ERC1155Supply: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cb3f2ab900e39c5ab6e0de6663edf06f573b834f/contracts/token/ERC1155/extensions/ERC1155Supply.sol\r\n * 4.2 delete imports and comments on top of the contract.\r\n *\r\n * 5. put this under the file ERC1155PresetMinterPauser: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cb3f2ab900e39c5ab6e0de6663edf06f573b834f/contracts/token/ERC1155/presets/ERC1155PresetMinterPauser.sol\r\n * 5.2 delete imports and comments on top of the contract.\r\n *\r\n * 6. refactor the file with prettier\r\n * 7. compare it with our local ERC1155SupplyMinterPauser.sol\r\n * 8. only changes we did are the same with the https://www.diffchecker.com/UOAdD16A\r\n */\r\n\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            account != address(0),\r\n            \"ERC1155: address zero is not a valid owner\"\r\n        );\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(\r\n            accounts.length == ids.length,\r\n            \"ERC1155: accounts and ids length mismatch\"\r\n        );\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not token owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not token owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC1155: insufficient balance for transfer\"\r\n        );\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(\r\n                fromBalance >= amount,\r\n                \"ERC1155: insufficient balance for transfer\"\r\n            );\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(\r\n            operator,\r\n            from,\r\n            to,\r\n            ids,\r\n            amounts,\r\n            data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _doSafeTransferAcceptanceCheck(\r\n            operator,\r\n            address(0),\r\n            to,\r\n            id,\r\n            amount,\r\n            data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(\r\n            operator,\r\n            address(0),\r\n            to,\r\n            ids,\r\n            amounts,\r\n            data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `from`\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(\r\n            ids.length == amounts.length,\r\n            \"ERC1155: ids and amounts length mismatch\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(\r\n                fromBalance >= amount,\r\n                \"ERC1155: burn amount exceeds balance\"\r\n            );\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155Received(\r\n                    operator,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155BatchReceived(\r\n                    operator,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element)\r\n        private\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\nabstract contract ERC1155Burnable is ERC1155 {\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not token owner nor approved\"\r\n        );\r\n\r\n        _burn(account, id, value);\r\n    }\r\n\r\n    function burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory values\r\n    ) public virtual {\r\n        require(\r\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\r\n            \"ERC1155: caller is not token owner nor approved\"\r\n        );\r\n\r\n        _burnBatch(account, ids, values);\r\n    }\r\n}\r\n\r\nabstract contract ERC1155Pausable is ERC1155, Pausable {\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the contract must not be paused.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\r\n    }\r\n}\r\n\r\nabstract contract ERC1155Supply is ERC1155 {\r\n    mapping(uint256 => uint256) private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total amount of tokens in with a given id.\r\n     */\r\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\r\n        return _totalSupply[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Indicates whether any token exist with a given id, or not.\r\n     */\r\n    function exists(uint256 id) public view virtual returns (bool) {\r\n        return ERC1155Supply.totalSupply(id) > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                uint256 id = ids[i];\r\n                uint256 amount = amounts[i];\r\n                uint256 supply = _totalSupply[id];\r\n                require(\r\n                    supply >= amount,\r\n                    \"ERC1155: burn amount exceeds totalSupply\"\r\n                );\r\n                unchecked {\r\n                    _totalSupply[id] = supply - amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC1155SupplyMinterPauser is\r\n    Context,\r\n    AccessControlEnumerable,\r\n    ERC1155Burnable,\r\n    ERC1155Pausable,\r\n    ERC1155Supply\r\n{\r\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n    /**\r\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\r\n     * deploys the contract.\r\n     */\r\n    constructor(string memory uri) ERC1155(uri) {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n\r\n        _setupRole(MINTER_ROLE, _msgSender());\r\n        _setupRole(PAUSER_ROLE, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\r\n     *\r\n     * See {ERC1155-_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `MINTER_ROLE`.\r\n     */\r\n    function mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            hasRole(MINTER_ROLE, _msgSender()),\r\n            \"ERC1155PresetMinterPauser: must have minter role to mint\"\r\n        );\r\n\r\n        _mint(to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\r\n     */\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            hasRole(MINTER_ROLE, _msgSender()),\r\n            \"ERC1155PresetMinterPauser: must have minter role to mint\"\r\n        );\r\n\r\n        _mintBatch(to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses all token transfers.\r\n     *\r\n     * See {ERC1155Pausable} and {Pausable-_pause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function pause() public virtual {\r\n        require(\r\n            hasRole(PAUSER_ROLE, _msgSender()),\r\n            \"ERC1155PresetMinterPauser: must have pauser role to pause\"\r\n        );\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses all token transfers.\r\n     *\r\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `PAUSER_ROLE`.\r\n     */\r\n    function unpause() public virtual {\r\n        require(\r\n            hasRole(PAUSER_ROLE, _msgSender()),\r\n            \"ERC1155PresetMinterPauser: must have pauser role to unpause\"\r\n        );\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(AccessControlEnumerable, ERC1155)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override(ERC1155, ERC1155Pausable, ERC1155Supply) {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/Portal/helpers/test/ERC1155ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\ncontract ERC1155ReceiverMock is ERC165, IERC1155Receiver {\r\n    bytes4 private _recRetval;\r\n    bool private _recReverts;\r\n    bytes4 private _batRetval;\r\n    bool private _batReverts;\r\n\r\n    event Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes data,\r\n        uint256 gas\r\n    );\r\n    event BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] ids,\r\n        uint256[] values,\r\n        bytes data,\r\n        uint256 gas\r\n    );\r\n\r\n    constructor(\r\n        bytes4 recRetval,\r\n        bool recReverts,\r\n        bytes4 batRetval,\r\n        bool batReverts\r\n    ) {\r\n        _recRetval = recRetval;\r\n        _recReverts = recReverts;\r\n        _batRetval = batRetval;\r\n        _batReverts = batReverts;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");\r\n        emit Received(operator, from, id, value, data, gasleft());\r\n        return _recRetval;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        require(\r\n            !_batReverts,\r\n            \"ERC1155ReceiverMock: reverting on batch receive\"\r\n        );\r\n        emit BatchReceived(operator, from, ids, values, data, gasleft());\r\n        return _batRetval;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/Portal/withdrawalPool/helpers/test/TestSwapReturnValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\r\nimport \"../../../../interfaces/ISwap.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ncontract TestSwapReturnValues is ERC1155Holder {\r\n    using SafeMath for uint256;\r\n\r\n    ISwap public swap;\r\n    IERC1155 public gETH;\r\n    IERC20 public lpToken;\r\n    uint8 public n;\r\n\r\n    uint256 public constant MAX_INT = 2**256 - 1;\r\n\r\n    constructor(\r\n        ISwap swapContract,\r\n        IERC1155 gETHReference,\r\n        IERC20 lpTokenContract,\r\n        uint8 numOfTokens\r\n    ) {\r\n        swap = swapContract;\r\n        gETH = gETHReference;\r\n        lpToken = lpTokenContract;\r\n        n = numOfTokens;\r\n\r\n        // Pre-approve tokens\r\n        gETH.setApprovalForAll(address(swap), true);\r\n        lpToken.approve(address(swap), MAX_INT);\r\n    }\r\n\r\n    function test_swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) public payable {\r\n        uint256 etherbalanceBefore = address(this).balance;\r\n        uint256 getherbalanceBefore = gETH.balanceOf(\r\n            address(this),\r\n            swap.getToken()\r\n        );\r\n\r\n        if (tokenIndexFrom == 0) {\r\n            // If ether to gether\r\n            uint256 returnValue = swap.swap{value: msg.value}(\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx,\r\n                minDy,\r\n                block.timestamp\r\n            );\r\n\r\n            uint256 getherbalanceAfter = gETH.balanceOf(\r\n                address(this),\r\n                swap.getToken()\r\n            );\r\n\r\n            require(\r\n                returnValue == getherbalanceAfter.sub(getherbalanceBefore),\r\n                \"swap()'s return value does not match received gether amount\"\r\n            );\r\n        } else {\r\n            uint256 returnValue = swap.swap(\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx,\r\n                minDy,\r\n                block.timestamp\r\n            );\r\n\r\n            uint256 etherbalanceAfter = address(this).balance;\r\n\r\n            require(\r\n                returnValue == etherbalanceAfter.sub(etherbalanceBefore),\r\n                \"swap()'s return value does not match received ether amount\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function test_addLiquidity(uint256[] calldata amounts, uint256 minToMint)\r\n        public\r\n        payable\r\n    {\r\n        require(\r\n            msg.value == amounts[0],\r\n            \"The update of about ETH amount -0xCypher\"\r\n        );\r\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\r\n        uint256 returnValue = swap.addLiquidity{value: msg.value}(\r\n            amounts,\r\n            minToMint,\r\n            MAX_INT\r\n        );\r\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\r\n\r\n        console.log(\r\n            \"addLiquidity: Expected %s, got %s\",\r\n            balanceAfter.sub(balanceBefore),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceAfter.sub(balanceBefore),\r\n            \"addLiquidity()'s return value does not match minted amount\"\r\n        );\r\n    }\r\n\r\n    function test_removeLiquidity(uint256 amount, uint256[] memory minAmounts)\r\n        public\r\n    {\r\n        uint256[] memory balanceBefore = new uint256[](n);\r\n        uint256[] memory balanceAfter = new uint256[](n);\r\n\r\n        balanceBefore[0] = address(this).balance;\r\n        balanceBefore[1] = gETH.balanceOf(address(this), swap.getToken());\r\n\r\n        uint256[] memory returnValue = swap.removeLiquidity(\r\n            amount,\r\n            minAmounts,\r\n            MAX_INT\r\n        );\r\n        balanceAfter[0] = address(this).balance;\r\n        balanceAfter[1] = gETH.balanceOf(address(this), swap.getToken());\r\n\r\n        for (uint8 i = 0; i < n; i++) {\r\n            console.log(\r\n                \"removeLiquidity: Expected %s, got %s\",\r\n                balanceAfter[i].sub(balanceBefore[i]),\r\n                returnValue[i]\r\n            );\r\n            require(\r\n                balanceAfter[i].sub(balanceBefore[i]) == returnValue[i],\r\n                \"removeLiquidity()'s return value does not match received amounts of tokens\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function test_removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount\r\n    ) public {\r\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\r\n        uint256 returnValue = swap.removeLiquidityImbalance(\r\n            amounts,\r\n            maxBurnAmount,\r\n            MAX_INT\r\n        );\r\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\r\n\r\n        console.log(\r\n            \"removeLiquidityImbalance: Expected %s, got %s\",\r\n            balanceBefore.sub(balanceAfter),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceBefore.sub(balanceAfter),\r\n            \"removeLiquidityImbalance()'s return value does not match burned lpToken amount\"\r\n        );\r\n    }\r\n\r\n    function test_removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) public {\r\n        uint256 balanceBefore;\r\n        if (tokenIndex == 0) {\r\n            balanceBefore = address(this).balance;\r\n        } else {\r\n            balanceBefore = gETH.balanceOf(address(this), swap.getToken());\r\n        }\r\n        uint256 returnValue = swap.removeLiquidityOneToken(\r\n            tokenAmount,\r\n            tokenIndex,\r\n            minAmount,\r\n            MAX_INT\r\n        );\r\n\r\n        uint256 balanceAfter;\r\n        if (tokenIndex == 0) {\r\n            balanceAfter = address(this).balance;\r\n        } else {\r\n            balanceAfter = gETH.balanceOf(address(this), swap.getToken());\r\n        }\r\n        console.log(\r\n            \"removeLiquidityOneToken: Expected %s, got %s\",\r\n            balanceAfter.sub(balanceBefore),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceAfter.sub(balanceBefore),\r\n            \"removeLiquidityOneToken()'s return value does not match received token amount\"\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Portal/withdrawalPool/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\nimport \"./helpers/OwnerPausableUpgradeable.sol\";\r\nimport \"./utils/SwapUtils.sol\";\r\nimport \"./utils/AmplificationUtils.sol\";\r\nimport \"../../interfaces/ISwap.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n * @dev The main functionality of Withdrawal Pools is allowing the depositors to have instant withdrawals\r\n * relying on the Oracle Price, with the help of Liquidity Providers.\r\n * It is important to change the focus point (1-1) of the pricing algorithm with PriceIn and PriceOut functions.\r\n * Because the underlying price of the staked assets are expected to raise in time.\r\n * One can see this similar to accomplishing a \"rebasing\" logic, with the help of a trusted price source.\r\n */\r\ncontract Swap is\r\n    ISwap,\r\n    OwnerPausableUpgradeable,\r\n    ReentrancyGuardUpgradeable,\r\n    ERC1155HolderUpgradeable\r\n{\r\n    using SwapUtils for SwapUtils.Swap;\r\n    using AmplificationUtils for SwapUtils.Swap;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\r\n    SwapUtils.Swap public swapStorage;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _gETH reference of the ERC1155 contract\r\n     * @param _pooledTokenId gEther ID that the Pool is operating with\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IgETH _gETH,\r\n        uint256 _pooledTokenId,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public virtual override initializer returns (address) {\r\n        __OwnerPausable_init();\r\n        __ReentrancyGuard_init();\r\n        __ERC1155Holder_init();\r\n\r\n        require(\r\n            lpTokenTargetAddress != address(0),\r\n            \"Swap: lpTokenTargetAddress can not be zero\"\r\n        );\r\n        require(address(_gETH) != address(0), \"Swap: _gETH can not be zero\");\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < AmplificationUtils.MAX_A, \"Swap: _a exceeds maximum\");\r\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"Swap: _fee exceeds maximum\");\r\n        require(\r\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\r\n            \"Swap: _adminFee exceeds maximum\"\r\n        );\r\n\r\n        // Clone and initialize a LPToken contract\r\n        ILPToken lpToken = ILPToken(Clones.clone(lpTokenTargetAddress));\r\n        require(\r\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\r\n            \"Swap: could not init lpToken clone\"\r\n        );\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.gETH = _gETH;\r\n        swapStorage.lpToken = lpToken;\r\n        swapStorage.pooledTokenId = _pooledTokenId;\r\n        swapStorage.balances = new uint256[](2);\r\n        swapStorage.initialA = _a * AmplificationUtils.A_PRECISION;\r\n        swapStorage.futureA = _a * AmplificationUtils.A_PRECISION;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n        return address(lpToken);\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check deadline against current timestamp\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 deadline) {\r\n        require(block.timestamp <= deadline, \"Swap: Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n    function getERC1155() external view virtual override returns (address) {\r\n        return address(swapStorage.gETH);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view virtual override returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view virtual override returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return id of the pooled token\r\n     * @return id of the pooled gEther token\r\n     */\r\n    function getSwapFee() external view virtual override returns (uint256) {\r\n        return swapStorage.swapFee;\r\n    }\r\n\r\n    function getToken() external view virtual override returns (uint256) {\r\n        return swapStorage.pooledTokenId;\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 index)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(index < 2, \"Swap: Index out of range\");\r\n        return swapStorage.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price\r\n     */\r\n    function getVirtualPrice()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Debt, The amount of buyback for stable pricing (1=1).\r\n     * @return debt the half of the D StableSwap invariant when debt is needed to be payed.\r\n     */\r\n    function getDebt() external view virtual override returns (uint256) {\r\n        // might change when price is in.\r\n        return swapStorage.getDebt();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view virtual override returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.calculateTokenAmount(amounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.calculateRemoveLiquidity(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view virtual override returns (uint256 availableTokenAmount) {\r\n        return swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 index)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.getAdminBalance(index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.addLiquidity(amounts, minToMint);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        deadlineCheck(deadline)\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.removeLiquidity(amount, minAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            swapStorage.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice donate ether as fee, respecting the admin fee\r\n     * @return amount of fees paid, basically EthDonation and gEthDonation if successful\r\n     */\r\n    function donateBalancedFees(uint256 EthDonation, uint256 gEthDonation)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        returns (uint256, uint256)\r\n    {\r\n        require(\r\n            msg.value == EthDonation,\r\n            \"Swap: received less or more ETH than expected\"\r\n        );\r\n        return swapStorage.donateBalancedFees(EthDonation, gEthDonation);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner\r\n     */\r\n    function withdrawAdminFees()\r\n        external\r\n        virtual\r\n        override\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        swapStorage.withdrawAdminFees(owner());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(uint256 newAdminFee)\r\n        external\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        swapStorage.setAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 newSwapFee)\r\n        external\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        swapStorage.setSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param futureA the new A to ramp towards\r\n     * @param futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 futureA, uint256 futureTime)\r\n        external\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        swapStorage.rampA(futureA, futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external virtual override onlyOwner {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/withdrawalPool/helpers/OwnerPausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\n\r\n/**\r\n * @title OwnerPausable\r\n * @notice An ownable contract allows the owner to pause and unpause the\r\n * contract without a delay.\r\n * @dev Only methods using the provided modifiers will be paused.\r\n */\r\nabstract contract OwnerPausableUpgradeable is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable\r\n{\r\n    function __OwnerPausable_init() internal onlyInitializing {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    /**\r\n     * @notice Pause the contract. Revert if already paused.\r\n     */\r\n    function pause() external onlyOwner {\r\n        PausableUpgradeable._pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause the contract. Revert if already unpaused.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        PausableUpgradeable._unpause();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Portal/withdrawalPool/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n * @dev Only Swap contracts should initialize and own LPToken contracts.\r\n */\r\ncontract LPToken is ERC20BurnableUpgradeable, OwnableUpgradeable {\r\n    /**\r\n     * @notice Initializes this LPToken contract with the given name and symbol\r\n     * @dev The caller of this function will become the owner. A Swap contract should call this\r\n     * in its initializer function.\r\n     * @param name name of this token\r\n     * @param symbol symbol of this token\r\n     */\r\n    function initialize(string memory name, string memory symbol)\r\n        external\r\n        initializer\r\n        returns (bool)\r\n    {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name, symbol);\r\n        __Ownable_init_unchained();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner {\r\n        require(amount != 0, \"LPToken: cannot mint 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\r\n     * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\r\n     * This assumes the owner is set to a Swap contract's address.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override(ERC20Upgradeable) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        require(to != address(this), \"LPToken: cannot send to itself\");\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/Portal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n//   ██████╗ ███████╗ ██████╗ ██████╗ ███████╗    ██████╗  ██████╗ ██████╗ ████████╗ █████╗ ██╗\r\n//  ██╔════╝ ██╔════╝██╔═══██╗██╔══██╗██╔════╝    ██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██╔══██╗██║\r\n//  ██║  ███╗█████╗  ██║   ██║██║  ██║█████╗      ██████╔╝██║   ██║██████╔╝   ██║   ███████║██║\r\n//  ██║   ██║██╔══╝  ██║   ██║██║  ██║██╔══╝      ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██╔══██║██║\r\n//  ╚██████╔╝███████╗╚██████╔╝██████╔╝███████╗    ██║     ╚██████╔╝██║  ██║   ██║   ██║  ██║███████╗\r\n//   ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚══════╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚══════╝\r\n//\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\n\r\nimport \"./utils/DataStoreUtilsLib.sol\";\r\nimport \"./utils/GeodeUtilsLib.sol\";\r\nimport \"./utils/OracleUtilsLib.sol\";\r\nimport \"./utils/MaintainerUtilsLib.sol\";\r\nimport \"./utils/StakeUtilsLib.sol\";\r\n\r\nimport \"../interfaces/IPortal.sol\";\r\nimport \"../interfaces/IgETH.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title Geode Finance Ethereum Portal: Trustless Dynamic Liquid Staking Pools\r\n * *\r\n * @notice Geode Portal provides a first of its kind trustless implementation on LSDs: gETH\r\n * * * These derivatives are maintained within Portal's functionality.\r\n *\r\n * * Global trustlessness is achieved by GeodeUtils, which makes sure that\r\n * * * every update is approved by a Senate before being effective.\r\n * * * Senate is elected by the all maintainers.\r\n *\r\n * * Local trustlessness is achieved by MiniGovernances, which is used as a withdrawal\r\n * * * credential contract. However, similar to Portal, upgrade requires the approval of\r\n * * * local Senate. Isolation Mode (WIP), will allow these contracts to become mini-portals\r\n * * * and allow the unstaking operations to be done directly, in the future.\r\n *\r\n * * StakeUtils contains all the staking related functionalities, including pool management\r\n * * * and Oracle activities.\r\n * * * These operations relies on a Dynamic Withdrawal Pool, which is a StableSwap\r\n * * * pool with a dynamic peg.\r\n *\r\n * * * One thing to consider is that currently private pools implementation is WIP, but the overall\r\n * * * design is done while ensuring it is possible without much changes in the future.\r\n *\r\n * @dev refer to DataStoreUtils before reviewing\r\n * @dev refer to GeodeUtils > Includes the logic for management of Geode Portal with Senate/Governance.\r\n * @dev refer to StakeUtils > Includes the logic for staking functionality with Withdrawal Pools\r\n * * * MaintainerUtils is a library used by StakeUtils, handling the maintainer related functionalities\r\n * * * OracleUtils is a library used by StakeUtils, handling the Oracle related functionalities\r\n *\r\n * @notice TYPE: seperates the proposals and related functionality between different ID types.\r\n * * CURRENTLY RESERVED TYPES on Portal:\r\n * * * TYPE 0: *invalid*\r\n * * * TYPE 1: Senate Election\r\n * * * TYPE 2: Portal Upgrade\r\n * * * TYPE 3: *gap*\r\n * * * TYPE 4: Validator Operator\r\n * * * TYPE 5: Planet (public pool)\r\n * * * TYPE 6: Comet (private pool)\r\n * * * TYPE 11: MiniGovernance Upgrade\r\n *\r\n * note ctrl+k+2 and ctrl+k+1 then scroll while reading the function names and opening the comments.\r\n */\r\n\r\ncontract Portal is\r\n    IPortal,\r\n    ReentrancyGuardUpgradeable,\r\n    PausableUpgradeable,\r\n    ERC1155HolderUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n    using MaintainerUtils for DataStoreUtils.DataStore;\r\n    using GeodeUtils for GeodeUtils.Universe;\r\n    using StakeUtils for StakeUtils.StakePool;\r\n    using OracleUtils for OracleUtils.Oracle;\r\n\r\n    /**\r\n     * @dev following events are added to help fellow devs with a better ABI\r\n     */\r\n\r\n    /// GeodeUtils EVENTS\r\n    event GovernanceTaxUpdated(uint256 newFee);\r\n    event MaxGovernanceTaxUpdated(uint256 newMaxFee);\r\n    event ControllerChanged(uint256 id, address newCONTROLLER);\r\n    event Proposed(\r\n        uint256 id,\r\n        address CONTROLLER,\r\n        uint256 TYPE,\r\n        uint256 deadline\r\n    );\r\n    event ProposalApproved(uint256 id);\r\n    event ElectorTypeSet(uint256 TYPE, bool isElector);\r\n    event Vote(uint256 proposalId, uint256 electorId);\r\n    event NewSenate(address senate, uint256 senateExpiry);\r\n\r\n    /// MaintainerUtils EVENTS\r\n    event IdInitiated(uint256 id, uint256 TYPE);\r\n    event MaintainerChanged(uint256 id, address newMaintainer);\r\n    event MaintainerFeeSwitched(\r\n        uint256 id,\r\n        uint256 fee,\r\n        uint256 effectiveTimestamp\r\n    );\r\n\r\n    /// OracleUtils EVENTS\r\n    event Alienated(bytes pubkey);\r\n    event Busted(bytes pubkey);\r\n    event Prisoned(uint256 id, uint256 releaseTimestamp);\r\n    event Released(uint256 id);\r\n    event VerificationIndexUpdated(uint256 validatorVerificationIndex);\r\n\r\n    /// StakeUtils EVENTS\r\n    event ValidatorPeriodUpdated(uint256 operatorId, uint256 newPeriod);\r\n    event OperatorApproval(\r\n        uint256 planetId,\r\n        uint256 operatorId,\r\n        uint256 allowance\r\n    );\r\n    event PausedPool(uint256 id);\r\n    event UnpausedPool(uint256 id);\r\n    event ProposeStaked(bytes pubkey, uint256 planetId, uint256 operatorId);\r\n    event BeaconStaked(bytes pubkey);\r\n    event UnstakeSignal(bytes pubkey);\r\n\r\n    // Portal Events\r\n    event ContractVersionSet(uint256 version);\r\n    event ParamsUpdated(\r\n        address DEFAULT_gETH_INTERFACE,\r\n        address DEFAULT_DWP,\r\n        address DEFAULT_LP_TOKEN,\r\n        uint256 MAX_MAINTAINER_FEE,\r\n        uint256 BOOSTRAP_PERIOD,\r\n        uint256 PERIOD_PRICE_INCREASE_LIMIT,\r\n        uint256 PERIOD_PRICE_DECREASE_LIMIT,\r\n        uint256 COMET_TAX,\r\n        uint256 BOOST_SWITCH_LATENCY\r\n    );\r\n\r\n    // Portal VARIABLES\r\n    /**\r\n     * @notice always refers to the proposal (TYPE2) id.\r\n     * Does NOT increase uniformly like the expected versioning style.\r\n     */\r\n    uint256 public CONTRACT_VERSION;\r\n    DataStoreUtils.DataStore private DATASTORE;\r\n    GeodeUtils.Universe private GEODE;\r\n    StakeUtils.StakePool private STAKEPOOL;\r\n\r\n    function initialize(\r\n        address _GOVERNANCE,\r\n        address _gETH,\r\n        address _ORACLE_POSITION,\r\n        address _DEFAULT_gETH_INTERFACE,\r\n        address _DEFAULT_DWP,\r\n        address _DEFAULT_LP_TOKEN,\r\n        address _MINI_GOVERNANCE_POSITION,\r\n        uint256 _GOVERNANCE_TAX,\r\n        uint256 _COMET_TAX,\r\n        uint256 _MAX_MAINTAINER_FEE,\r\n        uint256 _BOOSTRAP_PERIOD\r\n    ) public virtual override initializer {\r\n        __ReentrancyGuard_init();\r\n        __Pausable_init();\r\n        __ERC1155Holder_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        GEODE.SENATE = _GOVERNANCE;\r\n        GEODE.GOVERNANCE = _GOVERNANCE;\r\n        GEODE.GOVERNANCE_TAX = _GOVERNANCE_TAX;\r\n        GEODE.MAX_GOVERNANCE_TAX = _GOVERNANCE_TAX;\r\n        GEODE.SENATE_EXPIRY = type(uint256).max;\r\n\r\n        STAKEPOOL.GOVERNANCE = _GOVERNANCE;\r\n        STAKEPOOL.gETH = IgETH(_gETH);\r\n        STAKEPOOL.TELESCOPE.gETH = IgETH(_gETH);\r\n        STAKEPOOL.TELESCOPE.ORACLE_POSITION = _ORACLE_POSITION;\r\n\r\n        updateStakingParams(\r\n            _DEFAULT_gETH_INTERFACE,\r\n            _DEFAULT_DWP,\r\n            _DEFAULT_LP_TOKEN,\r\n            _MAX_MAINTAINER_FEE,\r\n            _BOOSTRAP_PERIOD,\r\n            type(uint256).max,\r\n            type(uint256).max,\r\n            _COMET_TAX,\r\n            3 days\r\n        );\r\n\r\n        uint256 _MINI_GOVERNANCE_VERSION = GEODE.newProposal(\r\n            _MINI_GOVERNANCE_POSITION,\r\n            11,\r\n            \"mini-v1\",\r\n            2 days\r\n        );\r\n        GEODE.approveProposal(DATASTORE, _MINI_GOVERNANCE_VERSION);\r\n        STAKEPOOL.MINI_GOVERNANCE_VERSION = _MINI_GOVERNANCE_VERSION;\r\n\r\n        // currently only planet controllers has a say on Senate elections\r\n        GEODE.setElectorType(DATASTORE, 5, true);\r\n        uint256 version_id = GEODE.newProposal(\r\n            _getImplementation(),\r\n            2,\r\n            \"V1\",\r\n            2 days\r\n        );\r\n        GEODE.approveProposal(DATASTORE, version_id);\r\n        CONTRACT_VERSION = version_id;\r\n        GEODE.approvedUpgrade = address(0);\r\n\r\n        emit ContractVersionSet(getVersion());\r\n    }\r\n\r\n    /**\r\n     * @dev required by the OZ UUPS module\r\n     * note that there is no Governance check, as upgrades are effective\r\n     * * right after the Senate approval\r\n     */\r\n    function _authorizeUpgrade(address proposed_implementation)\r\n        internal\r\n        virtual\r\n        override\r\n    {\r\n        require(proposed_implementation != address(0));\r\n        require(\r\n            GEODE.isUpgradeAllowed(proposed_implementation),\r\n            \"Portal: is not allowed to upgrade\"\r\n        );\r\n    }\r\n\r\n    function pause() external virtual override {\r\n        require(\r\n            msg.sender == GEODE.GOVERNANCE,\r\n            \"Portal: sender not GOVERNANCE\"\r\n        );\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external virtual override {\r\n        require(\r\n            msg.sender == GEODE.GOVERNANCE,\r\n            \"Portal: sender not GOVERNANCE\"\r\n        );\r\n        _unpause();\r\n    }\r\n\r\n    function getVersion() public view virtual override returns (uint256) {\r\n        return CONTRACT_VERSION;\r\n    }\r\n\r\n    function gETH() external view virtual override returns (address) {\r\n        return address(STAKEPOOL.gETH);\r\n    }\r\n\r\n    /// @return returns an array of IDs of the given TYPE from Datastore\r\n    function allIdsByType(uint256 _type)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        return DATASTORE.allIdsByType[_type];\r\n    }\r\n\r\n    /// @notice id is keccak(name, type)\r\n    function getIdFromName(string calldata _name, uint256 _type)\r\n        external\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint256 id)\r\n    {\r\n        id = uint256(keccak256(abi.encodePacked(_name, _type)));\r\n    }\r\n\r\n    /**\r\n     *                                  ** Geode Functionalities **\r\n     */\r\n\r\n    function GeodeParams()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            address SENATE,\r\n            address GOVERNANCE,\r\n            uint256 GOVERNANCE_TAX,\r\n            uint256 MAX_GOVERNANCE_TAX,\r\n            uint256 SENATE_EXPIRY\r\n        )\r\n    {\r\n        SENATE = GEODE.getSenate();\r\n        GOVERNANCE = GEODE.getGovernance();\r\n        GOVERNANCE_TAX = GEODE.getGovernanceTax();\r\n        MAX_GOVERNANCE_TAX = GEODE.getMaxGovernanceTax();\r\n        SENATE_EXPIRY = GEODE.getSenateExpiry();\r\n    }\r\n\r\n    function getProposal(uint256 id)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (GeodeUtils.Proposal memory proposal)\r\n    {\r\n        proposal = GEODE.getProposal(id);\r\n    }\r\n\r\n    function isUpgradeAllowed(address proposedImplementation)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return GEODE.isUpgradeAllowed(proposedImplementation);\r\n    }\r\n\r\n    /**\r\n     * @notice GOVERNANCE Functions\r\n     */\r\n\r\n    function setGovernanceTax(uint256 newFee)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return GEODE.setGovernanceTax(newFee);\r\n    }\r\n\r\n    function newProposal(\r\n        address _CONTROLLER,\r\n        uint256 _TYPE,\r\n        bytes calldata _NAME,\r\n        uint256 duration\r\n    ) external virtual override whenNotPaused {\r\n        require(\r\n            msg.sender == GEODE.GOVERNANCE,\r\n            \"Portal: sender not GOVERNANCE\"\r\n        );\r\n        GEODE.newProposal(_CONTROLLER, _TYPE, _NAME, duration);\r\n    }\r\n\r\n    /**\r\n     * @notice SENATE Functions\r\n     */\r\n\r\n    function setMaxGovernanceTax(uint256 newMaxFee)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        return GEODE.setMaxGovernanceTax(newMaxFee);\r\n    }\r\n\r\n    function approveProposal(uint256 id)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        GEODE.approveProposal(DATASTORE, id);\r\n        if (DATASTORE.readUintForId(id, \"TYPE\") == 11)\r\n            STAKEPOOL.setMiniGovernanceVersion(DATASTORE, id);\r\n    }\r\n\r\n    /**\r\n     * @notice CONTROLLER Functions\r\n     */\r\n\r\n    function changeIdCONTROLLER(uint256 id, address newCONTROLLER)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        GeodeUtils.changeIdCONTROLLER(DATASTORE, id, newCONTROLLER);\r\n    }\r\n\r\n    function approveSenate(uint256 proposalId, uint256 electorId)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n    {\r\n        GEODE.approveSenate(DATASTORE, proposalId, electorId);\r\n    }\r\n\r\n    /**\r\n     *                                  ** gETH Functionalities **\r\n     */\r\n\r\n    function allInterfaces(uint256 id)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        return StakeUtils.allInterfaces(DATASTORE, id);\r\n    }\r\n\r\n    function setInterface(uint256 id, address _interface)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        STAKEPOOL.setInterface(DATASTORE, id, _interface);\r\n    }\r\n\r\n    function unsetInterface(uint256 id, uint256 index)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        STAKEPOOL.unsetInterface(DATASTORE, id, index);\r\n    }\r\n\r\n    /**\r\n     *                                     ** Oracle Operations **\r\n     */\r\n    function TelescopeParams()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            address ORACLE_POSITION,\r\n            uint256 ORACLE_UPDATE_TIMESTAMP,\r\n            uint256 MONOPOLY_THRESHOLD,\r\n            uint256 VALIDATORS_INDEX,\r\n            uint256 VERIFICATION_INDEX,\r\n            uint256 PERIOD_PRICE_INCREASE_LIMIT,\r\n            uint256 PERIOD_PRICE_DECREASE_LIMIT,\r\n            bytes32 PRICE_MERKLE_ROOT\r\n        )\r\n    {\r\n        ORACLE_POSITION = STAKEPOOL.TELESCOPE.ORACLE_POSITION;\r\n        ORACLE_UPDATE_TIMESTAMP = STAKEPOOL.TELESCOPE.ORACLE_UPDATE_TIMESTAMP;\r\n        MONOPOLY_THRESHOLD = STAKEPOOL.TELESCOPE.MONOPOLY_THRESHOLD;\r\n        VALIDATORS_INDEX = STAKEPOOL.TELESCOPE.VALIDATORS_INDEX;\r\n        VERIFICATION_INDEX = STAKEPOOL.TELESCOPE.VERIFICATION_INDEX;\r\n        PERIOD_PRICE_INCREASE_LIMIT = STAKEPOOL\r\n            .TELESCOPE\r\n            .PERIOD_PRICE_INCREASE_LIMIT;\r\n        PERIOD_PRICE_DECREASE_LIMIT = STAKEPOOL\r\n            .TELESCOPE\r\n            .PERIOD_PRICE_DECREASE_LIMIT;\r\n        PRICE_MERKLE_ROOT = STAKEPOOL.TELESCOPE.PRICE_MERKLE_ROOT;\r\n    }\r\n\r\n    function getValidator(bytes calldata pubkey)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (OracleUtils.Validator memory)\r\n    {\r\n        return STAKEPOOL.TELESCOPE.getValidator(pubkey);\r\n    }\r\n\r\n    /**\r\n     * @notice Updating PricePerShare\r\n     */\r\n    function isOracleActive() external view virtual override returns (bool) {\r\n        return STAKEPOOL.TELESCOPE._isOracleActive();\r\n    }\r\n\r\n    function reportOracle(\r\n        bytes32 merkleRoot,\r\n        uint256[] calldata beaconBalances,\r\n        bytes32[][] calldata priceProofs\r\n    ) external virtual override nonReentrant {\r\n        STAKEPOOL.TELESCOPE.reportOracle(\r\n            DATASTORE,\r\n            merkleRoot,\r\n            beaconBalances,\r\n            priceProofs\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Batch validator verification and regulating operators\r\n     */\r\n    function isPrisoned(uint256 operatorId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return OracleUtils.isPrisoned(DATASTORE, operatorId);\r\n    }\r\n\r\n    function updateVerificationIndex(\r\n        uint256 allValidatorsCount,\r\n        uint256 validatorVerificationIndex,\r\n        bytes[] calldata alienatedPubkeys\r\n    ) external virtual override {\r\n        STAKEPOOL.TELESCOPE.updateVerificationIndex(\r\n            DATASTORE,\r\n            allValidatorsCount,\r\n            validatorVerificationIndex,\r\n            alienatedPubkeys\r\n        );\r\n    }\r\n\r\n    function regulateOperators(\r\n        bytes[] calldata bustedExits,\r\n        bytes[] calldata bustedSignals,\r\n        uint256[2][] calldata feeThefts\r\n    ) external virtual override {\r\n        STAKEPOOL.TELESCOPE.regulateOperators(\r\n            DATASTORE,\r\n            bustedExits,\r\n            bustedSignals,\r\n            feeThefts\r\n        );\r\n    }\r\n\r\n    /**\r\n     *                                       ** Staking Operations **\r\n     */\r\n    function StakingParams()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            address DEFAULT_gETH_INTERFACE,\r\n            address DEFAULT_DWP,\r\n            address DEFAULT_LP_TOKEN,\r\n            uint256 MINI_GOVERNANCE_VERSION,\r\n            uint256 MAX_MAINTAINER_FEE,\r\n            uint256 BOOSTRAP_PERIOD,\r\n            uint256 COMET_TAX\r\n        )\r\n    {\r\n        DEFAULT_gETH_INTERFACE = STAKEPOOL.DEFAULT_gETH_INTERFACE;\r\n        DEFAULT_DWP = STAKEPOOL.DEFAULT_DWP;\r\n        DEFAULT_LP_TOKEN = STAKEPOOL.DEFAULT_LP_TOKEN;\r\n        MINI_GOVERNANCE_VERSION = STAKEPOOL.MINI_GOVERNANCE_VERSION;\r\n        MAX_MAINTAINER_FEE = STAKEPOOL.MAX_MAINTAINER_FEE;\r\n        BOOSTRAP_PERIOD = STAKEPOOL.BOOSTRAP_PERIOD;\r\n        COMET_TAX = STAKEPOOL.COMET_TAX;\r\n    }\r\n\r\n    function getPlanet(uint256 planetId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            bytes memory name,\r\n            address CONTROLLER,\r\n            address maintainer,\r\n            uint256 initiated,\r\n            uint256 fee,\r\n            uint256 feeSwitch,\r\n            uint256 surplus,\r\n            uint256 secured,\r\n            uint256 withdrawalBoost,\r\n            address withdrawalPool,\r\n            address LPToken,\r\n            address miniGovernance\r\n        )\r\n    {\r\n        name = DATASTORE.readBytesForId(planetId, \"NAME\");\r\n        CONTROLLER = DATASTORE.readAddressForId(planetId, \"CONTROLLER\");\r\n        maintainer = DATASTORE.readAddressForId(planetId, \"maintainer\");\r\n        initiated = DATASTORE.readUintForId(planetId, \"initiated\");\r\n        fee = DATASTORE.getMaintainerFee(planetId);\r\n        feeSwitch = DATASTORE.readUintForId(planetId, \"feeSwitch\");\r\n        surplus = DATASTORE.readUintForId(planetId, \"surplus\");\r\n        secured = DATASTORE.readUintForId(planetId, \"secured\");\r\n        withdrawalBoost = DATASTORE.readUintForId(planetId, \"withdrawalBoost\");\r\n        withdrawalPool = DATASTORE.readAddressForId(planetId, \"withdrawalPool\");\r\n        LPToken = DATASTORE.readAddressForId(planetId, \"LPToken\");\r\n        miniGovernance = DATASTORE.readAddressForId(planetId, \"miniGovernance\");\r\n    }\r\n\r\n    function getOperator(uint256 operatorId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            bytes memory name,\r\n            address CONTROLLER,\r\n            address maintainer,\r\n            uint256 initiated,\r\n            uint256 fee,\r\n            uint256 feeSwitch,\r\n            uint256 totalActiveValidators,\r\n            uint256 validatorPeriod,\r\n            uint256 released\r\n        )\r\n    {\r\n        name = DATASTORE.readBytesForId(operatorId, \"NAME\");\r\n        CONTROLLER = DATASTORE.readAddressForId(operatorId, \"CONTROLLER\");\r\n        maintainer = DATASTORE.readAddressForId(operatorId, \"maintainer\");\r\n        initiated = DATASTORE.readUintForId(operatorId, \"initiated\");\r\n        fee = DATASTORE.getMaintainerFee(operatorId);\r\n        feeSwitch = DATASTORE.readUintForId(operatorId, \"feeSwitch\");\r\n        totalActiveValidators = DATASTORE.readUintForId(\r\n            operatorId,\r\n            \"totalActiveValidators\"\r\n        );\r\n        validatorPeriod = DATASTORE.readUintForId(\r\n            operatorId,\r\n            \"validatorPeriod\"\r\n        );\r\n        released = DATASTORE.readUintForId(operatorId, \"released\");\r\n    }\r\n\r\n    function miniGovernanceVersion()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256 version)\r\n    {\r\n        version = STAKEPOOL.MINI_GOVERNANCE_VERSION;\r\n    }\r\n\r\n    /**\r\n     * @notice Governance functions on pools\r\n     */\r\n\r\n    /**\r\n     * @notice updating the StakePool Params that does NOT require Senate approval\r\n     * @dev onlyGovernance\r\n     */\r\n    function updateStakingParams(\r\n        address _DEFAULT_gETH_INTERFACE,\r\n        address _DEFAULT_DWP,\r\n        address _DEFAULT_LP_TOKEN,\r\n        uint256 _MAX_MAINTAINER_FEE,\r\n        uint256 _BOOSTRAP_PERIOD,\r\n        uint256 _PERIOD_PRICE_INCREASE_LIMIT,\r\n        uint256 _PERIOD_PRICE_DECREASE_LIMIT,\r\n        uint256 _COMET_TAX,\r\n        uint256 _BOOST_SWITCH_LATENCY\r\n    ) public virtual override {\r\n        require(\r\n            msg.sender == GEODE.GOVERNANCE,\r\n            \"Portal: sender not GOVERNANCE\"\r\n        );\r\n        require(\r\n            _DEFAULT_gETH_INTERFACE.code.length > 0,\r\n            \"Portal: DEFAULT_gETH_INTERFACE NOT contract\"\r\n        );\r\n        require(\r\n            _DEFAULT_DWP.code.length > 0,\r\n            \"Portal: DEFAULT_DWP NOT contract\"\r\n        );\r\n        require(\r\n            _DEFAULT_LP_TOKEN.code.length > 0,\r\n            \"Portal: DEFAULT_LP_TOKEN NOT contract\"\r\n        );\r\n        require(\r\n            _MAX_MAINTAINER_FEE > 0 &&\r\n                _MAX_MAINTAINER_FEE <= StakeUtils.PERCENTAGE_DENOMINATOR,\r\n            \"Portal: incorrect MAX_MAINTAINER_FEE\"\r\n        );\r\n        require(\r\n            _PERIOD_PRICE_INCREASE_LIMIT > 0,\r\n            \"Portal: incorrect PERIOD_PRICE_INCREASE_LIMIT\"\r\n        );\r\n        require(\r\n            _PERIOD_PRICE_DECREASE_LIMIT > 0,\r\n            \"Portal: incorrect PERIOD_PRICE_DECREASE_LIMIT\"\r\n        );\r\n        require(\r\n            _COMET_TAX <= _MAX_MAINTAINER_FEE,\r\n            \"Portal: COMET_TAX should be less than MAX_MAINTAINER_FEE\"\r\n        );\r\n        STAKEPOOL.DEFAULT_gETH_INTERFACE = _DEFAULT_gETH_INTERFACE;\r\n        STAKEPOOL.DEFAULT_DWP = _DEFAULT_DWP;\r\n        STAKEPOOL.DEFAULT_LP_TOKEN = _DEFAULT_LP_TOKEN;\r\n        STAKEPOOL.MAX_MAINTAINER_FEE = _MAX_MAINTAINER_FEE;\r\n        STAKEPOOL.COMET_TAX = _COMET_TAX;\r\n        STAKEPOOL.BOOSTRAP_PERIOD = _BOOSTRAP_PERIOD;\r\n        STAKEPOOL.BOOST_SWITCH_LATENCY = _BOOST_SWITCH_LATENCY;\r\n        STAKEPOOL\r\n            .TELESCOPE\r\n            .PERIOD_PRICE_INCREASE_LIMIT = _PERIOD_PRICE_INCREASE_LIMIT;\r\n        STAKEPOOL\r\n            .TELESCOPE\r\n            .PERIOD_PRICE_DECREASE_LIMIT = _PERIOD_PRICE_DECREASE_LIMIT;\r\n        emit ParamsUpdated(\r\n            _DEFAULT_gETH_INTERFACE,\r\n            _DEFAULT_DWP,\r\n            _DEFAULT_LP_TOKEN,\r\n            _MAX_MAINTAINER_FEE,\r\n            _BOOSTRAP_PERIOD,\r\n            _PERIOD_PRICE_INCREASE_LIMIT,\r\n            _PERIOD_PRICE_DECREASE_LIMIT,\r\n            _COMET_TAX,\r\n            _BOOST_SWITCH_LATENCY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev onlyGovernance\r\n     */\r\n    function releasePrisoned(uint256 operatorId) external virtual override {\r\n        require(\r\n            msg.sender == GEODE.GOVERNANCE,\r\n            \"Portal: sender not GOVERNANCE\"\r\n        );\r\n        OracleUtils.releasePrisoned(DATASTORE, operatorId);\r\n    }\r\n\r\n    /**\r\n     * @notice ID initiatiors for different types\r\n     * @dev comets(private pools) are not implemented yet\r\n     */\r\n\r\n    function initiateOperator(\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        uint256 _validatorPeriod\r\n    ) external virtual override whenNotPaused {\r\n        STAKEPOOL.initiateOperator(\r\n            DATASTORE,\r\n            _id,\r\n            _fee,\r\n            _maintainer,\r\n            _validatorPeriod\r\n        );\r\n    }\r\n\r\n    function initiatePlanet(\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        string calldata _interfaceName,\r\n        string calldata _interfaceSymbol\r\n    ) external virtual override whenNotPaused {\r\n        STAKEPOOL.initiatePlanet(\r\n            DATASTORE,\r\n            _id,\r\n            _fee,\r\n            _maintainer,\r\n            [_interfaceName, _interfaceSymbol]\r\n        );\r\n    }\r\n\r\n    function changeOperatorMaintainer(uint256 id, address newMaintainer)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        StakeUtils.changeOperatorMaintainer(DATASTORE, id, newMaintainer);\r\n    }\r\n\r\n    /**\r\n     * @notice Maintainer functions\r\n     */\r\n\r\n    function changePoolMaintainer(\r\n        uint256 id,\r\n        bytes calldata password,\r\n        bytes32 newPasswordHash,\r\n        address newMaintainer\r\n    ) external virtual override whenNotPaused {\r\n        StakeUtils.changePoolMaintainer(\r\n            DATASTORE,\r\n            id,\r\n            password,\r\n            newPasswordHash,\r\n            newMaintainer\r\n        );\r\n    }\r\n\r\n    function switchMaintainerFee(uint256 id, uint256 newFee)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        STAKEPOOL.switchMaintainerFee(DATASTORE, id, newFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Maintainer wallet\r\n     */\r\n\r\n    function getMaintainerWalletBalance(uint256 id)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return DATASTORE.getMaintainerWalletBalance(id);\r\n    }\r\n\r\n    function increaseMaintainerWallet(uint256 id)\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n        returns (bool success)\r\n    {\r\n        success = StakeUtils.increaseMaintainerWallet(DATASTORE, id);\r\n    }\r\n\r\n    function decreaseMaintainerWallet(uint256 id, uint256 value)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n        returns (bool success)\r\n    {\r\n        success = StakeUtils.decreaseMaintainerWallet(DATASTORE, id, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Pool - Operator interactions\r\n     */\r\n\r\n    function switchWithdrawalBoost(uint256 poolId, uint256 withdrawalBoost)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        STAKEPOOL.switchWithdrawalBoost(DATASTORE, poolId, withdrawalBoost);\r\n    }\r\n\r\n    function operatorAllowance(uint256 poolId, uint256 operatorId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            uint256 allowance,\r\n            uint256 proposedValidators,\r\n            uint256 activeValidators\r\n        )\r\n    {\r\n        allowance = StakeUtils.operatorAllowance(DATASTORE, poolId, operatorId);\r\n        proposedValidators = DATASTORE.readUintForId(\r\n            poolId,\r\n            DataStoreUtils.getKey(operatorId, \"proposedValidators\")\r\n        );\r\n        activeValidators = DATASTORE.readUintForId(\r\n            poolId,\r\n            DataStoreUtils.getKey(operatorId, \"activeValidators\")\r\n        );\r\n    }\r\n\r\n    function approveOperator(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        uint256 allowance\r\n    ) external virtual override whenNotPaused returns (bool) {\r\n        return\r\n            StakeUtils.approveOperator(\r\n                DATASTORE,\r\n                poolId,\r\n                operatorId,\r\n                allowance\r\n            );\r\n    }\r\n\r\n    function updateValidatorPeriod(uint256 operatorId, uint256 newPeriod)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        StakeUtils.updateValidatorPeriod(DATASTORE, operatorId, newPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Depositing functions (user)\r\n     * @dev comets(private pools) are not implemented yet\r\n     */\r\n\r\n    function canDeposit(uint256 id)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return StakeUtils.canDeposit(DATASTORE, id);\r\n    }\r\n\r\n    function pauseStakingForPool(uint256 id) external virtual override {\r\n        StakeUtils.pauseStakingForPool(DATASTORE, id);\r\n    }\r\n\r\n    function unpauseStakingForPool(uint256 id)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n    {\r\n        StakeUtils.unpauseStakingForPool(DATASTORE, id);\r\n    }\r\n\r\n    function depositPlanet(\r\n        uint256 poolId,\r\n        uint256 mingETH,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n        returns (uint256 gEthToSend)\r\n    {\r\n        gEthToSend = STAKEPOOL.depositPlanet(\r\n            DATASTORE,\r\n            poolId,\r\n            mingETH,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Withdrawal functions (user)\r\n     * @dev comets(private pools) are not implemented yet\r\n     */\r\n\r\n    function withdrawPlanet(\r\n        uint256 poolId,\r\n        uint256 gEthToWithdraw,\r\n        uint256 minETH,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n        returns (uint256 EthToSend)\r\n    {\r\n        EthToSend = STAKEPOOL.withdrawPlanet(\r\n            DATASTORE,\r\n            poolId,\r\n            gEthToWithdraw,\r\n            minETH,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Validator creation (Stake) functions (operator)\r\n     */\r\n\r\n    function canStake(bytes calldata pubkey)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return STAKEPOOL.canStake(DATASTORE, pubkey);\r\n    }\r\n\r\n    function proposeStake(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        bytes[] calldata signatures\r\n    ) external virtual override whenNotPaused nonReentrant {\r\n        STAKEPOOL.proposeStake(\r\n            DATASTORE,\r\n            poolId,\r\n            operatorId,\r\n            pubkeys,\r\n            signatures\r\n        );\r\n    }\r\n\r\n    function beaconStake(uint256 operatorId, bytes[] calldata pubkeys)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n    {\r\n        STAKEPOOL.beaconStake(DATASTORE, operatorId, pubkeys);\r\n    }\r\n\r\n    /**\r\n     * @notice Validator exiting (Unstake) functions (operator)\r\n     */\r\n\r\n    function signalUnstake(bytes[] calldata pubkeys)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        nonReentrant\r\n    {\r\n        STAKEPOOL.signalUnstake(DATASTORE, pubkeys);\r\n    }\r\n\r\n    function fetchUnstake(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        uint256[] calldata balances,\r\n        bool[] calldata isExit\r\n    ) external virtual override whenNotPaused nonReentrant {\r\n        STAKEPOOL.fetchUnstake(\r\n            DATASTORE,\r\n            poolId,\r\n            operatorId,\r\n            pubkeys,\r\n            balances,\r\n            isExit\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice We do care.\r\n     */\r\n\r\n    function Do_we_care() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    uint256[46] private __gap;\r\n}\r\n"
    },
    "contracts/interfaces/IPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"../Portal/utils/GeodeUtilsLib.sol\";\r\nimport \"../Portal/utils/OracleUtilsLib.sol\";\r\n\r\ninterface IPortal {\r\n    function initialize(\r\n        address _GOVERNANCE,\r\n        address _gETH,\r\n        address _ORACLE_POSITION,\r\n        address _DEFAULT_gETH_INTERFACE,\r\n        address _DEFAULT_DWP,\r\n        address _DEFAULT_LP_TOKEN,\r\n        address _MINI_GOVERNANCE_POSITION,\r\n        uint256 _GOVERNANCE_TAX,\r\n        uint256 _COMET_TAX,\r\n        uint256 _MAX_MAINTAINER_FEE,\r\n        uint256 _BOOSTRAP_PERIOD\r\n    ) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    function getVersion() external view returns (uint256);\r\n\r\n    function gETH() external view returns (address);\r\n\r\n    function allIdsByType(uint256 _type)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getIdFromName(string calldata _name, uint256 _type)\r\n        external\r\n        pure\r\n        returns (uint256 id);\r\n\r\n    function GeodeParams()\r\n        external\r\n        view\r\n        returns (\r\n            address SENATE,\r\n            address GOVERNANCE,\r\n            uint256 GOVERNANCE_TAX,\r\n            uint256 MAX_GOVERNANCE_TAX,\r\n            uint256 SENATE_EXPIRY\r\n        );\r\n\r\n    function getProposal(uint256 id)\r\n        external\r\n        view\r\n        returns (GeodeUtils.Proposal memory proposal);\r\n\r\n    function isUpgradeAllowed(address proposedImplementation)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function setGovernanceTax(uint256 newFee) external returns (bool);\r\n\r\n    function newProposal(\r\n        address _CONTROLLER,\r\n        uint256 _TYPE,\r\n        bytes calldata _NAME,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function setMaxGovernanceTax(uint256 newMaxFee) external returns (bool);\r\n\r\n    function approveProposal(uint256 id) external;\r\n\r\n    function changeIdCONTROLLER(uint256 id, address newCONTROLLER) external;\r\n\r\n    function approveSenate(uint256 proposalId, uint256 electorId) external;\r\n\r\n    function allInterfaces(uint256 id) external view returns (address[] memory);\r\n\r\n    function setInterface(uint256 id, address _interface) external;\r\n\r\n    function unsetInterface(uint256 id, uint256 index) external;\r\n\r\n    function TelescopeParams()\r\n        external\r\n        view\r\n        returns (\r\n            address ORACLE_POSITION,\r\n            uint256 ORACLE_UPDATE_TIMESTAMP,\r\n            uint256 MONOPOLY_THRESHOLD,\r\n            uint256 VALIDATORS_INDEX,\r\n            uint256 VERIFICATION_INDEX,\r\n            uint256 PERIOD_PRICE_INCREASE_LIMIT,\r\n            uint256 PERIOD_PRICE_DECREASE_LIMIT,\r\n            bytes32 PRICE_MERKLE_ROOT\r\n        );\r\n\r\n    function releasePrisoned(uint256 operatorId) external;\r\n\r\n    function miniGovernanceVersion() external view returns (uint256 id);\r\n\r\n    function getValidator(bytes calldata pubkey)\r\n        external\r\n        view\r\n        returns (OracleUtils.Validator memory);\r\n\r\n    function isOracleActive() external view returns (bool);\r\n\r\n    function reportOracle(\r\n        bytes32 merkleRoot,\r\n        uint256[] calldata beaconBalances,\r\n        bytes32[][] calldata priceProofs\r\n    ) external;\r\n\r\n    function isPrisoned(uint256 operatorId) external view returns (bool);\r\n\r\n    function getPlanet(uint256 planetId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes memory name,\r\n            address CONTROLLER,\r\n            address maintainer,\r\n            uint256 initiated,\r\n            uint256 fee,\r\n            uint256 feeSwitch,\r\n            uint256 surplus,\r\n            uint256 secured,\r\n            uint256 withdrawalBoost,\r\n            address withdrawalPool,\r\n            address LPToken,\r\n            address miniGovernance\r\n        );\r\n\r\n    function getOperator(uint256 operatorId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes memory name,\r\n            address CONTROLLER,\r\n            address maintainer,\r\n            uint256 initiated,\r\n            uint256 fee,\r\n            uint256 feeSwitch,\r\n            uint256 totalActiveValidators,\r\n            uint256 validatorPeriod,\r\n            uint256 released\r\n        );\r\n\r\n    function updateVerificationIndex(\r\n        uint256 allValidatorsCount,\r\n        uint256 validatorVerificationIndex,\r\n        bytes[] calldata alienatedPubkeys\r\n    ) external;\r\n\r\n    function regulateOperators(\r\n        bytes[] calldata bustedExits,\r\n        bytes[] calldata bustedSignals,\r\n        uint256[2][] calldata feeThefts\r\n    ) external;\r\n\r\n    function StakingParams()\r\n        external\r\n        view\r\n        returns (\r\n            address DEFAULT_gETH_INTERFACE,\r\n            address DEFAULT_DWP,\r\n            address DEFAULT_LP_TOKEN,\r\n            uint256 MINI_GOVERNANCE_VERSION,\r\n            uint256 MAX_MAINTAINER_FEE,\r\n            uint256 BOOSTRAP_PERIOD,\r\n            uint256 COMET_TAX\r\n        );\r\n\r\n    function updateStakingParams(\r\n        address _DEFAULT_gETH_INTERFACE,\r\n        address _DEFAULT_DWP,\r\n        address _DEFAULT_LP_TOKEN,\r\n        uint256 _MAX_MAINTAINER_FEE,\r\n        uint256 _BOOSTRAP_PERIOD,\r\n        uint256 _PERIOD_PRICE_INCREASE_LIMIT,\r\n        uint256 _PERIOD_PRICE_DECREASE_LIMIT,\r\n        uint256 _COMET_TAX,\r\n        uint256 _BOOST_SWITCH_LATENCY\r\n    ) external;\r\n\r\n    function initiateOperator(\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        uint256 _validatorPeriod\r\n    ) external;\r\n\r\n    function initiatePlanet(\r\n        uint256 _id,\r\n        uint256 _fee,\r\n        address _maintainer,\r\n        string calldata _interfaceName,\r\n        string calldata _interfaceSymbol\r\n    ) external;\r\n\r\n    function changeOperatorMaintainer(uint256 id, address newMaintainer)\r\n        external;\r\n\r\n    function changePoolMaintainer(\r\n        uint256 id,\r\n        bytes calldata password,\r\n        bytes32 newPasswordHash,\r\n        address newMaintainer\r\n    ) external;\r\n\r\n    function getMaintainerWalletBalance(uint256 id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function switchMaintainerFee(uint256 id, uint256 newFee) external;\r\n\r\n    function increaseMaintainerWallet(uint256 id)\r\n        external\r\n        payable\r\n        returns (bool success);\r\n\r\n    function decreaseMaintainerWallet(uint256 id, uint256 value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function switchWithdrawalBoost(uint256 poolId, uint256 withdrawalBoost)\r\n        external;\r\n\r\n    function operatorAllowance(uint256 poolId, uint256 operatorId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 allowance,\r\n            uint256 proposedValidators,\r\n            uint256 activeValidators\r\n        );\r\n\r\n    function approveOperator(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        uint256 allowance\r\n    ) external returns (bool);\r\n\r\n    function updateValidatorPeriod(uint256 operatorId, uint256 newPeriod)\r\n        external;\r\n\r\n    function canDeposit(uint256 _id) external view returns (bool);\r\n\r\n    function canStake(bytes calldata pubkey) external view returns (bool);\r\n\r\n    function pauseStakingForPool(uint256 id) external;\r\n\r\n    function unpauseStakingForPool(uint256 id) external;\r\n\r\n    function depositPlanet(\r\n        uint256 poolId,\r\n        uint256 mingETH,\r\n        uint256 deadline\r\n    ) external payable returns (uint256 gEthToSend);\r\n\r\n    function withdrawPlanet(\r\n        uint256 poolId,\r\n        uint256 gEthToWithdraw,\r\n        uint256 minETH,\r\n        uint256 deadline\r\n    ) external returns (uint256 EthToSend);\r\n\r\n    function proposeStake(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        bytes[] calldata signatures\r\n    ) external;\r\n\r\n    function beaconStake(uint256 operatorId, bytes[] calldata pubkeys) external;\r\n\r\n    function signalUnstake(bytes[] calldata pubkeys) external;\r\n\r\n    function fetchUnstake(\r\n        uint256 poolId,\r\n        uint256 operatorId,\r\n        bytes[] calldata pubkeys,\r\n        uint256[] calldata balances,\r\n        bool[] calldata isExit\r\n    ) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "contracts/Portal/MiniGovernance/MiniGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"../utils/DataStoreUtilsLib.sol\";\r\nimport \"../utils/GeodeUtilsLib.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\nimport \"../../interfaces/IPortal.sol\";\r\nimport \"../../interfaces/IMiniGovernance.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title MiniGovernance: local defense layer of the trustless Staking Derivatives\r\n * @dev Global defense layer is the Portal\r\n * @notice This contract is being used as the withdrawal credential of the validators,\r\n * * that are maintained by the given IDs maintainer.\r\n * @dev currently only defense mechanics this contract provides is the trustless updates that are\r\n * * achieved with GeodeUtils and passwordHashes\r\n * * 1. portal cannot change the maintainer without knowing the real password\r\n * * 2. portal cannot upgrade the contract without Maintainer's approval\r\n * *\r\n * * However there are such improvements planned to be implemented to make\r\n * * the staking environment more trustless.\r\n * * * \"isolationMode\" is one of them, currently only rules of the isolation mode is Senate_Expiry and\r\n * * * isUpgraded check. However, this is a good start to ensure that the future implementations will be\r\n * * * enforced to incentivise the trustless behaviour! The end goal is to create mini-portals\r\n * * * with different mechanics and allow auto-staking contracts...\r\n */\r\ncontract MiniGovernance is\r\n    IMiniGovernance,\r\n    ReentrancyGuardUpgradeable,\r\n    PausableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    event Proposed(\r\n        uint256 id,\r\n        address _CONTROLLER,\r\n        uint256 _type,\r\n        uint256 _duration\r\n    );\r\n    event ProposalApproved(uint256 id);\r\n    event NewSenate(address senate, uint256 senate_expiry);\r\n\r\n    event ContractVersionSet(uint256 version);\r\n\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n    using GeodeUtils for GeodeUtils.Universe;\r\n\r\n    DataStoreUtils.DataStore private DATASTORE;\r\n    GeodeUtils.Universe private GEM; // MiniGeode :)\r\n    PoolGovernance private SELF;\r\n\r\n    /**\r\n     * @dev While there are currently no worry on if the pool will be abandoned,\r\n     * with the introduction of private pools, it can be a problem.\r\n     * Thus, we require senate to refresh it's validity time to time.\r\n     */\r\n    uint256 SENATE_VALIDITY = 180 days;\r\n    /**\r\n     * @dev While there are currently no worry on what pausing will affect,\r\n     * with the next implementations, spamming stake/unstake can cause an issue.\r\n     * Thus, we require senate to wait a bit before pausing the contract again, allowing\r\n     * validator unstake(maybe).\r\n     */\r\n    uint256 PAUSE_LAPSE = 1 weeks;\r\n\r\n    struct PoolGovernance {\r\n        IgETH gETH;\r\n        uint256 ID;\r\n        bytes32 PASSWORD_HASH;\r\n        uint256 lastPause;\r\n        uint256 whenPauseAllowed;\r\n        uint256 contractVersion;\r\n        uint256 proposedVersion;\r\n    }\r\n\r\n    function initialize(\r\n        address _gETH,\r\n        address _PORTAL,\r\n        address _MAINTAINER,\r\n        uint256 _ID,\r\n        uint256 _VERSION\r\n    ) public virtual override initializer {\r\n        __ReentrancyGuard_init();\r\n        __Pausable_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        SELF.gETH = IgETH(_gETH);\r\n        SELF.ID = _ID;\r\n        SELF.lastPause = type(uint256).max;\r\n        GEM.GOVERNANCE = _PORTAL;\r\n        _refreshSenate(_MAINTAINER);\r\n\r\n        SELF.contractVersion = _VERSION;\r\n        emit ContractVersionSet(_VERSION);\r\n    }\r\n\r\n    modifier onlyPortal() {\r\n        require(\r\n            msg.sender == GEM.GOVERNANCE,\r\n            \"StakeUtils: sender is NOT PORTAL\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyMaintainer() {\r\n        require(msg.sender == GEM.SENATE, \"StakeUtils: sender is NOT SENATE\");\r\n        _;\r\n    }\r\n\r\n    function getPortal() internal view returns (IPortal) {\r\n        return IPortal(GEM.GOVERNANCE);\r\n    }\r\n\r\n    ///@dev required by the UUPS module\r\n    function _authorizeUpgrade(address proposed_implementation)\r\n        internal\r\n        virtual\r\n        override\r\n        onlyMaintainer\r\n    {\r\n        require(\r\n            GEM.isUpgradeAllowed(proposed_implementation),\r\n            \"MiniGovernance: is NOT allowed to upgrade\"\r\n        );\r\n    }\r\n\r\n    function pause() external virtual override onlyMaintainer {\r\n        require(block.timestamp > SELF.whenPauseAllowed);\r\n        _pause();\r\n        SELF.lastPause = block.timestamp;\r\n    }\r\n\r\n    /// @dev cannot spam, be careful\r\n    function unpause() external virtual override onlyMaintainer {\r\n        _unpause();\r\n        SELF.whenPauseAllowed = block.timestamp + PAUSE_LAPSE;\r\n        SELF.lastPause = type(uint256).max;\r\n    }\r\n\r\n    function getCurrentVersion()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return SELF.contractVersion;\r\n    }\r\n\r\n    function getProposedVersion()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return SELF.proposedVersion;\r\n    }\r\n\r\n    function isolationMode() public view virtual override returns (bool) {\r\n        return\r\n            SELF.contractVersion != SELF.proposedVersion ||\r\n            block.timestamp > GEM.SENATE_EXPIRY;\r\n    }\r\n\r\n    /**\r\n     *                                          ** PROPOSALS **\r\n     */\r\n\r\n    /**\r\n     * @notice anyone can fetch proposal from Portal, so  we don't need to call it.\r\n     */\r\n    function fetchUpgradeProposal() external virtual override {\r\n        uint256 id = getPortal().miniGovernanceVersion();\r\n        require(id != SELF.contractVersion);\r\n        GeodeUtils.Proposal memory proposal = getPortal().getProposal(id);\r\n        require(proposal.TYPE == 11);\r\n        GEM.newProposal(proposal.CONTROLLER, 2, proposal.NAME, 4 weeks);\r\n        SELF.proposedVersion = id;\r\n    }\r\n\r\n    function approveProposal(uint256 _id)\r\n        external\r\n        virtual\r\n        override\r\n        whenNotPaused\r\n        onlyMaintainer\r\n    {\r\n        GEM.approveProposal(DATASTORE, _id);\r\n    }\r\n\r\n    /**\r\n     *                                          ** SENATE & UPGRADE MANAGEMENT **\r\n     */\r\n    function _refreshSenate(address newSenate) internal virtual whenNotPaused {\r\n        GEM._setSenate(newSenate, block.timestamp + SENATE_VALIDITY);\r\n    }\r\n\r\n    /**\r\n     * @dev should change the password, every now and then\r\n     * @param newPasswordHash = keccak256(abi.encodePacked(SELF.ID, password))\r\n     */\r\n    function refreshSenate(bytes32 newPasswordHash)\r\n        external\r\n        virtual\r\n        override\r\n        onlyMaintainer\r\n    {\r\n        SELF.PASSWORD_HASH = newPasswordHash;\r\n        _refreshSenate(GEM.SENATE);\r\n    }\r\n\r\n    /**\r\n     * @notice Portal changing the Senate of Minigovernance when the maintainer of the pool is changed\r\n     * @dev (Senate+Governance) can possibly access this function if they are working together.\r\n     * * Thus, access to this function requires an optional password.\r\n     * @param newPasswordHash = keccak256(abi.encodePacked(SELF.ID, password))\r\n     */\r\n    function changeMaintainer(\r\n        bytes calldata password,\r\n        bytes32 newPasswordHash,\r\n        address newMaintainer\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        onlyPortal\r\n        whenNotPaused\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            SELF.PASSWORD_HASH == bytes32(0) ||\r\n                SELF.PASSWORD_HASH ==\r\n                keccak256(abi.encodePacked(SELF.ID, password))\r\n        );\r\n        SELF.PASSWORD_HASH = newPasswordHash;\r\n\r\n        _refreshSenate(newMaintainer);\r\n\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @notice according to eip-4895, the unstaked balances will be just happen to emerge within this contract.\r\n     * * Telescope (oracle) will be watching these events andn finalizing the unstakes.\r\n     * * This method even makes it possible to claim rewards without unstake, which we know is a possibility\r\n     * @param claim specified amount can be the unstaked balance or just a reward, ETH.\r\n     * @return success if claim was successful\r\n     */\r\n    function claimUnstake(uint256 claim)\r\n        external\r\n        virtual\r\n        override\r\n        onlyPortal\r\n        nonReentrant\r\n        returns (bool success)\r\n    {\r\n        (success, ) = payable(GEM.GOVERNANCE).call{value: claim}(\"\");\r\n        require(success, \"MiniGovernance: Failed to send Ether\");\r\n    }\r\n\r\n    uint256[45] private __gap;\r\n}\r\n"
    },
    "contracts/Portal/helpers/test/TestGeodeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"../../utils/DataStoreUtilsLib.sol\";\r\nimport \"../../utils/GeodeUtilsLib.sol\";\r\n\r\ncontract TestGeodeUtils {\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n    using GeodeUtils for GeodeUtils.Universe;\r\n    DataStoreUtils.DataStore private DATASTORE;\r\n    GeodeUtils.Universe private GEODE;\r\n\r\n    constructor(\r\n        address _GOVERNANCE,\r\n        address _SENATE,\r\n        uint256 _GOVERNANCE_TAX,\r\n        uint256 _MAX_GOVERNANCE_TAX\r\n    ) {\r\n        GEODE.GOVERNANCE = _GOVERNANCE;\r\n        GEODE.SENATE = _SENATE;\r\n        GEODE.SENATE_EXPIRY = block.timestamp + 1 days;\r\n        GEODE.GOVERNANCE_TAX = _GOVERNANCE_TAX;\r\n        GEODE.MAX_GOVERNANCE_TAX = _MAX_GOVERNANCE_TAX;\r\n\r\n        GEODE.setElectorType(DATASTORE, 5, true); // allow type4 to vote for Senate\r\n\r\n        GEODE.approvedUpgrade = address(0);\r\n    }\r\n\r\n    function getSenate() external view virtual returns (address) {\r\n        return GEODE.getSenate();\r\n    }\r\n\r\n    function getGovernance() external view virtual returns (address) {\r\n        return GEODE.getGovernance();\r\n    }\r\n\r\n    function getGovernanceTax() external view virtual returns (uint256) {\r\n        return GEODE.getGovernanceTax();\r\n    }\r\n\r\n    function getPERCENTAGE_DENOMINATOR()\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return GeodeUtils.PERCENTAGE_DENOMINATOR;\r\n    }\r\n\r\n    function getMaxGovernanceTax() external view virtual returns (uint256) {\r\n        return GEODE.getMaxGovernanceTax();\r\n    }\r\n\r\n    function getSenateExpiry() external view virtual returns (uint256) {\r\n        return GEODE.getSenateExpiry();\r\n    }\r\n\r\n    /**\r\n     **  ID GETTERS **\r\n     */\r\n    function getIdsByTYPE(uint256 _TYPE)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        return DATASTORE.allIdsByType[_TYPE];\r\n    }\r\n\r\n    function getId(string calldata _NAME, uint256 _TYPE)\r\n        external\r\n        pure\r\n        virtual\r\n        returns (uint256 _id)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(_NAME, _TYPE)));\r\n    }\r\n\r\n    function getCONTROLLERFromId(uint256 _id)\r\n        external\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        return GeodeUtils.getCONTROLLERFromId(DATASTORE, _id);\r\n    }\r\n\r\n    function getTYPEFromId(uint256 _id)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return GeodeUtils.getTYPEFromId(DATASTORE, _id);\r\n    }\r\n\r\n    function getNAMEFromId(uint256 _id)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bytes memory)\r\n    {\r\n        return GeodeUtils.getNAMEFromId(DATASTORE, _id);\r\n    }\r\n\r\n    /**\r\n     *                                          ** SETTERS **\r\n     */\r\n    function changeIdCONTROLLER(uint256 _id, address _newCONTROLLER)\r\n        external\r\n        virtual\r\n    {\r\n        GeodeUtils.changeIdCONTROLLER(DATASTORE, _id, _newCONTROLLER);\r\n    }\r\n\r\n    /**\r\n     * ** GOVERNANCE/SENATE SETTERS **\r\n     */\r\n    function setGovernanceTax(uint256 _newFee)\r\n        external\r\n        virtual\r\n        returns (bool success)\r\n    {\r\n        // onlyGovernance CHECKED inside\r\n        success = GEODE.setGovernanceTax(_newFee);\r\n    }\r\n\r\n    function setMaxGovernanceTax(uint256 _newFee)\r\n        external\r\n        virtual\r\n        returns (bool success)\r\n    {\r\n        // onlySenate CHECKED inside\r\n        success = GEODE.setMaxGovernanceTax(_newFee);\r\n    }\r\n\r\n    /**\r\n     *                                          ** PROPOSALS **\r\n     */\r\n\r\n    function getProposal(uint256 id)\r\n        external\r\n        view\r\n        virtual\r\n        returns (GeodeUtils.Proposal memory)\r\n    {\r\n        return GEODE.getProposal(id);\r\n    }\r\n\r\n    function newProposal(\r\n        address _CONTROLLER,\r\n        uint256 _TYPE,\r\n        bytes calldata _NAME,\r\n        uint256 _proposalDuration\r\n    ) external virtual {\r\n        require(\r\n            DATASTORE\r\n                .readBytesForId(\r\n                    uint256(keccak256(abi.encodePacked(_NAME, _TYPE))),\r\n                    \"NAME\"\r\n                )\r\n                .length == 0,\r\n            \"GeodeUtils: NAME already claimed\"\r\n        );\r\n        GEODE.newProposal(_CONTROLLER, _TYPE, _NAME, _proposalDuration);\r\n    }\r\n\r\n    function approveProposal(uint256 _id) external virtual {\r\n        GEODE.approveProposal(DATASTORE, _id);\r\n    }\r\n\r\n    function approveSenate(uint256 proposalId, uint256 electorId)\r\n        external\r\n        virtual\r\n    {\r\n        GEODE.approveSenate(DATASTORE, proposalId, electorId);\r\n    }\r\n\r\n    function setSenate(address newSenate, uint256 senatePeriod)\r\n        external\r\n        virtual\r\n    {\r\n        GEODE._setSenate(newSenate, senatePeriod);\r\n    }\r\n\r\n    /// @dev DO NOT TOUCH, EVER! WHATEVER YOU DEVELOP IN FUCKING 3022.\r\n    function isUpgradeAllowed(address proposed_implementation)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return GEODE.isUpgradeAllowed(proposed_implementation);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/test/TestDataStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"../../utils/DataStoreUtilsLib.sol\";\r\n\r\ncontract DataStoreUtilsTest {\r\n    using DataStoreUtils for DataStoreUtils.DataStore;\r\n    DataStoreUtils.DataStore private DATASTORE;\r\n\r\n    function readUintForId(uint256 _id, bytes32 _key)\r\n        public\r\n        view\r\n        returns (uint256 data)\r\n    {\r\n        data = DATASTORE.readUintForId(_id, _key);\r\n    }\r\n\r\n    function readBytesForId(uint256 _id, bytes32 _key)\r\n        public\r\n        view\r\n        returns (bytes memory data)\r\n    {\r\n        data = DATASTORE.readBytesForId(_id, _key);\r\n    }\r\n\r\n    function readAddressForId(uint256 _id, bytes32 _key)\r\n        public\r\n        view\r\n        returns (address data)\r\n    {\r\n        data = DATASTORE.readAddressForId(_id, _key);\r\n    }\r\n\r\n    function writeUintForId(\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 data\r\n    ) public {\r\n        DATASTORE.writeUintForId(_id, _key, data);\r\n    }\r\n\r\n    function addUintForId(\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 addend\r\n    ) public {\r\n        DATASTORE.addUintForId(_id, _key, addend);\r\n    }\r\n\r\n    function subUintForId(\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        uint256 minuend\r\n    ) public {\r\n        DATASTORE.subUintForId(_id, _key, minuend);\r\n    }\r\n\r\n    function writeBytesForId(\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        bytes memory data\r\n    ) public {\r\n        DATASTORE.writeBytesForId(_id, _key, data);\r\n    }\r\n\r\n    function writeAddressForId(\r\n        uint256 _id,\r\n        bytes32 _key,\r\n        address data\r\n    ) public {\r\n        DATASTORE.writeAddressForId(_id, _key, data);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/gETHInterfaces/ERC20InterfaceUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"../../interfaces/IgETH.sol\";\r\n\r\n/**\r\n * @dev differences between ERC20InterfaceUpgradable and Openzeppelin's implementation of ERC20Upgradeable is:\r\n * -> pragma set to =0.8.7;\r\n * -> ERC20InterfaceUpgradable uses gETH contract for balances and totalsupply info.\r\n * -> unique id of ERC1155 is used\r\n * -> there is no mint or burn functionality implemented here.\r\n *\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/2cb8996b777060e658e2b8c9b1630313aedb04c0/contracts/token/ERC20/ERC20Upgradeable.sol\r\n * diffchecker link: https://www.diffchecker.com/0PlrxJT9\r\n */\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n\r\ncontract ERC20InterfaceUpgradable is\r\n    Initializable,\r\n    ContextUpgradeable,\r\n    IERC20Upgradeable,\r\n    IERC20MetadataUpgradeable\r\n{\r\n    /**\r\n     * @dev gETH ERC20 interface doesn't use balance info, catches it from ERC1155.\r\n     * mapping(address => uint256) private _balances;\r\n     **/\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /**\r\n     * @dev gETH ERC20 interface doesn't use totalSupply info, catches it from ERC1155.\r\n     * uint256 private _totalSupply;\r\n     **/\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    uint256 private _id;\r\n    IgETH private _ERC1155;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n\r\n    function __ERC20interface_init(\r\n        uint256 id_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address gETH_1155\r\n    ) internal onlyInitializing {\r\n        __ERC20interface_init_unchained(id_, name_, symbol_, gETH_1155);\r\n    }\r\n\r\n    function __ERC20interface_init_unchained(\r\n        uint256 id_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address gETH_1155\r\n    ) internal onlyInitializing {\r\n        _id = id_;\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _ERC1155 = IgETH(gETH_1155);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     * @dev CHANGED for gETH.\r\n     * @dev See {gETH-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _ERC1155.totalSupply(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     * @dev CHANGED for gETH.\r\n     * @dev See {gETH-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _ERC1155.balanceOf(account, _id);\r\n    }\r\n\r\n    /**\r\n     * @dev shows the underlying ETH for 1 staked ether for a given id\r\n     * @dev CHANGED for gETH.\r\n     * @dev See {gETH-pricePerShare}.\r\n     */\r\n    function pricePerShare() public view returns (uint256) {\r\n        return _ERC1155.pricePerShare(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * @dev CHANGED for gETH.\r\n     * @dev See {gETH-safeTransferFrom}.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = balanceOf(from);\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _ERC1155.safeTransferFrom(from, to, _id, amount, \"\");\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: insufficient allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n\r\n    uint256[45] private __gap;\r\n}\r\n"
    },
    "contracts/Portal/gETHInterfaces/ERC20InterfacePermitUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport \"./ERC20InterfaceUpgradable.sol\";\r\n\r\n/**\r\n * @dev differences between ERC20InterfacePermitUpgradable and Openzeppelin's implementation of ERC20PermitUpgradable is:\r\n * -> pragma set to =0.8.7;\r\n * -> using ERC20InterfaceUpgradable instead of ERC20Upgradeable\r\n * -> added initialize\r\n *\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/54803be62207c2412e27d09325243f2f1452f7b9/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\r\n * diffchecker: https://www.diffchecker.com/Hwmvi5HF\r\n */\r\n\r\n/**\r\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * _Available since v3.4._\r\n *\r\n * @custom:storage-size 51\r\n */\r\ncontract ERC20InterfacePermitUpgradable is\r\n    Initializable,\r\n    ERC20InterfaceUpgradable,\r\n    IERC20PermitUpgradeable,\r\n    EIP712Upgradeable\r\n{\r\n    using CountersUpgradeable for CountersUpgradeable.Counter;\r\n\r\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private constant _PERMIT_TYPEHASH =\r\n        keccak256(\r\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n        );\r\n    /**\r\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\r\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\r\n     * to reserve a slot.\r\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\r\n     */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     */\r\n    function initialize(\r\n        uint256 id_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address gETH_1155\r\n    ) public virtual initializer {\r\n        __ERC20interfacePermit_init(id_, name_, symbol_, gETH_1155);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\r\n     *\r\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\r\n     */\r\n    function __ERC20interfacePermit_init(\r\n        uint256 id_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address gETH_1155\r\n    ) internal onlyInitializing {\r\n        __ERC20interface_init_unchained(id_, name_, symbol_, gETH_1155);\r\n        __EIP712_init_unchained(name_, \"1\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-permit}.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual override {\r\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                _PERMIT_TYPEHASH,\r\n                owner,\r\n                spender,\r\n                value,\r\n                _useNonce(owner),\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 hash = _hashTypedDataV4(structHash);\r\n\r\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\r\n        require(signer == owner, \"ERC20Permit: invalid signature\");\r\n\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-nonces}.\r\n     */\r\n    function nonces(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _nonces[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n\r\n    /**\r\n     * @dev \"Consume a nonce\": return the current value and increment.\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    function _useNonce(address owner)\r\n        internal\r\n        virtual\r\n        returns (uint256 current)\r\n    {\r\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\r\n        current = nonce.current();\r\n        nonce.increment();\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/Portal/helpers/test/nonERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"../../../interfaces/IgETH.sol\";\r\n\r\ncontract nonERC1155Receiver is Context {\r\n    uint256 private immutable _id;\r\n    IgETH private immutable _ERC1155;\r\n\r\n    constructor(uint256 id_, address gETH_1155) {\r\n        _id = id_;\r\n        _ERC1155 = IgETH(gETH_1155);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"burn from the zero address\");\r\n\r\n        unchecked {\r\n            _ERC1155.burn(account, _id, amount);\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        unchecked {\r\n            _ERC1155.safeTransferFrom(sender, recipient, _id, amount, \"\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/gETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\nimport \"./helpers/ERC1155SupplyMinterPauser.sol\";\r\n\r\n/**\r\n * @author Icebear & Crash Bandicoot\r\n * @title Geode Finance Liquid Staking derivatives(g-derivatives) : gETH\r\n *\r\n * gETH is a special ERC1155 contract with additional functionalities.\r\n * One of the unique functionalities are the included price logic that tracks the underlaying ratio with\r\n * staked asset, ETH.\r\n *\r\n * Other and most important change is the implementation of ERC1155Interfaces.\r\n * This addition effectively result in changes in safeTransferFrom(), burn(), _doSafeTransferAcceptanceCheck()\r\n * functions, reasoning is in the comments.\r\n * However if one wants to remain unbound from Interfaces, it can be done so by calling \"avoidInterfaces\".\r\n *\r\n * @dev recommended to check helpers/ERC1155SupplyMinterPauser.sol first\r\n */\r\n\r\ncontract gETH is ERC1155SupplyMinterPauser {\r\n    using Address for address;\r\n\r\n    event InterfaceChanged(\r\n        address indexed newInterface,\r\n        uint256 id,\r\n        bool isSet\r\n    );\r\n    event InterfacesAvoided(address indexed avoider, bool isAvoid);\r\n    event PriceUpdated(\r\n        uint256 id,\r\n        uint256 pricePerShare,\r\n        uint256 updateTimestamp\r\n    );\r\n\r\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\r\n    string public constant name = \"Geode Staked ETH\";\r\n    string public constant symbol = \"gETH\";\r\n    uint256 private constant _denominator = 1 ether;\r\n\r\n    /**\r\n     * @notice Mapping from pool IDs to ERC1155interface implementation addresses\r\n     * There can be multiple Interfaces for 1 staking pool.\r\n     * @dev ADDED for gETH\r\n     **/\r\n    mapping(uint256 => mapping(address => bool)) private _interfaces;\r\n\r\n    /**\r\n     * @notice Mapping of user addresses who chose to restrict the usage of interfaces\r\n     * @dev ADDED for gETH\r\n     **/\r\n    mapping(address => bool) private _interfaceAvoiders;\r\n\r\n    /**\r\n     * @notice shows the underlying ETH for 1 staked gETH for a given asset id\r\n     * @dev freshly assigned ids should return 1e18 since initally 1 ETH = 1 gETH\r\n     * @dev ADDED for gETH\r\n     **/\r\n    mapping(uint256 => uint256) private _pricePerShare;\r\n\r\n    /**\r\n     * @notice id to timestamp, pointing the second that the latest price update happened\r\n     * @dev ADDED for gETH\r\n     **/\r\n    mapping(uint256 => uint256) private _priceUpdateTimestamp;\r\n\r\n    constructor(string memory uri) ERC1155SupplyMinterPauser(uri) {\r\n        _setupRole(ORACLE_ROLE, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @notice a centralized denominator = 1e18\r\n     * @dev ADDED for gETH\r\n     */\r\n    function denominator() external view virtual returns (uint256) {\r\n        return _denominator;\r\n    }\r\n\r\n    /**\r\n     * @notice checks if an address is defined as an interface for the given Planet id.\r\n     * @dev ADDED for gETH\r\n     */\r\n    function isInterface(address _interface, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _interface != address(0),\r\n            \"gETH: interface query for the zero address\"\r\n        );\r\n\r\n        return _interfaces[id][_interface];\r\n    }\r\n\r\n    /**\r\n     * @dev only authorized parties should set the interface as this is super crucial.\r\n     * @dev ADDED for gETH\r\n     */\r\n    function _setInterface(\r\n        address _interface,\r\n        uint256 _id,\r\n        bool _isSet\r\n    ) internal virtual {\r\n        require(\r\n            _interface != address(0),\r\n            \"gETH: interface query for the zero address\"\r\n        );\r\n\r\n        _interfaces[_id][_interface] = _isSet;\r\n    }\r\n\r\n    /**\r\n     * @notice to be used to set an address of a contract that will\r\n     * act as an interface on gETH contract for a spesific ID\r\n     * @dev ADDED for gETH\r\n     */\r\n    function setInterface(\r\n        address _interface,\r\n        uint256 id,\r\n        bool isSet\r\n    ) external virtual {\r\n        require(\r\n            hasRole(MINTER_ROLE, _msgSender()),\r\n            \"gETH: must have MINTER_ROLE\"\r\n        );\r\n        require(_interface.isContract(), \"gETH: _interface must be a contract\");\r\n\r\n        _setInterface(_interface, id, isSet);\r\n\r\n        emit InterfaceChanged(_interface, id, isSet);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the given address restricts the affect of the interfaces on their gETH\r\n     * @dev ADDED for gETH\r\n     **/\r\n    function isAvoider(address account) public view virtual returns (bool) {\r\n        return _interfaceAvoiders[account];\r\n    }\r\n\r\n    /**\r\n     * @notice One can desire to restrict the affect of interfaces on their gETH,\r\n     * this can be achieved by simply calling this function\r\n     * @param isAvoid true: restrict interfaces, false: allow the interfaces,\r\n     * @dev ADDED for gETH\r\n     **/\r\n    function avoidInterfaces(bool isAvoid) external virtual {\r\n        _interfaceAvoiders[_msgSender()] = isAvoid;\r\n\r\n        emit InterfacesAvoided(_msgSender(), isAvoid);\r\n    }\r\n\r\n    /**\r\n     * @dev ADDED for gETH\r\n     */\r\n    function pricePerShare(uint256 id) external view returns (uint256) {\r\n        return _pricePerShare[id];\r\n    }\r\n\r\n    /**\r\n     * @dev ADDED for gETH\r\n     */\r\n    function priceUpdateTimestamp(uint256 id) external view returns (uint256) {\r\n        return _priceUpdateTimestamp[id];\r\n    }\r\n\r\n    /**\r\n     * @dev ADDED for gETH\r\n     */\r\n    function _setPricePerShare(uint256 _price, uint256 _id) internal virtual {\r\n        _pricePerShare[_id] = _price;\r\n        _priceUpdateTimestamp[_id] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Only ORACLE can call this function and set price\r\n     * @dev ADDED for gETH\r\n     */\r\n    function setPricePerShare(uint256 price, uint256 id) external virtual {\r\n        require(\r\n            hasRole(ORACLE_ROLE, _msgSender()),\r\n            \"gETH: must have ORACLE to set\"\r\n        );\r\n        require(id != 0, \"gETH: price query for the zero address\");\r\n\r\n        _setPricePerShare(price, id);\r\n\r\n        emit PriceUpdated(id, price, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the authorized party for Minter operations related to minting\r\n     * @dev Minter is basically a superUser, there can be only 1 at a given time,\r\n     * @dev intended as \"Portal\"\r\n     */\r\n    function updateMinterRole(address Minter) external virtual {\r\n        require(\r\n            hasRole(MINTER_ROLE, _msgSender()),\r\n            \"gETH: must have MINTER_ROLE\"\r\n        );\r\n\r\n        renounceRole(MINTER_ROLE, _msgSender());\r\n        _setupRole(MINTER_ROLE, Minter);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the authorized party for Pausing operations.\r\n     * @dev Pauser is basically a superUser, there can be only 1 at a given time,\r\n     * @dev intended as \"Portal\"\r\n     */\r\n    function updatePauserRole(address Pauser) external virtual {\r\n        require(\r\n            hasRole(PAUSER_ROLE, _msgSender()),\r\n            \"gETH: must have PAUSER_ROLE\"\r\n        );\r\n\r\n        renounceRole(PAUSER_ROLE, _msgSender());\r\n        _setupRole(PAUSER_ROLE, Pauser);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the authorized party for Oracle operations related to pricing.\r\n     * @dev Oracle is basically a superUser, there can be only 1 at a given time,\r\n     * @dev intended as \"Portal\"\r\n     */\r\n    function updateOracleRole(address Oracle) external virtual {\r\n        require(\r\n            hasRole(ORACLE_ROLE, _msgSender()),\r\n            \"gETH: must have ORACLE_ROLE\"\r\n        );\r\n\r\n        renounceRole(ORACLE_ROLE, _msgSender());\r\n        _setupRole(ORACLE_ROLE, Oracle);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     * @dev interfaces can move your tokens without asking you\r\n     * @dev CHANGED for gETH\r\n     * @dev ADDED \"|| (isInterface(_msgSender(), id) && !isAvoider(from))\"\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() ||\r\n                isApprovedForAll(from, _msgSender()) ||\r\n                (isInterface(_msgSender(), id) && !isAvoider(from)),\r\n            \"ERC1155: caller is not owner nor approved nor an allowed interface\"\r\n        );\r\n\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     * @dev CHANGED for gETH\r\n     * @dev ADDED \"|| (isInterface(_msgSender(), id) && !isAvoider(account))\"\r\n     */\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) public virtual override {\r\n        require(\r\n            account == _msgSender() ||\r\n                isApprovedForAll(account, _msgSender()) ||\r\n                (isInterface(_msgSender(), id) && !isAvoider(account)),\r\n            \"ERC1155: caller is not owner nor approved nor an allowed interface\"\r\n        );\r\n\r\n        _burn(account, id, value);\r\n    }\r\n\r\n    /**\r\n     * @notice interfaces should handle their own Checks in the contract\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     * @dev CHANGED for gETH\r\n     * @dev ADDED \"&& !isInterface(operator,id))\"\r\n     */\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        if (to.isContract() && !isInterface(operator, id)) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155Received(\r\n                    operator,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/withdrawalPool/helpers/test/TestMathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"../../utils/MathUtils.sol\";\r\n\r\ncontract TestMathUtils {\r\n    using MathUtils for uint256;\r\n\r\n    function within1(uint256 a, uint256 b) public pure returns (bool) {\r\n        return a.within1(b);\r\n    }\r\n\r\n    function difference(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return a.difference(b);\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/test/TestDepositContractUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.7;\r\n\r\nimport \"../../../interfaces/IDepositContract.sol\";\r\nimport \"../../utils/DepositContractUtilsLib.sol\";\r\n\r\ncontract DepositContractUtilsTest {\r\n    function getDepositContract()\r\n        external\r\n        view\r\n        virtual\r\n        returns (IDepositContract)\r\n    {\r\n        return DepositContractUtils.DEPOSIT_CONTRACT;\r\n    }\r\n\r\n    function getDepositDataRoot(\r\n        bytes memory _pubkey,\r\n        bytes memory _withdrawal_credentials,\r\n        bytes memory _signature,\r\n        uint256 _stakeAmount\r\n    ) external view virtual returns (bytes32) {\r\n        return\r\n            DepositContractUtils._getDepositDataRoot(\r\n                _pubkey,\r\n                _withdrawal_credentials,\r\n                _signature,\r\n                _stakeAmount\r\n            );\r\n    }\r\n\r\n    function addressToWC(address _wc_address)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bytes memory)\r\n    {\r\n        return DepositContractUtils.addressToWC(_wc_address);\r\n    }\r\n\r\n    function getPubkeyLength() external view virtual returns (uint256) {\r\n        return DepositContractUtils.PUBKEY_LENGTH;\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/test/DepositContract.sol": {
      "content": "/**\r\n *Submitted for verification at Etherscan.io on 2020-10-14\r\n */\r\n\r\n// ┏━━━┓━┏┓━┏┓━━┏━━━┓━━┏━━━┓━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━┏┓━━━━━┏━━━┓━━━━━━━━━┏┓━━━━━━━━━━━━━━┏┓━\r\n// ┃┏━━┛┏┛┗┓┃┃━━┃┏━┓┃━━┃┏━┓┃━━━━┗┓┏┓┃━━━━━━━━━━━━━━━━━━┏┛┗┓━━━━┃┏━┓┃━━━━━━━━┏┛┗┓━━━━━━━━━━━━┏┛┗┓\r\n// ┃┗━━┓┗┓┏┛┃┗━┓┗┛┏┛┃━━┃┃━┃┃━━━━━┃┃┃┃┏━━┓┏━━┓┏━━┓┏━━┓┏┓┗┓┏┛━━━━┃┃━┗┛┏━━┓┏━┓━┗┓┏┛┏━┓┏━━┓━┏━━┓┗┓┏┛\r\n// ┃┏━━┛━┃┃━┃┏┓┃┏━┛┏┛━━┃┃━┃┃━━━━━┃┃┃┃┃┏┓┃┃┏┓┃┃┏┓┃┃━━┫┣┫━┃┃━━━━━┃┃━┏┓┃┏┓┃┃┏┓┓━┃┃━┃┏┛┗━┓┃━┃┏━┛━┃┃━\r\n// ┃┗━━┓━┃┗┓┃┃┃┃┃┃┗━┓┏┓┃┗━┛┃━━━━┏┛┗┛┃┃┃━┫┃┗┛┃┃┗┛┃┣━━┃┃┃━┃┗┓━━━━┃┗━┛┃┃┗┛┃┃┃┃┃━┃┗┓┃┃━┃┗┛┗┓┃┗━┓━┃┗┓\r\n// ┗━━━┛━┗━┛┗┛┗┛┗━━━┛┗┛┗━━━┛━━━━┗━━━┛┗━━┛┃┏━┛┗━━┛┗━━┛┗┛━┗━┛━━━━┗━━━┛┗━━┛┗┛┗┛━┗━┛┗┛━┗━━━┛┗━━┛━┗━┛\r\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┃┃━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┗┛━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n// SPDX-License-Identifier: CC0-1.0\r\n\r\npragma solidity >=0.6.11;\r\n\r\n// This interface is designed to be compatible with the Vyper version.\r\n/// @notice This is the Ethereum 2.0 deposit contract interface.\r\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\r\ninterface IDepositContract {\r\n    /// @notice A processed deposit event.\r\n    event DepositEvent(\r\n        bytes pubkey,\r\n        bytes withdrawal_credentials,\r\n        bytes amount,\r\n        bytes signature,\r\n        bytes index\r\n    );\r\n\r\n    /// @notice Submit a Phase 0 DepositData object.\r\n    /// @param pubkey A BLS12-381 public key.\r\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\r\n    /// @param signature A BLS12-381 signature.\r\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\r\n    /// Used as a protection against malformed input.\r\n    function deposit(\r\n        bytes calldata pubkey,\r\n        bytes calldata withdrawal_credentials,\r\n        bytes calldata signature,\r\n        bytes32 deposit_data_root\r\n    ) external payable;\r\n\r\n    /// @notice Query the current deposit root hash.\r\n    /// @return The deposit root hash.\r\n    function get_deposit_root() external view returns (bytes32);\r\n\r\n    /// @notice Query the current deposit count.\r\n    /// @return The deposit count encoded as a little endian 64-bit number.\r\n    function get_deposit_count() external view returns (bytes memory);\r\n}\r\n\r\n// Based on official specification in https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceId` and\r\n    ///  `interfaceId` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\r\n}\r\n\r\n// This is a rewrite of the Vyper Eth2.0 deposit contract in Solidity.\r\n// It tries to stay as close as possible to the original source code.\r\n/// @notice This is the Ethereum 2.0 deposit contract interface.\r\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\r\ncontract DepositContract is IDepositContract, ERC165 {\r\n    uint256 constant DEPOSIT_CONTRACT_TREE_DEPTH = 32;\r\n    // NOTE: this also ensures `deposit_count` will fit into 64-bits\r\n    uint256 constant MAX_DEPOSIT_COUNT = 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1;\r\n\r\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] branch;\r\n    uint256 deposit_count;\r\n\r\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] zero_hashes;\r\n\r\n    constructor() public {\r\n        // Compute hashes in empty sparse Merkle tree\r\n        for (\r\n            uint256 height = 0;\r\n            height < DEPOSIT_CONTRACT_TREE_DEPTH - 1;\r\n            height++\r\n        )\r\n            zero_hashes[height + 1] = sha256(\r\n                abi.encodePacked(zero_hashes[height], zero_hashes[height])\r\n            );\r\n    }\r\n\r\n    function get_deposit_root() external view override returns (bytes32) {\r\n        bytes32 node;\r\n        uint256 size = deposit_count;\r\n        for (\r\n            uint256 height = 0;\r\n            height < DEPOSIT_CONTRACT_TREE_DEPTH;\r\n            height++\r\n        ) {\r\n            if ((size & 1) == 1)\r\n                node = sha256(abi.encodePacked(branch[height], node));\r\n            else node = sha256(abi.encodePacked(node, zero_hashes[height]));\r\n            size /= 2;\r\n        }\r\n        return\r\n            sha256(\r\n                abi.encodePacked(\r\n                    node,\r\n                    to_little_endian_64(uint64(deposit_count)),\r\n                    bytes24(0)\r\n                )\r\n            );\r\n    }\r\n\r\n    function get_deposit_count() external view override returns (bytes memory) {\r\n        return to_little_endian_64(uint64(deposit_count));\r\n    }\r\n\r\n    function deposit(\r\n        bytes calldata pubkey,\r\n        bytes calldata withdrawal_credentials,\r\n        bytes calldata signature,\r\n        bytes32 deposit_data_root\r\n    ) external payable override {\r\n        // Extended ABI length checks since dynamic types are used.\r\n        require(pubkey.length == 48, \"DepositContract: invalid pubkey length\");\r\n        require(\r\n            withdrawal_credentials.length == 32,\r\n            \"DepositContract: invalid withdrawal_credentials length\"\r\n        );\r\n        require(\r\n            signature.length == 96,\r\n            \"DepositContract: invalid signature length\"\r\n        );\r\n\r\n        // Check deposit amount\r\n        require(msg.value >= 1 ether, \"DepositContract: deposit value too low\");\r\n        require(\r\n            msg.value % 1 gwei == 0,\r\n            \"DepositContract: deposit value not multiple of gwei\"\r\n        );\r\n        uint256 deposit_amount = msg.value / 1 gwei;\r\n        require(\r\n            deposit_amount <= type(uint64).max,\r\n            \"DepositContract: deposit value too high\"\r\n        );\r\n\r\n        // Emit `DepositEvent` log\r\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\r\n        emit DepositEvent(\r\n            pubkey,\r\n            withdrawal_credentials,\r\n            amount,\r\n            signature,\r\n            to_little_endian_64(uint64(deposit_count))\r\n        );\r\n\r\n        // Compute deposit data root (`DepositData` hash tree root)\r\n        bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\r\n        bytes32 signature_root = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(signature[:64])),\r\n                sha256(abi.encodePacked(signature[64:], bytes32(0)))\r\n            )\r\n        );\r\n        bytes32 node = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\r\n                sha256(abi.encodePacked(amount, bytes24(0), signature_root))\r\n            )\r\n        );\r\n\r\n        // Verify computed and expected deposit data roots match\r\n        require(\r\n            node == deposit_data_root,\r\n            \"DepositContract: reconstructed DepositData does not match supplied deposit_data_root\"\r\n        );\r\n\r\n        // Avoid overflowing the Merkle tree (and prevent edge case in computing `branch`)\r\n        require(\r\n            deposit_count < MAX_DEPOSIT_COUNT,\r\n            \"DepositContract: merkle tree full\"\r\n        );\r\n\r\n        // Add deposit data root to Merkle tree (update a single `branch` node)\r\n        deposit_count += 1;\r\n        uint256 size = deposit_count;\r\n        for (\r\n            uint256 height = 0;\r\n            height < DEPOSIT_CONTRACT_TREE_DEPTH;\r\n            height++\r\n        ) {\r\n            if ((size & 1) == 1) {\r\n                branch[height] = node;\r\n                return;\r\n            }\r\n            node = sha256(abi.encodePacked(branch[height], node));\r\n            size /= 2;\r\n        }\r\n        // As the loop should always end prematurely with the `return` statement,\r\n        // this code should be unreachable. We assert `false` just to be safe.\r\n        assert(false);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        pure\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(ERC165).interfaceId ||\r\n            interfaceId == type(IDepositContract).interfaceId;\r\n    }\r\n\r\n    function to_little_endian_64(uint64 value)\r\n        internal\r\n        pure\r\n        returns (bytes memory ret)\r\n    {\r\n        ret = new bytes(8);\r\n        bytes8 bytesValue = bytes8(value);\r\n        // Byteswapping during copying to bytes.\r\n        ret[0] = bytesValue[7];\r\n        ret[1] = bytesValue[6];\r\n        ret[2] = bytesValue[5];\r\n        ret[3] = bytesValue[4];\r\n        ret[4] = bytesValue[3];\r\n        ret[5] = bytesValue[2];\r\n        ret[6] = bytesValue[1];\r\n        ret[7] = bytesValue[0];\r\n    }\r\n}\r\n"
    },
    "contracts/Portal/helpers/test/TestStakeUtils.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity =0.8.7;\r\n// import \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\r\n// import \"../../utils/DataStoreUtilsLib.sol\";\r\n// import \"../../utils/MaintainerUtilsLib.sol\";\r\n// import \"../../utils/OracleUtilsLib.sol\";\r\n// import \"../../utils/StakeUtilsLib.sol\";\r\n// import \"../../../interfaces/IgETH.sol\";\r\n\r\n// contract TestStakeUtils is ERC1155Holder {\r\n//     using MaintainerUtils for DataStoreUtils.DataStore;\r\n//     using DataStoreUtils for DataStoreUtils.DataStore;\r\n//     using OracleUtils for OracleUtils.Oracle;\r\n//     using StakeUtils for StakeUtils.StakePool;\r\n\r\n//     DataStoreUtils.DataStore private DATASTORE;\r\n//     StakeUtils.StakePool private STAKEPOOL;\r\n\r\n//     constructor(\r\n//         address _gETH,\r\n//         address _GOVERNANCE,\r\n//         address _DEFAULT_DWP,\r\n//         address _DEFAULT_LP_TOKEN,\r\n//         address _DEFAULT_gETH_INTERFACE,\r\n//         address _DEFAULT_MINI_GOVERNANCE,\r\n//         uint256 _BOOSTRAP_PERIOD,\r\n//         address _ORACLE_POSITION\r\n//     ) {\r\n//         STAKEPOOL.gETH = IgETH(_gETH);\r\n//         STAKEPOOL.GOVERNANCE = _GOVERNANCE;\r\n//         STAKEPOOL.DEFAULT_DWP = _DEFAULT_DWP;\r\n//         STAKEPOOL.DEFAULT_LP_TOKEN = _DEFAULT_LP_TOKEN;\r\n//         STAKEPOOL.DEFAULT_gETH_INTERFACE = _DEFAULT_gETH_INTERFACE;\r\n//         STAKEPOOL.BOOSTRAP_PERIOD = _BOOSTRAP_PERIOD; //10%\r\n//         STAKEPOOL.MAX_MAINTAINER_FEE =\r\n//             (10 * StakeUtils.PERCENTAGE_DENOMINATOR) /\r\n//             1e2; //10%\r\n\r\n//         STAKEPOOL.TELESCOPE.gETH = IgETH(_gETH);\r\n//         STAKEPOOL.TELESCOPE.ORACLE_POSITION = _ORACLE_POSITION;\r\n//         STAKEPOOL.TELESCOPE.PERIOD_PRICE_INCREASE_LIMIT =\r\n//             (2 * StakeUtils.PERCENTAGE_DENOMINATOR) /\r\n//             1e3;\r\n//         STAKEPOOL.TELESCOPE.PERIOD_PRICE_DECREASE_LIMIT =\r\n//             (2 * StakeUtils.PERCENTAGE_DENOMINATOR) /\r\n//             1e3;\r\n//         STAKEPOOL.TELESCOPE.PRICE_MERKLE_ROOT = \"\";\r\n//         STAKEPOOL.MINI_GOVERNANCE_VERSION = 31415926535;\r\n//         DATASTORE.writeAddressForId(\r\n//             STAKEPOOL.MINI_GOVERNANCE_VERSION,\r\n//             \"CONTROLLER\",\r\n//             _DEFAULT_MINI_GOVERNANCE\r\n//         );\r\n//     }\r\n\r\n//     function getStakePoolParams()\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (\r\n//             address gETH,\r\n//             address GOVERNANCE,\r\n//             address DEFAULT_gETH_INTERFACE,\r\n//             address DEFAULT_DWP,\r\n//             address DEFAULT_LP_TOKEN,\r\n//             uint256 MAX_MAINTAINER_FEE,\r\n//             uint256 BOOSTRAP_PERIOD,\r\n//             uint256 WITHDRAWAL_DELAY\r\n//         )\r\n//     {\r\n//         gETH = address(STAKEPOOL.gETH);\r\n//         GOVERNANCE = STAKEPOOL.GOVERNANCE;\r\n//         DEFAULT_gETH_INTERFACE = STAKEPOOL.DEFAULT_gETH_INTERFACE;\r\n//         DEFAULT_DWP = STAKEPOOL.DEFAULT_DWP;\r\n//         DEFAULT_LP_TOKEN = STAKEPOOL.DEFAULT_LP_TOKEN;\r\n//         MAX_MAINTAINER_FEE = STAKEPOOL.MAX_MAINTAINER_FEE;\r\n//         BOOSTRAP_PERIOD = STAKEPOOL.BOOSTRAP_PERIOD;\r\n//         WITHDRAWAL_DELAY = STAKEPOOL.TELESCOPE.WITHDRAWAL_DELAY;\r\n//     }\r\n\r\n//     function getOracleParams()\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (\r\n//             address ORACLE,\r\n//             uint256 ORACLE_UPDATE_TIMESTAMP,\r\n//             uint256 MONOPOLY_THRESHOLD, // max number of validators an operator is allowed to operate.\r\n//             uint256 VALIDATORS_INDEX,\r\n//             uint256 VERIFICATION_INDEX,\r\n//             uint256 PERIOD_PRICE_INCREASE_LIMIT,\r\n//             uint256 PERIOD_PRICE_DECREASE_LIMIT,\r\n//             bytes32 PRICE_MERKLE_ROOT\r\n//         )\r\n//     {\r\n//         ORACLE = STAKEPOOL.TELESCOPE.ORACLE_POSITION;\r\n//         ORACLE_UPDATE_TIMESTAMP = STAKEPOOL.TELESCOPE.ORACLE_UPDATE_TIMESTAMP;\r\n//         MONOPOLY_THRESHOLD = STAKEPOOL.TELESCOPE.MONOPOLY_THRESHOLD;\r\n//         VALIDATORS_INDEX = STAKEPOOL.TELESCOPE.VALIDATORS_INDEX;\r\n//         VERIFICATION_INDEX = STAKEPOOL.TELESCOPE.VERIFICATION_INDEX;\r\n//         PERIOD_PRICE_INCREASE_LIMIT = STAKEPOOL\r\n//             .TELESCOPE\r\n//             .PERIOD_PRICE_INCREASE_LIMIT;\r\n//         PERIOD_PRICE_DECREASE_LIMIT = STAKEPOOL\r\n//             .TELESCOPE\r\n//             .PERIOD_PRICE_DECREASE_LIMIT;\r\n//         PRICE_MERKLE_ROOT = STAKEPOOL.TELESCOPE.PRICE_MERKLE_ROOT;\r\n//     }\r\n\r\n//     function changeOracle() public {\r\n//         STAKEPOOL.gETH.updateOracleRole(msg.sender);\r\n//     }\r\n\r\n//     /**\r\n//      * Maintainer\r\n//      */\r\n//     function getMaintainerFromId(uint256 _id)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (address)\r\n//     {\r\n//         return DATASTORE.getMaintainerFromId(_id);\r\n//     }\r\n\r\n//     function beController(uint256 _id) external {\r\n//         DATASTORE.writeAddressForId(_id, \"CONTROLLER\", msg.sender);\r\n//     }\r\n\r\n//     function setType(uint256 _id, uint256 _type) external {\r\n//         DATASTORE.writeUintForId(_id, \"TYPE\", _type);\r\n//     }\r\n\r\n//     function mintgETH(\r\n//         address _to,\r\n//         uint256 _id,\r\n//         uint256 _amount\r\n//     ) external virtual {\r\n//         STAKEPOOL.gETH.mint(_to, _id, _amount, \"\");\r\n//     }\r\n\r\n//     function buyback(\r\n//         address to,\r\n//         uint256 poolId,\r\n//         uint256 sellEth,\r\n//         uint256 minToBuy,\r\n//         uint256 deadline\r\n//     ) external returns (uint256 outAmount) {\r\n//         outAmount = STAKEPOOL._buyback(\r\n//             DATASTORE,\r\n//             to,\r\n//             poolId,\r\n//             sellEth,\r\n//             minToBuy,\r\n//             deadline\r\n//         );\r\n//     }\r\n\r\n//     function changeIdMaintainer(uint256 _id, address _newMaintainer)\r\n//         external\r\n//         virtual\r\n//     {\r\n//         StakeUtils.changeOperatorMaintainer(DATASTORE, _id, _newMaintainer);\r\n//     }\r\n\r\n//     function switchMaintainerFee(uint256 _id, uint256 _newFee)\r\n//         external\r\n//         virtual\r\n//     {\r\n//         STAKEPOOL.switchMaintainerFee(DATASTORE, _id, _newFee);\r\n//     }\r\n\r\n//     function updateGovernanceParams(\r\n//         address _DEFAULT_gETH_INTERFACE, // contract?\r\n//         address _DEFAULT_DWP, // contract?\r\n//         address _DEFAULT_LP_TOKEN, // contract?\r\n//         uint256 _MAX_MAINTAINER_FEE, // < 100\r\n//         uint256 _BOOSTRAP_PERIOD,\r\n//         uint256 _PERIOD_PRICE_INCREASE_LIMIT,\r\n//         uint256 _PERIOD_PRICE_DECREASE_LIMIT,\r\n//         uint256 _WITHDRAWAL_DELAY\r\n//     ) external virtual {\r\n//         // do not forget only governance check\r\n//         require(\r\n//             _DEFAULT_gETH_INTERFACE.code.length > 0,\r\n//             \"StakeUtils: DEFAULT_gETH_INTERFACE NOT contract\"\r\n//         );\r\n//         require(\r\n//             _DEFAULT_DWP.code.length > 0,\r\n//             \"StakeUtils: DEFAULT_DWP NOT contract\"\r\n//         );\r\n//         require(\r\n//             _DEFAULT_LP_TOKEN.code.length > 0,\r\n//             \"StakeUtils: DEFAULT_LP_TOKEN NOT contract\"\r\n//         );\r\n//         require(\r\n//             _PERIOD_PRICE_INCREASE_LIMIT > 0,\r\n//             \"StakeUtils: incorrect PERIOD_PRICE_INCREASE_LIMIT\"\r\n//         );\r\n//         require(\r\n//             _PERIOD_PRICE_DECREASE_LIMIT > 0,\r\n//             \"StakeUtils: incorrect PERIOD_PRICE_DECREASE_LIMIT\"\r\n//         );\r\n//         require(\r\n//             _MAX_MAINTAINER_FEE > 0 &&\r\n//                 _MAX_MAINTAINER_FEE <= StakeUtils.PERCENTAGE_DENOMINATOR,\r\n//             \"StakeUtils: incorrect MAX_MAINTAINER_FEE\"\r\n//         );\r\n//         STAKEPOOL.DEFAULT_gETH_INTERFACE = _DEFAULT_gETH_INTERFACE;\r\n//         STAKEPOOL.DEFAULT_DWP = _DEFAULT_DWP;\r\n//         STAKEPOOL.DEFAULT_LP_TOKEN = _DEFAULT_LP_TOKEN;\r\n//         STAKEPOOL.MAX_MAINTAINER_FEE = _MAX_MAINTAINER_FEE;\r\n//         STAKEPOOL.BOOSTRAP_PERIOD = _BOOSTRAP_PERIOD;\r\n//         STAKEPOOL\r\n//             .TELESCOPE\r\n//             .PERIOD_PRICE_INCREASE_LIMIT = _PERIOD_PRICE_INCREASE_LIMIT;\r\n//         STAKEPOOL\r\n//             .TELESCOPE\r\n//             .PERIOD_PRICE_DECREASE_LIMIT = _PERIOD_PRICE_DECREASE_LIMIT;\r\n//         STAKEPOOL.TELESCOPE.WITHDRAWAL_DELAY = _WITHDRAWAL_DELAY;\r\n//     }\r\n\r\n//     function getMaintainerFee(uint256 _id)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (uint256)\r\n//     {\r\n//         return DATASTORE.getMaintainerFee(_id);\r\n//     }\r\n\r\n//     function updateValidatorPeriod(uint256 _operatorId, uint256 _newPeriod)\r\n//         external\r\n//         virtual\r\n//     {\r\n//         StakeUtils.updateValidatorPeriod(DATASTORE, _operatorId, _newPeriod);\r\n//     }\r\n\r\n//     function getValidatorPeriod(uint256 _id)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (uint256)\r\n//     {\r\n//         return StakeUtils.getValidatorPeriod(DATASTORE, _id);\r\n//     }\r\n\r\n//     function setPricePerShare(uint256 price, uint256 _planetId) external {\r\n//         STAKEPOOL.gETH.setPricePerShare(price, _planetId);\r\n//     }\r\n\r\n//     function getPricePerShare(uint256 _planetId)\r\n//         external\r\n//         view\r\n//         returns (uint256)\r\n//     {\r\n//         return STAKEPOOL.gETH.pricePerShare(_planetId);\r\n//     }\r\n\r\n//     function setInterface(uint256 _planetId, address _interface) external {\r\n//         STAKEPOOL.setInterface(DATASTORE, _planetId, _interface);\r\n//     }\r\n\r\n//     function unsetInterface(uint256 _planetId, uint256 _index) external {\r\n//         STAKEPOOL.unsetInterface(DATASTORE, _planetId, _index);\r\n//     }\r\n\r\n//     function allInterfaces(uint256 _planetId)\r\n//         external\r\n//         view\r\n//         returns (address[] memory)\r\n//     {\r\n//         return StakeUtils.allInterfaces(DATASTORE, _planetId);\r\n//     }\r\n\r\n//     function withdrawalBoost(uint256 _id)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (uint256)\r\n//     {\r\n//         return DATASTORE.readUintForId(_id, \"withdrawalBoost\");\r\n//     }\r\n\r\n//     function whenInitiated(uint256 _planetId)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (uint256)\r\n//     {\r\n//         return DATASTORE.readUintForId(_planetId, \"initiated\");\r\n//     }\r\n\r\n//     function initiateOperator(\r\n//         uint256 _planetId,\r\n//         uint256 _fee,\r\n//         address _maintainer,\r\n//         uint256 _cometPeriod\r\n//     ) external {\r\n//         STAKEPOOL.initiateOperator(\r\n//             DATASTORE,\r\n//             _planetId,\r\n//             _fee,\r\n//             _maintainer,\r\n//             _cometPeriod\r\n//         );\r\n//     }\r\n\r\n//     function initiatePlanet(\r\n//         uint256 _planetId,\r\n//         uint256 _fee,\r\n//         uint256 _withdrawalBoost,\r\n//         address _maintainer,\r\n//         string memory _interfaceName,\r\n//         string memory _interfaceSymbol\r\n//     ) external {\r\n//         STAKEPOOL.initiatePlanet(\r\n//             DATASTORE,\r\n//             _planetId,\r\n//             _fee,\r\n//             _withdrawalBoost,\r\n//             _maintainer,\r\n//             [_interfaceName, _interfaceSymbol]\r\n//         );\r\n//     }\r\n\r\n//     function initiateComet(\r\n//         uint256 _planetId,\r\n//         uint256 _fee,\r\n//         address _maintainer\r\n//     ) external {\r\n//         STAKEPOOL.initiateComet(DATASTORE, _planetId, _fee, _maintainer);\r\n//     }\r\n\r\n//     function operatorAllowance(uint256 _planetId, uint256 _operatorId)\r\n//         external\r\n//         view\r\n//         returns (uint256 allowence)\r\n//     {\r\n//         allowence = StakeUtils.operatorAllowance(\r\n//             DATASTORE,\r\n//             _planetId,\r\n//             _operatorId\r\n//         );\r\n//     }\r\n\r\n//     function approveOperator(\r\n//         uint256 _planetId,\r\n//         uint256 _operatorId,\r\n//         uint256 _allowance\r\n//     ) external returns (bool success) {\r\n//         success = StakeUtils.approveOperator(\r\n//             DATASTORE,\r\n//             _planetId,\r\n//             _operatorId,\r\n//             _allowance\r\n//         );\r\n//     }\r\n\r\n//     function getMaintainerWalletBalance(uint256 id)\r\n//         external\r\n//         view\r\n//         returns (uint256 balance)\r\n//     {\r\n//         balance = DATASTORE.getMaintainerWalletBalance(id);\r\n//     }\r\n\r\n//     function increaseMaintainerWallet(uint256 id)\r\n//         external\r\n//         payable\r\n//         returns (bool success)\r\n//     {\r\n//         success = StakeUtils.increaseMaintainerWallet(DATASTORE, id);\r\n//     }\r\n\r\n//     function decreaseMaintainerWallet(uint256 id, uint256 value)\r\n//         external\r\n//         returns (bool success)\r\n//     {\r\n//         success = StakeUtils.decreaseMaintainerWallet(DATASTORE, id, value);\r\n//     }\r\n\r\n//     function deployWithdrawalPool(uint256 _id)\r\n//         external\r\n//         returns (address WithdrawalPool)\r\n//     {\r\n//         WithdrawalPool = DATASTORE._deployWithdrawalPool(\r\n//             _id,\r\n//             address(STAKEPOOL.gETH),\r\n//             STAKEPOOL.DEFAULT_DWP,\r\n//             STAKEPOOL.DEFAULT_LP_TOKEN\r\n//         );\r\n//     }\r\n\r\n//     function withdrawalPoolById(uint256 _id)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (address)\r\n//     {\r\n//         return address(StakeUtils.withdrawalPoolById(DATASTORE, _id));\r\n//     }\r\n\r\n//     function LPTokenById(uint256 _id) external view virtual returns (address) {\r\n//         return address(StakeUtils.LPTokenById(DATASTORE, _id));\r\n//     }\r\n\r\n//     function dailyMintBuffer(uint256 poolId) external view returns (uint256) {\r\n//         bytes32 dailyBufferKey = DataStoreUtils.getKey(\r\n//             block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//             \"mintBuffer\"\r\n//         );\r\n//         return DATASTORE.readUintForId(poolId, dailyBufferKey);\r\n//     }\r\n\r\n//     function dailyBurnBuffer(uint256 poolId) external view returns (uint256) {\r\n//         bytes32 dailyBufferKey = DataStoreUtils.getKey(\r\n//             block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//             \"burnBuffer\"\r\n//         );\r\n//         return DATASTORE.readUintForId(poolId, dailyBufferKey);\r\n//     }\r\n\r\n//     function surplusById(uint256 _planetId) external view returns (uint256) {\r\n//         return DATASTORE.readUintForId(_planetId, \"surplus\");\r\n//     }\r\n\r\n//     function securedById(uint256 _planetId) external view returns (uint256) {\r\n//         return DATASTORE.readUintForId(_planetId, \"secured\");\r\n//     }\r\n\r\n//     function proposedValidatorsById(uint256 _planetId, uint256 _operatorId)\r\n//         external\r\n//         view\r\n//         returns (uint256)\r\n//     {\r\n//         return\r\n//             DATASTORE.readUintForId(\r\n//                 _planetId,\r\n//                 DataStoreUtils.getKey(_operatorId, \"proposedValidators\")\r\n//             );\r\n//     }\r\n\r\n//     function totalProposedValidatorsById(uint256 _operatorId)\r\n//         external\r\n//         view\r\n//         returns (uint256)\r\n//     {\r\n//         return DATASTORE.readUintForId(_operatorId, \"totalProposedValidators\");\r\n//     }\r\n\r\n//     function activeValidatorsById(uint256 _planetId, uint256 _operatorId)\r\n//         external\r\n//         view\r\n//         returns (uint256)\r\n//     {\r\n//         return\r\n//             DATASTORE.readUintForId(\r\n//                 _planetId,\r\n//                 DataStoreUtils.getKey(_operatorId, \"activeValidators\")\r\n//             );\r\n//     }\r\n\r\n//     function canDeposit(uint256 id) external view returns (bool) {\r\n//         return StakeUtils.canDeposit(DATASTORE, id);\r\n//     }\r\n\r\n//     function pauseStakingForPool(uint256 id) external {\r\n//         StakeUtils.pauseStakingForPool(DATASTORE, id);\r\n//     }\r\n\r\n//     function unpauseStakingForPool(uint256 id) external {\r\n//         StakeUtils.unpauseStakingForPool(DATASTORE, id);\r\n//     }\r\n\r\n//     function donateBalancedFees(\r\n//         uint256 poolId,\r\n//         uint256 burnSurplus_,\r\n//         uint256 burnGeth\r\n//     ) external returns (uint256 ethDonation, uint256 gEthDonation) {\r\n//         return\r\n//             StakeUtils._donateBalancedFees(\r\n//                 DATASTORE,\r\n//                 poolId,\r\n//                 burnSurplus_,\r\n//                 burnGeth\r\n//             );\r\n//     }\r\n\r\n//     function burnSurplus(uint256 poolId, uint256 withdrawnGeth)\r\n//         external\r\n//         returns (uint256, uint256)\r\n//     {\r\n//         return STAKEPOOL._burnSurplus(DATASTORE, poolId, withdrawnGeth);\r\n//     }\r\n\r\n//     uint256 public ethToSend;\r\n\r\n//     function lastEthToSend() external view virtual returns (uint256) {\r\n//         return ethToSend;\r\n//     }\r\n\r\n//     function withdrawPlanet(\r\n//         uint256 poolId,\r\n//         uint256 withdrawnGeth,\r\n//         uint256 minETH,\r\n//         uint256 deadline\r\n//     ) external virtual {\r\n//         ethToSend = STAKEPOOL.withdrawPlanet(\r\n//             DATASTORE,\r\n//             poolId,\r\n//             withdrawnGeth,\r\n//             minETH,\r\n//             deadline\r\n//         );\r\n//     }\r\n\r\n//     function depositPlanet(\r\n//         uint256 planetId,\r\n//         uint256 minGEth,\r\n//         uint256 deadline\r\n//     ) external payable virtual returns (uint256 totalgEth) {\r\n//         totalgEth = STAKEPOOL.depositPlanet(\r\n//             DATASTORE,\r\n//             planetId,\r\n//             minGEth,\r\n//             deadline\r\n//         );\r\n//         require(totalgEth > minGEth, \"Portal: unsuccesful deposit\");\r\n//     }\r\n\r\n//     function canStake(bytes calldata pubkey)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (bool)\r\n//     {\r\n//         return STAKEPOOL.TELESCOPE.canStake(pubkey);\r\n//     }\r\n\r\n//     function proposeStake(\r\n//         uint256 planetId,\r\n//         uint256 operatorId,\r\n//         bytes[] calldata pubkeys,\r\n//         bytes[] calldata signatures\r\n//     ) external virtual {\r\n//         STAKEPOOL.proposeStake(\r\n//             DATASTORE,\r\n//             planetId,\r\n//             operatorId,\r\n//             pubkeys,\r\n//             signatures\r\n//         );\r\n//     }\r\n\r\n//     function beaconStake(uint256 operatorId, bytes[] calldata pubkeys)\r\n//         external\r\n//         virtual\r\n//     {\r\n//         STAKEPOOL.beaconStake(DATASTORE, operatorId, pubkeys);\r\n//     }\r\n\r\n//     function setSurplus(uint256 _id, uint256 _surplus) external {\r\n//         DATASTORE.writeUintForId(_id, \"surplus\", _surplus);\r\n//     }\r\n\r\n//     function setMONOPOLY_THRESHOLD(uint256 threshold) external virtual {\r\n//         STAKEPOOL.TELESCOPE.MONOPOLY_THRESHOLD = threshold;\r\n//     }\r\n\r\n//     function regulateOperators(\r\n//         uint256 all_validators_count,\r\n//         uint256 VERIFICATION_INDEX,\r\n//         uint256 unstake_verification_index,\r\n//         bytes[][] calldata regulatedPubkeys, //i = 0: alienated, 1: cured, 2: busted, 3: released\r\n//         uint256[] calldata prisonedIds\r\n//     ) external virtual {\r\n//         STAKEPOOL.TELESCOPE.regulateOperators(\r\n//             DATASTORE,\r\n//             all_validators_count,\r\n//             VERIFICATION_INDEX,\r\n//             unstake_verification_index,\r\n//             regulatedPubkeys,\r\n//             prisonedIds\r\n//         );\r\n//     }\r\n\r\n//     function isPrisoned(uint256 operatorId)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (bool)\r\n//     {\r\n//         return StakeUtils.isPrisoned(DATASTORE, operatorId);\r\n//     }\r\n\r\n//     function releasePrisoned(uint256 operatorId) external virtual {\r\n//         STAKEPOOL.releasePrisoned(DATASTORE, operatorId);\r\n//     }\r\n\r\n//     function alienatePubKey(bytes calldata pubkey) external virtual {\r\n//         STAKEPOOL.TELESCOPE._validators[pubkey].state = 69;\r\n//     }\r\n\r\n//     function getValidatorData(bytes calldata pubkey)\r\n//         external\r\n//         view\r\n//         virtual\r\n//         returns (OracleUtils.Validator memory)\r\n//     {\r\n//         return STAKEPOOL.TELESCOPE._validators[pubkey];\r\n//     }\r\n\r\n//     function getVALIDATORS_INDEX() external view virtual returns (uint256) {\r\n//         return STAKEPOOL.TELESCOPE.VALIDATORS_INDEX;\r\n//     }\r\n\r\n//     function getVERIFICATION_INDEX() external view virtual returns (uint256) {\r\n//         return STAKEPOOL.TELESCOPE.VERIFICATION_INDEX;\r\n//     }\r\n\r\n//     function getContractBalance() external view virtual returns (uint256) {\r\n//         return address(this).balance;\r\n//     }\r\n\r\n//     function setORACLE_UPDATE_TIMESTAMP(uint256 ts) external virtual {\r\n//         STAKEPOOL.TELESCOPE.ORACLE_UPDATE_TIMESTAMP = ts;\r\n//     }\r\n\r\n//     function isOracleActive() external view virtual returns (bool) {\r\n//         return STAKEPOOL.TELESCOPE._isOracleActive();\r\n//     }\r\n\r\n//     function sanityCheck(uint256 _id, uint256 _newPrice) external view {\r\n//         STAKEPOOL.TELESCOPE._sanityCheck(\r\n//             _id,\r\n//             (block.timestamp +\r\n//                 OracleUtils.ORACLE_ACTIVE_PERIOD -\r\n//                 STAKEPOOL.TELESCOPE.ORACLE_UPDATE_TIMESTAMP) /\r\n//                 OracleUtils.ORACLE_PERIOD,\r\n//             _newPrice\r\n//         );\r\n//     }\r\n\r\n//     function priceSync(\r\n//         bytes32 merkleRoot,\r\n//         uint256 index,\r\n//         uint256 poolId,\r\n//         uint256 beaconBalance,\r\n//         uint256 periodsSinceUpdate,\r\n//         bytes32[] calldata priceProofs\r\n//     ) external virtual {\r\n//         bytes32[2] memory dailyBufferKeys = [\r\n//             DataStoreUtils.getKey(\r\n//                 block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//                 \"mintBuffer\"\r\n//             ),\r\n//             DataStoreUtils.getKey(\r\n//                 block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//                 \"burnBuffer\"\r\n//             )\r\n//         ];\r\n//         STAKEPOOL.TELESCOPE.PRICE_MERKLE_ROOT = merkleRoot;\r\n//         STAKEPOOL.TELESCOPE._priceSync(\r\n//             DATASTORE,\r\n//             dailyBufferKeys,\r\n//             index,\r\n//             poolId,\r\n//             beaconBalance,\r\n//             periodsSinceUpdate,\r\n//             priceProofs\r\n//         );\r\n//     }\r\n\r\n//     uint256 lastRealPrice;\r\n//     uint256 lastExpectedPrice;\r\n\r\n//     function getLastPrices() external view returns (uint256, uint256) {\r\n//         return (lastRealPrice, lastExpectedPrice);\r\n//     }\r\n\r\n//     function findPrices(uint256 poolId, uint256 beaconBalance)\r\n//         external\r\n//         returns (uint256 real, uint256 expected)\r\n//     {\r\n//         (real, expected) = STAKEPOOL.TELESCOPE._findPrices_ClearBuffer(\r\n//             DATASTORE,\r\n//             DataStoreUtils.getKey(\r\n//                 block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//                 \"mintBuffer\"\r\n//             ),\r\n//             DataStoreUtils.getKey(\r\n//                 block.timestamp - (block.timestamp % OracleUtils.ORACLE_PERIOD),\r\n//                 \"burnBuffer\"\r\n//             ),\r\n//             poolId,\r\n//             beaconBalance\r\n//         );\r\n//         (lastRealPrice, lastExpectedPrice) = (real, expected);\r\n//     }\r\n\r\n//     function reportOracle(\r\n//         bytes32 merkleRoot,\r\n//         uint256[] calldata beaconBalances,\r\n//         bytes32[][] calldata priceProofs\r\n//     ) external {\r\n//         STAKEPOOL.TELESCOPE.reportOracle(\r\n//             DATASTORE,\r\n//             merkleRoot,\r\n//             beaconBalances,\r\n//             priceProofs\r\n//         );\r\n//     }\r\n\r\n//     function Receive() external payable {}\r\n\r\n//     receive() external payable {}\r\n// }\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}